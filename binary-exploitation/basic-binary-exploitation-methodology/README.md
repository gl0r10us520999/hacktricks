# Metodología Básica de Explotación de Binarios

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Información Básica sobre ELF

Antes de comenzar a explotar cualquier cosa, es interesante entender parte de la estructura de un **binario ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Herramientas de Explotación

{% content-ref url="tools/" %}
[herramientas](tools/)
{% endcontent-ref %}

## Metodología de Desbordamiento de Pila

Con tantas técnicas, es bueno tener un esquema de cuándo cada técnica será útil. Ten en cuenta que las mismas protecciones afectarán a diferentes técnicas. Puedes encontrar formas de evadir las protecciones en cada sección de protección, pero no en esta metodología.

## Controlando el Flujo

Hay diferentes formas en las que podrías terminar controlando el flujo de un programa:

* [**Desbordamientos de Pila**](../stack-overflow/) sobrescribiendo el puntero de retorno de la pila o el EBP -> ESP -> EIP.
* Podría ser necesario abusar de un [**Desbordamiento de Enteros**](../integer-overflow.md) para causar el desbordamiento.
* O a través de **Escrituras Arbitrarias + Escribir Qué Dónde a la Ejecución**
* [**Cadenas de Formato**](../format-strings/)**:** Abusar de `printf` para escribir contenido arbitrario en direcciones arbitrarias.
* [**Indexación de Arreglos**](../array-indexing.md): Abusar de una indexación mal diseñada para poder controlar algunos arreglos y obtener una escritura arbitraria.
* Podría ser necesario abusar de un [**Desbordamiento de Enteros**](../integer-overflow.md) para causar el desbordamiento.
* **bof a WWW a través de ROP**: Abusar de un desbordamiento de búfer para construir un ROP y poder obtener un WWW.

Puedes encontrar las técnicas de **Escribir Qué Dónde a la Ejecución** en:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Bucles Eternos

Algo a tener en cuenta es que generalmente **solo una explotación de una vulnerabilidad puede no ser suficiente** para ejecutar con éxito un exploit, especialmente si se necesitan evadir algunas protecciones. Por lo tanto, es interesante discutir algunas opciones para **hacer que una sola vulnerabilidad sea explotable varias veces** en la misma ejecución del binario:

* Escribir en una cadena **ROP** la dirección de la función **`main`** o la dirección donde está ocurriendo la **vulnerabilidad**.
* Controlando una cadena ROP adecuada, podrías ser capaz de realizar todas las acciones en esa cadena.
* Escribir en la dirección de **`exit` en GOT** (o cualquier otra función utilizada por el binario antes de finalizar) la dirección para volver a la **vulnerabilidad**.
* Como se explica en [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)**,** almacenar 2 funciones aquí, una para llamar nuevamente a la vulnerabilidad y otra para llamar a **`__libc_csu_fini`** que llamará nuevamente a la función de `.fini_array`.

## Objetivos de Explotación

### Objetivo: Llamar a una función existente

* [**ret2win**](./#ret2win): Hay una función en el código que necesitas llamar (quizás con algunos parámetros específicos) para obtener la bandera.
* En un **bof regular sin** [**PIE**](../common-binary-protections-and-bypasses/pie/) **y sin** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), solo necesitas escribir la dirección en la dirección de retorno almacenada en la pila.
* En un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/), necesitarás evadirlo.
* En un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), necesitarás evadirlo.
* Si necesitas establecer varios parámetros para llamar correctamente a la función **ret2win** puedes usar:
* Una cadena [**ROP**](./#rop-and-ret2...-techniques) **si hay suficientes gadgets** para preparar todos los parámetros.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (en caso de que puedas llamar a esta llamada al sistema) para controlar muchos registros.
* Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) y [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) para controlar varios registros.
* A través de un [**Escribir Qué Dónde**](../arbitrary-write-2-exec/) podrías abusar de otras vulnerabilidades (no bof) para llamar a la función **`win`**.
* [**Redirección de Punteros**](../stack-overflow/pointer-redirecting.md): En caso de que la pila contenga punteros a una función que se va a llamar o a una cadena que va a ser utilizada por una función interesante (system o printf), es posible sobrescribir esa dirección.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) podrían afectar las direcciones.
* [**Variables no inicializadas**](../stack-overflow/uninitialized-variables.md): Nunca se sabe.

### Objetivo: RCE

#### A través de shellcode, si nx está deshabilitado o mezclando shellcode con ROP:

* [**(Stack) Shellcode**](./#stack-shellcode): Esto es útil para almacenar un shellcode en la pila antes o después de sobrescribir el puntero de retorno y luego **saltar a él** para ejecutarlo:
* **En cualquier caso, si hay un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** en un bof regular necesitarás evadirlo (filtrarlo).
* **Sin** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **y sin** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) es posible saltar a la dirección de la pila ya que nunca cambiará.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) necesitarás técnicas como [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) para saltar a ella.
* **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), necesitarás usar algún [**ROP**](../rop-return-oriented-programing/) **para llamar a `memprotect`** y hacer que alguna página sea `rwx`, para luego **almacenar el shellcode allí** (llamando a read por ejemplo) y luego saltar allí.
* Esto mezclará el shellcode con una cadena ROP.
#### A través de syscalls

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): Útil para llamar a `execve` y ejecutar comandos arbitrarios. Necesitas encontrar los **gadgets para llamar al syscall específico con los parámetros**.
* Si se habilita [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/), necesitarás vencerlos **para usar los gadgets ROP** del binario o las bibliotecas.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) puede ser útil para preparar el **ret2execve**.
* Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) y [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) para controlar varios registros.

#### A través de libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Útil para llamar a una función de una biblioteca (generalmente de **`libc`**) como **`system`** con algunos argumentos preparados (por ejemplo, `'/bin/sh'`). Necesitas que el binario **cargue la biblioteca** con la función que deseas llamar (generalmente libc).
* Si está **compilado estáticamente y no hay** [**PIE**](../common-binary-protections-and-bypasses/pie/), la **dirección** de `system` y `/bin/sh` no cambiarán, por lo que es posible usarlos estáticamente.
* **Sin** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **y conociendo la versión de libc** cargada, la **dirección** de `system` y `/bin/sh` no cambiarán, por lo que es posible usarlos estáticamente.
* Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **pero sin** [**PIE**](../common-binary-protections-and-bypasses/pie/), conociendo la libc y con el binario utilizando la función `system` es posible **`ret` a la dirección de system en el GOT** con la dirección de `'/bin/sh'` en el parámetro (tendrás que descubrir esto).
* Con [ASLR](../common-binary-protections-and-bypasses/aslr/) pero sin [PIE](../common-binary-protections-and-bypasses/pie/), conociendo la libc y **sin que el binario utilice el `system`**:
* Usa [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) para resolver la dirección de `system` y llamarla&#x20;
* **Evade** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) y calcula la dirección de `system` y `'/bin/sh'` en memoria.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **y** [**PIE**](../common-binary-protections-and-bypasses/pie/) **y sin conocer la libc**: Necesitas:
* Evadir [**PIE**](../common-binary-protections-and-bypasses/pie/)
* Encontrar la **versión de `libc`** utilizada (filtrar un par de direcciones de funciones)
* Verificar los **escenarios anteriores con ASLR** para continuar.

#### A través de EBP/RBP

* [**Pivoteo de pila / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controla el ESP para controlar RET a través del EBP almacenado en la pila.
* Útil para desbordamientos de pila **off-by-one**.
* Útil como una forma alternativa de controlar EIP mientras se abusa de EIP para construir la carga útil en memoria y luego saltar a ella a través de EBP.

#### Misceláneo

* [**Redirección de punteros**](../stack-overflow/pointer-redirecting.md): En caso de que la pila contenga punteros a una función que va a ser llamada o a una cadena que va a ser utilizada por una función interesante (system o printf), es posible sobrescribir esa dirección.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) podrían afectar las direcciones.
* [**Variables no inicializadas**](../stack-overflow/uninitialized-variables.md): Nunca se sabe.
