# ベーシックバイナリエクスプロイテーション手法

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合は**、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローする**。
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

## ELF基本情報

何かをエクスプロイトする前に、**ELFバイナリ**の構造の一部を理解することが興味深いです：

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## エクスプロイトツール

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## スタックオーバーフローメソドロジー

多くのテクニックがあるため、各テクニックがいつ役立つかを理解するためのスキームを持っていると良いです。同じ保護が異なるテクニックに影響を与えることに注意してください。保護をバイパスする方法は各保護セクションで見つけることができますが、この手法では見つけることはできません。

## フローの制御

プログラムのフローを制御する方法はいくつかあります：

* **スタックオーバーフロー**を使用して、スタックから戻りポインタまたはEBP -> ESP -> EIPを上書きする
* **整数オーバーフロー**を悪用してオーバーフローを引き起こす必要がある場合があります
* または**任意の書き込み+書き込む場所への実行**を介して
* **フォーマット文字列**：`printf`を悪用して、任意のアドレスに任意のコンテンツを書き込む
* **配列インデックス**：設計が不十分なインデックスを悪用して、いくつかの配列を制御し、任意の書き込みを取得できるようにする
* **整数オーバーフロー**を悪用してオーバーフローを引き起こす必要がある場合があります
* **bof to WWW via ROP**：バッファオーバーフローを悪用してROPを構築し、WWWを取得できるようにする

**Write What Where to Execution**のテクニックは以下で見つけることができます：

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 永続的なループ

考慮すべき重要な点は、通常**脆弱性の単一のエクスプロイトだけでは十分でない**ことです。特にいくつかの保護をバイパスする必要がある場合があります。したがって、**単一の脆弱性を同じバイナリの実行中に複数回エクスプロイト可能にする**いくつかのオプションを検討することが重要です：

* **ROP**チェーンに**`main`関数のアドレス**または**脆弱性が発生しているアドレス**を書き込む
* 適切なROPチェーンを制御することで、そのチェーン内のすべてのアクションを実行できるかもしれません
* **`exit`アドレスをGOT**（または終了前にバイナリで使用される他の関数）に書き込んで**脆弱性に戻るアドレス**を指定する
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)で説明されているように、ここに2つの関数を保存し、脆弱性を再度呼び出すための1つと`.fini_array`から再度関数を呼び出す**`__libc_csu_fini`**のためのもう1つを保存します。

## エクスプロイトの目標

### 目標：既存の関数を呼び出す

* **ret2win**：呼び出す必要のあるコード内の関数があります（おそらく特定のパラメータを使用して）。フラグを取得するために。
* **PIE**と**canary**なしの通常のbofでは、スタックに格納された戻りアドレスにアドレスを書き込むだけで済みます。
* [**PIE**](../common-binary-protections-and-bypasses/pie/)を使用するbofでは、バイパスする必要があります
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)を使用するbofでは、バイパスする必要があります
* **ret2win**関数を正しく呼び出すために複数のパラメータを設定する必要がある場合は、次のようにできます：
* **ROP**チェーン（十分なガジェットがある場合）を使用してすべてのパラメータを準備する
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)（このシステムコールを呼び出すことができる場合）を使用して多くのレジスタを制御する
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)および[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)からのガジェットを使用して複数のレジスタを制御する
* [**Write What Where**](../arbitrary-write-2-exec/)を介して、他の脆弱性（bof以外）を悪用して**`win`**関数を呼び出すことができます。
* [**ポインタリダイレクト**](../stack-overflow/pointer-redirecting.md)：スタックに関数へのポインタが含まれているか、興味深い関数（systemまたはprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることができます。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)はアドレスに影響を与える可能性があります。
* [**未初期化変数**](../stack-overflow/uninitialized-variables.md)：わからないことがあります。

### 目標：RCE

#### nxが無効になっている場合やシェルコードをROPと混在させる場合：

* **（スタック）シェルコード**：これは、スタックにシェルコードを保存してから、戻りポインタを上書きした後にそれにジャンプして実行するために役立ちます：
* **通常のbofで** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**がある場合は**、バイパス（リーク）が必要です
* **ASLR**と**nx**がない場合、スタックのアドレスにジャンプできるため、そのアドレスにジャンプできます
* **ASLR**がある場合、[**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)などのテクニックを使用してジャンプする必要があります
* **nx**がある場合、[**ROP**](../rop-return-oriented-programing/)を使用して`memprotect`を呼び出してページを`rwx`にする必要があります。その後、そこにシェルコードを保存するために（たとえばreadを呼び出して）ジャンプする必要があります。
* これにより、シェルコードがROPチェーンと混在します。
#### シスコール経由

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): 任意のコマンドを実行するために`execve`を呼び出すのに便利です。**特定のシスコールをパラメータとともに呼び出すためのガジェットを見つける必要があります**。
* もし[**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)が有効になっている場合、バイナリやライブラリからのROPガジェットを使用するためにそれらを打破する必要があります。
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)は**ret2execve**を準備するのに役立ちます。
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)や[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)から複数のレジスタを制御するためのガジェット

#### libc経由

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 通常は**`libc`**からの関数（通常は**`system`**）を呼び出すのに便利です。準備された引数（例：`'/bin/sh'`）と共に。呼び出したい関数を含むライブラリをバイナリが**ロードする必要があります**。
* **静的にコンパイルされており**[**PIE**](../common-binary-protections-and-bypasses/pie/)がない場合、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用することが可能です。
* **ASLR**なしで**libcのバージョンを知っている場合**、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用することが可能です。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)があるが[**PIE**](../common-binary-protections-and-bypasses/pie/)がない場合、libcを知っていてバイナリが`system`関数を使用している場合、`'/bin/sh'`のアドレスをパラメータとして`GOT`内のsystemのアドレスに**`ret`する**ことが可能です（これを解決する必要があります）。
* [ASLR](../common-binary-protections-and-bypasses/aslr/)があるが[PIE](../common-binary-protections-and-bypasses/pie/)がない場合、libcを知っていて**バイナリが`system`を使用していない場合**：
* [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)を使用して`system`のアドレスを解決し、それを呼び出す&#x20;
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)を**バイパス**して、メモリ内の`system`と`'/bin/sh'`のアドレスを計算します。
* **ASLR**があり、**PIE**があり、libcがわからない場合：次の手順が必要です：
* [**PIE**](../common-binary-protections-and-bypasses/pie/)をバイパスする
* 使用されている**`libc`バージョン**を見つける（いくつかの関数アドレスをリークさせる）
* 続行するために**ASLRの前のシナリオを確認します**。

#### EBP/RBP経由

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): スタック内の保存されたEBPを介してESPを制御してRETを制御します。
* **オフバイワン**スタックオーバーフローに便利
* EIPを制御する代替手段として役立ち、EIPを悪用してメモリ内でペイロードを構築し、それにジャンプする方法

#### その他

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): スタックに呼び出される関数へのポインタや、興味深い関数（systemやprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることが可能です。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)がアドレスに影響を与える可能性があります。
* [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): 予測できません。
