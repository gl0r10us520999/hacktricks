# Metodologia di base per l'exploit di binari

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di base su ELF

Prima di iniziare a sfruttare qualsiasi cosa, √® interessante comprendere parte della struttura di un **binario ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Strumenti di exploitazione

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## Metodologia dello stack overflow

Con cos√¨ tante tecniche √® utile avere uno schema in cui ogni tecnica sar√† utile. Nota che le stesse protezioni influenzeranno tecniche diverse. √à possibile trovare modi per aggirare le protezioni in ciascuna sezione di protezione ma non in questa metodologia.

## Controllo del flusso

Ci sono diversi modi in cui potresti finire per controllare il flusso di un programma:

* [**Stack Overflows**](../stack-overflow/) sovrascrivendo il puntatore di ritorno dallo stack o l'EBP -> ESP -> EIP.
* Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow
* Oppure tramite **Scritture Arbitrarie + Scrivi Cosa Dove all'Esecuzione**
* [**Stringhe di formato**](../format-strings/)**:** Abusare di `printf` per scrivere contenuti arbitrari in indirizzi arbitrari.
* [**Indicizzazione di array**](../array-indexing.md): Abusare di un'indicizzazione mal progettata per poter controllare alcuni array e ottenere una scrittura arbitraria.
* Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow
* **bof to WWW via ROP**: Abusare di un buffer overflow per costruire un ROP e poter ottenere un WWW.

√à possibile trovare le tecniche di **Scrivi Cosa Dove all'Esecuzione** in:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Loop eterni

Qualcosa da tenere in considerazione √® che di solito **un solo sfruttamento di una vulnerabilit√† potrebbe non essere sufficiente** per eseguire con successo un exploit, specialmente se alcune protezioni devono essere aggirate. Pertanto, √® interessante discutere alcune opzioni per **rendere una singola vulnerabilit√† sfruttabile pi√π volte** nella stessa esecuzione del binario:

* Scrivere in una catena **ROP** l'indirizzo della funzione **`main`** o all'indirizzo in cui si verifica la **vulnerabilit√†**.
* Controllando una corretta catena ROP potresti essere in grado di eseguire tutte le azioni in quella catena
* Scrivere nell'indirizzo **`exit` in GOT** (o in qualsiasi altra funzione utilizzata dal binario prima della fine) l'indirizzo per tornare alla **vulnerabilit√†**
* Come spiegato in [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)**,** memorizzare qui 2 funzioni, una per richiamare nuovamente la vulnerabilit√† e un'altra per richiamare**`__libc_csu_fini`** che richiamer√† nuovamente la funzione da `.fini_array`.

## Obiettivi dell'exploit

### Obiettivo: Chiamare una funzione esistente

* [**ret2win**](./#ret2win): C'√® una funzione nel codice che devi chiamare (forse con alcuni parametri specifici) per ottenere la flag.
* In un **bof regolare senza** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) devi solo scrivere l'indirizzo nell'indirizzo di ritorno memorizzato nello stack.
* In un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/), dovrai aggirarlo
* In un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), dovrai aggirarlo
* Se √® necessario impostare diversi parametri per chiamare correttamente la funzione **ret2win** puoi usare:
* Una catena [**ROP**](./#rop-and-ret2...-techniques) **se ci sono abbastanza gadget** per preparare tutti i parametri
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (nel caso in cui puoi chiamare questa syscall) per controllare molti registri
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri
* Attraverso un [**Scrivi Cosa Dove**](../arbitrary-write-2-exec/) potresti abusare di altre vulnerabilit√† (non bof) per chiamare la funzione **`win`**.
* [**Reindirizzamento dei puntatori**](../stack-overflow/pointer-redirecting.md): Nel caso lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

### Obiettivo: RCE

#### Tramite shellcode, se nx disabilitato o mescolando shellcode con ROP:

* [**(Stack) Shellcode**](./#stack-shellcode): Questo √® utile per memorizzare uno shellcode nello stack prima o dopo la sovrascrittura del puntatore di ritorno e quindi **saltare ad esso** per eseguirlo:
* **In ogni caso, se c'√® un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** in un bof regolare dovrai aggirarlo (leak)
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) √® possibile saltare all'indirizzo dello stack poich√© non cambier√† mai
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) dovrai utilizzare tecniche come [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) per saltarci
* **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), dovrai utilizzare alcuni [**ROP**](../rop-return-oriented-programing/) **per chiamare `memprotect`** e rendere alcune pagine `rwx`, per poi **memorizzare lo shellcode l√¨** (chiamando ad esempio read) e poi saltare l√¨.
* Questo mescoler√† lo shellcode con una catena ROP.
#### Attraverso le syscalls

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): Utile per chiamare `execve` per eseguire comandi arbitrari. √à necessario essere in grado di trovare i **gadget per chiamare la specifica syscall con i parametri**.
* Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) sono abilitati, sar√† necessario sconfiggerli **per utilizzare i gadget ROP** dal binario o dalle librerie.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) pu√≤ essere utile per preparare il **ret2execve**
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri

#### Attraverso libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Utile per chiamare una funzione da una libreria (di solito da **`libc`**) come **`system`** con alcuni argomenti preparati (ad es. `'/bin/sh'`). √à necessario che il binario **carichi la libreria** con la funzione che si desidera chiamare (di solito libc).
* Se **compilato staticamente e senza** [**PIE**](../common-binary-protections-and-bypasses/pie/), l'**indirizzo** di `system` e `/bin/sh` non cambieranno, quindi √® possibile utilizzarli staticamente.
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e conoscendo la versione di libc** caricata, l'**indirizzo** di `system` e `/bin/sh` non cambieranno, quindi √® possibile utilizzarli staticamente.
* Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ma senza** [**PIE**](../common-binary-protections-and-bypasses/pie/), conoscendo la libc e con il binario che utilizza la funzione `system` √® possibile **`ret` all'indirizzo di system nel GOT** con l'indirizzo di `'/bin/sh'` nei parametri (bisogner√† capire questo).
* Con [ASLR](../common-binary-protections-and-bypasses/aslr/) ma senza [PIE](../common-binary-protections-and-bypasses/pie/), conoscendo la libc e **senza che il binario utilizzi il `system`**:
* Utilizzare [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) per risolvere l'indirizzo di `system` e chiamarlo&#x20;
* **Eludere** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) e calcolare l'indirizzo di `system` e `'/bin/sh'` in memoria.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e senza conoscere la libc**: √à necessario:
* Eludere [**PIE**](../common-binary-protections-and-bypasses/pie/)
* Trovare la **versione di `libc`** utilizzata (effettuare un leak di un paio di indirizzi di funzione)
* Controllare i **scenari precedenti con ASLR** per continuare.

#### Attraverso EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controllare l'ESP per controllare RET attraverso l'EBP memorizzato nello stack.
* Utile per **overflow dello stack di uno**
* Utile come modo alternativo per controllare EIP mentre si abusa di EIP per costruire il payload in memoria e quindi saltare ad esso tramite EBP

#### Varie

* [**Riorientamento dei puntatori**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai
