# Podstawowa Metodologia Eksploatacji Binarnych

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>
{% endhint %}

## Podstawowe Informacje o ELF

Zanim zaczniesz eksploatować cokolwiek, warto zrozumieć część struktury **pliku binarnego ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Narzędzia Eksploatacji

{% content-ref url="tools/" %}
[narzędzia](tools/)
{% endcontent-ref %}

## Metodologia Przepełnienia Stosu

Przy tak wielu technikach dobrze jest mieć schemat, kiedy każda technika będzie przydatna. Zauważ, że te same zabezpieczenia będą wpływać na różne techniki. Możesz znaleźć sposoby na obejście zabezpieczeń w każdej sekcji zabezpieczeń, ale nie w tej metodologii.

## Kontrolowanie Przepływu

Istnieją różne sposoby, w jakie możesz kontrolować przepływ programu:

* [**Przepełnienia Stosu**](../stack-overflow/) nadpisując wskaźnik powrotu ze stosu lub EBP -> ESP -> EIP.
* Może być konieczne nadużycie [**Przepełnień Liczbowych**](../integer-overflow.md), aby spowodować przepełnienie.
* Lub poprzez **Arbitralne Zapisanie + Write What Where to Execution**.
* [**Formaty ciągów**](../format-strings/)**:** Nadużyj `printf`, aby zapisać arbitralną zawartość w arbitralnych adresach.
* [**Indeksowanie Tablic**](../array-indexing.md): Nadużyj źle zaprojektowanego indeksowania, aby móc kontrolować niektóre tablice i uzyskać arbitralne zapisanie.
* Może być konieczne nadużycie [**Przepełnień Liczbowych**](../integer-overflow.md), aby spowodować przepełnienie.
* **bof do WWW poprzez ROP**: Nadużyj przepełnienia bufora, aby skonstruować ROP i móc uzyskać WWW.

Możesz znaleźć techniki **Write What Where to Execution** w:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Wieczne Pętle

Coś, co należy wziąć pod uwagę, to że zazwyczaj **jedna eksploatacja luki może nie być wystarczająca**, aby przeprowadzić udaną eksploatację, szczególnie niektóre zabezpieczenia muszą być obejście. Dlatego warto omówić kilka opcji, aby **uczynić jedną lukę eksploatowalną wiele razy** w tej samej egzekucji binarnej:

* Zapisz w łańcuchu **ROP** adres funkcji **`main`** lub adres, w którym występuje **luka**.
* Kontrolując odpowiedni łańcuch ROP, możesz wykonać wszystkie akcje w tym łańcuchu.
* Zapisz w **adresie `exit` w GOT** (lub jakiejkolwiek innej funkcji używanej przez binarny przed zakończeniem) adres, aby wrócić **do luki**.
* Jak wyjaśniono w [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)**,** przechowuj tutaj 2 funkcje, jedną do ponownego wywołania luki i drugą do wywołania **`__libc_csu_fini`**, która ponownie wywoła funkcję z `.fini_array`.

## Cele Eksploatacji

### Cel: Wywołanie Istniejącej Funkcji

* [**ret2win**](./#ret2win): Istnieje funkcja w kodzie, którą musisz wywołać (może z pewnymi specyficznymi parametrami), aby uzyskać flagę.
* W **zwykłym bof bez** [**PIE**](../common-binary-protections-and-bypasses/pie/) **i** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) wystarczy zapisać adres w adresie powrotu przechowywanym na stosie.
* W bof z [**PIE**](../common-binary-protections-and-bypasses/pie/), będziesz musiał to obejść.
* W bof z [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), będziesz musiał to obejść.
* Jeśli musisz ustawić kilka parametrów, aby poprawnie wywołać funkcję **ret2win**, możesz użyć:
* Łańcucha [**ROP**](./#rop-and-ret2...-techniques) **jeśli jest wystarczająco dużo gadżetów**, aby przygotować wszystkie parametry.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (w przypadku, gdy możesz wywołać ten syscall) do kontrolowania wielu rejestrów.
* Gadżetów z [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) i [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) do kontrolowania kilku rejestrów.
* Poprzez [**Write What Where**](../arbitrary-write-2-exec/) możesz nadużyć innych luk (nie bof), aby wywołać funkcję **`win`**.
* [**Przekierowywanie Wskaźników**](../stack-overflow/pointer-redirecting.md): W przypadku, gdy stos zawiera wskaźniki do funkcji, która ma być wywołana lub do ciągu, który ma być użyty przez interesującą funkcję (system lub printf), możliwe jest nadpisanie tego adresu.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/) mogą wpływać na adresy.
* [**Niezainicjowane zmienne**](../stack-overflow/uninitialized-variables.md): Nigdy nie wiesz.

### Cel: RCE

#### Poprzez shellcode, jeśli nx wyłączone lub mieszając shellcode z ROP:

* [**(Stos) Shellcode**](./#stack-shellcode): To jest przydatne do przechowywania shellcode na stosie przed lub po nadpisaniu wskaźnika powrotu, a następnie **skoczyć do niego**, aby go wykonać:
* **W każdym przypadku, jeśli istnieje** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** w zwykłym bof będziesz musiał to obejść (leak).
* **Bez** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) możliwe jest skoczenie do adresu stosu, ponieważ nigdy się nie zmieni.
* **Z** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) będziesz potrzebować technik takich jak [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md), aby do niego skoczyć.
* **Z** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), będziesz musiał użyć [**ROP**](../rop-return-oriented-programing/), **aby wywołać `memprotect`** i ustawić stronę `rwx`, aby następnie **przechować shellcode tam** (wywołując read na przykład) i następnie skoczyć tam.
* To połączy shellcode z łańcuchem ROP.

#### Poprzez syscalls

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): Przydatne do wywołania `execve`, aby uruchomić arbitralne polecenia. Musisz być w stanie znaleźć **gadżety do wywołania konkretnego syscall z parametrami**.
* Jeśli [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/) są włączone, będziesz musiał je pokonać **w celu użycia gadżetów ROP** z binarnego lub bibliotek.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) może być przydatne do przygotowania **ret2execve**.
* Gadżety z [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) i [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) do kontrolowania kilku rejestrów.

#### Poprzez libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Przydatne do wywołania funkcji z biblioteki (zwykle z **`libc`**) jak **`system`** z pewnymi przygotowanymi argumentami (np. `'/bin/sh'`). Musisz, aby binarny **załadował bibliotekę** z funkcją, którą chciałbyś wywołać (zwykle libc).
* Jeśli **skompilowane statycznie i bez** [**PIE**](../common-binary-protections-and-bypasses/pie/), **adres** `system` i `/bin/sh` nie będą się zmieniać, więc możliwe jest ich użycie statycznie.
* **Bez** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i znając wersję libc** załadowaną, **adres** `system` i `/bin/sh` nie będą się zmieniać, więc możliwe jest ich użycie statycznie.
* Z [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ale bez** [**PIE**](../common-binary-protections-and-bypasses/pie/)**, znając libc i z binarnym używającym funkcji `system`**, możliwe jest **`ret` do adresu system w GOT** z adresem `'/bin/sh'` w parametrze (musisz to ustalić).
* Z [ASLR](../common-binary-protections-and-bypasses/aslr/) ale bez [PIE](../common-binary-protections-and-bypasses/pie/), znając libc i **bez binarnego używającego `system`**:
* Użyj [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md), aby rozwiązać adres `system` i go wywołać.
* **Obejdź** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) i oblicz adres `system` i `'/bin/sh'` w pamięci.
* **Z** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i** [**PIE**](../common-binary-protections-and-bypasses/pie/) **i nie znając libc**: Musisz:
* Obejść [**PIE**](../common-binary-protections-and-bypasses/pie/).
* Znaleźć **wersję `libc`** używaną (leak kilka adresów funkcji).
* Sprawdzić **poprzednie scenariusze z ASLR**, aby kontynuować.

#### Poprzez EBP/RBP

* [**Pivotowanie Stosu / EBP2Ret / Łańcuchowanie EBP**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Kontroluj ESP, aby kontrolować RET poprzez przechowywane EBP na stosie.
* Przydatne dla **przepełnień stosu off-by-one**.
* Przydatne jako alternatywny sposób na kontrolowanie EIP, nadużywając EIP do skonstruowania ładunku w pamięci, a następnie skacząc do niego poprzez EBP.

#### Różne

* [**Przekierowywanie Wskaźników**](../stack-overflow/pointer-redirecting.md): W przypadku, gdy stos zawiera wskaźniki do funkcji, która ma być wywołana lub do ciągu, który ma być użyty przez interesującą funkcję (system lub printf), możliwe jest nadpisanie tego adresu.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/) mogą wpływać na adresy.
* [**Niezainicjowane zmienne**](../stack-overflow/uninitialized-variables.md): Nigdy nie wiesz.

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>
{% endhint %}
