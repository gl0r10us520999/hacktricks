# ベーシックバイナリエクスプロイテーション手法

{% hint style="success" %}
AWSハッキングの学習と練習:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と**HackTricks Cloud**のGitHubリポジトリにPRを提出して、ハッキングトリックを共有してください。

</details>
{% endhint %}

## ELF基本情報

何かをエクスプロイトする前に、**ELFバイナリ**の構造の一部を理解することが興味深いです：

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## エクスプロイトツール

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## スタックオーバーフロー手法

多くのテクニックがあるため、各テクニックがいつ役立つかを把握するスキームを持っていると良いです。同じ保護が異なるテクニックに影響を与えることに注意してください。保護のセクションごとに保護をバイパスする方法を見つけることができますが、この手法ではありません。

## フローの制御

プログラムのフローを制御する方法はいくつかあります：

* [**スタックオーバーフロー**](../stack-overflow/)：スタックからリターンポインタまたはEBP -> ESP -> EIPを上書きします。
* オーバーフローを引き起こすために[**整数オーバーフロー**](../integer-overflow.md)を悪用する必要があるかもしれません
* または**任意の書き込み + 書き込む場所への実行**
* [**フォーマット文字列**](../format-strings/)**:** `printf`を悪用して、任意のアドレスに任意のコンテンツを書き込みます。
* [**配列インデックス**](../array-indexing.md)：設計が不十分なインデックスを悪用して、いくつかの配列を制御し、任意の書き込みを取得できるようにします。
* オーバーフローを引き起こすために[**整数オーバーフロー**](../integer-overflow.md)を悪用する必要があるかもしれません
* **bof to WWW via ROP**：バッファオーバーフローを悪用してROPを構築し、WWWを取得できるようにします。

**Write What Where to Execution**の手法は以下で見つけることができます：

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 永続的なループ

考慮すべきことの1つは、通常**脆弱性の単一のエクスプロイトだけでは十分でない**ことです。特にいくつかの保護をバイパスする必要がある場合があります。したがって、**単一の脆弱性を同じバイナリの実行中に複数回エクスプロイト可能にする**いくつかのオプションを検討することが興味深いです：

* **ROP**チェーンに**`main`関数のアドレス**または**脆弱性が発生しているアドレス**を書き込む
* 適切なROPチェーンを制御することで、そのチェーン内のすべてのアクションを実行できるかもしれません
* **`exit`アドレスをGOT**（または終了前にバイナリで使用される他の関数）に書き込んで、**脆弱性に戻るアドレス**を指定します
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)で説明されているように、ここに2つの関数を保存し、脆弱性を再度呼び出すためのものと、`.fini_array`から再度関数を呼び出す**`__libc_csu_fini`**を呼び出すためのものを保存します。

## エクスプロイトの目標

### 目標: 既存の関数を呼び出す

* [**ret2win**](./#ret2win)：呼び出す必要のあるコード内の関数（おそらく特定のパラメータを使用して）があります。
* [**PIE**](../common-binary-protections-and-bypasses/pie/) **および** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) **なしの**通常のbofでは、スタックに格納されたリターンアドレスにアドレスを書き込むだけで済みます。
* [**PIE**](../common-binary-protections-and-bypasses/pie/)を使用するbofの場合、バイパスする必要があります
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)を使用するbofの場合、バイパスする必要があります
* **ret2win**関数を正しく呼び出すために複数のパラメータを設定する必要がある場合は、次のようにできます：
* 十分なガジェットがある場合は、[**ROP**](./#rop-and-ret2...-techniques) **チェーン**を使用してすべてのパラメータを準備します
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)（このシステムコールを呼び出すことができる場合）を使用して、多くのレジスタを制御します
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)および[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)からのガジェットを使用して、複数のレジスタを制御します
* [**Write What Where**](../arbitrary-write-2-exec/)を介して、他の脆弱性（bof以外）を悪用して**`win`**関数を呼び出すことができます。
* [**ポインタのリダイレクト**](../stack-overflow/pointer-redirecting.md)：スタックに関数へのポインタが含まれている場合、そのアドレスを上書きすることができます。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)はアドレスに影響を与える可能性があります。
* [**未初期化変数**](../stack-overflow/uninitialized-variables.md)：わからないことがあります。

### 目標: RCE

#### nxが無効になっている場合やシェルコードとROPを混在させる場合：

* [**(スタック) シェルコード**](./#stack-shellcode)：スタックにシェルコードを保存してから、リターンポインタを上書きする前または後にジャンプして実行します：
* **通常のbofで** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**がある場合、バイパス（リーク）する必要があります**
* **[ASLR](../common-binary-protections-and-bypasses/aslr/)** **および** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) **なしの場合、スタックのアドレスにジャンプできます**（変更されないため）
* **[ASLR](../common-binary-protections-and-bypasses/aslr/)**がある場合、[**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)などのテクニックを使用してジャンプする必要があります
* **[nx](../common-binary-protections-and-bypasses/no-exec-nx.md)**がある場合、[**ROP**](../rop-return-oriented-programing/)を使用して`memprotect`を呼び出し、ページを`rwx`に変更してから（たとえばreadを呼び出して）そこにシェルコードを保存し、そこにジャンプする必要があります。
* これにより、シェルコードがROPチェーンと混在します。
#### シスコール経由

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): `execve`を呼び出して任意のコマンドを実行するのに便利です。**特定のシスコールを呼び出すためのガジェットを見つける必要があります**。
* もし[**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)が有効になっている場合、バイナリやライブラリからのROPガジェットを使用するためには、それらを**打破する必要があります**。
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)は**ret2execve**を準備するのに役立ちます。
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)や[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)から複数のレジスタを制御するためのガジェット

#### libc経由

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 通常は**`libc`**からの関数（通常は**`system`**）を呼び出すのに便利です。準備された引数（例：`'/bin/sh'`）と共に。呼び出したい関数を含むライブラリをバイナリが**ロードする必要があります**。
* **静的にコンパイルされており**[**PIE**](../common-binary-protections-and-bypasses/pie/)がない場合、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用できます。
* **ASLR**が**無効**で、ロードされたlibcのバージョンを知っている場合、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用できます。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)が有効でも[**PIE**](../common-binary-protections-and-bypasses/pie/)が**無い**場合、libcを知っていてバイナリが`system`を使用している場合、`'/bin/sh'`のアドレスと共に**GOT内のsystemのアドレスに`ret`**することが可能です（これを解明する必要があります）。
* [ASLR](../common-binary-protections-and-bypasses/aslr/)が有効でも[PIE](../common-binary-protections-and-bypasses/pie/)が**無い**場合、libcを知っていて**バイナリが`system`を使用していない**場合：
* [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)を使用して`system`のアドレスを解決し、それを呼び出す&#x20;
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)を**バイパス**して、メモリ内の`system`と`'/bin/sh'`のアドレスを計算します。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)と[**PIE**](../common-binary-protections-and-bypasses/pie/)が**有効**で、libcを知らない場合：以下が必要です：
* [**PIE**](../common-binary-protections-and-bypasses/pie/)をバイパスする
* 使用されている**`libc`バージョン**を見つける（いくつかの関数アドレスをリークさせる）
* 続行するために**ASLRの前述のシナリオを確認します**。

#### EBP/RBP経由

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): スタック内の保存されたEBPを介してESPを制御してRETを制御します。
* **オフバイワン**スタックオーバーフローに便利
* EIPを制御する代替方法として役立ち、EIPを悪用してメモリ内でペイロードを構築し、それをEBP経由でジャンプする方法

#### その他

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): スタックに呼び出される関数へのポインタや、興味深い関数（systemやprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることが可能です。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)がアドレスに影響を与える可能性があります。
* [**未初期化変数**](../stack-overflow/uninitialized-variables.md): 決してわかりません
