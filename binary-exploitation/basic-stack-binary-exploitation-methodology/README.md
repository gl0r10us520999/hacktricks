# Metodologia di Base per l'Esplorazione Binaria

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
{% endhint %}

## Informazioni di Base su ELF

Prima di iniziare a sfruttare qualsiasi cosa, √® interessante comprendere parte della struttura di un **binario ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Strumenti di Sfruttamento

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## Metodologia dello Sfruttamento dello Stack Overflow

Con cos√¨ tante tecniche, √® utile avere uno schema in cui ogni tecnica sar√† utile. Nota che le stesse protezioni influenzeranno diverse tecniche. Puoi trovare modi per aggirare le protezioni in ciascuna sezione di protezione ma non in questa metodologia.

## Controllo del Flusso

Ci sono diversi modi in cui potresti finire per controllare il flusso di un programma:

* [**Stack Overflows**](../stack-overflow/) sovrascrivendo il puntatore di ritorno dallo stack o l'EBP -> ESP -> EIP.
* Potresti dover abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow
* Oppure tramite **Scritture Arbitrarie + Write What Where to Execution**
* [**Stringhe di Formato**](../format-strings/)**:** Abusare di `printf` per scrivere contenuti arbitrari in indirizzi arbitrari.
* [**Indicizzazione di Array**](../array-indexing.md): Abusare di un'indicizzazione mal progettata per poter controllare alcuni array e ottenere una scrittura arbitraria.
* Potresti dover abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow
* **bof to WWW via ROP**: Abusare di un buffer overflow per costruire un ROP e poter ottenere un WWW.

Puoi trovare le tecniche di **Write What Where to Execution** in:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Cicli Eterni

Qualcosa da tenere in considerazione √® che di solito **un solo sfruttamento di una vulnerabilit√† potrebbe non essere sufficiente** per eseguire con successo uno sfruttamento, specialmente se alcune protezioni devono essere aggirate. Pertanto, √® interessante discutere alcune opzioni per **rendere una singola vulnerabilit√† sfruttabile pi√π volte** nella stessa esecuzione del binario:

* Scrivere in una catena **ROP** l'indirizzo della funzione **`main`** o l'indirizzo in cui si verifica la **vulnerabilit√†**.
* Controllando una corretta catena ROP potresti essere in grado di eseguire tutte le azioni in quella catena
* Scrivere l'indirizzo di **`exit` in GOT** (o di qualsiasi altra funzione utilizzata dal binario prima della fine) per tornare all'indirizzo della vulnerabilit√†
* Come spiegato in [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)**,** memorizzare qui 2 funzioni, una per richiamare nuovamente la vulnerabilit√† e un'altra per richiamare**`__libc_csu_fini`** che richiamer√† nuovamente la funzione da `.fini_array`.

## Obiettivi dello Sfruttamento

### Obiettivo: Chiamare una Funzione Esistente

* [**ret2win**](./#ret2win): C'√® una funzione nel codice che devi chiamare (forse con alcuni parametri specifici) per ottenere la flag.
* In un **bof regolare senza** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) devi solo scrivere l'indirizzo nell'indirizzo di ritorno memorizzato nello stack.
* In un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/), dovrai aggirarlo
* In un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), dovrai aggirarlo
* Se devi impostare diversi parametri per chiamare correttamente la funzione **ret2win** puoi usare:
* Una catena [**ROP**](./#rop-and-ret2...-techniques) **se ci sono abbastanza gadget** per preparare tutti i parametri
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (nel caso in cui puoi chiamare questa syscall) per controllare molti registri
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri
* Attraverso un [**Write What Where**](../arbitrary-write-2-exec/) potresti abusare di altre vulnerabilit√† (non bof) per chiamare la funzione **`win`**.
* [**Reindirizzamento dei Puntatori**](../stack-overflow/pointer-redirecting.md): Nel caso lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

### Obiettivo: RCE

#### Tramite shellcode, se nx disabilitato o mescolando shellcode con ROP:

* [**(Stack) Shellcode**](./#stack-shellcode): √à utile memorizzare uno shellcode nello stack prima o dopo la sovrascrittura del puntatore di ritorno e quindi **saltare ad esso** per eseguirlo:
* **In ogni caso, se c'√® un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** in un bof regolare dovrai aggirarlo (leak)
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) √® possibile saltare all'indirizzo dello stack poich√© non cambier√† mai
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) dovrai utilizzare tecniche come [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) per saltarci
* **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), dovrai utilizzare alcuni [**ROP**](../rop-return-oriented-programing/) **per chiamare `memprotect`** e rendere alcune pagine `rwx`, per poi **memorizzare lo shellcode l√¨** (chiamando ad esempio read) e quindi saltare l√¨.
* Questo mescoler√† lo shellcode con una catena ROP.
#### Attraverso le syscalls

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): Utile per chiamare `execve` per eseguire comandi arbitrari. √à necessario essere in grado di trovare i **gadget per chiamare la syscall specifica con i parametri**.
* Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) sono abilitati, sar√† necessario sconfiggerli **per utilizzare i gadget ROP** dal binario o dalle librerie.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) pu√≤ essere utile per preparare il **ret2execve**
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri

#### Attraverso libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Utile per chiamare una funzione da una libreria (di solito da **`libc`**) come **`system`** con alcuni argomenti preparati (ad es. `'/bin/sh'`). √à necessario che il binario **carichi la libreria** con la funzione che si desidera chiamare (di solito libc).
* Se **compilato staticamente e senza** [**PIE**](../common-binary-protections-and-bypasses/pie/), l'**indirizzo** di `system` e `/bin/sh` non cambieranno, quindi √® possibile utilizzarli staticamente.
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e conoscendo la versione di libc** caricata, l'**indirizzo** di `system` e `/bin/sh` non cambieranno, quindi √® possibile utilizzarli staticamente.
* Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ma senza** [**PIE**](../common-binary-protections-and-bypasses/pie/)**, conoscendo la libc e con il binario che utilizza la funzione `system`** √® possibile **`ret` all'indirizzo di system nel GOT** con l'indirizzo di `'/bin/sh'` nei parametri (dovrai risolvere questo).
* Con [ASLR](../common-binary-protections-and-bypasses/aslr/) ma senza [PIE](../common-binary-protections-and-bypasses/pie/), conoscendo la libc e **senza che il binario utilizzi la funzione `system`**:
* Utilizzare [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) per risolvere l'indirizzo di `system` e chiamarlo&#x20;
* **Eludere** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) e calcolare l'indirizzo di `system` e `'/bin/sh'` in memoria.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e senza conoscere la libc**: √à necessario:
* Eludere [**PIE**](../common-binary-protections-and-bypasses/pie/)
* Trovare la **versione di `libc`** utilizzata (leak di un paio di indirizzi di funzione)
* Controllare i **casi precedenti con ASLR** per continuare.

#### Attraverso EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controlla l'ESP per controllare RET attraverso l'EBP memorizzato nello stack.
* Utile per stack overflow **off-by-one**
* Utile come modo alternativo per controllare EIP mentre si abusa di EIP per costruire il payload in memoria e quindi saltare ad esso tramite EBP

#### Varie

* [**Riorientamento dei puntatori**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai
