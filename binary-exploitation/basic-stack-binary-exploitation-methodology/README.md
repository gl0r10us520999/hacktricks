# Metodologia di Base per l'Exploitation Binaria

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}

## Informazioni di Base su ELF

Prima di iniziare a sfruttare qualsiasi cosa, √® interessante comprendere parte della struttura di un **binario ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Strumenti di Exploitation

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## Metodologia di Stack Overflow

Con cos√¨ tante tecniche, √® utile avere uno schema su quando ciascuna tecnica sar√† utile. Nota che le stesse protezioni influenzeranno tecniche diverse. Puoi trovare modi per bypassare le protezioni in ciascuna sezione di protezione, ma non in questa metodologia.

## Controllare il Flusso

Ci sono diversi modi in cui potresti finire per controllare il flusso di un programma:

* [**Stack Overflows**](../stack-overflow/) sovrascrivendo il puntatore di ritorno dallo stack o l'EBP -> ESP -> EIP.
* Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow.
* O tramite **Scritture Arbitrari + Write What Where to Execution**.
* [**Stringhe di formato**](../format-strings/)**:** Abusare di `printf` per scrivere contenuti arbitrari in indirizzi arbitrari.
* [**Indicizzazione degli Array**](../array-indexing.md): Abusare di un indicizzazione mal progettata per poter controllare alcuni array e ottenere una scrittura arbitraria.
* Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow.
* **bof a WWW tramite ROP**: Abusare di un buffer overflow per costruire un ROP e poter ottenere un WWW.

Puoi trovare le tecniche di **Write What Where to Execution** in:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Loop Eterni

Qualcosa da tenere in considerazione √® che di solito **una sola exploitation di una vulnerabilit√† potrebbe non essere sufficiente** per eseguire un exploit con successo, specialmente alcune protezioni devono essere bypassate. Pertanto, √® interessante discutere alcune opzioni per **rendere una singola vulnerabilit√† sfruttabile pi√π volte** nella stessa esecuzione del binario:

* Scrivere in una **catena ROP** l'indirizzo della **funzione `main`** o l'indirizzo in cui si verifica la **vulnerabilit√†**.
* Controllando una corretta catena ROP potresti essere in grado di eseguire tutte le azioni in quella catena.
* Scrivere nell'**indirizzo `exit` in GOT** (o qualsiasi altra funzione utilizzata dal binario prima di terminare) l'indirizzo per tornare **alla vulnerabilit√†**.
* Come spiegato in [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**,** memorizza qui 2 funzioni, una per chiamare di nuovo la vuln e un'altra per chiamare **`__libc_csu_fini`** che richiamer√† di nuovo la funzione da `.fini_array`.

## Obiettivi di Exploitation

### Obiettivo: Chiamare una Funzione Esistente

* [**ret2win**](./#ret2win): C'√® una funzione nel codice che devi chiamare (forse con alcuni parametri specifici) per ottenere il flag.
* In un **bof regolare senza** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) devi solo scrivere l'indirizzo nel puntatore di ritorno memorizzato nello stack.
* In un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/), dovrai bypassarlo.
* In un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), dovrai bypassarlo.
* Se hai bisogno di impostare diversi parametri per chiamare correttamente la funzione **ret2win** puoi usare:
* Una [**catena ROP**](./#rop-and-ret2...-techniques) **se ci sono abbastanza gadget** per preparare tutti i parametri.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (nel caso tu possa chiamare questa syscall) per controllare molti registri.
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.
* Tramite un [**Write What Where**](../arbitrary-write-2-exec/) potresti abusare di altre vulnerabilit√† (non bof) per chiamare la funzione **`win`**.
* [**Puntatori di Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili Non Inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

### Obiettivo: RCE

#### Via shellcode, se nx disabilitato o mescolando shellcode con ROP:

* [**(Stack) Shellcode**](./#stack-shellcode): Questo √® utile per memorizzare uno shellcode nello stack prima o dopo aver sovrascritto il puntatore di ritorno e poi **saltare a esso** per eseguirlo:
* **In ogni caso, se c'√® un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** in un bof regolare dovrai bypassarlo (leak).
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) √® possibile saltare all'indirizzo dello stack poich√© non cambier√† mai.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) dovrai utilizzare tecniche come [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) per saltarci.
* **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), dovrai usare alcuni [**ROP**](../rop-return-oriented-programing/) **per chiamare `memprotect`** e rendere alcune pagine `rwx`, per poi **memorizzare lo shellcode l√¨** (chiamando read ad esempio) e poi saltarci.
* Questo mescoler√† shellcode con una catena ROP.

#### Via syscalls

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): Utile per chiamare `execve` per eseguire comandi arbitrari. Devi essere in grado di trovare i **gadget per chiamare la syscall specifica con i parametri**.
* Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) sono abilitati, dovrai sconfiggerli **per utilizzare i gadget ROP** dal binario o dalle librerie.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) pu√≤ essere utile per preparare il **ret2execve**.
* Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.

#### Via libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Utile per chiamare una funzione da una libreria (di solito da **`libc`**) come **`system`** con alcuni argomenti preparati (ad es. `'/bin/sh'`). Devi che il binario **carichi la libreria** con la funzione che desideri chiamare (libc di solito).
* Se **compilato staticamente e senza** [**PIE**](../common-binary-protections-and-bypasses/pie/), l'**indirizzo** di `system` e `/bin/sh` non cambier√†, quindi √® possibile usarli staticamente.
* **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e conoscendo la versione di libc** caricata, l'**indirizzo** di `system` e `/bin/sh` non cambier√†, quindi √® possibile usarli staticamente.
* Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ma senza** [**PIE**](../common-binary-protections-and-bypasses/pie/)**, conoscendo la libc e con il binario che utilizza la funzione `system`** √® possibile **`ret` all'indirizzo di system in GOT** con l'indirizzo di `'/bin/sh'` nel parametro (dovrai scoprirlo).
* Con [ASLR](../common-binary-protections-and-bypasses/aslr/) ma senza [PIE](../common-binary-protections-and-bypasses/pie/), conoscendo la libc e **senza il binario che utilizza la `system`** :
* Usa [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) per risolvere l'indirizzo di `system` e chiamarlo.
* **Bypassa** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) e calcola l'indirizzo di `system` e `'/bin/sh'` in memoria.
* **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/) **e non conoscendo la libc**: Devi:
* Bypassare [**PIE**](../common-binary-protections-and-bypasses/pie/).
* Trovare la **versione di `libc`** utilizzata (leak un paio di indirizzi di funzione).
* Controllare gli **scenari precedenti con ASLR** per continuare.

#### Via EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controlla l'ESP per controllare RET tramite l'EBP memorizzato nello stack.
* Utile per **off-by-one** stack overflows.
* Utile come modo alternativo per controllare EIP mentre si abusa di EIP per costruire il payload in memoria e poi saltarci tramite EBP.

#### Varie

* [**Puntatori di Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verr√† chiamata o a una stringa che verr√† utilizzata da una funzione interessante (system o printf), √® possibile sovrascrivere quell'indirizzo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) o [**PIE**](../common-binary-protections-and-bypasses/pie/) potrebbero influenzare gli indirizzi.
* [**Variabili Non Inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
