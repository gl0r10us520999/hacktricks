# スタックオーバーフロー

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングトリックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>
{% endhint %}

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたよりも多くのデータを書き込むときに発生する脆弱性です。この余分なデータは**隣接するメモリ空間を上書き**し、有効なデータの破損、制御フローの混乱、そして潜在的には悪意のあるコードの実行を引き起こします。この問題は、入力に対して境界チェックを行わない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**保存された命令ポインタ（EIP/RIP）**と**保存されたベースポインタ（EBP/RBP）**が前の関数に戻るために**スタックに保存されている**ことです。したがって、攻撃者はそれらを上書きし、**プログラムの実行フローを制御**できるようになります。

この脆弱性は通常、関数が**スタックに割り当てられたバイト数よりも多くのバイトをコピーする**ことによって発生し、他のスタックの部分を上書きできるようになります。

これに脆弱な一般的な関数には、**`strcpy`、`strcat`、`sprintf`、`gets`**などがあります。また、**`fgets`**、**`read`**、および**`memcpy`**のような**長さ引数**を取る関数も、指定された長さが割り当てられたものより大きい場合に脆弱な方法で使用される可能性があります。

例えば、以下の関数が脆弱である可能性があります：
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローのオフセットを見つける

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな入力の `A`s を与えることです（例： `python3 -c 'print("A"*1000)'`）そして、**アドレス `0x41414141` にアクセスしようとしたことを示す `Segmentation Fault` を期待します**。

さらに、スタックオーバーフローの脆弱性があることがわかったら、**リターンアドレスを上書きするために必要なオフセットを見つける**必要があります。そのためには、通常 **De Bruijn シーケンス** が使用されます。これは、サイズ _k_ のアルファベットと長さ _n_ の部分列に対して、**長さ \_n**\_\*\* のすべての可能な部分列がちょうど一度だけ**連続した部分列として現れる**サイクリックシーケンスです。

この方法では、EIP を制御するために必要なオフセットを手動で特定する代わりに、これらのシーケンスの1つをパディングとして使用し、上書きされたバイトのオフセットを見つけることができます。

これには **pwntools** を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分大きいと仮定すると）、スタック内のローカル変数の値を**上書き**することができ、保存された**EBP/RBPおよびEIP/RIP（またはそれ以上）**に到達します。\
この種の脆弱性を悪用する最も一般的な方法は、**戻りアドレスを変更する**ことで、関数が終了すると**制御フローがユーザーが指定したポインタの場所にリダイレクトされる**ことです。

しかし、他のシナリオでは、スタック内の**いくつかの変数の値を上書きする**だけで悪用が可能な場合もあります（簡単なCTFチャレンジのように）。

### Ret2win

この種のCTFチャレンジでは、**バイナリ内に** **決して呼び出されない** **関数**があり、**勝つために呼び出す必要があります**。これらのチャレンジでは、**戻りアドレスを上書きするためのオフセット**を見つけ、呼び出す**関数のアドレス**を見つけるだけで済みます（通常、[**ASLR**](../common-binary-protections-and-bypasses/aslr/)は無効になります）ので、脆弱な関数が戻ると、隠れた関数が呼び出されます：

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御されたEIP/RIPを悪用してシェルコードにジャンプし、任意のコードを実行することができます：

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP & Ret2... テクニック

このテクニックは、前のテクニックに対する主要な保護を回避するための基本的なフレームワークです：**実行可能なスタックなし（NX）**。これにより、バイナリ内の既存の命令を悪用して任意のコマンドを実行する他のいくつかのテクニック（ret2lib、ret2syscall...）を実行することができます：

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## ヒープオーバーフロー

オーバーフローは常にスタック内で発生するわけではなく、例えば**ヒープ**内で発生することもあります：

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## 保護の種類

脆弱性の悪用を防ぐためのいくつかの保護があります。詳細は以下を確認してください：

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してハッキングトリックを共有してください。

</details>
{% endhint %}
