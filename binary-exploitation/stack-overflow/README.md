# Stack Overflow

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Was ist ein Stack Overflow

Ein **Stack Overflow** ist eine Schwachstelle, die auftritt, wenn ein Programm mehr Daten auf den Stack schreibt, als ihm zugewiesen sind. Diese √ºbersch√ºssigen Daten werden **benachbarte Speicherbereiche √ºberschreiben**, was zur Korruption g√ºltiger Daten, zur St√∂rung des Kontrollflusses und m√∂glicherweise zur Ausf√ºhrung von sch√§dlichem Code f√ºhrt. Dieses Problem tritt h√§ufig aufgrund der Verwendung unsicherer Funktionen auf, die keine Grenzkontrolle f√ºr Eingaben durchf√ºhren.

Das Hauptproblem dieses √úberschreibens ist, dass der **gespeicherte Befehlszeiger (EIP/RIP)** und der **gespeicherte Basiszeiger (EBP/RBP)**, um zur vorherigen Funktion zur√ºckzukehren, **auf dem Stack gespeichert sind**. Daher wird ein Angreifer in der Lage sein, diese zu √ºberschreiben und **den Ausf√ºhrungsfluss des Programms zu steuern**.

Die Schwachstelle tritt normalerweise auf, weil eine Funktion **mehr Bytes auf den Stack kopiert, als ihr zugewiesen sind**, und somit in der Lage ist, andere Teile des Stacks zu √ºberschreiben.

Einige g√§ngige Funktionen, die anf√§llig daf√ºr sind, sind: **`strcpy`, `strcat`, `sprintf`, `gets`**... Auch Funktionen wie **`fgets`**, **`read` & `memcpy`**, die ein **L√§ngenargument** annehmen, k√∂nnten auf eine anf√§llige Weise verwendet werden, wenn die angegebene L√§nge gr√∂√üer ist als die zugewiesene.

Zum Beispiel k√∂nnten die folgenden Funktionen anf√§llig sein:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Finden von Stack Overflow Offsets

Die g√§ngigste Methode, um Stack Overflows zu finden, besteht darin, eine sehr gro√üe Eingabe von `A`s zu geben (z. B. `python3 -c 'print("A"*1000)'`) und einen `Segmentation Fault` zu erwarten, der anzeigt, dass die **Adresse `0x41414141` versucht wurde zuzugreifen**.

Dar√ºber hinaus, sobald Sie festgestellt haben, dass es eine Stack Overflow-Sicherheitsanf√§lligkeit gibt, m√ºssen Sie den Offset finden, bis es m√∂glich ist, die **R√ºcksprungadresse zu √ºberschreiben**. Dazu wird normalerweise eine **De Bruijn-Sequenz** verwendet. Diese ist f√ºr ein gegebenes Alphabet der Gr√∂√üe _k_ und Teilsequenzen der L√§nge _n_ eine **zyklische Sequenz, in der jede m√∂gliche Teilsequenz der L√§nge \_n**\_\*\* genau einmal\*\* als zusammenh√§ngende Teilsequenz erscheint.

Auf diese Weise ist es anstelle von Hand erforderlich, herauszufinden, welcher Offset ben√∂tigt wird, um das EIP zu steuern, m√∂glich, als Padding eine dieser Sequenzen zu verwenden und dann den Offset der Bytes zu finden, die es √ºberschrieben haben.

Es ist m√∂glich, **pwntools** daf√ºr zu verwenden:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
oder **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Ausnutzen von Stack-√úberl√§ufen

W√§hrend eines √úberlaufs (vorausgesetzt, die √úberlaufgr√∂√üe ist gro√ü genug) wirst du in der Lage sein, **Werte von lokalen Variablen im Stack zu √ºberschreiben**, bis du das gespeicherte **EBP/RBP und EIP/RIP (oder sogar mehr)** erreichst.\
Die h√§ufigste Methode, diese Art von Schwachstelle auszunutzen, besteht darin, die **R√ºcksprungadresse zu modifizieren**, sodass, wenn die Funktion endet, der **Kontrollfluss dorthin umgeleitet wird, wo der Benutzer in diesem Zeiger angegeben hat**.

In anderen Szenarien k√∂nnte es jedoch ausreichen, einfach **einige Variablenwerte im Stack zu √ºberschreiben**, um die Ausnutzung zu erreichen (wie bei einfachen CTF-Herausforderungen).

### Ret2win

In dieser Art von CTF-Herausforderungen gibt es eine **Funktion**, die **innerhalb** der Bin√§rdatei ist und **nie aufgerufen wird**, die du **aufrufen musst, um zu gewinnen**. F√ºr diese Herausforderungen musst du nur den **Offset finden, um die R√ºcksprungadresse zu √ºberschreiben**, und **die Adresse der Funktion finden**, die aufgerufen werden soll (in der Regel w√§re [**ASLR**](../common-binary-protections-and-bypasses/aslr/) deaktiviert), sodass, wenn die verwundbare Funktion zur√ºckkehrt, die versteckte Funktion aufgerufen wird:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Stack Shellcode

In diesem Szenario k√∂nnte der Angreifer einen Shellcode im Stack platzieren und den kontrollierten EIP/RIP ausnutzen, um zum Shellcode zu springen und beliebigen Code auszuf√ºhren:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP & Ret2... Techniken

Diese Technik ist das grundlegende Framework, um den Hauptschutz der vorherigen Technik zu umgehen: **Nicht ausf√ºhrbarer Stack (NX)**. Und sie erm√∂glicht die Durchf√ºhrung mehrerer anderer Techniken (ret2lib, ret2syscall...), die dazu f√ºhren, dass beliebige Befehle ausgef√ºhrt werden, indem vorhandene Anweisungen in der Bin√§rdatei ausgenutzt werden:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Heap-√úberl√§ufe

Ein √úberlauf wird nicht immer im Stack sein, er k√∂nnte auch im **Heap** sein, zum Beispiel:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Arten von Schutzma√ünahmen

Es gibt mehrere Schutzma√ünahmen, die versuchen, die Ausnutzung von Schwachstellen zu verhindern, √ºberpr√ºfe sie in:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
