# Tamsayı Taşması

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **HackTricks** ve **HackTricks Cloud** github depolarına PR göndererek hacking püf noktalarını paylaşın.

</details>
{% endhint %}

## Temel Bilgiler

**Tamsayı taşması**nın merkezinde, bilgisayar programlamasındaki veri türlerinin **boyutu** ve verinin **yorumlanması** tarafından uygulanan sınırlama bulunmaktadır.

Örneğin, bir **8-bit işaretsiz tamsayı**, **0 ile 255** arasındaki değerleri temsil edebilir. Bir 8-bit işaretsiz tamsayıya 256 değerini saklamaya çalışırsanız, saklama kapasitesinin sınırlılığı nedeniyle değer 0'a döner. Benzer şekilde, **16-bit işaretsiz tamsayı** için, **0 ile 65,535** arasındaki değerleri tutabilir, 65,535'e 1 eklemek değeri tekrar 0'a döndürecektir.

Ayrıca, bir **8-bit işaretli tamsayı**, **-128 ile 127** arasındaki değerleri temsil edebilir. Bu, bir bitin işareti (pozitif veya negatif) temsil etmek için kullanılması nedeniyle, büyüklüğü temsil etmek için 7 bitin kullanılması nedeniyle gerçekleşir. En negatif sayı **-128** olarak temsil edilir (ikili `10000000`), ve en pozitif sayı **127** olarak temsil edilir (ikili `01111111`).

### Maksimum Değerler

Potansiyel **web güvenlik açıkları** için desteklenen maksimum değerleri bilmek oldukça ilginçtir:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}

## Tamsayı Taşması

Tamsayı taşması, bir değişkenin maksimum değerini aştığında oluşan bir durumdur. Bu durum, beklenmedik sonuçlara neden olabilir ve kötü niyetli kullanıcılar tarafından istismar edilebilir. Tamsayı taşması genellikle işaretçilerle veya bellek tahsis işlemleriyle ilgili işlemlerde karşılaşılır.

Tamsayı taşması saldırıları genellikle bellek bölgelerine yazma, hizmet reddi veya kötü amaçlı kod yürütme gibi tehlikeli sonuçlara yol açabilir. Bu tür saldırılardan korunmak için giriş doğrulaması yapılmalı ve güvenlik kontrolleri uygulanmalıdır.

Örnek bir tamsayı taşması durumu aşağıdaki gibi olabilir:

```c
int a = INT_MAX;
a = a + 1;
```

Bu durumda, `a` değişkeni maksimum tamsayı değerini aştığı için bir tamsayı taşması oluşacaktır.

Tamsayı taşması genellikle dikkatsizce yazılmış kodlardan kaynaklanır ve iyi bir kod incelemesi ve test süreci ile tespit edilebilir.

{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Örnekler

### Saf taşma

Yazdırılan sonuç 0 olacaktır çünkü char'ı aştık:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### İmzalıdan İmsiz Dönüşüm

Kullanıcı girdisinden okunan bir imzalı tamsayı düşünün ve ardından uygun doğrulama yapılmadan onu imzalı bir tamsayı olarak işleyen bir bağlamda kullanılır:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Bu örnekte, bir kullanıcı negatif bir sayı girerse, ikili değerlerin nasıl yorumlandığından dolayı büyük bir işaretsiz tamsayı olarak yorumlanabilir, bu da beklenmeyen davranışlara yol açabilir.

### Diğer Örnekler

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Sadece 1B, şifrenin boyutunu depolamak için kullanıldığından, taşması ve uzunluğunun aslında 260 olduğunu düşünerek uzunluk kontrol korumasını atlatmak mümkündür.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Verilen bir çift sayıyı kullanarak z3'ü kullanarak, birinci sayıyla çarpıldığında ikinci sayıyı verecek yeni bir sayıyı bulun:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Sadece 1B, şifrenin boyutunu depolamak için kullanıldığından, taşması ve uzunluğunun aslında 260 olduğunu düşünerek uzunluk kontrol korumasını atlatmak ve yığında bir sonraki yerel değişkeni üzerine yazarak her iki korumayı da atlatmak mümkündür.

## ARM64

Bu **ARM64'te değişmez** [**bu blog yazısında**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/) görebileceğiniz gibi.

{% hint style="success" %}
AWS Hacking öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitimi AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitimi GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* Hacking püf noktalarını göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın.

</details>
{% endhint %}
