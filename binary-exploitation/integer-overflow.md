# Przepełnienie liczb całkowitych

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępniaj sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Podstawowe informacje

W centrum **przepełnienia liczb całkowitych** leży ograniczenie narzucone przez **rozmiar** typów danych w programowaniu komputerowym i **interpretację** danych.

Na przykład **8-bitowa liczba całkowita bez znaku** może reprezentować wartości od **0 do 255**. Jeśli spróbujesz przechować wartość 256 w 8-bitowej liczbie całkowitej bez znaku, zawiśnie ona do 0 ze względu na ograniczenie jej pojemności. Podobnie, dla **16-bitowej liczby całkowitej bez znaku**, która może przechowywać wartości od **0 do 65 535**, dodanie 1 do 65 535 spowoduje zawinięcie wartości z powrotem do 0.

Co więcej, **8-bitowa liczba całkowita ze znakiem** może reprezentować wartości od **-128 do 127**. Wynika to z faktu, że jeden bit jest używany do reprezentowania znaku (dodatni lub ujemny), pozostawiając 7 bitów do reprezentowania wartości bezwzględnej. Najbardziej ujemna liczba jest reprezentowana jako **-128** (binarnie `10000000`), a najbardziej dodatnia liczba to **127** (binarnie `01111111`).

### Maksymalne wartości

Dla potencjalnych **podatności internetowych** bardzo interesujące jest poznanie maksymalnie obsługiwanych wartości:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
Integer overflows occur when the result of an arithmetic operation exceeds the maximum size that the data type can hold. This can lead to unexpected behavior and security vulnerabilities in C programs. To prevent integer overflows, developers should carefully validate input data, use data types that can accommodate the expected range of values, and implement checks to detect overflow conditions before they cause harm.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Przykłady

### Czyste przepełnienie

Wydrukowany wynik będzie wynosił 0, ponieważ przepełniliśmy typ char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Konwersja ze znakowanej na nieznakowaną

Rozważ sytuację, w której liczba całkowita ze znakiem jest odczytywana z wejścia użytkownika, a następnie używana w kontekście traktującym ją jako liczbę całkowitą bez znaku, bez odpowiedniej walidacji:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
W tym przykładzie, jeśli użytkownik wprowadzi liczbę ujemną, zostanie ona zinterpretowana jako duża liczba całkowita bez znaku ze względu na sposób interpretacji wartości binarnych, co potencjalnie prowadzi do nieoczekiwanego zachowania.

### Inne Przykłady

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Do przechowywania rozmiaru hasła użyto tylko 1B, więc istnieje możliwość przepełnienia go i sprawienia, że będzie myślało, że ma długość 4, podczas gdy faktycznie wynosi 260, aby ominąć ochronę sprawdzającą długość
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
*   Mając parę liczb, znajdź za pomocą z3 nową liczbę, która pomnożona przez pierwszą da drugą:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Do przechowywania rozmiaru hasła użyto tylko 1B, więc istnieje możliwość przepełnienia go i sprawienia, że będzie myślało, że ma długość 4, podczas gdy faktycznie wynosi 260, aby ominąć ochronę sprawdzającą długość i nadpisać na stosie następną zmienną lokalną, omijając obie ochrony

## ARM64

To **nie zmienia się w ARM64**, jak można zobaczyć w [**tym poście na blogu**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).
