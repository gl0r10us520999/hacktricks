# D√©bordement d'entier

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Informations de base

Au c≈ìur d'un **d√©bordement d'entier** se trouve la limitation impos√©e par la **taille** des types de donn√©es en programmation informatique et l'**interpr√©tation** des donn√©es.

Par exemple, un **entier non sign√© sur 8 bits** peut repr√©senter des valeurs de **0 √† 255**. Si vous essayez de stocker la valeur 256 dans un entier non sign√© sur 8 bits, elle revient √† 0 en raison de la limitation de sa capacit√© de stockage. De m√™me, pour un **entier non sign√© sur 16 bits**, qui peut contenir des valeurs de **0 √† 65 535**, ajouter 1 √† 65 535 ram√®nera la valeur √† 0.

De plus, un **entier sign√© sur 8 bits** peut repr√©senter des valeurs de **-128 √† 127**. Cela est d√ª au fait qu'un bit est utilis√© pour repr√©senter le signe (positif ou n√©gatif), laissant 7 bits pour repr√©senter la magnitude. Le nombre le plus n√©gatif est repr√©sent√© par **-128** (binaire `10000000`), et le nombre le plus positif est **127** (binaire `01111111`).

### Valeurs maximales

Pour les potentielles **vuln√©rabilit√©s web**, il est tr√®s int√©ressant de conna√Ætre les valeurs maximales prises en charge :

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
Les d√©bordements d'entiers se produisent lorsqu'une op√©ration math√©matique d√©passe la capacit√© maximale d'un type de donn√©es. Cela peut entra√Æner des r√©sultats inattendus, tels que des valeurs incorrectes ou des plantages de programme. Il est important de v√©rifier et de g√©rer correctement les d√©bordements d'entiers pour √©viter les vuln√©rabilit√©s de s√©curit√©.
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{% endtab %}
{% endtabs %}

## Exemples

### D√©bordement pur

Le r√©sultat imprim√© sera 0 car nous avons d√©bord√© le char :
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Conversion de sign√© √† non sign√©

Consid√©rez une situation o√π un entier sign√© est lu √† partir de l'entr√©e utilisateur, puis utilis√© dans un contexte qui le traite comme un entier non sign√©, sans validation appropri√©e :
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Dans cet exemple, si un utilisateur entre un nombre n√©gatif, il sera interpr√©t√© comme un grand entier non sign√© en raison de la fa√ßon dont les valeurs binaires sont interpr√©t√©es, ce qui peut entra√Æner un comportement inattendu.

### Autres exemples

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Seulement 1B est utilis√© pour stocker la taille du mot de passe, il est donc possible de le d√©border et de le faire penser qu'il a une longueur de 4 alors qu'il est en r√©alit√© de 260 pour contourner la protection de v√©rification de longueur
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
*   √âtant donn√© quelques nombres, d√©couvrez en utilisant z3 un nouveau nombre qui, multipli√© par le premier, donnera le deuxi√®me:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Seulement 1B est utilis√© pour stocker la taille du mot de passe, il est donc possible de le d√©border et de le faire penser qu'il a une longueur de 4 alors qu'il est en r√©alit√© de 260 pour contourner la protection de v√©rification de longueur et √©craser dans la pile la variable locale suivante et contourner les deux protections

## ARM64

Cela **ne change pas en ARM64** comme vous pouvez le voir dans [**cet article de blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).
