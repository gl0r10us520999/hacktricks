# Desbordamiento de enteros

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* 춰Consulta los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci칩n B치sica

En el coraz칩n de un **desbordamiento de enteros** se encuentra la limitaci칩n impuesta por el **tama침o** de los tipos de datos en la programaci칩n inform치tica y la **interpretaci칩n** de los datos.

Por ejemplo, un **entero sin signo de 8 bits** puede representar valores de **0 a 255**. Si intentas almacenar el valor 256 en un entero sin signo de 8 bits, se envuelve de vuelta a 0 debido a la limitaci칩n de su capacidad de almacenamiento. De manera similar, para un **entero sin signo de 16 bits**, que puede contener valores de **0 a 65,535**, sumar 1 a 65,535 envolver치 el valor de vuelta a 0.

Adem치s, un **entero con signo de 8 bits** puede representar valores de **-128 a 127**. Esto se debe a que un bit se utiliza para representar el signo (positivo o negativo), dejando 7 bits para representar la magnitud. El n칰mero m치s negativo se representa como **-128** (binario `10000000`), y el n칰mero m치s positivo es **127** (binario `01111111`).

### Valores m치ximos

Para posibles **vulnerabilidades web** es muy interesante conocer los valores m치ximos admitidos:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
### Desbordamiento de enteros

El desbordamiento de enteros ocurre cuando se intenta almacenar un valor en una variable que es demasiado grande para ser representado en el tipo de dato espec칤fico. Esto puede llevar a resultados inesperados, como valores negativos inesperados o incluso vulnerabilidades de seguridad si no se maneja adecuadamente. Es importante tener cuidado al realizar operaciones aritm칠ticas con variables que podr칤an resultar en desbordamientos de enteros.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{% endtab %}
{% endtabs %}

## Ejemplos

### Desbordamiento puro

El resultado impreso ser치 0 ya que hemos desbordado el char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Conversi칩n de Firmado a No firmado

Considere una situaci칩n en la que se lee un entero firmado desde la entrada del usuario y luego se utiliza en un contexto que lo trata como un entero no firmado, sin una validaci칩n adecuada:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
En este ejemplo, si un usuario ingresa un n칰mero negativo, ser치 interpretado como un entero sin signo grande debido a la forma en que se interpretan los valores binarios, lo que potencialmente puede llevar a un comportamiento inesperado.

### Otros Ejemplos

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Solo se utiliza 1B para almacenar el tama침o de la contrase침a, por lo que es posible desbordarlo y hacer que piense que su longitud es de 4 cuando en realidad es de 260 para evadir la protecci칩n de verificaci칩n de longitud.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Dados un par de n칰meros, descubre usando z3 un nuevo n칰mero que, multiplicado por el primero, dar치 el segundo:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Solo se utiliza 1B para almacenar el tama침o de la contrase침a, por lo que es posible desbordarlo y hacer que piense que su longitud es de 4 cuando en realidad es de 260 para evadir la protecci칩n de verificaci칩n de longitud y sobrescribir en la pila la siguiente variable local y evadir ambas protecciones

## ARM64

Esto **no cambia en ARM64** como se puede ver en [**esta publicaci칩n de blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).
