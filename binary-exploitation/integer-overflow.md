# Integer Oorvloei

{% hint style="success" %}
Leer en oefen AWS-hacking: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer en oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Controleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## Basiese Inligting

In die kern van 'n **integer oorvloei** is die beperking wat opgel√™ word deur die **grootte** van data tipes in rekenaarsprogrammering en die **interpretasie** van die data.

Byvoorbeeld, 'n **8-bit ondertekenlose heelgetal** kan waardes van **0 tot 255** voorstel. As jy probeer om die waarde 256 in 'n 8-bit ondertekenlose heelgetal te stoor, sal dit na 0 oorvloei as gevolg van die beperking van sy stoorvermo√´. Op soortgelyke wyse, vir 'n **16-bit ondertekenlose heelgetal**, wat waardes van **0 tot 65,535** kan hou, sal die byvoeging van 1 tot 65,535 die waarde terug na 0 bring.

Verder kan 'n **8-bit ondertekende heelgetal** waardes van **-128 tot 127** voorstel. Dit is omdat een bit gebruik word om die teken (positief of negatief) voor te stel, wat 7 bits oorlaat om die grootte voor te stel. Die mees negatiewe getal word voorgestel as **-128** (bin√™re `10000000`), en die mees positiewe getal is **127** (bin√™re `01111111`).

### Maksimum waardes

Vir potensi√´le **web kwesbaarhede** is dit baie interessant om die maksimum ondersteunde waardes te ken:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
Integer overflow occurs when an arithmetic operation results in a value that exceeds the maximum size that the data type can hold. This can lead to unexpected behavior in the program, such as wrapping around to a minimum value or causing a buffer overflow. Integer overflow can be exploited by an attacker to manipulate the program's behavior and potentially execute malicious code.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Voorbeelde

### Skoon oorvloei

Die gedrukte resultaat sal 0 wees aangesien ons die karakter oorvloei het:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Onderteken na Ondertekenloos Omskakeling

Oorweeg 'n situasie waar 'n ondertekende heelgetal van gebruikersinvoer gelees word en dan in 'n konteks gebruik word wat dit as 'n ondertekenloos heelgetal hanteer, sonder behoorlike validering:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
In hierdie voorbeeld, as 'n gebruiker 'n negatiewe nommer invoer, sal dit ge√Ønterpreteer word as 'n groot ondertekenlose heelgetal as gevolg van die manier waarop bin√™re waardes ge√Ønterpreteer word, wat moontlik tot onverwagte gedrag kan lei.

### Ander Voorbeelde

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Slegs 1B word gebruik om die grootte van die wagwoord te stoor, sodat dit moontlik is om dit te oorvloei en dit te laat dink dat dit 'n lengte van 4 is terwyl dit eintlik 260 is om die lengtekontrolebeskerming te omseil
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Gegee 'n paar getalle, vind met behulp van z3 'n nuwe getal wat met die eerste vermenigvuldig sal word om die tweede een te gee:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Slegs 1B word gebruik om die grootte van die wagwoord te stoor, sodat dit moontlik is om dit te oorvloei en dit te laat dink dat dit 'n lengte van 4 is terwyl dit eintlik 260 is om die lengtekontrolebeskerming te omseil en in die stapel die volgende plaaslike veranderlike te oorskryf en beide beskermings te omseil

## ARM64

Dit **verander nie in ARM64** soos gesien kan word in [**hierdie blogpos**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).
