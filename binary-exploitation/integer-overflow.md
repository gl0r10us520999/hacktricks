# Estouro de Inteiro

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Treinamento HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Treinamento HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

No cerne de um **estouro de inteiro** est√° a limita√ß√£o imposta pelo **tamanho** dos tipos de dados na programa√ß√£o de computadores e a **interpreta√ß√£o** dos dados.

Por exemplo, um **inteiro sem sinal de 8 bits** pode representar valores de **0 a 255**. Se voc√™ tentar armazenar o valor 256 em um inteiro sem sinal de 8 bits, ele ser√° envolvido de volta para 0 devido √† limita√ß√£o de sua capacidade de armazenamento. Da mesma forma, para um **inteiro sem sinal de 16 bits**, que pode conter valores de **0 a 65.535**, adicionar 1 a 65.535 far√° com que o valor volte para 0.

Al√©m disso, um **inteiro com sinal de 8 bits** pode representar valores de **-128 a 127**. Isso ocorre porque um bit √© usado para representar o sinal (positivo ou negativo), deixando 7 bits para representar a magnitude. O n√∫mero mais negativo √© representado como **-128** (bin√°rio `10000000`), e o n√∫mero mais positivo √© **127** (bin√°rio `01111111`).

### Valores M√°ximos

Para potenciais **vulnerabilidades web**, √© muito interessante saber os valores m√°ximos suportados:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
## Transbordamento de Inteiro

Transbordamento de inteiro ocorre quando uma opera√ß√£o matem√°tica resulta em um valor que excede o limite m√°ximo ou m√≠nimo que o tipo de dado pode armazenar. Isso pode levar a comportamentos inesperados e vulnerabilidades de seguran√ßa em programas.

Um exemplo comum de transbordamento de inteiro √© quando um valor positivo √© adicionado a um valor muito grande, resultando em um valor negativo devido ao estouro. Isso pode ser explorado por hackers para manipular o comportamento do programa e potencialmente executar c√≥digo malicioso.

Para evitar transbordamentos de inteiro, √© importante validar entradas, verificar limites de valores e usar tipos de dados apropriados para as opera√ß√µes matem√°ticas realizadas no programa.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Exemplos

### Overflow puro

O resultado impresso ser√° 0, pois ocorreu um estouro no char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Convers√£o de Assinado para N√£o Assinado

Considere uma situa√ß√£o em que um inteiro assinado √© lido a partir da entrada do usu√°rio e depois utilizado em um contexto que o trata como um inteiro n√£o assinado, sem uma valida√ß√£o adequada:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Neste exemplo, se um usu√°rio inserir um n√∫mero negativo, ele ser√° interpretado como um grande inteiro n√£o assinado devido √† forma como os valores bin√°rios s√£o interpretados, potencialmente levando a comportamentos inesperados.

### Outros Exemplos

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Apenas 1B √© usado para armazenar o tamanho da senha, ent√£o √© poss√≠vel causar um estouro e fazer com que ele pense que tem um comprimento de 4, enquanto na verdade √© 260 para burlar a prote√ß√£o de verifica√ß√£o de comprimento
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Dados alguns n√∫meros, descubra usando z3 um novo n√∫mero que, multiplicado pelo primeiro, resultar√° no segundo:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Apenas 1B √© usado para armazenar o tamanho da senha, ent√£o √© poss√≠vel causar um estouro e fazer com que ele pense que tem um comprimento de 4, enquanto na verdade √© 260 para burlar a prote√ß√£o de verifica√ß√£o de comprimento e sobrescrever na pilha a pr√≥xima vari√°vel local e burlar ambas as prote√ß√µes

## ARM64

Isso **n√£o muda no ARM64** como voc√™ pode ver neste [**post de blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).
