# WWW2Exec - atexit(), TLS Storage & Ander verminkte Aanwysers

{% hint style="success" %}
Leer & oefen AWS Hack:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## **\_\_atexit Strukture**

{% hint style="danger" %}
Tans is dit baie **vreemd om dit uit te buit!**
{% endhint %}

**`atexit()`** is 'n funksie waar **ander funksies as parameters oorgedra word.** Hierdie **funksies** sal uitgevoer word wanneer 'n **`exit()`** uitgevoer word of die **terugkeer** van die **hooffunksie**.\
As jy die **adres** van enige van hierdie **funksies kan wysig** om na 'n shell-kode byvoorbeeld te wys, sal jy beheer oor die **proses kry**, maar dit is tans meer ingewikkeld.\
Tans is die **adresse van die funksies** wat uitgevoer moet word, **versteek** agter verskeie strukture en uiteindelik is die adres waarna dit wys nie die adresse van die funksies nie, maar is **versleutel met XOR** en verskuiwings met 'n **willekeurige sleutel**. Dus is hierdie aanvalsvektor tans **nie baie nuttig ten minste op x86** en **x64\_86** nie.\
Die **versleutelingsfunksie** is **`PTR_MANGLE`**. **Ander argitekture** soos m68k, mips32, mips64, aarch64, arm, hppa... **implementeer nie die versleuteling**-funksie nie omdat dit dieselfde teruggee as wat dit as inset ontvang het. Dus sou hierdie argitekture vatbaar wees vir hierdie vektor.

Jy kan 'n diepgaande verduideliking vind oor hoe dit werk by [https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html](https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html)

## link\_map

Soos verduidelik [**in hierdie pos**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure), As die program afsluit deur `return` of `exit()` te gebruik, sal dit `__run_exit_handlers()` hardloop wat geregistreerde vernietigers sal roep.

{% hint style="danger" %}
As die program afsluit via **`_exit()`**-funksie, sal dit die **`exit`-systaalaanroep** roep en die afsluit-handelaars sal nie uitgevoer word nie. Om te bevestig dat `__run_exit_handlers()` uitgevoer word, kan jy 'n breekpunt daarop stel.
{% endhint %}

Die belangrike kode is ([bron](https://elixir.bootlin.com/glibc/glibc-2.32/source/elf/dl-fini.c#L131)):
```c
ElfW(Dyn) *fini_array = map->l_info[DT_FINI_ARRAY];
if (fini_array != NULL)
{
ElfW(Addr) *array = (ElfW(Addr) *) (map->l_addr + fini_array->d_un.d_ptr);
size_t sz = (map->l_info[DT_FINI_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr)));

while (sz-- > 0)
((fini_t) array[sz]) ();
}
[...]




// This is the d_un structure
ptype l->l_info[DT_FINI_ARRAY]->d_un
type = union {
Elf64_Xword d_val;	// address of function that will be called, we put our onegadget here
Elf64_Addr d_ptr;	// offset from l->l_addr of our structure
}
```
Merk op hoe `map -> l_addr + fini_array -> d_un.d_ptr` gebruik word om die posisie van die **array van funksies om te roep** te **bereken**.

Daar is 'n **paar opsies**:

* Oorskryf die waarde van `map->l_addr` om dit te laat wys na 'n **vals `fini_array`** met instruksies om willekeurige kode uit te voer
* Oorskryf `l_info[DT_FINI_ARRAY]` en `l_info[DT_FINI_ARRAYSZ]` inskrywings (wat min of meer opeenvolgend in die geheue is), om hulle te laat **wys na 'n vervals `Elf64_Dyn`** struktuur wat weer **`array` laat wys na 'n geheue sonde wat deur die aanvaller beheer word**.
* [**Hierdie uiteensetting**](https://github.com/nobodyisnobody/write-ups/tree/main/DanteCTF.2023/pwn/Sentence.To.Hell) oorskryf `l_info[DT_FINI_ARRAY]` met die adres van 'n beheerde geheue in `.bss` wat 'n vals `fini_array` bevat. Hierdie valse array bevat **eerstens 'n** [**een gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) **adres** wat uitgevoer sal word en dan die **verskil** tussen die adres van hierdie **vals array** en die waarde van `map->l_addr` sodat `*array` na die valse array wys.
* Volgens die hoofpos van hierdie tegniek en [**hierdie uiteensetting**](https://activities.tjhsst.edu/csc/writeups/angstromctf-2021-wallstreet) laat ld.so 'n aanwysing op die stapel wat wys na die bin√™re `link_map` in ld.so. Met 'n willekeurige skryf is dit moontlik om dit te oorskryf en dit te laat wys na 'n vals `fini_array` wat deur die aanvaller beheer word met die adres na 'n [**een gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) byvoorbeeld.

Na die vorige kode kan jy 'n ander interessante afdeling met die kode vind:
```c
/* Next try the old-style destructor.  */
ElfW(Dyn) *fini = map->l_info[DT_FINI];
if (fini != NULL)
DL_CALL_DT_FINI (map, ((void *) map->l_addr + fini->d_un.d_ptr));
}
```
In hierdie geval sou dit moontlik wees om die waarde van `map->l_info[DT_FINI]` te oorskryf wat na 'n vervalsde `ElfW(Dyn)` struktuur wys. Vind [**meer inligting hier**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure).

## TLS-Opslag dtor\_lys oorskryf in **`__run_exit_handlers`**

Soos [**hier verduidelik**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite), as 'n program afsluit via `return` of `exit()`, sal dit **`__run_exit_handlers()`** uitvoer wat enige vernietigersfunksie wat geregistreer is, sal aanroep.

Kode van `_run_exit_handlers()`:
```c
/* Call all functions registered with `atexit' and `on_exit',
in the reverse of the order in which they were registered
perform stdio cleanup, and terminate program execution with STATUS.  */
void
attribute_hidden
__run_exit_handlers (int status, struct exit_function_list **listp,
bool run_list_atexit, bool run_dtors)
{
/* First, call the TLS destructors.  */
#ifndef SHARED
if (&__call_tls_dtors != NULL)
#endif
if (run_dtors)
__call_tls_dtors ();
```
Kode van **`__call_tls_dtors()`**:
```c
typedef void (*dtor_func) (void *);
struct dtor_list //struct added
{
dtor_func func;
void *obj;
struct link_map *map;
struct dtor_list *next;
};

[...]
/* Call the destructors.  This is called either when a thread returns from the
initial function or when the process exits via the exit function.  */
void
__call_tls_dtors (void)
{
while (tls_dtor_list)		// parse the dtor_list chained structures
{
struct dtor_list *cur = tls_dtor_list;		// cur point to tls-storage dtor_list
dtor_func func = cur->func;
PTR_DEMANGLE (func);						// demangle the function ptr

tls_dtor_list = tls_dtor_list->next;		// next dtor_list structure
func (cur->obj);
[...]
}
}
```
Vir elke geregistreerde funksie in **`tls_dtor_list`**, sal dit die pointer vanaf **`cur->func`** demangle en dit oproep met die argument **`cur->obj`**.

Deur die **`tls`** funksie van hierdie [**fork van GEF**](https://github.com/bata24/gef) te gebruik, is dit moontlik om te sien dat die **`dtor_list`** baie **naby** aan die **stapel kanarie** en **PTR\_MANGLE koekie** is. Dus, met 'n oorvloei daarop sou dit moontlik wees om die **koekie** en die **stapel kanarie** te **owerwrite**.\
Deur die PTR\_MANGLE koekie te oorskryf, sou dit moontlik wees om die `PTR_DEMANLE` funksie te **verbygaan** deur dit in te stel op 0x00, wat beteken dat die **`xor`** wat gebruik word om die werklike adres te kry, net die gekonfigureerde adres is. Dan, deur te skryf na die **`dtor_list`** is dit moontlik om **verskeie funksies aan mekaar te koppel** met die funksie **adres** en sy **argument.**

Laastens, let daarop dat die gestoorde pointer nie net met die koekie ge-xor sal word nie, maar ook 17 bietjies geroteer sal word:
```armasm
0x00007fc390444dd4 <+36>:	mov    rax,QWORD PTR [rbx]      --> mangled ptr
0x00007fc390444dd7 <+39>:	ror    rax,0x11		        --> rotate of 17 bits
0x00007fc390444ddb <+43>:	xor    rax,QWORD PTR fs:0x30	--> xor with PTR_MANGLE
```
So jy moet hierdie in ag neem voordat jy 'n nuwe adres byvoeg.

Vind 'n voorbeeld in die [**oorspronklike pos**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite).

## Ander verminkte aanwysers in **`__run_exit_handlers`**

Hierdie tegniek word [**hier verduidelik**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite) en hang weer af van die program wat **afsluit deur `return` of `exit()` te roep** sodat **`__run_exit_handlers()`** geroep word.

Laat ons meer kode van hierdie funksie nagaan:
```c
while (true)
{
struct exit_function_list *cur;

restart:
cur = *listp;

if (cur == NULL)
{
/* Exit processing complete.  We will not allow any more
atexit/on_exit registrations.  */
__exit_funcs_done = true;
break;
}

while (cur->idx > 0)
{
struct exit_function *const f = &cur->fns[--cur->idx];
const uint64_t new_exitfn_called = __new_exitfn_called;

switch (f->flavor)
{
void (*atfct) (void);
void (*onfct) (int status, void *arg);
void (*cxafct) (void *arg, int status);
void *arg;

case ef_free:
case ef_us:
break;
case ef_on:
onfct = f->func.on.fn;
arg = f->func.on.arg;
PTR_DEMANGLE (onfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
onfct (status, arg);
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_at:
atfct = f->func.at;
PTR_DEMANGLE (atfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
atfct ();
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_cxa:
/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
we must mark this function as ef_free.  */
f->flavor = ef_free;
cxafct = f->func.cxa.fn;
arg = f->func.cxa.arg;
PTR_DEMANGLE (cxafct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
cxafct (arg, status);
__libc_lock_lock (__exit_funcs_lock);
break;
}

if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
/* The last exit function, or another thread, has registered
more exit functions.  Start the loop over.  */
goto restart;
}

*listp = cur->next;
if (*listp != NULL)
/* Don't free the last element in the chain, this is the statically
allocate element.  */
free (cur);
}

__libc_lock_unlock (__exit_funcs_lock);
```
Die veranderlike `f` wys na die **`initial`** struktuur en afhangende van die waarde van `f->flavor` sal verskillende funksies aangeroep word.\
Afhanklik van die waarde sal die adres van die funksie om te roep in 'n ander plek wees, maar dit sal altyd **gedekodeer** wees.

Verder, in die opsies **`ef_on`** en **`ef_cxa`** is dit ook moontlik om 'n **argument** te beheer.

Dit is moontlik om die **`initial` struktuur** in 'n foutopsporing-sessie met GEF hardloop **`gef> p initial`** te kontroleer.

Om hiervan misbruik te maak, moet jy ofwel die `PTR_MANGLE` koekie **lek of uitvee** en dan 'n `cxa` inskrywing in initial oorskryf met `system('/bin/sh')`.\
Jy kan 'n voorbeeld hiervan vind in die [**oorspronklike blogpos oor die tegniek**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#6---code-execution-via-other-mangled-pointers-in-initial-structure).
