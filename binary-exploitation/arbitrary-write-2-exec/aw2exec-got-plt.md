# WWW2Exec - GOT/PLT

{% hint style="success" %}
AWS Hacking'ı öğrenin ve uygulayın: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'ı öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## **Temel Bilgiler**

### **GOT: Global Offset Table**

**Global Offset Table (GOT)**, dinamik olarak bağlanmış ikili dosyalarda **harici işlevlerin adreslerini yönetmek için kullanılan bir mekanizmadır**. Bu adresler **çalışma zamanında bilinmediği için** (dinamik bağlantı nedeniyle), GOT, bu harici sembollerin adreslerinin **çözüldükten sonra bu adresleri dinamik olarak güncellemek için bir yol sağlar**.

GOT'taki her giriş, ikili dosyanın çağırabileceği harici kütüphanelerdeki bir sembole karşılık gelir. Bir **işlev ilk kez çağrıldığında, dinamik bağlayıcı tarafından gerçek adresi çözülür ve GOT'ta depolanır**. Aynı işlevin sonraki çağrıları, GOT'ta depolanan adresi kullanır, böylece adresi tekrar çözme gereksiniminden kaçınılır.

### **PLT: Procedure Linkage Table**

**Procedure Linkage Table (PLT)**, GOT ile yakından çalışır ve harici işlevlere yapılan çağrıları işlemek için bir trambolin görevi görür. Bir ikili **bir harici işlevi ilk kez çağırdığında, kontrol, o işlevle ilişkili PLT girişine geçer**. Bu PLT girişi, işlevin adresini çözmek için dinamik bağlayıcıyı çağırmaktan sorumludur eğer daha önce çözülmemişse. Adres çözüldükten sonra, GOT'ta depolanır.

**Bu nedenle,** harici bir işlevin veya değişkenin adresi çözüldüğünde GOT girişleri doğrudan kullanılır. **PLT girişleri, bu adreslerin başlangıçta çözülmesini** dinamik bağlayıcı aracılığıyla kolaylaştırmak için kullanılır.

## Yürütme Al

### GOT'u Kontrol Et

**`objdump -s -j .got ./exec`** komutu ile GOT tablosunun adresini alın.

![](<../../.gitbook/assets/image (121).png>)

GEF ile **yürütülebilir** dosyayı **yükledikten** sonra GOT'ta **bulunan** **işlevleri görebilirsiniz**: `gef➤ x/20x 0xADDR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

GEF kullanarak **hata ayıklama** oturumu başlatabilir ve GOT tablosunu görmek için **`got`** komutunu çalıştırabilirsiniz:

![](<../../.gitbook/assets/image (496).png>)

### GOT2Exec

Bir ikili dosyada GOT, **işlevlerin adreslerine veya** işlev adresini yükleyecek olan **PLT** bölümüne sahiptir. Bu keyfi yazma işleminin amacı, daha sonra **`system`** **işlevinin PLT'sinin adresiyle** değiştirilecek bir işlevin GOT girişini **geçersiz kılmaktır**.

İdeal olarak, **kontrolünü sağladığınız parametrelerle çağrılacak bir işlevin GOT'unu geçersiz kılacaksınız** (bu sayede sistem işlevine gönderilen parametreleri kontrol edebileceksiniz).

Eğer ikili tarafından **`system`** **kullanılmıyorsa**, sistem işlevinin **PLT'de bir girişi olmayacak**. Bu senaryoda, önce `system` işlevinin adresini sızdırmanız ve ardından GOT'u bu adrese işaretleyecek şekilde üzerine yazmanız gerekecektir.

PLT adreslerini **`objdump -j .plt -d ./vuln_binary`** komutu ile görebilirsiniz.

## libc GOT girişleri

**Libc GOT**'un **partial RELRO** ile derlenmesi genellikle mümkünse adresini bulmak için güzel bir hedef oluşturur ([**ASLR**](../common-binary-protections-and-bypasses/aslr/)).

Libc'nin yaygın işlevleri, **başka dahili işlevleri çağıracaklar** ve bu işlevlerin GOT'u geçersiz kılınarak kod yürütme elde edilebilir.

Bu tekniğe ilişkin [**daha fazla bilgiyi burada bulabilirsiniz**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

### **Free2system**

Heap istismarı CTF'lerinde genellikle parçaların içeriğini kontrol edebilmek ve GOT tablosunu hatta bazen üzerine yazabilmek mümkündür. Eğer bir gadget mevcut değilse RCE elde etmek için basit bir hile, `free` GOT adresini `system`'e işaret etmek ve bir parçaya `"/bin/sh"` yazmaktır. Bu şekilde bu parça serbest bırakıldığında `system("/bin/sh")` çalıştırılacaktır.

### **Strlen2system**

Başka yaygın bir teknik, **`strlen`** GOT adresini **`system`'e işaret etmek**tir, böylece bu işlev kullanıcı girdisiyle çağrıldığında `"/bin/sh"` dizesini geçmek ve bir kabuk almak mümkün olacaktır.

Ayrıca, eğer `puts` kullanıcı girdisiyle kullanılıyorsa, `strlen` GOT adresini `system`'e işaret etmek ve dize `"/bin/sh"`'yi geçmek mümkün olacaktır çünkü **`puts`, kullanıcı girdisiyle `strlen`'i çağıracaktır**.

## **One Gadget**

{% content-ref url="../rop-return-oriented-programing/ret2lib/one-gadget.md" %}
[one-gadget.md](../rop-return-oriented-programing/ret2lib/one-gadget.md)
{% endcontent-ref %}

## **Heap'ten GOT'un Kötüye Kullanımı**

Bir heap zafiyetinden RCE elde etmenin yaygın bir yolu, bir fastbin'i kötüye kullanmak ve GOT tablosunun bir kısmını hızlı bin içine eklemek, böylece o parça tahsis edildiğinde genellikle `free` işlevinin işaretçisini **üzerine yazmak mümkün olacaktır**.\
Ardından, `free`'yi `system`'e işaret etmek ve `/bin/sh\x00` yazılmış bir parçayı serbest bırakmak, bir kabuk yürütmek mümkün olacaktır.

Bir [**örneği burada bulabilirsiniz**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk\_extend\_overlapping/#hitcon-trainging-lab13)**.**
## **Koruma**

**Tam RELRO** koruması, ikili başlatıldığında tüm işlevlerin adreslerini çözerek ve ardından **GOT tablosunu salt okunur** hale getirerek bu tür tekniklere karşı koruma sağlamayı amaçlar:

{% content-ref url="../common-binary-protections-and-bypasses/relro.md" %}
[relro.md](../common-binary-protections-and-bypasses/relro.md)
{% endcontent-ref %}

## Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
* [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)
