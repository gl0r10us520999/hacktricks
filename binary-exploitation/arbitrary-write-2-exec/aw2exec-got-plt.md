# WWW2Exec - GOT/PLT

{% hint style="success" %}
Ucz się i praktykuj Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i praktykuj Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
{% endhint %}

## **Podstawowe informacje**

### **GOT: Globalna tabela przesunięć**

**Globalna tabela przesunięć (GOT)** to mechanizm używany w binariach dynamicznie łączonych do zarządzania **adresami funkcji zewnętrznych**. Ponieważ te **adresy nie są znane do czasu wykonania** (ze względu na dynamiczne łączenie), GOT zapewnia sposób **dynamicznego aktualizowania adresów tych symboli zewnętrznych** po ich rozwiązaniu.

Każdy wpis w GOT odpowiada symbolowi w bibliotekach zewnętrznych, które może wywołać binarny. Gdy **funkcja jest pierwszy raz wywołana, jej rzeczywisty adres jest rozwiązywany przez łącznik dynamiczny i przechowywany w GOT**. Kolejne wywołania tej samej funkcji używają adresu przechowywanego w GOT, unikając tym samym kosztów ponownego rozwiązywania adresu.

### **PLT: Tabela łączenia procedur**

**Tabela łączenia procedur (PLT)** ściśle współpracuje z GOT i służy jako trampolina do obsługi wywołań funkcji zewnętrznych. Gdy binarny **wywołuje funkcję zewnętrzną po raz pierwszy, kontrola jest przekazywana do wpisu w PLT związanego z tą funkcją**. Ten wpis PLT jest odpowiedzialny za wywołanie łącznika dynamicznego w celu rozwiązania adresu funkcji, jeśli nie został on jeszcze rozwiązany. Po rozwiązaniu adresu jest on przechowywany w **GOT**.

**Dlatego** wpisy GOT są używane bezpośrednio, gdy adres funkcji lub zmiennej zewnętrznej jest rozwiązany. **Wpisy PLT są używane do ułatwienia początkowego rozwiązania** tych adresów za pomocą łącznika dynamicznego.

## Uzyskanie wykonania

### Sprawdź GOT

Uzyskaj adres tabeli GOT za pomocą: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (121).png>)

Zauważ, jak po **załadowaniu** **wykonywalnego** pliku w GEF możesz **zobaczyć** **funkcje**, które znajdują się w **GOT**: `gef➤ x/20x 0xADDR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

Korzystając z GEF, możesz **rozpocząć** sesję **debugowania** i wykonać **`got`** aby zobaczyć tabelę got:

![](<../../.gitbook/assets/image (496).png>)

### GOT2Exec

W binarnym pliku GOT zawiera **adresy funkcji lub** sekcji **PLT**, która załaduje adres funkcji. Celem tego arbitralnego zapisu jest **nadpisanie wpisu GOT** funkcji, która zostanie wykonana później **adresem** PLT funkcji **`system`** na przykład.

Idealnie, nadpiszesz **GOT** funkcji, która **zostanie wywołana z kontrolowanymi przez ciebie parametrami** (dzięki czemu będziesz mógł kontrolować parametry przekazywane do funkcji systemowej).

Jeśli **`system`** **nie jest używany** przez binarny plik, funkcja systemowa **nie** będzie miała wpisu w PLT. W takim scenariuszu będziesz **musiał najpierw ujawnić adres** funkcji `system`, a następnie nadpisać GOT, aby wskazywał na ten adres.

Możesz zobaczyć adresy PLT za pomocą **`objdump -j .plt -d ./vuln_binary`**

## Wpisy GOT libc

**GOT libc** jest zazwyczaj kompilowany z **częściowym RELRO**, co czyni go atrakcyjnym celem, zakładając, że jest możliwe ustalenie jego adresu ([**ASLR**](../common-binary-protections-and-bypasses/aslr/)).

Powszechne funkcje libc będą wywoływać **inne funkcje wewnętrzne**, których GOT można nadpisać, aby uzyskać wykonanie kodu.

Znajdź [**więcej informacji na temat tej techniki tutaj**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

### **Free2system**

W wyzwalaczach eksploatacji sterty często można kontrolować zawartość fragmentów i w pewnym momencie nawet nadpisać tabelę GOT. Prostym trikiem, aby uzyskać RCE, jeśli nie są dostępne żadne gadżety, jest nadpisanie adresu `free` GOT, aby wskazywał na `system` i zapisanie w fragmencie `"/bin/sh"`. W ten sposób, gdy ten fragment zostanie zwolniony, zostanie wykonane `system("/bin/sh")`.

### **Strlen2system**

Inną powszechną techniką jest nadpisanie adresu **`strlen`** GOT, aby wskazywał na **`system`**, więc jeśli ta funkcja jest wywoływana z wejściem użytkownika, można przekazać ciąg `"/bin/sh"` i uzyskać dostęp do powłoki.

Co więcej, jeśli `puts` jest używane z wejściem użytkownika, można nadpisać adres `strlen` GOT, aby wskazywał na `system` i przekazać ciąg `"/bin/sh"` w celu uzyskania dostępu do powłoki, ponieważ **`puts` wywoła `strlen` z wejściem użytkownika**.

## **Jeden gadżet**

{% content-ref url="../rop-return-oriented-programing/ret2lib/one-gadget.md" %}
[one-gadget.md](../rop-return-oriented-programing/ret2lib/one-gadget.md)
{% endcontent-ref %}

## **Wykorzystywanie GOT z Heap**

Powszechnym sposobem uzyskania RCE z podatności sterty jest nadużycie fastbin, aby można było dodać część tabeli GOT do fast bin, więc za każdym razem, gdy ten fragment jest alokowany, będzie można **nadpisać wskaźnik funkcji, zazwyczaj `free`**.\
Następnie, wskazując `free` na `system` i zwalniając fragment, w którym został zapisany `/bin/sh\x00`, zostanie wykonana powłoka.

Możliwe jest znalezienie [**przykładu tutaj**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk\_extend\_overlapping/#hitcon-trainging-lab13)**.**
## **Ochrona**

Ochrona **Full RELRO** ma na celu ochronę przed tego rodzaju techniką poprzez rozwiązanie wszystkich adresów funkcji podczas uruchamiania pliku binarnego i ustawienie tabeli **GOT jako tylko do odczytu** po tym:

{% content-ref url="../common-binary-protections-and-bypasses/relro.md" %}
[relro.md](../common-binary-protections-and-bypasses/relro.md)
{% endcontent-ref %}

## Odnośniki

* [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
* [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępniaj sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
