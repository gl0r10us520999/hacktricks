# Κανάρια Στοίβας

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Κοινοποιήστε κόλπα χάκερ υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο GitHub.

</details>
{% endhint %}

## **StackGuard και StackShield**

Το **StackGuard** εισάγει μια ειδική τιμή γνωστή ως **κανάριο** πριν από το **EIP (Επεκτεινόμενο Δείκτη Εντολών)**, συγκεκριμένα `0x000aff0d` (που αντιπροσωπεύει το null, newline, EOF, carriage return) για προστασία από υπερχείλιση buffer. Ωστόσο, συναρτήσεις όπως `recv()`, `memcpy()`, `read()`, και `bcopy()` παραμένουν ευάλωτες, και δεν προστατεύει το **EBP (Βασικό Δείκτη)**.

Το **StackShield** ακολουθεί μια πιο εξελιγμένη προσέγγιση από το StackGuard διατηρώντας ένα **Καθολικό Στοίβα Επιστροφής**, το οποίο αποθηκεύει όλες τις διευθύνσεις επιστροφής (**EIPs**). Αυτή η ρύθμιση εξασφαλίζει ότι οποιαδήποτε υπερχείλιση δεν προκαλεί ζημιά, καθώς επιτρέπει τη σύγκριση μεταξύ αποθηκευμένων και πραγματικών διευθύνσεων επιστροφής για την ανίχνευση εμφανίσεων υπερχείλισης. Επιπλέον, το StackShield μπορεί να ελέγξει τη διεύθυνση επιστροφής έναντι μιας τιμής ορίου για να ανιχνεύσει αν η **EIP** δείχνει έξω από τον αναμενόμενο χώρο δεδομένων. Ωστόσο, αυτή η προστασία μπορεί να παρακαμφθεί μέσω τεχνικών όπως Return-to-libc, ROP (Return-Oriented Programming), ή ret2ret, υποδηλώνοντας ότι το StackShield επίσης δεν προστατεύει τοπικές μεταβλητές.

## **Προστάτης Καταστροφής Στοίβας (ProPolice) `-fstack-protector`:**

Αυτός ο μηχανισμός τοποθετεί ένα **κανάριο** πριν από το **EBP**, και αναδιατάσσει τις τοπικές μεταβλητές ώστε να τοποθετούνται τα buffers σε υψηλότερες διευθύνσεις μνήμης, αποτρέποντας την υπεργραφή άλλων μεταβλητών. Επίσης, αντιγράφει με ασφάλεια τα ορίσματα που περνιούνται στη στοίβα πάνω από τις τοπικές μεταβλητές και χρησιμοποιεί αυτές τις αντιγραφές ως ορίσματα. Ωστόσο, δεν προστατεύει πίνακες με λιγότερα από 8 στοιχεία ή buffers μέσα σε δομή χρήστη.

Το **κανάριο** είναι ένας τυχαίος αριθμός που προέρχεται από το `/dev/urandom` ή μια προεπιλεγμένη τιμή του `0xff0a0000`. Αποθηκεύεται στο **TLS (Αποθήκη Τοπικών Νημάτων)**, επιτρέποντας κοινόχρηστους χώρους μνήμης ανάμεσα σε νήματα να έχουν νήμα-συγκεκριμένες γενικές ή στατικές μεταβλητές. Αυτές οι μεταβλητές αντιγράφονται αρχικά από τη διεργασία γονέα, και οι διεργασίες-παιδιά μπορούν να τροποποιήσουν τα δεδομένα τους χωρίς να επηρεάζουν το γονέα ή τα αδέλφια. Ωστόσο, αν χρησιμοποιηθεί ένα **`fork()` χωρίς τη δημιουργία ενός νέου καναριού, όλες οι διεργασίες (γονέας και παιδιά) μοιράζονται το ίδιο κανάρι**, καθιστώντας το ευάλωτο. Στην αρχιτεκτονική **i386**, το κανάρι αποθηκεύεται στο `gs:0x14`, και στο **x86\_64**, στο `fs:0x28`.

Αυτή η τοπική προστασία αναγνωρίζει συναρτήσεις με buffers ευάλωτους σε επιθέσεις και ενθάρρυνει κώδικα στην αρχή αυτών των συναρτήσεων για να τοποθετήσει το κανάρι, και στο τέλος για να επαληθεύσει την ακεραιότητά του.

Όταν ένας διακομιστής web χρησιμοποιεί το `fork()`, επιτρέπει μια επίθεση με βία για να μαντέψει το κανάρι byte προς byte. Ωστόσο, χρησιμοποιώντας το `execve()` μετά το `fork()` αντικαθιστά τον χώρο μνήμης, αναιρώντας την επίθεση. Το `vfork()` επιτρέπει στη διεργασία-παιδί να εκτελείται χωρίς αντιγραφή μέχρι να προσπαθήσει να γράψει, στο σημείο που δημιουργείται ένα αντίγραφο, προσφέροντας μια διαφορετική προσέγγιση στη δημιουργία διεργασίας και στη διαχείριση μνήμης.

### Μήκη

Σε δυαδικά `x64`, το κανάρι cookie είναι ένα **`0x8`** byte qword. Τα **πρώτα επτά bytes είναι τυχαία** και το τελευταίο byte είναι ένα **null byte**.

Σε δυαδικά `x86`, το κανάρι cookie είναι ένα **`0x4`** byte dword. Τα **πρώτα τρία bytes είναι τυχαία** και το τελευταίο byte είναι ένα **null byte**.

{% hint style="danger" %}
Το λιγότερο σημαντικό byte και των δύο καναριών είναι ένα null byte επειδή θα είναι το πρώτο στη στοίβα προερχόμενο από χαμηλότερες διευθύνσεις και επομένως **οι συναρτήσεις που διαβάζουν συμβολοσειρές θα σταματήσουν πριν την ανάγνωσή του**.
{% endhint %}

## Παρακάμψεις

**Διαρροή του καναριού** και στη συνέχεια υπεργραφή του (π.χ. υπερχείλιση buffer) με τη δική του τιμή.

* Αν το **κανάρι δημιουργείται σε παιδικές διεργασίες** είναι δυνατό να **επιτεθείτε με βία** ένα byte κάθε φορά:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Αν υπάρχει κάποια ενδιαφέρουσα **διαρροή ή αυθαίρετη ανάγνωση ευπαθειών** στο δυαδικό μπορεί να είναι δυνατή η διαρροή του:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Υπεργραφή δεικτών αποθηκευμένων στη στοίβα**

Η στοίβα που είναι ευάλωτη σε υπερχείλιση μπορεί να **περιέχει διευθύνσεις σε συμβολοσειρές ή συναρτήσεις που μπορούν να υπεργραφούν** για να εκμεταλλευτεί την ευπάθεια χωρίς την ανάγκη να φτάσει το κανάρι της στοίβας. Ελέγξτε:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Τροποποίηση του κυρ
## Αναφορές

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο Hacking του AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο Hacking του GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** 💬 [**στην ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
{% endhint %}
