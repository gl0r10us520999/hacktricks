# Stack Canaries

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* ¬°Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **StackGuard y StackShield**

**StackGuard** inserta un valor especial conocido como **canary** antes del **EIP (Extended Instruction Pointer)**, espec√≠ficamente `0x000aff0d` (que representa nulo, nueva l√≠nea, EOF, retorno de carro) para protegerse contra desbordamientos de b√∫fer. Sin embargo, funciones como `recv()`, `memcpy()`, `read()` y `bcopy()` siguen siendo vulnerables, y no protege el **EBP (Base Pointer)**.

**StackShield** adopta un enfoque m√°s sofisticado que StackGuard al mantener una **Pila de Retorno Global**, que almacena todas las direcciones de retorno (**EIPs**). Esta configuraci√≥n garantiza que cualquier desbordamiento no cause da√±o, ya que permite comparar las direcciones de retorno almacenadas con las reales para detectar ocurrencias de desbordamiento. Adem√°s, StackShield puede verificar la direcci√≥n de retorno frente a un valor l√≠mite para detectar si el **EIP** apunta fuera del espacio de datos esperado. Sin embargo, esta protecci√≥n puede ser eludida mediante t√©cnicas como Return-to-libc, ROP (Programaci√≥n Orientada a Retorno) o ret2ret, lo que indica que StackShield tampoco protege las variables locales.

## **Protector de Stack Smash (ProPolice) `-fstack-protector`:**

Este mecanismo coloca un **canary** antes del **EBP** y reorganiza las variables locales para posicionar los b√∫feres en direcciones de memoria m√°s altas, evitando que sobrescriban otras variables. Tambi√©n copia de forma segura los argumentos pasados en la pila por encima de las variables locales y utiliza estas copias como argumentos. Sin embargo, no protege los arrays con menos de 8 elementos o los b√∫feres dentro de una estructura de usuario.

El **canary** es un n√∫mero aleatorio derivado de `/dev/urandom` o un valor predeterminado de `0xff0a0000`. Se almacena en **TLS (Thread Local Storage)**, lo que permite que espacios de memoria compartidos entre hilos tengan variables globales o est√°ticas espec√≠ficas del hilo. Estas variables se copian inicialmente del proceso padre, y los procesos hijos pueden modificar sus datos sin afectar al padre o a los hermanos. Sin embargo, si se utiliza un **`fork()` sin crear un nuevo canary, todos los procesos (padre e hijos) comparten el mismo canary**, volvi√©ndolo vulnerable. En la arquitectura **i386**, el canary se almacena en `gs:0x14`, y en **x86\_64**, en `fs:0x28`.

Esta protecci√≥n local identifica funciones con b√∫feres vulnerables a ataques e inyecta c√≥digo al inicio de estas funciones para colocar el canary, y al final para verificar su integridad.

Cuando un servidor web utiliza `fork()`, habilita un ataque de fuerza bruta para adivinar el byte del canary uno por uno. Sin embargo, usar `execve()` despu√©s de `fork()` sobrescribe el espacio de memoria, anulando el ataque. `vfork()` permite que el proceso hijo se ejecute sin duplicaci√≥n hasta que intenta escribir, momento en el que se crea una duplicaci√≥n, ofreciendo un enfoque diferente para la creaci√≥n de procesos y el manejo de memoria.

### Longitudes

En binarios `x64`, la cookie del canary es un qword de **`0x8`** bytes. Los **primeros siete bytes son aleatorios** y el √∫ltimo byte es un **byte nulo**.

En binarios `x86`, la cookie del canary es un dword de **`0x4`** bytes. Los **primeros tres bytes son aleatorios** y el √∫ltimo byte es un **byte nulo**.

{% hint style="danger" %}
El byte menos significativo de ambos canaries es un byte nulo porque ser√° el primero en la pila proveniente de direcciones m√°s bajas y, por lo tanto, **las funciones que leen cadenas se detendr√°n antes de leerlo**.
{% endhint %}

## Bypasses

**Filtrar el canary** y luego sobrescribirlo (por ejemplo, desbordamiento de b√∫fer) con su propio valor.

* Si el **canary se bifurca en procesos hijos** podr√≠a ser posible **forzarlo** un byte a la vez:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Si hay alguna **fuga interesante o vulnerabilidad de lectura arbitraria** en el binario, podr√≠a ser posible filtrarlo:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescribir punteros almacenados en la pila**

La pila vulnerable a un desbordamiento de pila podr√≠a **contener direcciones a cadenas o funciones que pueden ser sobrescritas** para explotar la vulnerabilidad sin necesidad de alcanzar el canary de la pila. Verifica:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificar tanto el canary maestro como el del hilo**

Un desbordamiento de b√∫fer en una funci√≥n enhebrada protegida con canary puede usarse para **modificar el canary maestro del hilo**. Como resultado, la mitigaci√≥n es in√∫til porque la verificaci√≥n se realiza con dos canaries que son iguales (aunque modificados).

Adem√°s, un desbordamiento de b√∫fer en una funci√≥n enhebrada protegida con canary podr√≠a usarse para **modificar el canary maestro almacenado en el TLS**. Esto se debe a que podr√≠a ser posible alcanzar la posici√≥n de memoria donde se almacena el TLS (y por lo tanto, el canary) a trav√©s de un **bof en la pila** de un hilo.\
Como resultado, la mitigaci√≥n es in√∫til porque la verificaci√≥n se realiza con dos canaries que son iguales (aunque modificados).\
Este ataque se realiza en el documento: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Consulta tambi√©n la presentaci√≥n de [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) que menciona que generalmente el **TLS** se almacena mediante **`mmap`** y cuando se crea una **pila** de **hilo** tambi√©n se genera mediante `mmap` seg√∫n esto, lo que podr√≠a permitir el desbordamiento como se muestra en el documento anterior.

* **Modificar la entrada GOT de `__stack_chk_fail`**

Si el binario tiene RELRO parcial, entonces puedes usar una escritura arbitraria para modificar la **entrada GOT de `__stack_chk_fail`** y que sea una funci√≥n ficticia que no bloquee el programa si el canary se modifica.

Este ataque se realiza en el documento: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
## Referencias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
