# Stack Canaries

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **StackGuard y StackShield**

**StackGuard** inserta un valor especial conocido como **canary** antes del **EIP (Extended Instruction Pointer)**, espec√≠ficamente `0x000aff0d` (representando null, newline, EOF, carriage return) para proteger contra desbordamientos de b√∫fer. Sin embargo, funciones como `recv()`, `memcpy()`, `read()`, y `bcopy()` siguen siendo vulnerables, y no protege el **EBP (Base Pointer)**.

**StackShield** adopta un enfoque m√°s sofisticado que StackGuard al mantener un **Global Return Stack**, que almacena todas las direcciones de retorno (**EIPs**). Esta configuraci√≥n asegura que cualquier desbordamiento no cause da√±o, ya que permite una comparaci√≥n entre las direcciones de retorno almacenadas y las reales para detectar ocurrencias de desbordamiento. Adem√°s, StackShield puede verificar la direcci√≥n de retorno contra un valor l√≠mite para detectar si el **EIP** apunta fuera del espacio de datos esperado. Sin embargo, esta protecci√≥n puede ser eludida a trav√©s de t√©cnicas como Return-to-libc, ROP (Return-Oriented Programming), o ret2ret, lo que indica que StackShield tampoco protege las variables locales.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Este mecanismo coloca un **canary** antes del **EBP**, y reorganiza las variables locales para posicionar los b√∫feres en direcciones de memoria m√°s altas, evitando que sobrescriban otras variables. Tambi√©n copia de manera segura los argumentos pasados en la pila por encima de las variables locales y utiliza estas copias como argumentos. Sin embargo, no protege los arreglos con menos de 8 elementos o los b√∫feres dentro de la estructura de un usuario.

El **canary** es un n√∫mero aleatorio derivado de `/dev/urandom` o un valor predeterminado de `0xff0a0000`. Se almacena en **TLS (Thread Local Storage)**, permitiendo que los espacios de memoria compartidos entre hilos tengan variables globales o est√°ticas espec√≠ficas del hilo. Estas variables se copian inicialmente del proceso padre, y los procesos hijos pueden alterar sus datos sin afectar al padre o a los hermanos. Sin embargo, si se utiliza un **`fork()` sin crear un nuevo canary, todos los procesos (padre e hijos) comparten el mismo canary**, lo que lo hace vulnerable. En la arquitectura **i386**, el canary se almacena en `gs:0x14`, y en **x86\_64**, en `fs:0x28`.

Esta protecci√≥n local identifica funciones con b√∫feres vulnerables a ataques e inyecta c√≥digo al inicio de estas funciones para colocar el canary, y al final para verificar su integridad.

Cuando un servidor web utiliza `fork()`, permite un ataque de fuerza bruta para adivinar el byte del canary byte por byte. Sin embargo, usar `execve()` despu√©s de `fork()` sobrescribe el espacio de memoria, negando el ataque. `vfork()` permite que el proceso hijo se ejecute sin duplicaci√≥n hasta que intente escribir, momento en el cual se crea una duplicaci√≥n, ofreciendo un enfoque diferente para la creaci√≥n de procesos y el manejo de memoria.

### Longitudes

En binarios `x64`, el cookie del canary es un **`0x8`** byte qword. Los **primeros siete bytes son aleatorios** y el √∫ltimo byte es un **byte nulo.**

En binarios `x86`, el cookie del canary es un **`0x4`** byte dword. Los **primeros tres bytes son aleatorios** y el √∫ltimo byte es un **byte nulo.**

{% hint style="danger" %}
El byte menos significativo de ambos canaries es un byte nulo porque ser√° el primero en la pila proveniente de direcciones m√°s bajas y, por lo tanto, **las funciones que leen cadenas se detendr√°n antes de leerlo**.
{% endhint %}

## Bypasses

**Filtrar el canary** y luego sobrescribirlo (por ejemplo, desbordamiento de b√∫fer) con su propio valor.

* Si el **canary se bifurca en procesos hijos**, podr√≠a ser posible **forzarlo** byte por byte:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Si hay alguna **filtraci√≥n interesante o vulnerabilidad de lectura arbitraria** en el binario, podr√≠a ser posible filtrarlo:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescribiendo punteros almacenados en la pila**

La pila vulnerable a un desbordamiento de pila podr√≠a **contener direcciones a cadenas o funciones que pueden ser sobrescritas** para explotar la vulnerabilidad sin necesidad de alcanzar el canary de la pila. Ver:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificando tanto el canary maestro como el de hilo**

Un desbordamiento de b√∫fer en una funci√≥n con hilos protegida con canary puede ser utilizado para **modificar el canary maestro del hilo**. Como resultado, la mitigaci√≥n es in√∫til porque la verificaci√≥n se utiliza con dos canaries que son los mismos (aunque modificados).

Adem√°s, un desbordamiento de b√∫fer en una funci√≥n con hilos protegida con canary podr√≠a ser utilizado para **modificar el canary maestro almacenado en el TLS**. Esto se debe a que podr√≠a ser posible alcanzar la posici√≥n de memoria donde se almacena el TLS (y, por lo tanto, el canary) a trav√©s de un **bof en la pila** de un hilo.\
Como resultado, la mitigaci√≥n es in√∫til porque la verificaci√≥n se utiliza con dos canaries que son los mismos (aunque modificados).\
Este ataque se realiza en el writeup: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Ver tambi√©n la presentaci√≥n de [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) que menciona que generalmente el **TLS** se almacena mediante **`mmap`** y cuando se crea una **pila** de **hilo** tambi√©n se genera mediante `mmap` de acuerdo a esto, lo que podr√≠a permitir el desbordamiento como se mostr√≥ en el writeup anterior.

* **Modificar la entrada GOT de `__stack_chk_fail`**

Si el binario tiene Partial RELRO, entonces puedes usar una escritura arbitraria para modificar la **entrada GOT de `__stack_chk_fail`** para que sea una funci√≥n ficticia que no bloquee el programa si el canary se modifica.

Este ataque se realiza en el writeup: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

## Referencias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
