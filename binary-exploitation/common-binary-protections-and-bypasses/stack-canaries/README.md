# Stack Canaries

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## **StackGuard et StackShield**

**StackGuard** ins√®re une valeur sp√©ciale appel√©e **canary** avant le **EIP (Extended Instruction Pointer)**, sp√©cifiquement `0x000aff0d` (repr√©sentant null, saut de ligne, EOF, retour chariot) pour se prot√©ger contre les d√©bordements de tampon. Cependant, des fonctions comme `recv()`, `memcpy()`, `read()`, et `bcopy()` restent vuln√©rables, et il ne prot√®ge pas l'**EBP (Base Pointer)**.

**StackShield** adopte une approche plus sophistiqu√©e que StackGuard en maintenant une **pile de retour globale**, qui stocke toutes les adresses de retour (**EIPs**). Cette configuration garantit qu'un d√©bordement ne cause aucun dommage, car elle permet de comparer les adresses de retour stock√©es et r√©elles pour d√©tecter les occurrences de d√©bordement. De plus, StackShield peut v√©rifier l'adresse de retour par rapport √† une valeur limite pour d√©tecter si l'**EIP** pointe en dehors de l'espace de donn√©es attendu. Cependant, cette protection peut √™tre contourn√©e √† l'aide de techniques comme Return-to-libc, ROP (Return-Oriented Programming), ou ret2ret, indiquant que StackShield ne prot√®ge pas non plus les variables locales.

## **Protecteur de d√©bordement de pile (ProPolice) `-fstack-protector`:**

Ce m√©canisme place un **canary** avant l'**EBP**, et r√©organise les variables locales pour positionner les tampons √† des adresses m√©moire plus √©lev√©es, les emp√™chant d'√©craser d'autres variables. Il copie √©galement de mani√®re s√©curis√©e les arguments pass√©s sur la pile au-dessus des variables locales et utilise ces copies comme arguments. Cependant, il ne prot√®ge pas les tableaux avec moins de 8 √©l√©ments ou les tampons √† l'int√©rieur d'une structure utilisateur.

Le **canary** est un nombre al√©atoire d√©riv√© de `/dev/urandom` ou d'une valeur par d√©faut de `0xff0a0000`. Il est stock√© dans le **TLS (Thread Local Storage)**, permettant aux espaces m√©moire partag√©s entre les threads d'avoir des variables globales ou statiques sp√©cifiques au thread. Ces variables sont initialement copi√©es du processus parent, et les processus enfants peuvent modifier leurs donn√©es sans affecter le parent ou les fr√®res et s≈ìurs. N√©anmoins, si un **`fork()` est utilis√© sans cr√©er un nouveau canary, tous les processus (parent et enfants) partagent le m√™me canary**, le rendant vuln√©rable. Sur l'architecture **i386**, le canary est stock√© √† `gs:0x14`, et sur **x86\_64**, √† `fs:0x28`.

Cette protection locale identifie les fonctions avec des tampons vuln√©rables aux attaques et injecte du code au d√©but de ces fonctions pour placer le canary, et √† la fin pour v√©rifier son int√©grit√©.

Lorsqu'un serveur web utilise `fork()`, cela permet une attaque par force brute pour deviner le byte du canary octet par octet. Cependant, l'utilisation de `execve()` apr√®s `fork()` √©crase l'espace m√©moire, annulant l'attaque. `vfork()` permet au processus enfant d'ex√©cuter sans duplication jusqu'√† ce qu'il tente d'√©crire, √† ce moment-l√† une duplication est cr√©√©e, offrant une approche diff√©rente √† la cr√©ation de processus et √† la gestion de la m√©moire.

### Longueurs

Dans les binaires `x64`, le cookie canary est un qword de **`0x8`** octets. Les **sept premiers octets sont al√©atoires** et le dernier octet est un **octet nul**.

Dans les binaires `x86`, le cookie canary est un dword de **`0x4`** octets. Les **trois premiers octets sont al√©atoires** et le dernier octet est un **octet nul**.

{% hint style="danger" %}
Le byte le moins significatif des deux canaries est un octet nul car il sera le premier dans la pile venant des adresses inf√©rieures et donc les **fonctions qui lisent des cha√Ænes s'arr√™teront avant de le lire**.
{% endhint %}

## Contournements

**Fuite du canary** puis √©crasement de celui-ci (par exemple, d√©bordement de tampon) avec sa propre valeur.

* Si le **canary est fork√© dans les processus enfants**, il pourrait √™tre possible de le **forcer par brute-force** un octet √† la fois :

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* S'il y a une **fuite int√©ressante ou une vuln√©rabilit√© de lecture arbitraire** dans le binaire, il pourrait √™tre possible de laisser fuiter :

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **√âcrasement des pointeurs stock√©s dans la pile**

La pile vuln√©rable √† un d√©bordement de pile pourrait **contenir des adresses vers des cha√Ænes ou des fonctions qui peuvent √™tre √©cras√©es** pour exploiter la vuln√©rabilit√© sans avoir besoin d'atteindre le canary de la pile. V√©rifiez :

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modification √† la fois du canary ma√Ætre et du canary du thread**

Un d√©bordement de tampon dans une fonction thread√©e prot√©g√©e par un canary peut √™tre utilis√© pour **modifier le canary ma√Ætre du thread**. Par cons√©quent, la mitigation est inutile car la v√©rification est effectu√©e avec deux canaries identiques (bien que modifi√©s).

De plus, un d√©bordement de tampon dans une fonction thread√©e prot√©g√©e par un canary pourrait √™tre utilis√© pour **modifier le canary ma√Ætre stock√© dans le TLS**. Cela est possible car il pourrait √™tre possible d'atteindre la position m√©moire o√π le TLS est stock√© (et donc, le canary) via un **d√©bordement de tampon dans la pile** d'un thread.\
Par cons√©quent, la mitigation est inutile car la v√©rification est effectu√©e avec deux canaries identiques (bien que modifi√©s).\
Cette attaque est r√©alis√©e dans le writeup : [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Consultez √©galement la pr√©sentation de [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) qui mentionne que g√©n√©ralement le **TLS** est stock√© par **`mmap`** et lorsqu'une **pile** de **thread** est cr√©√©e, elle est √©galement g√©n√©r√©e par `mmap` selon cela, ce qui pourrait permettre le d√©bordement comme indiqu√© dans le writeup pr√©c√©dent.

* **Modifier l'entr√©e GOT de `__stack_chk_fail`**

Si le binaire a Partial RELRO, alors vous pouvez utiliser une √©criture arbitraire pour modifier l'**entr√©e GOT de `__stack_chk_fail`** pour √™tre une fonction factice qui ne bloque pas le programme si le canary est modifi√©.

Cette attaque est r√©alis√©e dans le writeup : [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
## R√©f√©rences

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
