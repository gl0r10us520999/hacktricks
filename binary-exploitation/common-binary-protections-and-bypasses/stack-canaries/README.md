# Stack Canaries

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **StackGuard e StackShield**

**StackGuard** insere um valor especial conhecido como **canary** antes do **EIP (Extended Instruction Pointer)**, especificamente `0x000aff0d` (representando nulo, nova linha, EOF, retorno de carro) para proteger contra estouros de buffer. No entanto, fun√ß√µes como `recv()`, `memcpy()`, `read()` e `bcopy()` permanecem vulner√°veis, e n√£o protege o **EBP (Base Pointer)**.

**StackShield** adota uma abordagem mais sofisticada do que o StackGuard, mantendo uma **Global Return Stack**, que armazena todos os endere√ßos de retorno (**EIPs**). Essa configura√ß√£o garante que qualquer estouro n√£o cause danos, pois permite a compara√ß√£o entre os endere√ßos de retorno armazenados e os reais para detectar ocorr√™ncias de estouro. Al√©m disso, o StackShield pode verificar o endere√ßo de retorno em rela√ß√£o a um valor de limite para detectar se o **EIP** aponta para fora do espa√ßo de dados esperado. No entanto, essa prote√ß√£o pode ser contornada por t√©cnicas como Return-to-libc, ROP (Return-Oriented Programming) ou ret2ret, indicando que o StackShield tamb√©m n√£o protege vari√°veis locais.

## **Protetor de Stack Smash (ProPolice) `-fstack-protector`:**

Esse mecanismo coloca um **canary** antes do **EBP** e reorganiza as vari√°veis locais para posicionar buffers em endere√ßos de mem√≥ria mais altos, impedindo que eles sobrescrevam outras vari√°veis. Ele tamb√©m copia com seguran√ßa os argumentos passados na pilha acima das vari√°veis locais e usa essas c√≥pias como argumentos. No entanto, n√£o protege arrays com menos de 8 elementos ou buffers dentro de uma estrutura do usu√°rio.

O **canary** √© um n√∫mero aleat√≥rio derivado de `/dev/urandom` ou um valor padr√£o de `0xff0a0000`. Ele √© armazenado no **TLS (Thread Local Storage)**, permitindo que espa√ßos de mem√≥ria compartilhados entre threads tenham vari√°veis globais ou est√°ticas espec√≠ficas da thread. Essas vari√°veis s√£o inicialmente copiadas do processo pai, e os processos filhos podem alterar seus dados sem afetar o pai ou irm√£os. No entanto, se um **`fork()`** √© usado sem criar um novo canary, todos os processos (pai e filhos) compartilham o mesmo canary, tornando-o vulner√°vel. Na arquitetura **i386**, o canary √© armazenado em `gs:0x14`, e no **x86\_64**, em `fs:0x28`.

Essa prote√ß√£o local identifica fun√ß√µes com buffers vulner√°veis a ataques e injeta c√≥digo no in√≠cio dessas fun√ß√µes para colocar o canary e no final para verificar sua integridade.

Quando um servidor web usa `fork()`, ele permite um ataque de for√ßa bruta para adivinhar o byte do canary por byte. No entanto, usar `execve()` ap√≥s `fork()` sobrescreve o espa√ßo de mem√≥ria, anulando o ataque. `vfork()` permite que o processo filho execute sem duplica√ß√£o at√© tentar escrever, momento em que uma duplicata √© criada, oferecendo uma abordagem diferente para a cria√ß√£o de processos e manipula√ß√£o de mem√≥ria.

### Comprimentos

Em bin√°rios `x64`, o cookie do canary √© um qword de **`0x8`** bytes. Os **sete primeiros bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo**.

Em bin√°rios `x86`, o cookie do canary √© um dword de **`0x4`** bytes. Os **tr√™s primeiros bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo**.

{% hint style="danger" %}
O byte menos significativo de ambos os canaries √© um byte nulo porque ser√° o primeiro na pilha vindo de endere√ßos mais baixos e, portanto, **fun√ß√µes que leem strings ir√£o parar antes de l√™-lo**.
{% endhint %}

## Bypasses

**Vazando o canary** e ent√£o sobrescrevendo-o (por exemplo, estouro de buffer) com seu pr√≥prio valor.

* Se o **canary √© bifurcado em processos filhos**, pode ser poss√≠vel **for√ß√°-lo por tentativa e erro** um byte de cada vez:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Se houver alguma **vulnerabilidade de vazamento ou leitura arbitr√°ria interessante** no bin√°rio, pode ser poss√≠vel vaz√°-lo:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescrevendo ponteiros armazenados na pilha**

A pilha vulner√°vel a um estouro de pilha pode **conter endere√ßos de strings ou fun√ß√µes que podem ser sobrescritos** para explorar a vulnerabilidade sem precisar alcan√ßar o canary da pilha. Verifique:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificando tanto o canary mestre quanto o da thread**

Um **estouro de buffer em uma fun√ß√£o com thread** protegida com canary pode ser usado para **modificar o canary mestre da thread**. Como resultado, a mitiga√ß√£o √© in√∫til porque a verifica√ß√£o √© feita com dois canaries que s√£o iguais (embora modificados).

Al√©m disso, um **estouro de buffer em uma fun√ß√£o com thread** protegida com canary poderia ser usada para **modificar o canary mestre armazenado no TLS**. Isso ocorre porque pode ser poss√≠vel alcan√ßar a posi√ß√£o de mem√≥ria onde o TLS √© armazenado (e, portanto, o canary) por meio de um **bof na pilha** de uma thread.\
Como resultado, a mitiga√ß√£o √© in√∫til porque a verifica√ß√£o √© feita com dois canaries que s√£o iguais (embora modificados).\
Esse ataque √© realizado no artigo: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Verifique tamb√©m a apresenta√ß√£o de [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) que menciona que geralmente o **TLS** √© armazenado por **`mmap`** e quando uma **pilha** de **thread** √© criada, tamb√©m √© gerada por `mmap` de acordo com isso, o que pode permitir o estouro conforme mostrado no artigo anterior.

* **Modificar a entrada GOT de `__stack_chk_fail`**

Se o bin√°rio tiver Partial RELRO, ent√£o voc√™ pode usar uma escrita arbitr√°ria para modificar a **entrada GOT de `__stack_chk_fail`** para ser uma fun√ß√£o fict√≠cia que n√£o bloqueia o programa se o canary for modificado.

Esse ataque √© realizado no artigo: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
## Refer√™ncias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Treinamento AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Treinamento GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
