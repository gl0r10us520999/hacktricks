# Stack Canaries

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}

## **StackGuard e StackShield**

**StackGuard** inserisce un valore speciale noto come **canary** prima dell'**EIP (Extended Instruction Pointer)**, specificamente `0x000aff0d` (rappresentante null, newline, EOF, carriage return) per proteggersi dagli overflow di buffer. Tuttavia, funzioni come `recv()`, `memcpy()`, `read()`, e `bcopy()` rimangono vulnerabili, e non protegge l'**EBP (Base Pointer)**.

**StackShield** adotta un approccio pi√π sofisticato rispetto a StackGuard mantenendo uno **Stack di Ritorno Globale**, che memorizza tutti gli indirizzi di ritorno (**EIP**). Questa configurazione assicura che eventuali overflow non causino danni, poich√© consente di confrontare gli indirizzi di ritorno memorizzati con quelli effettivi per rilevare eventuali occorrenze di overflow. Inoltre, StackShield pu√≤ controllare l'indirizzo di ritorno rispetto a un valore di confine per rilevare se l'**EIP** punta al di fuori dello spazio dati previsto. Tuttavia, questa protezione pu√≤ essere aggirata attraverso tecniche come Return-to-libc, ROP (Return-Oriented Programming), o ret2ret, indicando che StackShield non protegge nemmeno le variabili locali.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Questo meccanismo posiziona un **canary** prima dell'**EBP**, e riorganizza le variabili locali posizionando i buffer a indirizzi di memoria pi√π alti, impedendo loro di sovrascrivere altre variabili. Copia in modo sicuro gli argomenti passati nello stack sopra le variabili locali e utilizza queste copie come argomenti. Tuttavia, non protegge gli array con meno di 8 elementi o i buffer all'interno di una struttura dell'utente.

Il **canary** √® un numero casuale derivato da `/dev/urandom` o un valore predefinito di `0xff0a0000`. √à memorizzato in **TLS (Thread Local Storage)**, consentendo a spazi di memoria condivisi tra thread di avere variabili globali o statiche specifiche del thread. Queste variabili vengono inizialmente copiate dal processo genitore, e i processi figlio possono modificare i loro dati senza influenzare il genitore o i fratelli. Tuttavia, se viene utilizzato un **`fork()` senza creare un nuovo canary, tutti i processi (genitore e figli) condivideranno lo stesso canary**, rendendolo vulnerabile. Sull'architettura **i386**, il canary √® memorizzato a `gs:0x14`, e su **x86\_64**, a `fs:0x28`.

Questa protezione locale identifica le funzioni con buffer vulnerabili agli attacchi e inietta codice all'inizio di queste funzioni per posizionare il canary, e alla fine per verificare la sua integrit√†.

Quando un server web utilizza `fork()`, consente un attacco di forza bruta per indovinare il byte del canary uno alla volta. Tuttavia, utilizzando `execve()` dopo `fork()` sovrascrive lo spazio di memoria, annullando l'attacco. `vfork()` consente al processo figlio di eseguire senza duplicazione fino a quando tenta di scrivere, momento in cui viene creata una duplicazione, offrendo un approccio diverso alla creazione di processi e alla gestione della memoria.

### Lunghezze

Nei binari `x64`, il cookie del canary √® un qword di **`0x8`** byte. I **primi sette byte sono casuali** e l'ultimo byte √® un **byte nullo**.

Nei binari `x86`, il cookie del canary √® un dword di **`0x4`** byte. I **primi tre byte sono casuali** e l'ultimo byte √® un **byte nullo**.

{% hint style="danger" %}
Il byte meno significativo di entrambi i canary √® un byte nullo perch√© sar√† il primo nello stack proveniente da indirizzi inferiori e quindi le **funzioni che leggono stringhe si fermeranno prima di leggerlo**.
{% endhint %}

## Bypass

**Leak del canary** e successiva sovrascrittura (ad es. overflow del buffer) con il proprio valore.

* Se il **canary √® forked nei processi figlio** potrebbe essere possibile **forzarne** uno byte alla volta:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Se c'√® qualche **leak interessante o vulnerabilit√† di lettura arbitraria** nel binario potrebbe essere possibile effettuare un leak:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sovrascrittura dei puntatori memorizzati nello stack**

Lo stack vulnerabile a un overflow dello stack potrebbe **contenere indirizzi a stringhe o funzioni che possono essere sovrascritti** per sfruttare la vulnerabilit√† senza dover raggiungere il canary dello stack. Controlla:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modifica sia del canary master che del canary del thread**

Un buffer **overflow in una funzione thread-safe** protetta con canary pu√≤ essere utilizzato per **modificare il canary master del thread**. Di conseguenza, la mitigazione √® inutile poich√© il controllo viene effettuato con due canary che sono gli stessi (anche se modificati).

Inoltre, un buffer **overflow in una funzione thread-safe** protetta con canary potrebbe essere utilizzato per **modificare il canary master memorizzato nel TLS**. Questo perch√© potrebbe essere possibile raggiungere la posizione di memoria in cui √® memorizzato il TLS (e quindi il canary) tramite un **bof nello stack** di un thread.\
Di conseguenza, la mitigazione √® inutile poich√© il controllo viene effettuato con due canary che sono gli stessi (anche se modificati).\
Questo attacco √® eseguito nel writeup: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Controlla anche la presentazione di [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) che menziona che di solito il **TLS** √® memorizzato da **`mmap`** e quando viene creato uno **stack** di **thread** viene generato anche da `mmap` secondo questo, che potrebbe consentire l'overflow come mostrato nel writeup precedente.

* **Modifica dell'entry GOT di `__stack_chk_fail`**

Se il binario ha Partial RELRO, √® possibile utilizzare una scrittura arbitraria per modificare l'**entry GOT di `__stack_chk_fail`** in una funzione fittizia che non blocca il programma se il canary viene modificato.

Questo attacco √® eseguito nel writeup: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
## Riferimenti

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
{% endhint %}
