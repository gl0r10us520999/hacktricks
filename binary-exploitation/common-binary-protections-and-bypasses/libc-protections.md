# Libc Beskerming

{% hint style="success" %}
Leer & oefen AWS Hack: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## Stuk Uitlynhandhawing

**Malloc** ken geheue toe in **8-byte (32-bit) of 16-byte (64-bit) groepe**. Dit beteken die einde van stukke in 32-bit stelsels moet belyn met **0x8**, en in 64-bit stelsels met **0x0**. Die sekuriteitskenmerk kontroleer dat elke stuk **korrek belyn** is by hierdie spesifieke plekke voordat 'n aanwyser van 'n bak gebruik word.

### Sekuriteitsvoordele

Die handhawing van stuk uitlyn in 64-bit stelsels verbeter Malloc se sekuriteit aansienlik deur **die plasing van valse stukke te beperk tot slegs 1 uit elke 16 adresse**. Dit bemoeilik uitbuitingspogings aansienlik, veral in scenario's waar die gebruiker beperkte beheer oor insetwaardes het, wat aanvalle meer kompleks en moeiliker maak om suksesvol uit te voer.

* **Fastbin Aanval op \_\_malloc\_hook**

Die nuwe uitlynre√´ls in Malloc dwarsboom ook 'n klassieke aanval wat die `__malloc_hook` betrek. Voorheen kon aanvallers stukgroottes manipuleer om hierdie funksieaanwyser te **oorheers en kode-uitvoering te verkry**. Nou verseker die streng uitlynvereiste dat sulke manipulasies nie meer lewensvatbaar is nie, wat 'n algemene uitbuitingsroete sluit en die algehele sekuriteit verbeter.

## Aanwyserverminking op fastbins en tcache

**Aanwyserverminking** is 'n sekuriteitsverbetering wat gebruik word om **fastbin en tcache Fd-aanwysers** te beskerm in geheuebestuurhandelinge. Hierdie tegniek help om sekere tipes geheue-uitbuitingstaktieke te voorkom, spesifiek di√© wat nie gelekte geheue-inligting vereis nie of wat geheuelokasies direk relatief tot bekende posisies manipuleer (relatiewe **oorheersings**).

Die kern van hierdie tegniek is 'n verduisteringsformule:

**`Nuwe_Aanw = (L >> 12) XOR P`**

* **L** is die **Stoorplek** van die aanwyser.
* **P** is die werklike **fastbin/tcache Fd-aanwyser**.

Die rede vir die bitgewyse skuif van die stoorplek (L) met 12-bits na regs voor die XOR-operasie is krities. Hierdie manipulasie spreek 'n kwesbaarheid aan wat inherent is aan die bepaalde aard van die minst betekenisvolle 12-bits van geheueadresse, wat tipies voorspelbaar is as gevolg van stelselargitektuurbeperkings. Deur die bits te skuif, word die voorspelbare gedeelte uit die vergelyking verwyder, wat die willekeurigheid van die nuwe, verminkte aanwyser verbeter en sodoende teen uitbuitings beskerm wat op die voorspelbaarheid van hierdie bits staatmaak.

Hierdie verminkte aanwyser maak gebruik van die bestaande willekeurigheid wat deur **Adresruimte-uitlegverandering (ASLR)** voorsien word, wat adresse wat deur programme gebruik word, willekeurig maak om dit vir aanvallers moeilik te maak om die geheuel√™er van 'n proses te voorspel.

**Ontverminking** van die aanwyser om die oorspronklike adres te herwin, behels die gebruik van dieselfde XOR-operasie. Hier word die verminkte aanwyser as P in die formule behandel, en wanneer dit met die onveranderde stoorplek (L) XOR word, lei dit daartoe dat die oorspronklike aanwyser onthul word. Hierdie simmetrie in verminking en ontverminking verseker dat die stelsel aanwysers doeltreffend kan kodeer en ontkodeer sonder beduidende oorhoofse, terwyl dit die sekuriteit teen aanvalle wat geheueaanwysers manipuleer, aansienlik verhoog.

### Sekuriteitsvoordele

Aanwyserverminking beoog om **gedeeltelike en volledige aanwyseroorheersings in die hoop**-bestuur te voorkom, 'n beduidende verbetering in sekuriteit. Hierdie kenmerk be√Ønvloed uitbuitingstegnieke op verskeie maniere:

1. **Voorkoming van Bye Byte Relatiewe Oorheersings**: Voorheen kon aanvallers 'n deel van 'n aanwyser verander om **geheuestukke na verskillende plekke om te lei sonder om die presiese adresse te ken**, 'n tegniek wat duidelik is in die leklose **House of Roman**-uitbuiting. Met aanwyserverminking vereis sulke relatiewe oorheersings **sonder 'n geheuelek nou brute force**, wat hul suksesmoontlikheid drasties verminder.
2. **Verhoogde Moeilikheid van Tcache Bin/Fastbin Aanvalle**: Gewone aanvalle wat funksieaanwysers oorskryf (soos `__malloc_hook`) deur fastbin- of tcache-inskrywings te manipuleer, word gehinder. Byvoorbeeld, 'n aanval kan 'n LibC-adres lek, 'n stuk in die tcache-bin vrymaak, en dan die Fd-aanwyser oorskryf om dit na `__malloc_hook` te stuur vir willekeurige kode-uitvoering. Met aanwyserverminking moet hierdie aanwysers korrek vermink word, **wat 'n geheuelek vir akkurate manipulasie noodsaak**, en sodoende die uitbuitingsdrempel verhoog.
3. **Vereiste vir Geheuelekke in Nie-Geheuelokasies**: Die skep van 'n valse stuk in nie-geheue-areas (soos die stok, .bss-afdeling, of PLT/GOT) vereis nou ook 'n geheuelek weens die behoefte aan aanwyserverminking. Dit verleng die kompleksiteit van die uitbuiting van hierdie areas, soortgelyk aan die vereiste vir die manipulasie van LibC-adresse.
4. **Lek van Geheueadresse Word Meer Uitdagend**: Aanwyserverminking beperk die bruikbaarheid van Fd-aanwysers in fastbin- en tcache-bakke as bronne vir geheueadreslekkasies. Tog bly aanwysers in ongesorteerde, klein, en groot bakke onvermink, dus steeds bruikbaar vir lekkasies van adresse. Hierdie skuif dwing aanvallers om hierdie bakke te ondersoek vir uitbuitbare inligting, alhoewel sommige tegnieke steeds mag toelaat om aanwysers te ontvermink voor 'n lek, alhoewel met beperkings.

### **Ontverminking van Aanwysers met 'n Geheuelek**

{% hint style="danger" %}
Vir 'n beter verduideliking van die proses [**kyk na die oorspronklike pos van hier**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algoritme-oorsig

Die formule wat gebruik word vir die verminking en ontverminking van aanwysers is:&#x20;

**`Nuwe_Aanw = (L >> 12) XOR P`**

Waar **L** die stoorplek is en **P** die Fd-aanwyser is. Wanneer **L** regs geskuif word met 12-bits, kry jy effektief die boonste 12-bits van **P** omdat die geskuifde gedeelte van **L** nul sal wees, wat **P se** ooreenstemmende bits onveranderd laat.

**Belangrike Stappe in die Algoritme:**

1. **Aanvanklike Lek van die Mees Betekenisvolle Bits**: Deur die geskuifde **L** met **P** te XOR, kry jy effektief die boonste 12-bits van **P** omdat die geskuifde gedeelte van **L** nul sal wees, wat **P se** ooreenstemmende bits onveranderd laat.
2. **Herwinning van Aanwyserbits**: Aangesien XOR omkeerbaar is, laat die kennis van die resultaat en een van die operandes jou toe om die ander operand te bereken. Hierdie eienskap word gebruik om die hele stel bits vir **P** af te lei deur bekende stelle bits suksesvol met dele van die verminkte aanwyser te XOR.
3. **Iteratiewe Ontverminking**: Die proses word herhaal, elke keer met die nuut ontdekte bits van **P** van die vorige stap om die volgende segment van die verminkte aanwyser te ontsluit, totdat alle bits herwin is.
4. **Hantering van Bepaalde Bits**: Die finale 12-bits van **L** gaan verlore weens die skuif, maar hulle is bepaal en kan na die proses herkonstrueer word.

Jy kan 'n implementering van hierdie algoritme hier vind: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Pointer Wagtwoord

Pointer wagtwoord is 'n uitbuitingstegniek wat gebruik word in glibc om gestoorde funksie-aanwysers te beskerm, veral di√© wat geregistreer is deur biblioteekoproepe soos `atexit()`. Hierdie beskerming behels die deurmekaarklits van die aanwysers deur hulle met 'n geheim wat gestoor word in die draaddata (`fs:0x30`) te XOR en 'n bitwyses rotasie toe te pas. Hierdie meganisme is daarop gemik om aanvallers te verhoed om beheervloei te kap nie deur funksie-aanwysers te oorskryf nie.

### **Bypassing Pointer Wagtwoord met 'n lek**

1. **Begrip van Pointer Wagtwoord Operasies:** Die deurmekaarklits (mangling) van aanwysers word gedoen met behulp van die `PTR_MANGLE` makro wat die aanwyser met 'n 64-bis geheim XOR en dan 'n linkse rotasie van 0x11-bits uitvoer. Die omgekeerde operasie om die oorspronklike aanwyser te herwin, word hanteer deur `PTR_DEMANGLE`.
2. **Aanvalstrategie:** Die aanval is gebaseer op 'n bekende-teksbenadering, waar die aanvaller beide die oorspronklike en die deurmekaargeklitte weergawes van 'n aanwyser moet ken om die geheim wat vir die deurmekaarklitting gebruik word, af te lei.
3. **Uitbuiting van Bekende Teks:**
* **Identifisering van Vaste Funksie-Aanwysers:** Deur glibc-bronkode te ondersoek of ge√Ønisialiseerde funksie-aanwyser-tabelle (soos `__libc_pthread_functions`) te ondersoek, kan 'n aanvaller voorspelbare funksie-aanwysers vind.
* **Berekening van die Geheim:** Deur 'n bekende funksie-aanwyser soos `__pthread_attr_destroy` te gebruik en sy deurmekaargeklitte weergawe van die funksie-aanwyser-tabel, kan die geheim bereken word deur die deurmekaargeklitte aanwyser om te keer (regs rotasie) en dit dan met die adres van die funksie te XOR.
4. **Alternatiewe Teks:** Die aanvaller kan ook eksperimenteer met die deurmekaarklitting van aanwysers met bekende waardes soos 0 of -1 om te sien of hierdie identifiseerbare patrone in geheue produseer, wat moontlik die geheim kan onthul wanneer hierdie patrone in geheue-afleidings gevind word.
5. **Praktiese Toepassing:** Na die berekening van die geheim kan 'n aanvaller aanwysers op 'n beheerde wyse manipuleer, wat essensieel die Pointer Wagtwoordbeskerming in 'n multidraadtoepassing kan omseil met kennis van die libc-basisadres en die vermo√´ om willekeurige geheuelokasies te lees.

## Verwysings

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
