# Libc Protections

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Chunk Alignment Enforcement

**Malloc** inatoa kumbukumbu katika **makundi ya byte 8 (32-bit) au byte 16 (64-bit)**. Hii inamaanisha kwamba mwisho wa makundi katika mifumo ya 32-bit inapaswa kuendana na **0x8**, na katika mifumo ya 64-bit na **0x0**. Kipengele hiki cha usalama kinathibitisha kwamba kila kundi **linapangwa kwa usahihi** katika maeneo haya maalum kabla ya kutumia kiashiria kutoka kwa bin.

### Faida za Usalama

Utekelezaji wa ulinganifu wa kundi katika mifumo ya 64-bit unaboresha usalama wa Malloc kwa **kudhibiti uwekaji wa makundi ya uwongo kuwa 1 tu kati ya anwani 16**. Hii inafanya juhudi za unyakuzi kuwa ngumu, hasa katika hali ambapo mtumiaji ana udhibiti mdogo juu ya thamani za pembejeo, na kufanya mashambulizi kuwa magumu zaidi na vigumu kutekeleza kwa mafanikio.

* **Fastbin Attack on \_\_malloc\_hook**

Sheria mpya za ulinganifu katika Malloc pia zinakabili shambulio la jadi linalohusisha `__malloc_hook`. Awali, washambuliaji wangeweza kubadilisha saizi za kundi ili **kuandika tena kiashiria hiki cha kazi** na kupata **utendaji wa msimbo**. Sasa, hitaji kali la ulinganifu linahakikisha kwamba manipulasi kama hizo hazifai tena, kufunga njia ya kawaida ya unyakuzi na kuboresha usalama kwa ujumla.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** ni uboreshaji wa usalama unaotumika kulinda **fastbin na tcache Fd pointers** katika operesheni za usimamizi wa kumbukumbu. Tekni hii husaidia kuzuia aina fulani za mbinu za unyakuzi wa kumbukumbu, hasa zile ambazo hazihitaji taarifa za kumbukumbu zilizovuja au ambazo zinabadilisha maeneo ya kumbukumbu moja kwa moja kulingana na nafasi zilizojulikana (kuandika **kurejelea**).

Msingi wa mbinu hii ni fomula ya kuficha:

**`New_Ptr = (L >> 12) XOR P`**

* **L** ni **Mahali pa Hifadhi** ya kiashiria.
* **P** ni kiashiria halisi cha **fastbin/tcache Fd**.

Sababu ya kuhamasisha mahali pa hifadhi (L) kwa bits 12 kwenda kulia kabla ya operesheni ya XOR ni muhimu. Manipulasi hii inashughulikia udhaifu ulio ndani ya asili ya kimaamuzi ya bits 12 za chini zaidi za anwani za kumbukumbu, ambazo kwa kawaida zinatabirika kutokana na vikwazo vya usanifu wa mfumo. Kwa kuhamasisha bits, sehemu inayoweza kutabirika inahamishwa nje ya hesabu, ikiongeza nasibu ya kiashiria kipya kilichofichwa na hivyo kulinda dhidi ya unyakuzi unaotegemea utabiri wa bits hizi.

Kiashiria hiki kilichofichwa kinatumia nasibu iliyopo iliyotolewa na **Address Space Layout Randomization (ASLR)**, ambayo inafanya anwani zinazotumiwa na programu kuwa ngumu kwa washambuliaji kutabiri mpangilio wa kumbukumbu wa mchakato.

**Demangling** kiashiria ili kupata anwani ya asili inahusisha kutumia operesheni sawa ya XOR. Hapa, kiashiria kilichofichwa kinachukuliwa kama P katika fomula, na wakati kinapofanywa XOR na mahali pa hifadhi (L) kisichobadilika, inasababisha kiashiria cha asili kufichuliwa. Ulinganifu huu katika kuficha na kufichua unahakikisha kwamba mfumo unaweza kuandika na kufichua viashiria kwa ufanisi bila mzigo mkubwa, huku ukiongeza usalama dhidi ya mashambulizi yanayobadilisha viashiria vya kumbukumbu.

### Faida za Usalama

Kuficha viashiria kuna lengo la **kuzuia kuandika tena kwa sehemu na kamili za viashiria katika usimamizi wa heap**, uboreshaji muhimu katika usalama. Kipengele hiki kinaathiri mbinu za unyakuzi kwa njia kadhaa:

1. **Kuzuia Kuandika Kurejelea kwa Byte**: Awali, washambuliaji wangeweza kubadilisha sehemu ya kiashiria ili **kuhamasisha makundi ya heap kwa maeneo tofauti bila kujua anwani halisi**, mbinu ambayo inaonekana katika unyakuzi wa **House of Roman** bila uvujaji. Kwa kuficha viashiria, kuandika tena kama hizo **bila uvujaji wa heap sasa kunahitaji nguvu ya kikatili**, kupunguza sana uwezekano wao wa kufanikiwa.
2. **Kuongeza Ugumu wa Mashambulizi ya Tcache Bin/Fastbin**: Mashambulizi ya kawaida yanayoandika viashiria vya kazi (kama `__malloc_hook`) kwa kubadilisha fastbin au tcache entries yanakabiliwa. Kwa mfano, shambulio linaweza kujumuisha kuvujisha anwani ya LibC, kuachilia kundi katika tcache bin, na kisha kuandika tena kiashiria cha Fd ili kuhamasisha kwa `__malloc_hook` kwa utendaji wa msimbo wa kiholela. Kwa kuficha viashiria, viashiria hivi lazima viandikwe kwa usahihi, **vinahitaji uvujaji wa heap kwa usahihi wa manipulasi**, hivyo kuongeza kizuizi cha unyakuzi.
3. **Hitaji la Uvujaji wa Heap katika Maeneo Yasiyo ya Heap**: Kuunda kundi la uwongo katika maeneo yasiyo ya heap (kama stack, sehemu ya .bss, au PLT/GOT) sasa pia **kunahitaji uvujaji wa heap** kutokana na hitaji la kuficha viashiria. Hii inapanua ugumu wa unyakuzi katika maeneo haya, sawa na hitaji la kubadilisha anwani za LibC.
4. **Kuvuja kwa Anwani za Heap Kunakuwa Ngumu Zaidi**: Kuficha viashiria kunapunguza matumizi ya viashiria vya Fd katika fastbin na tcache bins kama vyanzo vya uvujaji wa anwani za heap. Hata hivyo, viashiria katika bins zisizopangwa, ndogo, na kubwa vinabaki bila kufichwa, hivyo bado vinatumika kwa uvujaji wa anwani. Mabadiliko haya yanawasukuma washambuliaji kuchunguza bins hizi kwa taarifa zinazoweza kutumika, ingawa mbinu zingine zinaweza bado kuruhusu kufichua viashiria kabla ya uvujaji, ingawa kwa vikwazo.

### **Demangling Pointers with a Heap Leak**

{% hint style="danger" %}
For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algorithm Overview

Fomula inayotumika kwa kuficha na kufichua viashiria ni:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Ambapo **L** ni mahali pa hifadhi na **P** ni kiashiria cha Fd. Wakati **L** inahamishwa kulia kwa bits 12, inafichua bits muhimu zaidi za **P**, kutokana na asili ya **XOR**, ambayo inatoa 0 wakati bits zinapofanywa XOR na wenyewe.

**Hatua Muhimu katika Algorithm:**

1. **Uvujaji wa Awali wa Bits Muhimu Zaidi**: Kwa kufanya XOR ya **L** iliyohamishwa na **P**, unapata kwa ufanisi bits 12 za juu za **P** kwa sababu sehemu iliyohamishwa ya **L** itakuwa sifuri, ikiacha bits zinazohusiana za **P** zisibadilishwe.
2. **Kurejesha Bits za Kiashiria**: Kwa kuwa XOR ni ya kurudi, kujua matokeo na mmoja wa operandi kunakuruhusu kuhesabu operandi nyingine. Mali hii inatumika kudhibitisha seti nzima ya bits za **P** kwa kufanya XOR kwa mfululizo wa seti zinazojulikana za bits na sehemu za kiashiria kilichofichwa.
3. **Kufichua kwa Mfululizo**: Mchakato huu unarudiwa, kila wakati ukitumia bits mpya zilizogunduliwa za **P** kutoka hatua ya awali kufichua sehemu inayofuata ya kiashiria kilichofichwa, hadi bits zote zirejeshwe.
4. **Kushughulikia Bits za Kimaamuzi**: Bits za mwisho 12 za **L** zinapotea kutokana na kuhamishwa, lakini ni za kimaamuzi na zinaweza kujengwa tena baada ya mchakato.

Unaweza kupata utekelezaji wa algorithm hii hapa: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard ni mbinu ya kupunguza unyakuzi inayotumika katika glibc kulinda viashiria vya kazi vilivyohifadhiwa, hasa vile vilivyosajiliwa na wito wa maktaba kama `atexit()`. Ulinzi huu unahusisha kuchanganya viashiria kwa kufanya XOR na siri iliyohifadhiwa katika data ya thread (`fs:0x30`) na kutumia mzunguko wa bits. Mekanismu hii inalenga kuzuia washambuliaji kuiba mtiririko wa udhibiti kwa kuandika tena viashiria vya kazi.

### **Bypassing Pointer Guard with a leak**

1. **Kuelewa Operesheni za Pointer Guard:** Kuchanganya (kuficha) viashiria kunafanywa kwa kutumia macro ya `PTR_MANGLE` ambayo inafanya XOR ya kiashiria na siri ya bits 64 na kisha inafanya mzunguko wa kushoto wa bits 0x11. Operesheni ya kinyume ya kurejesha kiashiria cha asili inashughulikiwa na `PTR_DEMANGLE`.
2. **Mkakati wa Shambulio:** Shambulio linategemea mbinu ya maandiko yanayojulikana, ambapo mshambuliaji anahitaji kujua toleo la asili na la kufichwa la kiashiria ili kudhibitisha siri iliyotumika kwa kuficha.
3. **Kunutumia Maandishi Yanayojulikana:**
* **Kutambua Viashiria vya Kazi Vilivyowekwa:** Kwa kuchunguza msimbo wa chanzo wa glibc au meza za viashiria vya kazi zilizowekwa (kama `__libc_pthread_functions`), mshambuliaji anaweza kupata viashiria vya kazi vinavyoweza kutabirika.
* **Kuhesabu Siri:** Kwa kutumia kiashiria cha kazi kinachojulikana kama `__pthread_attr_destroy` na toleo lake lililofichwa kutoka kwenye meza ya viashiria vya kazi, siri inaweza kuhesabiwa kwa kuhamasisha kiashiria kilichofichwa na kisha kufanya XOR na anwani ya kazi.
4. **Maandishi Mbadala:** Mshambuliaji anaweza pia kujaribu kuficha viashiria kwa kutumia thamani zinazojulikana kama 0 au -1 ili kuona kama hizi zinatoa mifumo inayoweza kutambulika katika kumbukumbu, huenda zikafichua siri wakati mifumo hii inapatikana katika dump za kumbukumbu.
5. **Matumizi ya Vitendo:** Baada ya kuhesabu siri, mshambuliaji anaweza kubadilisha viashiria kwa njia iliyo na udhibiti, kimsingi akipita ulinzi wa Pointer Guard katika programu yenye nyuzi nyingi kwa maarifa ya anwani ya msingi ya libc na uwezo wa kusoma maeneo ya kumbukumbu yasiyo na mipaka.

## References

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
