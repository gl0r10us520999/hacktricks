# Protezioni di Libc

{% hint style="success" %}
Impara e pratica l'Hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di Github.

</details>
{% endhint %}

## Applicazione dell'Allineamento dei Chunk

**Malloc** alloca memoria in **gruppI di 8 byte (32-bit) o 16 byte (64-bit)**. Ci√≤ significa che la fine dei chunk nei sistemi a 32-bit dovrebbe allinearsi con **0x8**, e nei sistemi a 64-bit con **0x0**. La funzionalit√† di sicurezza controlla che ogni chunk si **allinei correttamente** a queste posizioni specifiche prima di utilizzare un puntatore da un bin.

### Benefici per la Sicurezza

L'applicazione dell'allineamento dei chunk nei sistemi a 64-bit migliora significativamente la sicurezza di Malloc limitando il posizionamento dei chunk falsi a solo 1 su ogni 16 indirizzi. Ci√≤ complica gli sforzi di exploit, specialmente in scenari in cui l'utente ha un controllo limitato sui valori di input, rendendo gli attacchi pi√π complessi e difficili da eseguire con successo.

* **Attacco Fastbin su \_\_malloc\_hook**

Le nuove regole di allineamento in Malloc ostacolano anche un attacco classico che coinvolge il `__malloc_hook`. Precedentemente, gli attaccanti potevano manipolare le dimensioni dei chunk per **sovrascrivere questo puntatore di funzione** e ottenere **esecuzione di codice**. Ora, il rigoroso requisito di allineamento garantisce che tali manipolazioni non siano pi√π valide, chiudendo una via comune di exploit e potenziando la sicurezza complessiva.

## Mascheramento dei Puntatori su fastbins e tcache

Il **Mascheramento dei Puntatori** √® un potenziamento della sicurezza utilizzato per proteggere i **puntatori Fd di fastbin e tcache** nelle operazioni di gestione della memoria. Questa tecnica aiuta a prevenire certe tattiche di exploit di memoria, in particolare quelle che non richiedono informazioni di memoria divulgate o che manipolano direttamente le posizioni di memoria relative a posizioni conosciute (sovrascritture **relative**).

Il cuore di questa tecnica √® una formula di oscuramento:

**`Nuovo_Ptr = (L >> 12) XOR P`**

* **L** √® la **Posizione di Archiviazione** del puntatore.
* **P** √® il vero **puntatore Fd di fastbin/tcache**.

La ragione dello spostamento bitwise della posizione di archiviazione (L) di 12 bit a destra prima dell'operazione XOR √® critica. Questa manipolazione affronta una vulnerabilit√† intrinseca nella natura deterministica dei 12 bit meno significativi degli indirizzi di memoria, che sono tipicamente prevedibili a causa dei vincoli dell'architettura di sistema. Spostando i bit, la parte prevedibile viene esclusa dall'equazione, migliorando la casualit√† del nuovo puntatore mascherato e proteggendo cos√¨ contro exploit che si basano sulla prevedibilit√† di questi bit.

Questo puntatore mascherato sfrutta la casualit√† esistente fornita dalla **Randomizzazione dello Spazio degli Indirizzi (ASLR)**, che randomizza gli indirizzi utilizzati dai programmi per rendere difficile agli attaccanti prevedere la disposizione della memoria di un processo.

**Demascherare** il puntatore per recuperare l'indirizzo originale coinvolge l'utilizzo della stessa operazione XOR. Qui, il puntatore mascherato √® trattato come P nella formula e, quando XORato con la posizione di archiviazione invariata (L), si ottiene il puntatore originale. Questa simmetria nel mascheramento e demascheramento garantisce che il sistema possa codificare e decodificare efficientemente i puntatori senza un overhead significativo, aumentando notevolmente la sicurezza contro attacchi che manipolano i puntatori di memoria.

### Benefici per la Sicurezza

Il mascheramento dei puntatori mira a **prevenire sovrascritture parziali e complete dei puntatori nell'heap**, un miglioramento significativo in termini di sicurezza. Questa funzionalit√† influisce sulle tecniche di exploit in diversi modi:

1. **Prevenzione delle Sovrascritture Relative di Byte**: Precedentemente, gli attaccanti potevano modificare parte di un puntatore per **reindirizzare i chunk dell'heap a posizioni diverse senza conoscere gli indirizzi esatti**, una tecnica evidente nell'exploit **House of Roman** senza leak. Con il mascheramento dei puntatori, tali sovrascritture relative **senza un leak dell'heap richiedono ora un attacco di forza bruta**, riducendo drasticamente la probabilit√† di successo.
2. **Aumento della Difficolt√† degli Attacchi ai Bin Tcache/Fastbin**: Gli attacchi comuni che sovrascrivono i puntatori di funzione (come `__malloc_hook`) manipolando le voci fastbin o tcache sono ostacolati. Ad esempio, un attacco potrebbe coinvolgere il leak di un indirizzo LibC, il rilascio di un chunk nel bin tcache e quindi la sovrascrittura del puntatore Fd per reindirizzarlo a `__malloc_hook` per l'esecuzione di codice arbitrario. Con il mascheramento dei puntatori, questi puntatori devono essere correttamente mascherati, **necessitando di un leak dell'heap per una manipolazione accurata**, elevando cos√¨ la barriera di exploit.
3. **Necessit√† di Leak dell'Heap in Posizioni non-Heap**: Creare un chunk falso in aree non-heap (come lo stack, la sezione .bss o PLT/GOT) ora richiede anche un leak dell'heap a causa della necessit√† di mascheramento dei puntatori. Ci√≤ estende la complessit√† nell'exploit di queste aree, simile alla necessit√† di manipolare gli indirizzi LibC.
4. **Rendere pi√π Complicato il Leak degli Indirizzi dell'Heap**: Il mascheramento dei puntatori limita l'utilit√† dei puntatori Fd nei bin fastbin e tcache come fonti di leak degli indirizzi dell'heap. Tuttavia, i puntatori nei bin non ordinati, piccoli e grandi rimangono non mascherati, quindi ancora utilizzabili per il leak degli indirizzi. Questo spinge gli attaccanti a esplorare questi bin per informazioni sfruttabili, anche se alcune tecniche potrebbero ancora consentire di demascherare i puntatori prima di un leak, sebbene con vincoli.

### **Demascherare i Puntatori con un Leak dell'Heap**

{% hint style="danger" %}
Per una migliore spiegazione del processo [**controlla il post originale da qui**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Panoramica dell'Algoritmo

La formula utilizzata per mascherare e demascherare i puntatori √®:&#x20;

**`Nuovo_Ptr = (L >> 12) XOR P`**

Dove **L** √® la posizione di archiviazione e **P** √® il puntatore Fd. Quando **L** viene spostato a destra di 12 bit, si ottengono i bit pi√π significativi di **P**, a causa della natura di **XOR**, che restituisce 0 quando i bit vengono XORati con se stessi.

**Passaggi Chiave nell'Algoritmo:**

1. **Leak Iniziale dei Bit pi√π Significativi**: XORando il **L** spostato con **P**, si ottengono efficacemente i primi 12 bit di **P** poich√© la parte spostata di **L** sar√† zero, lasciando invariati i bit corrispondenti di **P**.
2. **Recupero dei Bit del Puntatore**: Poich√© XOR √® reversibile, conoscere il risultato e uno degli operandi consente di calcolare l'altro operando. Questa propriet√† √® utilizzata per dedurre l'intero set di bit per **P** XORando successivamente set di bit con parti del puntatore mascherato.
3. **Demascheramento Iterativo**: Il processo viene ripetuto, ogni volta utilizzando i bit di **P** appena scoperti dal passaggio precedente per decodificare il segmento successivo del puntatore mascherato, fino a quando tutti i bit sono recuperati.
4. **Gestione dei Bit Deterministici**: I 12 bit finali di **L** vengono persi a causa dello spostamento, ma sono deterministici e possono essere ricostruiti dopo il processo.

Puoi trovare un'implementazione di questo algoritmo qui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Protezione Pointer Guard

Pointer guard √® una tecnica di mitigazione degli exploit utilizzata in glibc per proteggere i puntatori alle funzioni memorizzate, in particolare quelli registrati dalle chiamate di libreria come `atexit()`. Questa protezione coinvolge la mescolanza dei puntatori tramite XOR con un segreto memorizzato nei dati del thread (`fs:0x30`) e l'applicazione di una rotazione bit a bit. Questo meccanismo mira a impedire agli attaccanti di dirottare il flusso di controllo sovrascrivendo i puntatori alle funzioni.

### **Bypass di Pointer Guard con un leak**

1. **Comprensione delle Operazioni di Pointer Guard:** La mescolanza dei puntatori avviene utilizzando la macro `PTR_MANGLE` che esegue l'XOR del puntatore con un segreto a 64 bit e poi esegue una rotazione a sinistra di 0x11 bit. L'operazione inversa per recuperare il puntatore originale √® gestita da `PTR_DEMANGLE`.
2. **Strategia di Attacco:** L'attacco si basa su un approccio di testo noto, dove l'attaccante deve conoscere sia la versione originale che quella mescolata di un puntatore per dedurre il segreto usato per la mescolanza.
3. **Sfruttare i Testi Noto:**
* **Identificare i Puntatori alle Funzioni Fissi:** Esaminando il codice sorgente di glibc o le tabelle dei puntatori alle funzioni inizializzate (come `__libc_pthread_functions`), un attaccante pu√≤ trovare puntatori alle funzioni prevedibili.
* **Calcolare il Segreto:** Utilizzando un puntatore alle funzioni noto come `__pthread_attr_destroy` e la sua versione mescolata dalla tabella dei puntatori alle funzioni, il segreto pu√≤ essere calcolato ruotando all'indietro (rotazione a destra) il puntatore mescolato e quindi facendo l'XOR con l'indirizzo della funzione.
4. **Testi Alternativi:** L'attaccante pu√≤ anche sperimentare la mescolanza dei puntatori con valori noti come 0 o -1 per vedere se questi producono pattern identificabili in memoria, rivelando potenzialmente il segreto quando questi pattern vengono trovati negli snapshot di memoria.
5. **Applicazione Pratica:** Dopo aver calcolato il segreto, un attaccante pu√≤ manipolare i puntatori in modo controllato, bypassando essenzialmente la protezione Pointer Guard in un'applicazione multithread con la conoscenza dell'indirizzo di base di libc e la capacit√† di leggere posizioni di memoria arbitrarie.

## Riferimenti

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
