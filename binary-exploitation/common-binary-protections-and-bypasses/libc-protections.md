# Libc Korumaları

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin**.
* **Hacking püf noktalarını paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## Parça Hizalaması Zorlaması

**Malloc**, belleği **8 bayt (32-bit) veya 16 bayt (64-bit) gruplarında** ayırır. Bu, 32-bit sistemlerde parçaların sonunun **0x8** ile, 64-bit sistemlerde ise **0x0** ile hizalanması gerektiği anlamına gelir. Güvenlik özelliği, bir bin'den bir işaretçi kullanmadan önce her parçanın bu belirli konumlarda **doğru şekilde hizalandığını** kontrol eder.

### Güvenlik Avantajları

64-bit sistemlerde parça hizalamasının zorunlu olması, Malloc'ın güvenliğini önemli ölçüde artırır çünkü **sahte parçaların yerleştirilmesini sadece her 16 adresin birine** sınırlar. Bu, özellikle kullanıcının giriş değerleri üzerinde sınırlı kontrolü olduğu senaryolarda saldırıları daha karmaşık ve başarılı bir şekilde gerçekleştirmeyi zorlaştırır.

* **\_\_malloc\_hook Üzerindeki Fastbin Saldırısı**

Malloc'daki yeni hizalama kuralları, `__malloc_hook`'u içeren klasik bir saldırıyı da engeller. Önceden saldırganlar, parça boyutlarını manipüle ederek bu fonksiyon işaretçisini **üzerine yazabilir** ve **kod yürütme** elde edebilirdi. Şimdi, sıkı hizalama gereksinimi, böyle manipülasyonların artık mümkün olmadığından emin olur, yaygın bir sömürü yolunu kapatır ve genel güvenliği artırır.

## Fastbin ve tcache Üzerinde İşaretçi Karıştırma

**İşaretçi Karıştırma**, bellek yönetimi işlemlerinde **fastbin ve tcache Fd işaretçilerini** korumak için kullanılan bir güvenlik artırmasıdır. Bu teknik, sızdırılmış bellek bilgisi gerektirmeyen veya bilinen konumlara doğrudan bağlı bellek konumlarını manipüle eden belirli türdeki bellek sömürü taktiklerini önlemeye yardımcı olur (**bağıl **üzerine yazmalar).

Bu tekniğin çekirdeği bir karıştırma formülüdür:

**`Yeni_Ptr = (L >> 12) XOR P`**

* **L**, işaretçinin **Depolama Konumu**'dur.
* **P**, gerçek **fastbin/tcache Fd İşaretçisi**'dir.

Depolama konumunun (L) XOR işleminden önce 12 bit sağa kaydırılmasının nedeni kritiktir. Bu manipülasyon, bellek adreslerinin en az anlamlı 12 bitinin belirlenmiş doğasıyla ilgili bir zafiyeti ele alır. Bu bitler genellikle sistem mimarisi kısıtlamaları nedeniyle tahmin edilebilir olduğundan, bitleri kaydırarak, tahmin edilebilir kısmın denklem dışına çıkarılması, yeni, karışık işaretçinin rastgeleliğini artırır ve böylece bu bitlerin tahmin edilebilirliğine dayanan saldırılara karşı koruma sağlar.

Bu karışık işaretçi, programların kullandığı adresleri rastgele hale getiren **Adres Alanı Düzeni Rastgeleleştirme (ASLR)** tarafından sağlanan mevcut rastgeleliği kullanır.

İşaretçiyi orijinal adresi almak için **karıştırma** işlemi, aynı XOR işlemi kullanılarak yapılır. Burada, karışık işaretçi formülde P olarak işlem görür ve değişmeyen depolama konumu (L) ile XOR işlemine tabi tutulduğunda orijinal işaretçi ortaya çıkar. Bu karıştırma ve çözme simetrisi, sistemin bellek işaretçilerini etkin bir şekilde kodlamasına ve kodlamasına olanak tanırken, bellek işaretçilerini manipüle eden saldırılara karşı güvenliği önemli ölçüde artırır.

### Güvenlik Avantajları

İşaretçi karıştırma, heap yönetiminde **kısmi ve tam işaretçi üzerine yazmaları önlemeyi** amaçlar ve bu, güvenlik açısından önemli bir gelişmedir. Bu özellik, sömürü tekniklerini birkaç şekilde etkiler:

1. **Bye Byte Bağıl Üzerine Yazmaların Önlenmesi**: Önceden, saldırganlar, **kesin adresleri bilmeden** heap parçalarını farklı konumlara yönlendirmek için işaretçinin bir kısmını değiştirebilirdi, bu teknik, sızıntısız **House of Roman** sömürüsünde açıkça görülebilir. İşaretçi karıştırma ile, bu tür bağıl üzerine yazmalar **artık bir heap sızıntısı gerektirir**, başarılı olma olasılığını büyük ölçüde azaltarak.
2. **Tcache Bin/Fastbin Saldırılarının Zorlaştırılması**: Fastbin veya tcache girişlerini manipüle ederek işlev işaretçilerini (örneğin, `__malloc_hook`) üzerine yazan yaygın saldırılar engellenir. Örneğin, bir saldırı, bir LibC adresi sızdırmayı, bir parçayı tcache bölmesine serbest bırakmayı ve ardından Fd işaretçisini `__malloc_hook`'a yönlendirmek için üzerine yazmayı içerebilir. İşaretçi karıştırma ile, bu işaretçilerin doğru şekilde karıştırılması gerekmektedir, **doğru manipülasyon için bir heap sızıntısı gerektirir**, böylece sömürü engeli yükseltilir.
3. **Heap Sızıntıları İçin Heap Sızıntıları Gerekliliği**: Sahte bir parça oluşturmak artık heap sızıntısı gerektiren non-heap alanlarda (örneğin, yığın, .bss bölümü veya PLT/GOT) da gereklidir. Bu, bu alanların sömürülmesinin karmaşıklığını artırır, LibC adreslerini manipüle etme gereksinimi gibi.
4. **Heap Adreslerinin Sızdırılması Daha Zor Hale Gelir**: İşaretçi karıştırma, fastbin ve tcache bölümlerindeki Fd işaretçilerinin heap adres sızıntıları için kullanışlılığını kısıtlar. Ancak, sıralanmamış, küçük ve büyük bölümlerdeki işaretçiler karıştırılmamış kalır, bu nedenle hala adres sızıntıları için kullanılabilirler. Bu değişiklik, saldırganları bu bölümlerde sömürülebilir bilgileri keşfetmeye zorlar, ancak bazı teknikler hala sızıntıdan önce işaretçilerin çözülmesine izin verebilir, ancak kısıtlamalarla.

### **Heap Sızıntısı ile İşaretçilerin Çözülmesi**

{% hint style="danger" %}
İşlemi daha iyi açıklamak için [**buradan orijinal gönderiyi kontrol edin**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algoritma Genel Bakış

İşaretçilerin karıştırılması ve çözülmesi için kullanılan formül:&#x20;

**`Yeni_Ptr = (L >> 12) XOR P`**

Burada **L**, depolama konumu ve **P**, Fd işaretçisidir. **L**'nin 12 bit sağa kaydırılmasıyla, **XOR**'un doğası gereği, kendileriyle XOR işlemi yapıldığında 0 çıktığında, **P**'nin en üst 12 bitini elde edersiniz.

**Algoritmadaki Ana Adımlar:**

1. **En Önemli Bitlerin Başlangıç Sızıntısı**: Kaydırılmış **L**'yi **P** ile XORladığınızda, kaydırılmış **L**'nin sıfır olacağından dolayı, **P**'nin ilgili bitleri değişmeden kalır ve **P**'nin en üst 12 bitini elde edersiniz.
2. **İşaretçi Bitlerinin Kurtarılması**: XOR tersine çevrilebilir olduğundan, sonucu ve bir operatörü bildiğinizde diğer operatörü hesaplayabilirsiniz. Bu özellik, karışık işaretçinin parçalarının tamamını, karışık işaretçinin parçalarının parçalarını sırayla XORlayarak çıkarmanızı sağlar.
3. **İteratif Karıştırma Çözme**: İşlem, her seferinde önceki adımdan elde edilen **P**'nin yeni keşfedilen bitlerini kullanarak tekrarlanır ve tüm bitler kurtarıncaya kadar devam eder.
4. **Belirlenmiş Bitlerin İşlenmesi**: Kaydırma nedeniyle **L**'nin son 12 biti kaybolur, ancak bunlar belirlidir ve işlem sonrası yeniden oluşturulabilir.

Bu algoritmanın bir uygulamasını burada bulabilirsiniz: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Pointer Guard

Pointer guard, glibc'de kullanılan bir sömürü koruma tekniğidir ve özellikle `atexit()` gibi kütüphane çağrıları tarafından kaydedilen işlev işaretçilerini korumak için kullanılır. Bu koruma, işaretçileri `fs:0x30` konumundaki bir gizli değerle XOR işlemine tabi tutarak ve bit düzeyinde bir döndürme işlemi uygulayarak karıştırma işlemi içerir. Bu mekanizma, saldırganların işlev işaretçilerini üzerine yazarak kontrol akışını ele geçirmesini engellemeyi amaçlar.

### **Pointer Guard'ı Bir Sızıntı ile Atlatma**

1. **Pointer Guard İşlemlerini Anlama:** İşaretçilerin karıştırılması, işaretçilerin `PTR_MANGLE` makrosunu kullanarak 64 bitlik bir gizli değerle XOR işlemine tabi tutulması ve ardından 0x11 bitlik bir sola döndürme işlemiyle gerçekleştirilir. Orijinal işaretçiyi kurtarmak için ters işlem, `PTR_DEMANGLE` tarafından ele alınır.
2. **Saldırı Stratejisi:** Saldırı, bilinen-metin yaklaşımına dayanır, saldırganın karıştırma için kullanılan gizli değeri çıkarmak için bir işaretçinin hem orijinal hem de karıştırılmış sürümlerini bilmeleri gerekmektedir.
3. **Bilinen Metinlerin Sömürülmesi:**
* **Sabit İşlev İşaretçilerini Tanımlama:** glibc kaynak kodunu veya başlatılmış işlev işaretçisi tablolarını (örneğin `__libc_pthread_functions`) inceleyerek, bir saldırgan öngörülebilir işlev işaretçileri bulabilir.
* **Gizli Değeri Hesaplama:** `__pthread_attr_destroy` gibi bilinen bir işlev işaretçisini ve işlev işaretçisi tablosundan karıştırılmış sürümünü kullanarak, gizli değer, karıştırılmış işaretçiyi ters döndürerek (sağa döndürme) ve ardından işlevin adresiyle XOR işlemi yaparak hesaplanabilir.
4. **Alternatif Metinler:** Saldırgan, bellekte tanınabilir desenler oluşturup oluşturmadığını görmek için bilinen değerlerle (örneğin 0 veya -1) işaretçileri karıştırmayı deneyebilir; bu desenler bellek dökümlerinde bulunduğunda, gizli değeri ortaya çıkarabilir.
5. **Pratik Uygulama:** Gizli değeri hesapladıktan sonra, bir saldırgan, libc taban adresini bilerek ve keyfi bellek konumlarını okuyabilme yeteneğiyle, işaretçileri kontrol edilmiş bir şekilde manipüle edebilir ve temelde Pointer Guard korumasını atlayabilir.

## Referanslar

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
