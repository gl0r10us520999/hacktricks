# Prote√ß√µes Libc

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## Aplica√ß√£o de Alinhamento de Chunk

**Malloc** aloca mem√≥ria em **agrupamentos de 8 bytes (32 bits) ou 16 bytes (64 bits)**. Isso significa que o final dos chunks em sistemas de 32 bits deve alinhar com **0x8**, e em sistemas de 64 bits com **0x0**. O recurso de seguran√ßa verifica se cada chunk **alinha corretamente** nesses locais espec√≠ficos antes de usar um ponteiro de um bin.

### Benef√≠cios de Seguran√ßa

A aplica√ß√£o de alinhamento de chunk em sistemas de 64 bits melhora significativamente a seguran√ßa do Malloc ao **limitar a coloca√ß√£o de chunks falsos a apenas 1 em cada 16 endere√ßos**. Isso complica os esfor√ßos de explora√ß√£o, especialmente em cen√°rios onde o usu√°rio tem controle limitado sobre os valores de entrada, tornando os ataques mais complexos e dif√≠ceis de executar com sucesso.

* **Ataque Fastbin em \_\_malloc\_hook**

As novas regras de alinhamento no Malloc tamb√©m frustram um ataque cl√°ssico envolvendo o `__malloc_hook`. Anteriormente, os atacantes podiam manipular tamanhos de chunks para **sobrescrever este ponteiro de fun√ß√£o** e ganhar **execu√ß√£o de c√≥digo**. Agora, a exig√™ncia de alinhamento rigoroso garante que tais manipula√ß√µes n√£o sejam mais vi√°veis, fechando uma rota comum de explora√ß√£o e melhorando a seguran√ßa geral.

## Mistura de Ponteiros em fastbins e tcache

**Mistura de Ponteiros** √© uma melhoria de seguran√ßa usada para proteger **ponteiros Fd de fastbin e tcache** em opera√ß√µes de gerenciamento de mem√≥ria. Esta t√©cnica ajuda a prevenir certos tipos de t√°ticas de explora√ß√£o de mem√≥ria, especificamente aquelas que n√£o requerem informa√ß√µes de mem√≥ria vazadas ou que manipulam locais de mem√≥ria diretamente em rela√ß√£o a posi√ß√µes conhecidas (sobrescritas **relativas**).

O n√∫cleo desta t√©cnica √© uma f√≥rmula de ofusca√ß√£o:

**`New_Ptr = (L >> 12) XOR P`**

* **L** √© a **Localiza√ß√£o de Armazenamento** do ponteiro.
* **P** √© o **Ponteiro Fd de fastbin/tcache**.

A raz√£o para o deslocamento bit a bit da localiza√ß√£o de armazenamento (L) por 12 bits para a direita antes da opera√ß√£o XOR √© cr√≠tica. Essa manipula√ß√£o aborda uma vulnerabilidade inerente √† natureza determin√≠stica dos 12 bits menos significativos dos endere√ßos de mem√≥ria, que s√£o tipicamente previs√≠veis devido a restri√ß√µes da arquitetura do sistema. Ao deslocar os bits, a parte previs√≠vel √© removida da equa√ß√£o, aumentando a aleatoriedade do novo ponteiro misturado e, assim, protegendo contra explora√ß√µes que dependem da previsibilidade desses bits.

Esse ponteiro misturado aproveita a aleatoriedade existente fornecida pela **Randomiza√ß√£o de Layout de Espa√ßo de Endere√ßos (ASLR)**, que randomiza endere√ßos usados por programas para dificultar a previs√£o do layout de mem√≥ria de um processo pelos atacantes.

**Desmistificar** o ponteiro para recuperar o endere√ßo original envolve usar a mesma opera√ß√£o XOR. Aqui, o ponteiro misturado √© tratado como P na f√≥rmula, e quando XORado com a localiza√ß√£o de armazenamento inalterada (L), resulta na revela√ß√£o do ponteiro original. Essa simetria na mistura e desmistifica√ß√£o garante que o sistema possa codificar e decodificar ponteiros de forma eficiente, sem sobrecarga significativa, enquanto aumenta substancialmente a seguran√ßa contra ataques que manipulam ponteiros de mem√≥ria.

### Benef√≠cios de Seguran√ßa

A mistura de ponteiros visa **prevenir sobrescritas parciais e totais de ponteiros na heap**, uma melhoria significativa em seguran√ßa. Este recurso impacta t√©cnicas de explora√ß√£o de v√°rias maneiras:

1. **Preven√ß√£o de Sobrescritas Relativas por Byte**: Anteriormente, os atacantes podiam alterar parte de um ponteiro para **redirecionar chunks da heap para diferentes locais sem conhecer endere√ßos exatos**, uma t√©cnica evidente na explora√ß√£o **House of Roman** sem vazamento. Com a mistura de ponteiros, tais sobrescritas relativas **sem um vazamento da heap agora requerem for√ßa bruta**, reduzindo drasticamente a probabilidade de sucesso.
2. **Aumento da Dificuldade de Ataques em Tcache Bin/Fastbin**: Ataques comuns que sobrescrevem ponteiros de fun√ß√£o (como `__malloc_hook`) manipulando entradas de fastbin ou tcache s√£o dificultados. Por exemplo, um ataque pode envolver vazar um endere√ßo da LibC, liberar um chunk no bin tcache e, em seguida, sobrescrever o ponteiro Fd para redirecion√°-lo para `__malloc_hook` para execu√ß√£o de c√≥digo arbitr√°rio. Com a mistura de ponteiros, esses ponteiros devem ser corretamente misturados, **necessitando de um vazamento da heap para manipula√ß√£o precisa**, elevando assim a barreira de explora√ß√£o.
3. **Requisito de Vazamentos da Heap em Locais N√£o-Heap**: Criar um chunk falso em √°reas n√£o-heap (como a pilha, se√ß√£o .bss ou PLT/GOT) agora tamb√©m **requer um vazamento da heap** devido √† necessidade de mistura de ponteiros. Isso estende a complexidade de explorar essas √°reas, semelhante ao requisito de manipular endere√ßos da LibC.
4. **Vazar Endere√ßos da Heap Torna-se Mais Desafiador**: A mistura de ponteiros restringe a utilidade dos ponteiros Fd em fastbin e tcache como fontes para vazamentos de endere√ßos da heap. No entanto, ponteiros em bins n√£o ordenados, pequenos e grandes permanecem n√£o misturados, portanto ainda utiliz√°veis para vazar endere√ßos. Essa mudan√ßa empurra os atacantes a explorar esses bins em busca de informa√ß√µes explor√°veis, embora algumas t√©cnicas ainda possam permitir a desmistifica√ß√£o de ponteiros antes de um vazamento, embora com restri√ß√µes.

### **Desmistificando Ponteiros com um Vazamento da Heap**

{% hint style="danger" %}
Para uma melhor explica√ß√£o do processo [**verifique o post original aqui**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Vis√£o Geral do Algoritmo

A f√≥rmula usada para misturar e desmistificar ponteiros √©:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Onde **L** √© a localiza√ß√£o de armazenamento e **P** √© o ponteiro Fd. Quando **L** √© deslocado para a direita por 12 bits, exp√µe os bits mais significativos de **P**, devido √† natureza do **XOR**, que produz 0 quando os bits s√£o XORados consigo mesmos.

**Passos Chave no Algoritmo:**

1. **Vazamento Inicial dos Bits Mais Significativos**: Ao XORar o **L** deslocado com **P**, voc√™ efetivamente obt√©m os 12 bits superiores de **P** porque a parte deslocada de **L** ser√° zero, deixando os bits correspondentes de **P** inalterados.
2. **Recupera√ß√£o dos Bits do Ponteiro**: Como o XOR √© revers√≠vel, conhecer o resultado e um dos operandos permite que voc√™ calcule o outro operando. Essa propriedade √© usada para deduzir todo o conjunto de bits para **P** ao XORar sucessivamente conjuntos conhecidos de bits com partes do ponteiro misturado.
3. **Desmistifica√ß√£o Iterativa**: O processo √© repetido, cada vez usando os novos bits descobertos de **P** do passo anterior para decodificar o pr√≥ximo segmento do ponteiro misturado, at√© que todos os bits sejam recuperados.
4. **Tratamento de Bits Determin√≠sticos**: Os √∫ltimos 12 bits de **L** s√£o perdidos devido ao deslocamento, mas s√£o determin√≠sticos e podem ser reconstru√≠dos ap√≥s o processo.

Voc√™ pode encontrar uma implementa√ß√£o deste algoritmo aqui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Guarda de Ponteiro

A guarda de ponteiro √© uma t√©cnica de mitiga√ß√£o de explora√ß√£o usada no glibc para proteger ponteiros de fun√ß√£o armazenados, particularmente aqueles registrados por chamadas de biblioteca como `atexit()`. Essa prote√ß√£o envolve embaralhar os ponteiros XORando-os com um segredo armazenado nos dados da thread (`fs:0x30`) e aplicando uma rota√ß√£o bit a bit. Esse mecanismo visa impedir que atacantes sequestram o fluxo de controle sobrescrevendo ponteiros de fun√ß√£o.

### **Contornando a Guarda de Ponteiro com um vazamento**

1. **Entendendo as Opera√ß√µes da Guarda de Ponteiro:** O embaralhamento (mistura) de ponteiros √© feito usando o macro `PTR_MANGLE`, que XORa o ponteiro com um segredo de 64 bits e, em seguida, realiza uma rota√ß√£o √† esquerda de 0x11 bits. A opera√ß√£o reversa para recuperar o ponteiro original √© tratada por `PTR_DEMANGLE`.
2. **Estrat√©gia de Ataque:** O ataque √© baseado em uma abordagem de texto conhecido, onde o atacante precisa conhecer tanto a vers√£o original quanto a misturada de um ponteiro para deduzir o segredo usado para a mistura.
3. **Explorando Textos Conhecidos:**
* **Identificando Ponteiros de Fun√ß√£o Fixos:** Ao examinar o c√≥digo-fonte do glibc ou tabelas de ponteiros de fun√ß√£o inicializadas (como `__libc_pthread_functions`), um atacante pode encontrar ponteiros de fun√ß√£o previs√≠veis.
* **Calculando o Segredo:** Usando um ponteiro de fun√ß√£o conhecido, como `__pthread_attr_destroy`, e sua vers√£o misturada da tabela de ponteiros de fun√ß√£o, o segredo pode ser calculado girando para tr√°s (rota√ß√£o √† direita) o ponteiro misturado e, em seguida, XORando-o com o endere√ßo da fun√ß√£o.
4. **Textos Alternativos:** O atacante tamb√©m pode experimentar misturar ponteiros com valores conhecidos, como 0 ou -1, para ver se esses produzem padr√µes identific√°veis na mem√≥ria, potencialmente revelando o segredo quando esses padr√µes s√£o encontrados em dumps de mem√≥ria.
5. **Aplica√ß√£o Pr√°tica:** Ap√≥s calcular o segredo, um atacante pode manipular ponteiros de maneira controlada, essencialmente contornando a prote√ß√£o da Guarda de Ponteiro em uma aplica√ß√£o multithreaded com conhecimento do endere√ßo base da libc e a capacidade de ler locais de mem√≥ria arbitr√°rios.

## Refer√™ncias

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
