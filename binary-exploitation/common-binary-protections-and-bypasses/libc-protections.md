# Zaštita libc biblioteke

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Pomozite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Prinuda poravnanja delova

**Malloc** dodeljuje memoriju u grupama od **8 bajtova (32-bitni) ili 16 bajtova (64-bitni)**. To znači da bi kraj delova u 32-bitnim sistemima trebalo da se poravna sa **0x8**, a u 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki deo **pravilno poravna** na ovim specifičnim lokacijama pre korišćenja pokazivača iz binova.

### Bezbednosne prednosti

Prinuda poravnanja delova u 64-bitnim sistemima značajno poboljšava sigurnost Malloc-a tako što **ograničava postavljanje lažnih delova na samo 1 od svakih 16 adresa**. Ovo otežava napore za eksploataciju, posebno u scenarijima gde korisnik ima ograničenu kontrolu nad ulaznim vrednostima, čineći napade složenijim i težim za uspešno izvršavanje.

* **Napad na Fastbin na \_\_malloc\_hook**

Nove pravila poravnanja u Malloc-u takođe sprečavaju klasičan napad koji uključuje `__malloc_hook`. Ranije, napadači su mogli manipulisati veličinom delova da bi **prepisali ovaj pokazivač funkcije** i stekli **izvršavanje koda**. Sada, stroga zahtevnost poravnanja osigurava da takve manipulacije više nisu izvodljive, zatvarajući uobičajenu rutu eksploatacije i poboljšavajući ukupnu sigurnost.

## Mutilacija pokazivača na fastbinovima i tcache-u

**Mutilacija pokazivača** je sigurnosno unapređenje koje se koristi za zaštitu **fastbin i tcache Fd pokazivača** u operacijama upravljanja memorijom. Ova tehnika pomaže u sprečavanju određenih vrsta taktika eksploatacije memorije, posebno onih koje ne zahtevaju procurele informacije o memoriji ili koje direktno manipulišu lokacijama memorije relativno u odnosu na poznate pozicije (relativni **prepisivanja**).

Srž ove tehnike je obfuscaciona formula:

**`Novi_Ptr = (L >> 12) XOR P`**

* **L** je **Lokacija skladištenja** pokazivača.
* **P** je stvarni **fastbin/tcache Fd Pokazivač**.

Razlog bitnog pomeranja lokacije skladištenja (L) za 12 bitova udesno pre XOR operacije je ključan. Ova manipulacija adresira ranjivost inherentnu u determinističkoj prirodi najmanje značajnih 12 bitova adresa memorije, koji su obično predvidljivi zbog ograničenja arhitekture sistema. Pomeranjem bitova, predvidljivi deo se izbacuje iz jednačine, poboljšavajući nasumičnost novog, mutiliranog pokazivača i time štiteći se od eksploatacija koje se oslanjaju na predvidljivost ovih bitova.

Ovaj mutilirani pokazivač koristi postojeću nasumičnost koju pruža **Randomizacija rasporeda adresnog prostora (ASLR)**, koja nasumično raspoređuje adrese koje koriste programi kako bi otežala napadačima da predvide raspored memorije procesa.

**Demutilacija** pokazivača radi povratka originalne adrese uključuje korišćenje iste XOR operacije. Ovde se mutilirani pokazivač tretira kao P u formuli, i kada se XOR-uje sa nepromenjenom lokacijom skladištenja (L), rezultira otkrivanjem originalnog pokazivača. Ova simetrija u mutilaciji i demutilaciji osigurava da sistem može efikasno enkodirati i dekodirati pokazivače bez značajnog opterećenja, dok značajno povećava sigurnost protiv napada koji manipulišu pokazivačima memorije.

### Bezbednosne prednosti

Mutilacija pokazivača ima za cilj da **spreči delimična i potpuna prepisivanja pokazivača u heap** upravljanju, što je značajno unapređenje u sigurnosti. Ova funkcija utiče na tehnike eksploatacije na nekoliko načina:

1. **Sprečavanje relativnih prepisivanja bajtova**: Ranije, napadači su mogli promeniti deo pokazivača da bi **preusmerili delove heap-a na različite lokacije bez poznavanja tačnih adresa**, tehnika vidljiva u eksploataciji bez procurele informacije **House of Roman**. Sa mutilacijom pokazivača, takva relativna prepisivanja **bez procurele heap-a sada zahtevaju grubu silu**, značajno smanjujući verovatnoću uspeha.
2. **Povećana težina napada na Tcache Bin/Fastbin**: Uobičajeni napadi koji prepisuju pokazivače funkcija (poput `__malloc_hook`) manipulacijom unosa fastbin-a ili tcache-a su otežani. Na primer, napad može uključivati procurelu LibC adrese, oslobađanje dela u tcache bin, a zatim prepisivanje Fd pokazivača da bi ga preusmerili na `__malloc_hook` za izvršavanje proizvoljnog koda. Sa mutilacijom pokazivača, ovi pokazivači moraju biti pravilno mutilirani, **zahtevajući procurelu heap-a za tačnu manipulaciju**, time podižući barijeru eksploatacije.
3. **Potreba za procurelom heap-a na ne-heap lokacijama**: Kreiranje lažnog dela na lokacijama van heap-a (kao što su stek, .bss sekcija ili PLT/GOT) sada takođe **zahteva procurelu heap-a** zbog potrebe za mutilacijom pokazivača. Ovo proširuje složenost eksploatisanja ovih oblasti, slično zahtevu za manipulacijom LibC adresa.
4. **Procurela adresa heap-a postaje izazovnija**: Mutilacija pokazivača ograničava korisnost Fd pokazivača u fastbin i tcache binovima kao izvora procurelih adresa heap-a. Međutim, pokazivači u nesortiranim, malim i velikim binovima ostaju nemutilirani, i dalje korisni za procure adresa. Ova promena tera napadače da istraže ove binove za iskoristive informacije, iako neke tehnike još uvek mogu omogućiti demutilaciju pokazivača pre procure, iako uz ograničenja.

### **Demutilacija pokazivača sa procurelom heap-a**

{% hint style="danger" %}
Za bolje objašnjenje procesa [**proverite originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Pregled algoritma

Formula korišćena za mutilaciju i demutilaciju pokazivača je:&#x20;

**`Novi_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladištenja, a **P** je Fd pokazivač. Kada se **L** pomeri udesno za 12 bitova, otkriva najznačajnije bitove **P**, zbog prirode **XOR**, koji daje 0 kada se bitovi XOR-uju sa samim sobom.

**Ključni koraci u algoritmu:**

1. **Početna procurela najznačajnijih bitova**: XOR-ovanjem pomerene **L** sa **P**, efikasno dobijate gornjih 12 bitova **P** jer će pomerena deo **L** biti nula, ostavljajući odgovarajuće bitove **P** nepromenjene.
2. **Obnova bitova pokazivača**: Pošto je XOR reverzibilan, znajući rezultat i jedan od operanada vam omogućava da izračunate drugi operand. Ova osobina se koristi za zaključivanje celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih setova bitova sa delovima mutiliranog pokazivača.
3. **Iterativna demutilacija**: Proces se ponavlja, svaki put koristeći novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje sledećeg segmenta mutiliranog pokazivača, dok se ne oporave svi bitovi.
4. **Rukovanje determinističkim bitovima**: Poslednjih 12 bitova **L** su izgubljeni zbog pomeranja, ali su deterministički i mogu se rekonstruisati nakon procesa.

Implementaciju ovog algoritma možete pronaći ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Zaštita pokazivača

Zaštita pokazivača je tehnika mitigacije eksploatacije korišćena u glibc-u kako bi se zaštitili uskladišteni pokazivači funkcija, posebno oni registrovani pozivima biblioteke poput `atexit()`. Ova zaštita uključuje mešanje pokazivača XOR-ovanjem sa tajnom uskladištenom u podacima niti (`fs:0x30`) i primenom bitovske rotacije. Ovaj mehanizam ima za cilj da spreči napadače da preuzmu kontrolu toka izvršavanja preko prepisivanja pokazivača funkcija.

### **Bajpasovanje zaštite pokazivača pomoću procurivanja**

1. **Razumevanje operacija zaštite pokazivača:** Mešanje pokazivača se vrši korišćenjem makroa `PTR_MANGLE` koji XOR-uje pokazivač sa 64-bitnom tajnom, a zatim vrši levu rotaciju za 0x11 bitova. Obrnuta operacija za vraćanje originalnog pokazivača se obavlja pomoću `PTR_DEMANGLE`.
2. **Strategija napada:** Napad se zasniva na pristupu poznatog teksta, gde napadač mora znati kako originalnu, tako i izmenjenu verziju pokazivača kako bi zaključio tajnu korištenu za mešanje.
3. **Eksploatisanje poznatih tekstova:**
* **Identifikacija fiksnih pokazivača funkcija:** Proučavanjem izvornog koda glibc-a ili inicijalizovanih tabela pokazivača funkcija (kao što su `__libc_pthread_functions`), napadač može pronaći predvidljive pokazivače funkcija.
* **Računanje tajne:** Korišćenjem poznatog pokazivača funkcije poput `__pthread_attr_destroy` i njegove izmenjene verzije iz tabele pokazivača funkcija, tajna se može izračunati obrnutim rotiranjem (desna rotacija) izmenjenog pokazivača, a zatim XOR-ovanjem sa adresom funkcije.
4. **Alternativni poznati tekstovi:** Napadač takođe može eksperimentisati sa mešanjem pokazivača sa poznatim vrednostima poput 0 ili -1 kako bi video da li ove vrednosti proizvode prepoznatljive obrasce u memoriji, potencijalno otkrivajući tajnu kada se ovi obrasci pronađu u isecima memorije.
5. **Praktična primena:** Nakon što se izračuna tajna, napadač može manipulisati pokazivačima na kontrolisan način, suštinski zaobilazeći zaštitu pokazivača u višenitnoj aplikaciji sa znanjem o baznoj adresi libc-a i sposobnošću čitanja proizvoljnih lokacija memorije.

## Reference

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
