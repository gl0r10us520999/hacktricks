# Protections Libc

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team GCP (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supportez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Application de l'Alignement des Chunks

**Malloc** alloue de la m√©moire en **groupes de 8 octets (32 bits) ou 16 octets (64 bits)**. Cela signifie que la fin des chunks dans les syst√®mes 32 bits doit s'aligner avec **0x8**, et dans les syst√®mes 64 bits avec **0x0**. La fonctionnalit√© de s√©curit√© v√©rifie que chaque chunk **s'aligne correctement** √† ces emplacements sp√©cifiques avant d'utiliser un pointeur d'un bin.

### Avantages S√©curitaires

L'application de l'alignement des chunks dans les syst√®mes 64 bits am√©liore consid√©rablement la s√©curit√© de Malloc en **limitant le placement de faux chunks √† seulement 1 sur 16 adresses**. Cela complique les efforts d'exploitation, en particulier dans les sc√©narios o√π l'utilisateur a un contr√¥le limit√© sur les valeurs d'entr√©e, rendant les attaques plus complexes et plus difficiles √† ex√©cuter avec succ√®s.

* **Attaque Fastbin sur \_\_malloc\_hook**

Les nouvelles r√®gles d'alignement dans Malloc contrecarrent √©galement une attaque classique impliquant le `__malloc_hook`. Auparavant, les attaquants pouvaient manipuler les tailles de chunks pour **√©craser ce pointeur de fonction** et obtenir **l'ex√©cution de code**. Maintenant, l'exigence stricte d'alignement garantit que de telles manipulations ne sont plus viables, fermant une voie d'exploitation courante et am√©liorant la s√©curit√© globale.

## Mangling de Pointeur sur fastbins et tcache

**Mangling de Pointeur** est une am√©lioration de s√©curit√© utilis√©e pour prot√©ger les **pointeurs Fd de fastbin et tcache** dans les op√©rations de gestion de m√©moire. Cette technique aide √† pr√©venir certains types de tactiques d'exploitation de m√©moire, sp√©cifiquement celles qui ne n√©cessitent pas d'informations de m√©moire divulgu√©es ou qui manipulent directement les emplacements de m√©moire par rapport √† des positions connues (√©critures **relatives**).

Le c≈ìur de cette technique est une formule d'obfuscation :

**`New_Ptr = (L >> 12) XOR P`**

* **L** est la **Localisation de Stockage** du pointeur.
* **P** est le **pointeur Fd fastbin/tcache** r√©el.

La raison du d√©calage binaire de la localisation de stockage (L) de 12 bits vers la droite avant l'op√©ration XOR est critique. Cette manipulation traite une vuln√©rabilit√© inh√©rente √† la nature d√©terministe des 12 bits de poids faible des adresses m√©moire, qui sont g√©n√©ralement pr√©visibles en raison des contraintes d'architecture syst√®me. En d√©calant les bits, la portion pr√©visible est d√©plac√©e hors de l'√©quation, am√©liorant l'al√©atoire du nouveau pointeur mangl√© et prot√©geant ainsi contre les exploits qui s'appuient sur la pr√©visibilit√© de ces bits.

Ce pointeur mangl√© tire parti de l'al√©atoire existant fourni par **Address Space Layout Randomization (ASLR)**, qui randomise les adresses utilis√©es par les programmes pour rendre difficile pour les attaquants de pr√©dire la disposition m√©moire d'un processus.

**D√©mangling** du pointeur pour r√©cup√©rer l'adresse originale implique d'utiliser la m√™me op√©ration XOR. Ici, le pointeur mangl√© est trait√© comme P dans la formule, et lorsqu'il est XOR√© avec la localisation de stockage inchang√©e (L), cela r√©v√®le le pointeur original. Cette sym√©trie dans le mangling et le d√©mangling garantit que le syst√®me peut encoder et d√©coder efficacement les pointeurs sans surcharge significative, tout en augmentant consid√©rablement la s√©curit√© contre les attaques qui manipulent les pointeurs de m√©moire.

### Avantages S√©curitaires

Le mangling de pointeur vise √† **pr√©venir les √©crasements partiels et complets de pointeur dans la gestion de heap**, une am√©lioration significative de la s√©curit√©. Cette fonctionnalit√© impacte les techniques d'exploitation de plusieurs mani√®res :

1. **Pr√©vention des √âcritures Relatives par Octet** : Auparavant, les attaquants pouvaient changer une partie d'un pointeur pour **rediriger les chunks de heap vers diff√©rents emplacements sans conna√Ætre les adresses exactes**, une technique √©vidente dans l'exploitation sans fuite **House of Roman**. Avec le mangling de pointeur, de telles √©critures relatives **sans fuite de heap n√©cessitent maintenant un bruteforce**, r√©duisant consid√©rablement leur probabilit√© de succ√®s.
2. **Difficult√© Accrue des Attaques Tcache Bin/Fastbin** : Les attaques courantes qui √©crasent les pointeurs de fonction (comme `__malloc_hook`) en manipulant les entr√©es fastbin ou tcache sont entrav√©es. Par exemple, une attaque pourrait impliquer de divulguer une adresse LibC, de lib√©rer un chunk dans le bin tcache, puis d'√©craser le pointeur Fd pour le rediriger vers `__malloc_hook` pour une ex√©cution de code arbitraire. Avec le mangling de pointeur, ces pointeurs doivent √™tre correctement mangl√©s, **n√©cessitant une fuite de heap pour une manipulation pr√©cise**, augmentant ainsi la barri√®re d'exploitation.
3. **Exigence de Fuites de Heap dans des Emplacements Non-Heap** : Cr√©er un faux chunk dans des zones non-heap (comme la pile, la section .bss, ou PLT/GOT) n√©cessite √©galement **une fuite de heap** en raison de la n√©cessit√© de mangling de pointeur. Cela √©tend la complexit√© d'exploitation de ces zones, similaire √† l'exigence de manipulation des adresses LibC.
4. **Les Fuites d'Adresses de Heap Devenant Plus Difficiles** : Le mangling de pointeur restreint l'utilit√© des pointeurs Fd dans les bins fastbin et tcache comme sources de fuites d'adresses de heap. Cependant, les pointeurs dans les bins non tri√©s, petits et grands restent non mangl√©s, donc toujours utilisables pour des fuites d'adresses. Ce changement pousse les attaquants √† explorer ces bins pour des informations exploitables, bien que certaines techniques puissent encore permettre de d√©mangler les pointeurs avant une fuite, bien que sous contraintes.

### **D√©mangling des Pointeurs avec une Fuite de Heap**

{% hint style="danger" %}
Pour une meilleure explication du processus [**consultez le post original ici**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Aper√ßu de l'Algorithme

La formule utilis√©e pour le mangling et le d√©mangling des pointeurs est :&#x20;

**`New_Ptr = (L >> 12) XOR P`**

O√π **L** est la localisation de stockage et **P** est le pointeur Fd. Lorsque **L** est d√©cal√© vers la droite de 12 bits, il expose les bits les plus significatifs de **P**, en raison de la nature de **XOR**, qui produit 0 lorsque les bits sont XOR√©s avec eux-m√™mes.

**√âtapes Cl√©s de l'Algorithme :**

1. **Fuite Initiale des Bits les Plus Significatifs** : En XORant le **L** d√©cal√© avec **P**, vous obtenez effectivement les 12 bits sup√©rieurs de **P** car la portion d√©cal√©e de **L** sera z√©ro, laissant les bits correspondants de **P** inchang√©s.
2. **R√©cup√©ration des Bits de Pointeur** : Puisque XOR est r√©versible, conna√Ætre le r√©sultat et l'un des op√©randes vous permet de calculer l'autre op√©rande. Cette propri√©t√© est utilis√©e pour d√©duire l'ensemble des bits pour **P** en XORant successivement des ensembles de bits connus avec des parties du pointeur mangl√©.
3. **D√©mangling It√©ratif** : Le processus est r√©p√©t√©, chaque fois en utilisant les nouveaux bits d√©couverts de **P** de l'√©tape pr√©c√©dente pour d√©coder le segment suivant du pointeur mangl√©, jusqu'√† ce que tous les bits soient r√©cup√©r√©s.
4. **Gestion des Bits D√©terministes** : Les 12 derniers bits de **L** sont perdus en raison du d√©calage, mais ils sont d√©terministes et peuvent √™tre reconstruits apr√®s le processus.

Vous pouvez trouver une impl√©mentation de cet algorithme ici : [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Protection de Pointeur

La protection de pointeur est une technique d'att√©nuation des exploits utilis√©e dans glibc pour prot√©ger les pointeurs de fonction stock√©s, en particulier ceux enregistr√©s par des appels de biblioth√®que tels que `atexit()`. Cette protection implique de brouiller les pointeurs en les XORant avec un secret stock√© dans les donn√©es de thread (`fs:0x30`) et en appliquant une rotation binaire. Ce m√©canisme vise √† emp√™cher les attaquants de d√©tourner le flux de contr√¥le en √©crasant les pointeurs de fonction.

### **Contournement de la Protection de Pointeur avec une fuite**

1. **Comprendre les Op√©rations de Protection de Pointeur :** Le brouillage (mangling) des pointeurs est effectu√© √† l'aide de la macro `PTR_MANGLE` qui XOR le pointeur avec un secret de 64 bits et effectue ensuite une rotation √† gauche de 0x11 bits. L'op√©ration inverse pour r√©cup√©rer le pointeur original est g√©r√©e par `PTR_DEMANGLE`.
2. **Strat√©gie d'Attaque :** L'attaque est bas√©e sur une approche de texte clair connu, o√π l'attaquant doit conna√Ætre √† la fois les versions originales et mangl√©es d'un pointeur pour d√©duire le secret utilis√© pour le mangling.
3. **Exploitation des Textes Clairs Connus :**
* **Identification des Pointeurs de Fonction Fixes :** En examinant le code source de glibc ou les tables de pointeurs de fonction initialis√©es (comme `__libc_pthread_functions`), un attaquant peut trouver des pointeurs de fonction pr√©visibles.
* **Calcul du Secret :** En utilisant un pointeur de fonction connu tel que `__pthread_attr_destroy` et sa version mangl√©e de la table de pointeurs de fonction, le secret peut √™tre calcul√© en faisant une rotation inverse (rotation √† droite) du pointeur mangl√©, puis en le XORant avec l'adresse de la fonction.
4. **Textes Clairs Alternatifs :** L'attaquant peut √©galement exp√©rimenter avec le mangling de pointeurs avec des valeurs connues comme 0 ou -1 pour voir si cela produit des motifs identifiables en m√©moire, r√©v√©lant potentiellement le secret lorsque ces motifs sont trouv√©s dans des dumps m√©moire.
5. **Application Pratique :** Apr√®s avoir calcul√© le secret, un attaquant peut manipuler les pointeurs de mani√®re contr√¥l√©e, contournant essentiellement la protection de la Protection de Pointeur dans une application multithread√©e avec connaissance de l'adresse de base de libc et la capacit√© de lire des emplacements m√©moire arbitraires.

## R√©f√©rences

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team GCP (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supportez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
