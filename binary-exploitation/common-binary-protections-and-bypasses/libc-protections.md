# Protezioni Libc

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}

## Applicazione della Forzatura di Allineamento dei Chunk

**Malloc** alloca memoria in **raggruppamenti di 8 byte (32-bit) o 16 byte (64-bit)**. Ci√≤ significa che la fine dei chunk nei sistemi a 32 bit dovrebbe allinearsi con **0x8**, e nei sistemi a 64 bit con **0x0**. La funzionalit√† di sicurezza verifica che ogni chunk **sia allineato correttamente** in queste posizioni specifiche prima di utilizzare un puntatore da un bin.

### Vantaggi di Sicurezza

L'applicazione dell'allineamento dei chunk nei sistemi a 64 bit migliora significativamente la sicurezza di Malloc **limitando il posizionamento di chunk falsi a solo 1 su ogni 16 indirizzi**. Questo complica gli sforzi di sfruttamento, specialmente in scenari in cui l'utente ha un controllo limitato sui valori di input, rendendo gli attacchi pi√π complessi e difficili da eseguire con successo.

* **Attacco Fastbin su \_\_malloc\_hook**

Le nuove regole di allineamento in Malloc ostacolano anche un attacco classico che coinvolge il `__malloc_hook`. In precedenza, gli attaccanti potevano manipolare le dimensioni dei chunk per **sovrascrivere questo puntatore di funzione** e ottenere **esecuzione di codice**. Ora, il rigoroso requisito di allineamento assicura che tali manipolazioni non siano pi√π praticabili, chiudendo una comune via di sfruttamento e migliorando la sicurezza complessiva.

## Offuscamento dei Puntatori su fastbins e tcache

**Offuscamento dei Puntatori** √® un miglioramento della sicurezza utilizzato per proteggere i **puntatori Fd di fastbin e tcache** nelle operazioni di gestione della memoria. Questa tecnica aiuta a prevenire determinati tipi di tattiche di sfruttamento della memoria, specificamente quelle che non richiedono informazioni di memoria trapelate o che manipolano direttamente le posizioni di memoria relative a posizioni note (sovrascritture **relative**).

Il nucleo di questa tecnica √® una formula di offuscamento:

**`New_Ptr = (L >> 12) XOR P`**

* **L** √® la **Posizione di Memorizzazione** del puntatore.
* **P** √® il reale **Puntatore Fd di fastbin/tcache**.

Il motivo per cui lo spostamento bit a bit della posizione di memorizzazione (L) di 12 bit a destra prima dell'operazione XOR √® critico. Questa manipolazione affronta una vulnerabilit√† intrinseca nella natura deterministica dei 12 bit meno significativi degli indirizzi di memoria, che sono tipicamente prevedibili a causa delle limitazioni dell'architettura di sistema. Spostando i bit, la porzione prevedibile viene rimossa dall'equazione, aumentando la casualit√† del nuovo puntatore offuscato e quindi proteggendo contro gli exploit che si basano sulla prevedibilit√† di questi bit.

Questo puntatore offuscato sfrutta la casualit√† esistente fornita dalla **Randomizzazione del Layout dello Spazio degli Indirizzi (ASLR)**, che randomizza gli indirizzi utilizzati dai programmi per rendere difficile per gli attaccanti prevedere il layout di memoria di un processo.

**Demangling** del puntatore per recuperare l'indirizzo originale comporta l'uso della stessa operazione XOR. Qui, il puntatore offuscato √® trattato come P nella formula, e quando viene XORato con la posizione di memorizzazione invariata (L), si rivela il puntatore originale. Questa simmetria nell'offuscamento e nel demangling assicura che il sistema possa codificare e decodificare i puntatori in modo efficiente senza un sovraccarico significativo, aumentando sostanzialmente la sicurezza contro gli attacchi che manipolano i puntatori di memoria.

### Vantaggi di Sicurezza

L'offuscamento dei puntatori mira a **prevenire sovrascritture parziali e complete dei puntatori nella heap**, un significativo miglioramento della sicurezza. Questa funzionalit√† impatta le tecniche di sfruttamento in diversi modi:

1. **Prevenzione delle Sovrascritture Relative Byte per Byte**: In precedenza, gli attaccanti potevano cambiare parte di un puntatore per **reindirizzare i chunk della heap a diverse posizioni senza conoscere indirizzi esatti**, una tecnica evidente nell'exploit senza leak **House of Roman**. Con l'offuscamento dei puntatori, tali sovrascritture relative **senza un leak della heap ora richiedono brute forcing**, riducendo drasticamente la loro probabilit√† di successo.
2. **Aumento della Difficolt√† degli Attacchi Tcache Bin/Fastbin**: Gli attacchi comuni che sovrascrivono puntatori di funzione (come `__malloc_hook`) manipolando le voci di fastbin o tcache sono ostacolati. Ad esempio, un attacco potrebbe comportare il leak di un indirizzo LibC, liberando un chunk nel bin tcache, e poi sovrascrivendo il puntatore Fd per reindirizzarlo a `__malloc_hook` per l'esecuzione di codice arbitrario. Con l'offuscamento dei puntatori, questi puntatori devono essere correttamente offuscati, **richiedendo un leak della heap per una manipolazione accurata**, elevando cos√¨ la barriera di sfruttamento.
3. **Requisito di Leak della Heap in Posizioni Non Heap**: Creare un chunk falso in aree non heap (come lo stack, la sezione .bss, o PLT/GOT) ora richiede anche **un leak della heap** a causa della necessit√† di offuscamento dei puntatori. Questo estende la complessit√† di sfruttare queste aree, simile al requisito di manipolare indirizzi LibC.
4. **Il Leak degli Indirizzi della Heap Diventa Pi√π Difficile**: L'offuscamento dei puntatori limita l'utilit√† dei puntatori Fd nei fastbin e tcache come fonti per leak di indirizzi della heap. Tuttavia, i puntatori in bin non ordinati, piccoli e grandi rimangono non offuscati, quindi ancora utilizzabili per leak di indirizzi. Questo cambiamento spinge gli attaccanti a esplorare questi bin per informazioni sfruttabili, sebbene alcune tecniche possano ancora consentire il demangling dei puntatori prima di un leak, sebbene con vincoli.

### **Demangling dei Puntatori con un Leak della Heap**

{% hint style="danger" %}
Per una spiegazione migliore del processo [**controlla il post originale da qui**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Panoramica dell'Algoritmo

La formula utilizzata per offuscare e demanglare i puntatori √®:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Dove **L** √® la posizione di memorizzazione e **P** √® il puntatore Fd. Quando **L** viene spostato a destra di 12 bit, espone i bit pi√π significativi di **P**, a causa della natura dell'**XOR**, che restituisce 0 quando i bit sono XORati con se stessi.

**Passaggi Chiave nell'Algoritmo:**

1. **Leak Iniziale dei Bit Pi√π Significativi**: XORando il **L** spostato con **P**, si ottiene efficacemente i 12 bit superiori di **P** perch√© la porzione spostata di **L** sar√† zero, lasciando i bit corrispondenti di **P** invariati.
2. **Recupero dei Bit del Puntatore**: Poich√© l'XOR √® reversibile, conoscere il risultato e uno degli operandi consente di calcolare l'altro operando. Questa propriet√† viene utilizzata per dedurre l'intero insieme di bit per **P** XORando successivamente insiemi noti di bit con parti del puntatore offuscato.
3. **Demangling Iterativo**: Il processo viene ripetuto, ogni volta utilizzando i nuovi bit scoperti di **P** dal passaggio precedente per decodificare il segmento successivo del puntatore offuscato, fino a quando tutti i bit non sono recuperati.
4. **Gestione dei Bit Deterministici**: Gli ultimi 12 bit di **L** vengono persi a causa dello spostamento, ma sono deterministici e possono essere ricostruiti dopo il processo.

Puoi trovare un'implementazione di questo algoritmo qui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Protezione dei Puntatori

La protezione dei puntatori √® una tecnica di mitigazione degli exploit utilizzata in glibc per proteggere i puntatori di funzione memorizzati, in particolare quelli registrati da chiamate di libreria come `atexit()`. Questa protezione comporta la scrambatura dei puntatori XORandoli con un segreto memorizzato nei dati del thread (`fs:0x30`) e applicando una rotazione bit a bit. Questo meccanismo mira a prevenire che gli attaccanti dirottino il flusso di controllo sovrascrivendo i puntatori di funzione.

### **Superare la Protezione dei Puntatori con un leak**

1. **Comprendere le Operazioni della Protezione dei Puntatori:** La scrambatura (offuscamento) dei puntatori viene effettuata utilizzando il macro `PTR_MANGLE` che XORa il puntatore con un segreto a 64 bit e poi esegue una rotazione a sinistra di 0x11 bit. L'operazione inversa per recuperare il puntatore originale √® gestita da `PTR_DEMANGLE`.
2. **Strategia di Attacco:** L'attacco si basa su un approccio a testo in chiaro noto, in cui l'attaccante deve conoscere sia la versione originale che quella offuscata di un puntatore per dedurre il segreto utilizzato per l'offuscamento.
3. **Sfruttare i Testi in Chiaro Noti:**
* **Identificazione dei Puntatori di Funzione Fissi:** Esaminando il codice sorgente di glibc o le tabelle di puntatori di funzione inizializzati (come `__libc_pthread_functions`), un attaccante pu√≤ trovare puntatori di funzione prevedibili.
* **Calcolo del Segreto:** Utilizzando un puntatore di funzione noto come `__pthread_attr_destroy` e la sua versione offuscata dalla tabella dei puntatori di funzione, il segreto pu√≤ essere calcolato ruotando all'indietro (rotazione a destra) il puntatore offuscato e poi XORandolo con l'indirizzo della funzione.
4. **Testi in Chiaro Alternativi:** L'attaccante pu√≤ anche sperimentare con l'offuscamento dei puntatori con valori noti come 0 o -1 per vedere se questi producono schemi identificabili in memoria, rivelando potenzialmente il segreto quando questi schemi vengono trovati nei dump di memoria.
5. **Applicazione Pratica:** Dopo aver calcolato il segreto, un attaccante pu√≤ manipolare i puntatori in modo controllato, bypassando essenzialmente la protezione della Protezione dei Puntatori in un'applicazione multithreaded con conoscenza dell'indirizzo base di libc e la capacit√† di leggere posizioni di memoria arbitrarie.

## Riferimenti

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
