# Libc Beskermings

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Stuk Aligneeringsafdwinging

**Malloc** allokeer geheue in **8-byte (32-bit) of 16-byte (64-bit) groepe**. Dit beteken dat die einde van stukke in 32-bit stelsels met **0x8** moet ooreenstem, en in 64-bit stelsels met **0x0**. Die sekuriteitskenmerk kontroleer dat elke stuk **korrek geallineer** is op hierdie spesifieke plekke voordat 'n wysiger van 'n bin gebruik word.

### Sekuriteitsvoordele

Die afdwinging van stuk aligneering in 64-bit stelsels verbeter Malloc se sekuriteit aansienlik deur **die plasing van vals stukke te beperk tot slegs 1 uit elke 16 adresse**. Dit bemoeilik uitbuitpogings, veral in scenario's waar die gebruiker beperkte beheer oor invoerwaardes het, wat aanvalle meer kompleks en moeiliker maak om suksesvol uit te voer.

* **Fastbin Aanval op \_\_malloc\_hook**

Die nuwe aligneerre√´ls in Malloc keer ook 'n klassieke aanval wat die `__malloc_hook` betrek. Voorheen kon aanvallers stuk groottes manipuleer om **hierdie funksiewysiger te oorskry** en **kode-uitvoering** te verkry. Nou verseker die streng aligneervereiste dat sulke manipulasies nie meer lewensvatbaar is nie, wat 'n algemene uitbuitroete sluit en die algehele sekuriteit verbeter.

## Wysiger Verminking op fastbins en tcache

**Wysiger Verminking** is 'n sekuriteitsverbetering wat gebruik word om **fastbin en tcache Fd wysigers** in geheuebestuur operasies te beskerm. Hierdie tegniek help om sekere tipes geheue-uitbuit taktieke te voorkom, spesifiek di√© wat nie gelekte geheue-inligting vereis nie of wat geheue plekke direk manipuleer relatief tot bekende posisies (relatiewe **oorskrywings**).

Die kern van hierdie tegniek is 'n obfuskeringsformule:

**`New_Ptr = (L >> 12) XOR P`**

* **L** is die **Berging Plek** van die wysiger.
* **P** is die werklike **fastbin/tcache Fd Wysiger**.

Die rede vir die bitgewys verskuiwing van die berging plek (L) met 12 bits na regs voor die XOR operasie is krities. Hierdie manipulasie spreek 'n kwesbaarheid aan wat inherent is aan die deterministiese aard van die minste betekenisvolle 12 bits van geheue adresse, wat tipies voorspelbaar is weens stelsels argitektuur beperkings. Deur die bits te verskuif, word die voorspelbare gedeelte uit die vergelyking verwyder, wat die ewekansigheid van die nuwe, verminkte wysiger verbeter en sodoende beskerming bied teen uitbuit wat op die voorspelbaarheid van hierdie bits staatmaak.

Hierdie verminkte wysiger benut die bestaande ewekansigheid wat deur **Address Space Layout Randomization (ASLR)** verskaf word, wat adresse wat deur programme gebruik word, ewekansig maak om dit moeilik te maak vir aanvallers om die geheue uitleg van 'n proses te voorspel.

**Demangling** van die wysiger om die oorspronklike adres te herwin, behels die gebruik van dieselfde XOR operasie. Hier word die verminkte wysiger as P in die formule behandel, en wanneer dit met die onveranderde berging plek (L) XOR word, lei dit tot die oorspronklike wysiger wat onthul word. Hierdie simmetrie in verminking en demangling verseker dat die stelsel effektief wysigers kan kodeer en dekodeer sonder beduidende oorhoofse koste, terwyl dit aansienlik die sekuriteit teen aanvalle wat geheue wysigers manipuleer, verhoog.

### Sekuriteitsvoordele

Wysiger verminking poog om **gedeeltelike en volle wysiger oorskrywings in heap** bestuur te voorkom, 'n beduidende verbetering in sekuriteit. Hierdie kenmerk be√Ønvloed uitbuit tegnieke op verskeie maniere:

1. **Voorkoming van Bye Byte Relatiewe Oorskrywings**: Voorheen kon aanvallers 'n deel van 'n wysiger verander om **heap stukke na verskillende plekke te herlei sonder om presiese adresse te ken**, 'n tegniek wat in die leakless **House of Roman** uitbuit sigbaar is. Met wysiger verminking, vereis sulke relatiewe oorskrywings **sonder 'n heap leak nou brute forcing**, wat hul waarskynlikheid van sukses drasties verminder.
2. **Verhoogde Moeilikheid van Tcache Bin/Fastbin Aanvalle**: Algemene aanvalle wat funksiewysigers oorskryf (soos `__malloc_hook`) deur fastbin of tcache inskrywings te manipuleer, word belemmer. Byvoorbeeld, 'n aanval kan behels om 'n LibC adres te lek, 'n stuk in die tcache bin vry te stel, en dan die Fd wysiger te oorskryf om dit na `__malloc_hook` te herlei vir arbitr√™re kode-uitvoering. Met wysiger verminking, moet hierdie wysigers korrek vermink wees, **wat 'n heap leak vir akkurate manipulasie vereis**, wat die uitbuit hindernis verhoog.
3. **Vereiste vir Heap Leaks in Nie-Heap Plekke**: Om 'n vals stuk in nie-heap areas (soos die stapel, .bss afdeling, of PLT/GOT) te skep, vereis nou ook **'n heap leak** weens die behoefte aan wysiger verminking. Dit verleng die kompleksiteit van die uitbuit van hierdie areas, soortgelyk aan die vereiste om LibC adresse te manipuleer.
4. **Lek van Heap Adresse Word Meer Uitdagend**: Wysiger verminking beperk die nuttigheid van Fd wysigers in fastbin en tcache bins as bronne vir heap adres lek. Tog bly wysigers in onsorteerde, klein, en groot bins onvervormd, en bly dus steeds bruikbaar vir die lek van adresse. Hierdie skuif dwing aanvallers om hierdie bins te verken vir uitbuitbare inligting, alhoewel sommige tegnieke steeds toelaat dat wysigers gedemangeld word voor 'n lek, hoewel met beperkings.

### **Demangling Wysigers met 'n Heap Leak**

{% hint style="danger" %}
Vir 'n beter verduideliking van die proses [**kyk die oorspronklike pos hier**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algoritme Oorsig

Die formule wat gebruik word vir verminking en demangling van wysigers is:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Waar **L** die berging plek is en **P** die Fd wysiger is. Wanneer **L** met 12 bits na regs verskuif word, blootstel dit die mees betekenisvolle bits van **P**, weens die aard van **XOR**, wat 0 uitset wanneer bits met hulself XOR word.

**Sleutelstappe in die Algoritme:**

1. **Begin Leak van die Mees Betekenisvolle Bits**: Deur die verskoven **L** met **P** te XOR, kry jy effektief die boonste 12 bits van **P** omdat die verskoven gedeelte van **L** nul sal wees, wat **P's** ooreenstemmende bits onveranderd laat.
2. **Herwinning van Wysiger Bits**: Aangesien XOR omkeerbaar is, laat die kennis van die resultaat en een van die operandi jou toe om die ander operand te bereken. Hierdie eienskap word gebruik om die hele stel bits vir **P** af te lei deur bekendgestelde stelle bits met dele van die verminkte wysiger suksesvol te XOR.
3. **Iteratiewe Demangling**: Die proses word herhaal, elke keer die nuut ontdekte bits van **P** van die vorige stap gebruik om die volgende segment van die verminkte wysiger te dekodeer, totdat alle bits herwin is.
4. **Hantering van Deterministiese Bits**: Die finale 12 bits van **L** gaan verlore weens die verskuiwing, maar hulle is deterministies en kan na die proses weer opgebou word.

Jy kan 'n implementering van hierdie algoritme hier vind: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Wysiger Wag

Wysiger wag is 'n uitbuit mitigering tegniek wat in glibc gebruik word om gestoor funksiewysigers te beskerm, veral di√© wat deur biblioteek oproepe soos `atexit()` geregistreer is. Hierdie beskerming behels die verhaspeling van die wysigers deur hulle met 'n geheim wat in die draad data (`fs:0x30`) gestoor is, te XOR en 'n bitgewys rotasie toe te pas. Hierdie meganisme poog om te voorkom dat aanvallers die kontrole vloei oorneem deur funksiewysigers te oorskryf.

### **Om die Wysiger Wag te Bypass met 'n lek**

1. **Begrip van Wysiger Wag Operasies:** Die verhaspeling (verminking) van wysigers word gedoen met die `PTR_MANGLE` makro wat die wysiger met 'n 64-bit geheim XOR en dan 'n linker rotasie van 0x11 bits uitvoer. Die omgekeerde operasie om die oorspronklike wysiger te herwin, word hanteer deur `PTR_DEMANGLE`.
2. **Aanvalstrategie:** Die aanval is gebaseer op 'n bekende-plakstrategie, waar die aanvaller beide die oorspronklike en die verminkte weergawes van 'n wysiger moet ken om die geheim wat vir verminking gebruik is, af te lei.
3. **Uitbuiting van Bekende Plaktekste:**
* **Identifisering van Vaste Funksiewysigers:** Deur die glibc bronkode of ge√Ønitialiseerde funksiewysiger tabelles (soos `__libc_pthread_functions`) te ondersoek, kan 'n aanvaller voorspelbare funksiewysigers vind.
* **Berekening van die Geheim:** Deur 'n bekende funksiewysiger soos `__pthread_attr_destroy` en sy verminkte weergawe uit die funksiewysiger tabel te gebruik, kan die geheim bereken word deur die verminkte wysiger om te draai (regsrotasie) en dit dan met die adres van die funksie te XOR.
4. **Alternatiewe Plaktekste:** Die aanvaller kan ook eksperimenteer met die verminking van wysigers met bekende waardes soos 0 of -1 om te sien of hierdie identifiseerbare patrone in geheue produseer, wat moontlik die geheim onthul wanneer hierdie patrone in geheue dumps gevind word.
5. **Praktiese Toepassing:** Nadat die geheim bereken is, kan 'n aanvaller wysigers op 'n beheerde manier manipuleer, wat in wese die Wysiger Wag beskerming in 'n multithreaded toepassing omseil met kennis van die libc basis adres en 'n vermo√´ om arbitr√™re geheue plekke te lees.

## Verwysings

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
