# Libc-Schutzma√ünahmen

{% hint style="success" %}
Lerne & √ºbe AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Durchsetzung der Chunk-Ausrichtung

**Malloc** allokiert Speicher in **8-Byte (32-Bit) oder 16-Byte (64-Bit) Gruppen**. Das bedeutet, dass das Ende der Chunks in 32-Bit-Systemen mit **0x8** und in 64-Bit-Systemen mit **0x0** ausgerichtet sein sollte. Die Sicherheitsfunktion √ºberpr√ºft, dass jeder Chunk an diesen spezifischen Stellen **korrekt ausgerichtet** ist, bevor ein Zeiger aus einem Bin verwendet wird.

### Sicherheitsvorteile

Die Durchsetzung der Chunk-Ausrichtung in 64-Bit-Systemen verbessert die Sicherheit von Malloc erheblich, indem sie **die Platzierung von gef√§lschten Chunks auf nur 1 von 16 Adressen** beschr√§nkt. Dies erschwert die Ausnutzung, insbesondere in Szenarien, in denen der Benutzer nur begrenzte Kontrolle √ºber Eingabewerte hat, was Angriffe komplexer und schwieriger auszuf√ºhren macht.

* **Fastbin-Angriff auf \_\_malloc\_hook**

Die neuen Ausrichtungsregeln in Malloc vereiteln auch einen klassischen Angriff, der den `__malloc_hook` betrifft. Zuvor konnten Angreifer die Chunk-Gr√∂√üen manipulieren, um **diesen Funktionszeiger zu √ºberschreiben** und **Codeausf√ºhrung** zu erlangen. Jetzt stellt die strenge Ausrichtungsanforderung sicher, dass solche Manipulationen nicht mehr m√∂glich sind, wodurch ein h√§ufiger Ausnutzungsweg geschlossen und die allgemeine Sicherheit erh√∂ht wird.

## Zeigerverwirrung bei Fastbins und Tcache

**Zeigerverwirrung** ist eine Sicherheitsverbesserung, die verwendet wird, um **Fastbin- und Tcache-Fd-Zeiger** in Speicherverwaltungsoperationen zu sch√ºtzen. Diese Technik hilft, bestimmte Arten von Speicher-Ausnutzungs-Taktiken zu verhindern, insbesondere solche, die keine geleakten Speicherinformationen erfordern oder die Speicherorte direkt relativ zu bekannten Positionen manipulieren (relative **√úberschreibungen**).

Der Kern dieser Technik ist eine Obfuskationsformel:

**`New_Ptr = (L >> 12) XOR P`**

* **L** ist der **Speicherort** des Zeigers.
* **P** ist der tats√§chliche **Fastbin/Tcache-Fd-Zeiger**.

Der Grund f√ºr die bitweise Verschiebung des Speicherorts (L) um 12 Bits nach rechts vor der XOR-Operation ist entscheidend. Diese Manipulation adressiert eine Schwachstelle, die in der deterministischen Natur der 12 am wenigsten signifikanten Bits von Speicheradressen liegt, die aufgrund von Einschr√§nkungen der Systemarchitektur typischerweise vorhersehbar sind. Durch das Verschieben der Bits wird der vorhersehbare Teil aus der Gleichung entfernt, was die Zuf√§lligkeit des neuen, verwirrten Zeigers erh√∂ht und somit vor Ausnutzungen sch√ºtzt, die auf der Vorhersehbarkeit dieser Bits basieren.

Dieser verwirrte Zeiger nutzt die vorhandene Zuf√§lligkeit, die durch **Address Space Layout Randomization (ASLR)** bereitgestellt wird, die Adressen randomisiert, die von Programmen verwendet werden, um es Angreifern zu erschweren, das Speicherlayout eines Prozesses vorherzusagen.

**Entwirren** des Zeigers, um die urspr√ºngliche Adresse abzurufen, erfolgt durch die Verwendung derselben XOR-Operation. Hier wird der verwirrte Zeiger als P in der Formel behandelt, und wenn er mit dem unver√§nderten Speicherort (L) XORed wird, wird der urspr√ºngliche Zeiger offenbart. Diese Symmetrie in der Verwirrung und Entwirrung stellt sicher, dass das System Zeiger effizient kodieren und dekodieren kann, ohne signifikante √úberkopfkosten, w√§hrend die Sicherheit gegen Angriffe, die Speicherzeiger manipulieren, erheblich erh√∂ht wird.

### Sicherheitsvorteile

Die Zeigerverwirrung zielt darauf ab, **teilweise und vollst√§ndige Zeiger√ºberschreibungen im Heap**-Management zu verhindern, was eine erhebliche Verbesserung der Sicherheit darstellt. Diese Funktion beeinflusst Ausnutzungstechniken auf verschiedene Weise:

1. **Verhinderung von Byte-zu-Byte-relativen √úberschreibungen**: Zuvor konnten Angreifer einen Teil eines Zeigers √§ndern, um **Heap-Chunks an andere Standorte umzuleiten, ohne die genauen Adressen zu kennen**, eine Technik, die im leakless **House of Roman**-Exploit offensichtlich ist. Mit der Zeigerverwirrung erfordern solche relativen √úberschreibungen **ohne einen Heap-Leak jetzt Brute-Forcing**, was die Wahrscheinlichkeit ihres Erfolgs drastisch verringert.
2. **Erh√∂hte Schwierigkeit von Tcache-Bin/Fastbin-Angriffen**: H√§ufige Angriffe, die Funktionszeiger (wie `__malloc_hook`) durch Manipulation von Fastbin- oder Tcache-Eintr√§gen √ºberschreiben, werden behindert. Zum Beispiel k√∂nnte ein Angriff darin bestehen, eine LibC-Adresse zu leaken, einen Chunk in den Tcache-Bin freizugeben und dann den Fd-Zeiger zu √ºberschreiben, um ihn auf `__malloc_hook` umzuleiten, um beliebigen Code auszuf√ºhren. Mit der Zeigerverwirrung m√ºssen diese Zeiger korrekt verwirrt sein, **was einen Heap-Leak f√ºr eine genaue Manipulation erforderlich macht**, wodurch die Ausnutzungsbarriere erh√∂ht wird.
3. **Anforderung von Heap-Leaks in Nicht-Heap-Standorten**: Das Erstellen eines gef√§lschten Chunks in Nicht-Heap-Bereichen (wie dem Stack, dem .bss-Bereich oder PLT/GOT) erfordert jetzt ebenfalls **einen Heap-Leak** aufgrund der Notwendigkeit der Zeigerverwirrung. Dies erh√∂ht die Komplexit√§t der Ausnutzung dieser Bereiche, √§hnlich wie die Anforderung zur Manipulation von LibC-Adressen.
4. **Leaking von Heap-Adressen wird herausfordernder**: Die Zeigerverwirrung schr√§nkt die N√ºtzlichkeit von Fd-Zeigern in Fastbin- und Tcache-Bins als Quellen f√ºr Heap-Adresse-Leaks ein. Allerdings bleiben Zeiger in unsortierten, kleinen und gro√üen Bins unverwirrt und somit weiterhin nutzbar f√ºr das Leaken von Adressen. Diese Verschiebung zwingt Angreifer dazu, diese Bins nach ausnutzbaren Informationen zu durchsuchen, obwohl einige Techniken m√∂glicherweise immer noch das Entwirren von Zeigern vor einem Leak erm√∂glichen, wenn auch mit Einschr√§nkungen.

### **Entwirren von Zeigern mit einem Heap-Leak**

{% hint style="danger" %}
F√ºr eine bessere Erkl√§rung des Prozesses [**√ºberpr√ºfe den urspr√ºnglichen Beitrag hier**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algorithmus√ºbersicht

Die Formel, die f√ºr das Verwirren und Entwirren von Zeigern verwendet wird, ist:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Wobei **L** der Speicherort und **P** der Fd-Zeiger ist. Wenn **L** um 12 Bits nach rechts verschoben wird, werden die signifikantesten Bits von **P** offengelegt, aufgrund der Natur von **XOR**, das 0 ausgibt, wenn Bits mit sich selbst XORed werden.

**Wichtige Schritte im Algorithmus:**

1. **Erster Leak der signifikantesten Bits**: Durch das XORen des verschobenen **L** mit **P** erh√§lt man effektiv die obersten 12 Bits von **P**, da der verschobene Teil von **L** null sein wird, wodurch die entsprechenden Bits von **P** unver√§ndert bleiben.
2. **Wiederherstellung der Zeigerbits**: Da XOR umkehrbar ist, erm√∂glicht das Wissen um das Ergebnis und einen der Operanden, den anderen Operanden zu berechnen. Diese Eigenschaft wird verwendet, um die gesamte Menge von Bits f√ºr **P** abzuleiten, indem nacheinander bekannte Bitmengen mit Teilen des verwirrten Zeigers XORed werden.
3. **Iteratives Entwirren**: Der Prozess wird wiederholt, wobei jedes Mal die neu entdeckten Bits von **P** aus dem vorherigen Schritt verwendet werden, um das n√§chste Segment des verwirrten Zeigers zu dekodieren, bis alle Bits wiederhergestellt sind.
4. **Umgang mit deterministischen Bits**: Die letzten 12 Bits von **L** gehen aufgrund der Verschiebung verloren, sind jedoch deterministisch und k√∂nnen nachtr√§glich rekonstruiert werden.

Eine Implementierung dieses Algorithmus findest du hier: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Zeigerschutz

Der Zeigerschutz ist eine Technik zur Minderung von Ausnutzungen, die in glibc verwendet wird, um gespeicherte Funktionszeiger zu sch√ºtzen, insbesondere solche, die durch Bibliotheksaufrufe wie `atexit()` registriert werden. Dieser Schutz umfasst das Verwirren der Zeiger, indem sie mit einem geheimen Wert, der in den Thread-Daten (`fs:0x30`) gespeichert ist, XORed und eine bitweise Rotation angewendet wird. Dieser Mechanismus zielt darauf ab, Angreifern zu verhindern, den Kontrollfluss zu √ºbernehmen, indem sie Funktionszeiger √ºberschreiben.

### **Umgehung des Zeigerschutzes mit einem Leak**

1. **Verstehen der Zeigerschutzoperationen:** Das Verwirren (Mangling) der Zeiger erfolgt mit dem `PTR_MANGLE`-Makro, das den Zeiger mit einem 64-Bit-Geheimnis XORed und dann eine linke Rotation von 0x11 Bits durchf√ºhrt. Die Umkehroperation zum Wiederherstellen des urspr√ºnglichen Zeigers wird von `PTR_DEMANGLE` durchgef√ºhrt.
2. **Angriffsstrategie:** Der Angriff basiert auf einem bekannten Klartextansatz, bei dem der Angreifer sowohl die urspr√ºngliche als auch die verwirrte Version eines Zeigers kennen muss, um das Geheimnis zu deduzieren, das f√ºr das Verwirren verwendet wurde.
3. **Ausnutzung bekannter Klartexte:**
* **Identifizierung fester Funktionszeiger:** Durch die Untersuchung des glibc-Quellcodes oder der initialisierten Funktionszeigertabellen (wie `__libc_pthread_functions`) kann ein Angreifer vorhersehbare Funktionszeiger finden.
* **Berechnung des Geheimnisses:** Mit einem bekannten Funktionszeiger wie `__pthread_attr_destroy` und seiner verwirrten Version aus der Funktionszeigertabelle kann das Geheimnis berechnet werden, indem der verwirrte Zeiger r√ºckw√§rts rotiert (Rechtsrotation) und dann mit der Adresse der Funktion XORed wird.
4. **Alternative Klartexte:** Der Angreifer kann auch versuchen, Zeiger mit bekannten Werten wie 0 oder -1 zu verwirren, um zu sehen, ob diese identifizierbare Muster im Speicher erzeugen, die m√∂glicherweise das Geheimnis offenbaren, wenn diese Muster in Speicherausz√ºgen gefunden werden.
5. **Praktische Anwendung:** Nachdem das Geheimnis berechnet wurde, kann ein Angreifer Zeiger auf kontrollierte Weise manipulieren und somit den Zeigerschutz in einer multithreaded Anwendung mit Kenntnis der libc-Basisadresse und der F√§higkeit, beliebige Speicherorte zu lesen, umgehen.

## Referenzen

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{% hint style="success" %}
Lerne & √ºbe AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
