# Protections Libc

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Application de l'alignement des chunks

**Malloc** alloue de la m√©moire par groupes de **8 octets (32 bits) ou 16 octets (64 bits)**. Cela signifie que la fin des chunks dans les syst√®mes 32 bits doit s'aligner sur **0x8**, et dans les syst√®mes 64 bits sur **0x0**. La fonctionnalit√© de s√©curit√© v√©rifie que chaque chunk s'aligne correctement √† ces emplacements sp√©cifiques avant d'utiliser un pointeur d'un bin.

### Avantages en termes de s√©curit√©

L'application de l'alignement des chunks dans les syst√®mes 64 bits am√©liore consid√©rablement la s√©curit√© de Malloc en **limitant le placement des faux chunks √† seulement 1 adresse sur 16**. Cela complique les efforts d'exploitation, surtout dans les sc√©narios o√π l'utilisateur a un contr√¥le limit√© sur les valeurs d'entr√©e, rendant les attaques plus complexes et plus difficiles √† ex√©cuter avec succ√®s.

* **Attaque Fastbin sur \_\_malloc\_hook**

Les nouvelles r√®gles d'alignement dans Malloc contrecarrent √©galement une attaque classique impliquant le `__malloc_hook`. Auparavant, les attaquants pouvaient manipuler les tailles des chunks pour **√©craser ce pointeur de fonction** et obtenir une **ex√©cution de code**. D√©sormais, l'exigence stricte d'alignement garantit que de telles manipulations ne sont plus viables, fermant ainsi une voie d'exploitation courante et renfor√ßant la s√©curit√© globale.

## M√©lange de pointeurs sur fastbins et tcache

Le **m√©lange de pointeurs** est une am√©lioration de s√©curit√© utilis√©e pour prot√©ger les **pointeurs Fd fastbin et tcache** dans les op√©rations de gestion de m√©moire. Cette technique aide √† pr√©venir certains types de tactiques d'exploitation de m√©moire, en particulier celles qui ne n√©cessitent pas d'informations de m√©moire divulgu√©es ou qui manipulent directement les emplacements m√©moire par rapport √† des positions connues (√©crasements **relatifs**).

Le c≈ìur de cette technique est une formule d'obscurcissement :

**`Nouveau_Ptr = (L >> 12) XOR P`**

* **L** est l'**emplacement de stockage** du pointeur.
* **P** est le v√©ritable **pointeur Fd fastbin/tcache**.

La raison du d√©calage des bits de l'emplacement de stockage (L) de 12 bits vers la droite avant l'op√©ration XOR est cruciale. Cette manipulation adresse une vuln√©rabilit√© inh√©rente √† la nature d√©terministe des 12 bits de poids faible des adresses m√©moire, qui sont g√©n√©ralement pr√©visibles en raison des contraintes de l'architecture du syst√®me. En d√©calant les bits, la partie pr√©visible est √©limin√©e de l'√©quation, am√©liorant le caract√®re al√©atoire du nouveau pointeur m√©lang√© et prot√©geant ainsi contre les exploits qui reposent sur la pr√©visibilit√© de ces bits.

Ce pointeur m√©lang√© exploite le caract√®re al√©atoire existant fourni par la **Randomisation de l'Agencement de l'Espace d'Adresses (ASLR)**, qui randomise les adresses utilis√©es par les programmes pour rendre difficile aux attaquants de pr√©dire la disposition m√©moire d'un processus.

**D√©m√™ler** le pointeur pour retrouver l'adresse d'origine implique d'utiliser la m√™me op√©ration XOR. Ici, le pointeur m√©lang√© est trait√© comme P dans la formule, et lorsqu'il est XOR√© avec l'emplacement de stockage inchang√© (L), il r√©v√®le le pointeur d'origine. Cette sym√©trie dans le m√©lange et le d√©m√©lange garantit que le syst√®me peut encoder et d√©coder efficacement les pointeurs sans surcharge significative, tout en augmentant consid√©rablement la s√©curit√© contre les attaques qui manipulent les pointeurs m√©moire.

### Avantages en termes de s√©curit√©

Le m√©lange de pointeurs vise √† **emp√™cher les √©crasements partiels et complets de pointeurs dans la gestion du tas**, une am√©lioration significative en termes de s√©curit√©. Cette fonctionnalit√© impacte les techniques d'exploitation de plusieurs mani√®res :

1. **Pr√©vention des √©crasements relatifs de Bye Byte** : Auparavant, les attaquants pouvaient modifier une partie d'un pointeur pour **rediriger des chunks du tas vers des emplacements diff√©rents sans conna√Ætre les adresses exactes**, une technique √©vidente dans l'exploit **House of Roman** sans fuite. Avec le m√©lange de pointeurs, de tels √©crasements relatifs **sans fuite de tas n√©cessitent d√©sormais une force brute**, r√©duisant consid√©rablement leur probabilit√© de succ√®s.
2. **Difficult√© accrue des attaques sur les bins Tcache/Fastbin** : Les attaques courantes qui √©crasent les pointeurs de fonction (comme `__malloc_hook`) en manipulant les entr√©es fastbin ou tcache sont entrav√©es. Par exemple, une attaque pourrait impliquer la fuite d'une adresse LibC, la lib√©ration d'un chunk dans le bin tcache, puis l'√©crasement du pointeur Fd pour le rediriger vers `__malloc_hook` pour une ex√©cution de code arbitraire. Avec le m√©lange de pointeurs, ces pointeurs doivent √™tre correctement m√©lang√©s, **n√©cessitant une fuite de tas pour une manipulation pr√©cise**, √©levant ainsi la barri√®re d'exploitation.
3. **N√©cessit√© de fuites de tas dans des emplacements non-tas** : Cr√©er un faux chunk dans des zones non-tas (comme la pile, la section .bss ou PLT/GOT) n√©cessite d√©sormais √©galement une fuite de tas en raison du besoin de m√©lange de pointeurs. Cela √©tend la complexit√© de l'exploitation de ces zones, similaire √† l'exigence de manipulation des adresses LibC.
4. **La fuite d'adresses de tas devient plus difficile** : Le m√©lange de pointeurs restreint l'utilit√© des pointeurs Fd dans les bins fastbin et tcache en tant que sources de fuites d'adresses de tas. Cependant, les pointeurs dans les bins non tri√©s, petits et grands restent non m√©lang√©s, donc toujours utilisables pour la fuite d'adresses. Ce changement pousse les attaquants √† explorer ces bins pour des informations exploitables, bien que certaines techniques permettent toujours de d√©m√™ler les pointeurs avant une fuite, mais avec des contraintes.

### **D√©m√™ler les pointeurs avec une fuite de tas**

{% hint style="danger" %}
Pour une meilleure explication du processus [**consultez le post original ici**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Aper√ßu de l'algorithme

La formule utilis√©e pour m√©langer et d√©m√™ler les pointeurs est :&#x20;

**`Nouveau_Ptr = (L >> 12) XOR P`**

O√π **L** est l'emplacement de stockage et **P** est le pointeur Fd. Lorsque **L** est d√©cal√© vers la droite de 12 bits, il expose les bits les plus significatifs de **P**, en raison de la nature de **XOR**, qui produit 0 lorsque les bits sont XOR√©s avec eux-m√™mes.

**√âtapes cl√©s de l'algorithme :**

1. **Fuite initiale des bits les plus significatifs** : En XORant le d√©calage de **L** avec **P**, vous obtenez efficacement les 12 bits sup√©rieurs de **P** car la partie d√©cal√©e de **L** sera nulle, laissant les bits correspondants de **P** inchang√©s.
2. **R√©cup√©ration des bits du pointeur** : Comme XOR est r√©versible, conna√Ætre le r√©sultat et l'un des op√©randes vous permet de calculer l'autre op√©rande. Cette propri√©t√© est utilis√©e pour d√©duire l'ensemble complet de bits pour **P** en XORant successivement des ensembles de bits connus avec des parties du pointeur m√©lang√©.
3. **D√©m√™lage it√©ratif** : Le processus est r√©p√©t√©, chaque fois en utilisant les bits de **P** nouvellement d√©couverts de l'√©tape pr√©c√©dente pour d√©coder le segment suivant du pointeur m√©lang√©, jusqu'√† ce que tous les bits soient r√©cup√©r√©s.
4. **Gestion des bits d√©terministes** : Les 12 derniers bits de **L** sont perdus en raison du d√©calage, mais ils sont d√©terministes et peuvent √™tre reconstruits apr√®s le processus.

Vous pouvez trouver une impl√©mentation de cet algorithme ici : [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Garde de pointeur

La garde de pointeur est une technique de mitigation des exploits utilis√©e dans glibc pour prot√©ger les pointeurs de fonction stock√©s, en particulier ceux enregistr√©s par des appels de biblioth√®que tels que `atexit()`. Cette protection implique de brouiller les pointeurs en les XORant avec un secret stock√© dans les donn√©es du thread (`fs:0x30`) et en appliquant une rotation bit √† bit. Ce m√©canisme vise √† emp√™cher les attaquants de d√©tourner le flux de contr√¥le en √©crivant sur les pointeurs de fonction.

### **Contourner la Garde de Pointeur avec une fuite**

1. **Compr√©hension des Op√©rations de Garde de Pointeur :** Le brouillage des pointeurs est effectu√© en utilisant la macro `PTR_MANGLE` qui XOR le pointeur avec un secret de 64 bits puis effectue une rotation gauche de 0x11 bits. L'op√©ration inverse pour r√©cup√©rer le pointeur d'origine est g√©r√©e par `PTR_DEMANGLE`.
2. **Strat√©gie d'Attaque :** L'attaque est bas√©e sur une approche de texte clair connu, o√π l'attaquant doit conna√Ætre √† la fois la version originale et la version brouill√©e d'un pointeur pour d√©duire le secret utilis√© pour le brouillage.
3. **Exploitation des Textes Clairs Connus :**
* **Identification des Pointeurs de Fonction Fixes :** En examinant le code source de glibc ou les tables de pointeurs de fonction initialis√©es (comme `__libc_pthread_functions`), un attaquant peut trouver des pointeurs de fonction pr√©visibles.
* **Calcul du Secret :** En utilisant un pointeur de fonction connu tel que `__pthread_attr_destroy` et sa version brouill√©e √† partir de la table de pointeurs de fonction, le secret peut √™tre calcul√© en effectuant une rotation inverse (rotation droite) du pointeur brouill√© puis en le XORant avec l'adresse de la fonction.
4. **Textes Clairs Alternatifs :** L'attaquant peut √©galement exp√©rimenter en brouillant des pointeurs avec des valeurs connues comme 0 ou -1 pour voir si cela produit des motifs identifiables en m√©moire, r√©v√©lant potentiellement le secret lorsque ces motifs sont trouv√©s dans les vidages m√©moire.
5. **Application Pratique :** Apr√®s avoir calcul√© le secret, un attaquant peut manipuler les pointeurs de mani√®re contr√¥l√©e, contournant essentiellement la protection de la Garde de Pointeur dans une application multi-thread avec la connaissance de l'adresse de base de la libc et la capacit√© de lire des emplacements m√©moire arbitraires.

## R√©f√©rences

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
