# Prote√ß√µes do Libc

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Aplica√ß√£o de Alinhamento de Chunks

**Malloc** aloca mem√≥ria em **grupos de 8 bytes (32 bits) ou 16 bytes (64 bits)**. Isso significa que o final dos chunks em sistemas de 32 bits deve se alinhar com **0x8**, e em sistemas de 64 bits com **0x0**. A funcionalidade de seguran√ßa verifica se cada chunk **se alinha corretamente** nessas localiza√ß√µes espec√≠ficas antes de usar um ponteiro de um bin.

### Benef√≠cios de Seguran√ßa

A aplica√ß√£o do alinhamento de chunks em sistemas de 64 bits melhora significativamente a seguran√ßa do Malloc ao **limitar a coloca√ß√£o de chunks falsos para apenas 1 a cada 16 endere√ßos**. Isso complica os esfor√ßos de explora√ß√£o, especialmente em cen√°rios onde o usu√°rio tem controle limitado sobre os valores de entrada, tornando os ataques mais complexos e dif√≠ceis de executar com sucesso.

* **Ataque Fastbin no \_\_malloc\_hook**

As novas regras de alinhamento no Malloc tamb√©m impedem um ataque cl√°ssico envolvendo o `__malloc_hook`. Anteriormente, os atacantes podiam manipular tamanhos de chunk para **sobrescrever este ponteiro de fun√ß√£o** e obter **execu√ß√£o de c√≥digo**. Agora, o requisito estrito de alinhamento garante que tais manipula√ß√µes n√£o sejam mais vi√°veis, fechando uma rota comum de explora√ß√£o e melhorando a seguran√ßa geral.

## Ofusca√ß√£o de Ponteiros em fastbins e tcache

**Ofusca√ß√£o de Ponteiros** √© um aprimoramento de seguran√ßa usado para proteger **ponteiros Fd de fastbin e tcache** em opera√ß√µes de gerenciamento de mem√≥ria. Essa t√©cnica ajuda a prevenir certos tipos de t√°ticas de explora√ß√£o de mem√≥ria, especificamente aquelas que n√£o requerem informa√ß√µes de mem√≥ria vazadas ou que manipulam diretamente locais de mem√≥ria relativos a posi√ß√µes conhecidas (sobrescritas **relativas**).

O cerne dessa t√©cnica √© uma f√≥rmula de ofusca√ß√£o:

**`Novo_Ptr = (L >> 12) XOR P`**

* **L** √© a **Localiza√ß√£o de Armazenamento** do ponteiro.
* **P** √© o **Ponteiro Fd de fastbin/tcache** real.

A raz√£o para o deslocamento de bits da localiza√ß√£o de armazenamento (L) por 12 bits para a direita antes da opera√ß√£o XOR √© cr√≠tica. Essa manipula√ß√£o aborda uma vulnerabilidade inerente √† natureza determin√≠stica dos 12 bits menos significativos dos endere√ßos de mem√≥ria, que s√£o tipicamente previs√≠veis devido √†s restri√ß√µes da arquitetura do sistema. Ao deslocar os bits, a parte previs√≠vel √© removida da equa√ß√£o, aumentando a aleatoriedade do novo ponteiro ofuscado e, assim, protegendo contra explora√ß√µes que dependem da previsibilidade desses bits.

Este ponteiro ofuscado aproveita a aleatoriedade existente fornecida pela **Randomiza√ß√£o do Layout do Espa√ßo de Endere√ßos (ASLR)**, que randomiza os endere√ßos usados pelos programas para dificultar que os atacantes prevejam o layout de mem√≥ria de um processo.

**Desofuscar** o ponteiro para recuperar o endere√ßo original envolve o uso da mesma opera√ß√£o XOR. Aqui, o ponteiro ofuscado √© tratado como P na f√≥rmula e, quando XORado com a localiza√ß√£o de armazenamento inalterada (L), revela o ponteiro original. Essa simetria na ofusca√ß√£o e desofusca√ß√£o garante que o sistema possa codificar e decodificar eficientemente ponteiros sem sobrecarga significativa, ao mesmo tempo em que aumenta substancialmente a seguran√ßa contra ataques que manipulam ponteiros de mem√≥ria.

### Benef√≠cios de Seguran√ßa

A ofusca√ß√£o de ponteiros visa **prevenir sobrescritas parciais e completas de ponteiros em heap**, um aprimoramento significativo em seguran√ßa. Essa funcionalidade impacta as t√©cnicas de explora√ß√£o de v√°rias maneiras:

1. **Preven√ß√£o de Sobrescritas Relativas de Bye Byte**: Anteriormente, os atacantes podiam alterar parte de um ponteiro para **redirecionar chunks de heap para diferentes locais sem conhecer endere√ßos exatos**, uma t√©cnica evidente no exploit **House of Roman** sem vazamento. Com a ofusca√ß√£o de ponteiros, tais sobrescritas relativas **sem um vazamento de heap agora exigem for√ßa bruta**, reduzindo drasticamente a probabilidade de sucesso.
2. **Aumento da Dificuldade de Ataques a Tcache Bin/Fastbin**: Ataques comuns que sobrescrevem ponteiros de fun√ß√£o (como `__malloc_hook`) manipulando entradas de fastbin ou tcache s√£o prejudicados. Por exemplo, um ataque pode envolver vazar um endere√ßo LibC, liberar um chunk no tcache bin e, em seguida, sobrescrever o ponteiro Fd para redirecion√°-lo para `__malloc_hook` para execu√ß√£o de c√≥digo arbitr√°rio. Com a ofusca√ß√£o de ponteiros, esses ponteiros devem ser corretamente ofuscados, **exigindo um vazamento de heap para manipula√ß√£o precisa**, elevando assim a barreira de explora√ß√£o.
3. **Necessidade de Vazamentos de Heap em Locais N√£o-Heap**: Criar um chunk falso em √°reas n√£o-heap (como a pilha, se√ß√£o .bss ou PLT/GOT) agora tamb√©m **requer um vazamento de heap** devido √† necessidade de ofusca√ß√£o de ponteiros. Isso estende a complexidade de explorar essas √°reas, semelhante √† necessidade de manipular endere√ßos LibC.
4. **Vazar Endere√ßos de Heap se Torna Mais Desafiador**: A ofusca√ß√£o de ponteiros restringe a utilidade de ponteiros Fd em fastbin e tcache bins como fontes de vazamento de endere√ßos de heap. No entanto, ponteiros em bins n√£o ordenados, pequenos e grandes permanecem n√£o ofuscados, ainda podendo ser usados para vazar endere√ßos. Essa mudan√ßa leva os atacantes a explorar esses bins em busca de informa√ß√µes explor√°veis, embora algumas t√©cnicas ainda possam permitir desofuscar ponteiros antes de um vazamento, embora com restri√ß√µes.

### **Desofuscar Ponteiros com um Vazamento de Heap**

{% hint style="danger" %}
Para uma melhor explica√ß√£o do processo [**verifique a postagem original aqui**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Vis√£o Geral do Algoritmo

A f√≥rmula usada para ofuscar e desofuscar ponteiros √©:&#x20;

**`Novo_Ptr = (L >> 12) XOR P`**

Onde **L** √© a localiza√ß√£o de armazenamento e **P** √© o ponteiro Fd. Quando **L** √© deslocado para a direita por 12 bits, ele exp√µe os bits mais significativos de **P**, devido √† natureza do **XOR**, que produz 0 quando os bits s√£o XORados consigo mesmos.

**Passos Chave no Algoritmo:**

1. **Vazamento Inicial dos Bits Mais Significativos**: Ao XORar o **L** deslocado com **P**, voc√™ obt√©m efetivamente os 12 bits superiores de **P** porque a parte deslocada de **L** ser√° zero, deixando os bits correspondentes de **P** inalterados.
2. **Recupera√ß√£o dos Bits do Ponteiro**: Como o XOR √© revers√≠vel, conhecer o resultado e um dos operandos permite calcular o outro operando. Essa propriedade √© usada para deduzir o conjunto completo de bits para **P** sucessivamente XORando conjuntos conhecidos de bits com partes do ponteiro ofuscado.
3. **Desofusca√ß√£o Iterativa**: O processo √© repetido, cada vez usando os bits de **P** rec√©m-descobertos da etapa anterior para decodificar o pr√≥ximo segmento do ponteiro ofuscado, at√© que todos os bits sejam recuperados.
4. **Manuseio de Bits Determin√≠sticos**: Os √∫ltimos 12 bits de **L** s√£o perdidos devido ao deslocamento, mas s√£o determin√≠sticos e podem ser reconstru√≠dos p√≥s-processo.

Voc√™ pode encontrar uma implementa√ß√£o desse algoritmo aqui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Prote√ß√£o de Ponteiro

O ponteiro guard √© uma t√©cnica de mitiga√ß√£o de explora√ß√£o usada no glibc para proteger ponteiros de fun√ß√£o armazenados, especialmente aqueles registrados por chamadas de biblioteca como `atexit()`. Essa prote√ß√£o envolve embaralhar os ponteiros atrav√©s de XOR com um segredo armazenado nos dados da thread (`fs:0x30`) e aplicando uma rota√ß√£o bitwise. Esse mecanismo tem como objetivo evitar que atacantes assumam o controle do fluxo de execu√ß√£o sobrescrevendo ponteiros de fun√ß√£o.

### **Burlando o Ponteiro Guard com um vazamento**

1. **Compreendendo as Opera√ß√µes do Ponteiro Guard:** O embaralhamento (mangling) dos ponteiros √© feito usando a macro `PTR_MANGLE`, que faz XOR do ponteiro com um segredo de 64 bits e ent√£o realiza uma rota√ß√£o √† esquerda de 0x11 bits. A opera√ß√£o reversa para recuperar o ponteiro original √© tratada por `PTR_DEMANGLE`.
2. **Estrat√©gia de Ataque:** O ataque √© baseado em uma abordagem de texto conhecido, onde o atacante precisa conhecer tanto a vers√£o original quanto a vers√£o embaralhada de um ponteiro para deduzir o segredo usado para o embaralhamento.
3. **Explorando Textos Conhecidos:**
* **Identificando Ponteiros de Fun√ß√£o Fixos:** Ao examinar o c√≥digo-fonte do glibc ou tabelas de ponteiros de fun√ß√£o inicializados (como `__libc_pthread_functions`), um atacante pode encontrar ponteiros de fun√ß√£o previs√≠veis.
* **Calculando o Segredo:** Usando um ponteiro de fun√ß√£o conhecido, como `__pthread_attr_destroy`, e sua vers√£o embaralhada da tabela de ponteiros de fun√ß√£o, o segredo pode ser calculado revertendo a rota√ß√£o (rota√ß√£o √† direita) do ponteiro embaralhado e ent√£o fazendo XOR com o endere√ßo da fun√ß√£o.
4. **Textos Alternativos:** O atacante tamb√©m pode experimentar embaralhar ponteiros com valores conhecidos como 0 ou -1 para ver se produzem padr√µes identific√°veis na mem√≥ria, potencialmente revelando o segredo quando esses padr√µes s√£o encontrados em despejos de mem√≥ria.
5. **Aplica√ß√£o Pr√°tica:** Ap√≥s calcular o segredo, um atacante pode manipular ponteiros de forma controlada, essencialmente burlando a prote√ß√£o do Ponteiro Guard em um aplicativo multithread com conhecimento do endere√ßo base do libc e capacidade de ler locais de mem√≥ria arbitr√°rios.

## Refer√™ncias

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
