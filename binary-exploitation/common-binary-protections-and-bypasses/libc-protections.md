# Libc Protections

## チャンクアライメントの強制

**Malloc**はメモリを**8バイト（32ビット）または16バイト（64ビット）のグループ**で割り当てます。これは、32ビットシステムではチャンクの末尾が**0x8**に、64ビットシステムでは**0x0**に整列する必要があることを意味します。セキュリティ機能は、各チャンクがこれらの特定の場所で正しく整列しているかどうかを確認し、ビンからのポインタを使用する前にチェックします。

### セキュリティ上の利点

64ビットシステムでのチャンクアライメントの強制は、**フェイクチャンクの配置をアドレスの16分の1に制限**することで、Mallocのセキュリティを大幅に向上させます。これにより、攻撃がより複雑になり、入力値を制御できる場合に攻撃がより複雑で成功しにくくなります。

* **\_\_malloc\_hookに対するFastbin攻撃**

Mallocの新しい整列ルールは、`__malloc_hook`を巧妙に操作する古典的な攻撃を阻止します。以前は、攻撃者がチャンクサイズを操作してこの関数ポインタを**上書き**し、**コード実行**を取得できました。今、厳格な整列要件により、そのような操作がもはや実行不可能になり、一般的な攻撃経路を閉じ、全体的なセキュリティを向上させます。

## fastbinsおよびtcacheのポインタマングリング

**ポインタマングリング**は、メモリ管理操作での**fastbinおよびtcache Fdポインタ**を保護するために使用されるセキュリティ強化技術です。この技術は、メモリ情報の漏洩が必要ないあるいは既知の位置に対して直接メモリ位置を操作する攻撃手法、特に相対的な**上書き**を必要としないメモリ攻撃戦術を防ぐのに役立ちます。

この技術の中心は、次のような難読化式です：

**`New_Ptr = (L >> 12) XOR P`**

* **L**はポインタの**格納場所**です。
* **P**は実際の**fastbin/tcache Fdポインタ**です。

12ビット右にビットシフトされた格納場所（L）をXOR演算する理由は重要です。この操作は、通常システムアーキテクチャの制約により予測可能な最も下位の12ビットの決定論的性質に対処します。ビットをシフトすることで、予測可能な部分が方程式から取り除かれ、新しい難読化されたポインタのランダム性が向上し、これらのビットの予測可能性に依存する攻撃に対して保護されます。

この難読化されたポインタは、プログラムが使用するアドレスをランダム化する**アドレス空間配置ランダム化（ASLR）**によって提供される既存のランダム性を利用します。これにより、攻撃者がプロセスのメモリレイアウトを予測するのを困難にします。

### セキュリティ上の利点

ポインタマングリングは、ヒープ管理での**部分的および完全なポインタの上書きを防ぐ**ことを目的としており、セキュリティを大幅に向上させます。この機能は、いくつかの方法で攻撃手法に影響を与えます：

1. **バイトバイト相対上書きの防止**：以前は、攻撃者が正確なアドレスを知らなくても、ヒープチャンクを異なる場所に**リダイレクト**するためにポインタの一部を変更できました。これは、リークレスの**House of Roman**攻撃で明らかな手法です。ポインタマングリングにより、そのような相対的な上書きは**ヒープリークなしではブルートフォースが必要**となり、成功の可能性が著しく低下します。
2. **Tcache Bin/Fastbin攻撃の難化**：fastbinまたはtcacheエントリを操作して関数ポインタ（例：`__malloc_hook`）を上書きする一般的な攻撃が妨げられます。たとえば、攻撃はLibCアドレスをリークし、tcacheビンにチャンクを解放し、その後Fdポインタを`__malloc_hook`にリダイレクトして任意のコードを実行する可能性があります。ポインタマングリングにより、これらのポインタは正しく難読化される必要があり、**正確な操作のためにヒープリークが必要**となり、攻撃の障壁が高まります。
3. **ヒープ以外の場所でのヒープリークの要件**：ヒープ以外の場所（スタック、.bssセクション、またはPLT/GOTなど）に偽のチャンクを作成することも、ポインタマングリングの必要性により**ヒープリークが必要**となります。これにより、これらの領域の攻撃の複雑さが拡大し、LibCアドレスを操作する必要があるのと同様になります。
4. **ヒープアドレスのリークがより困難に**：ポインタマングリングにより、fastbinおよびtcacheビンのFdポインタをヒープアドレスのリーク元として使用することが制限されます。ただし、未整列の、小さな、大きなビンのポインタは未難読化のままであり、アドレスのリークに使用できます。この変化により、攻撃者はこれらのビンを探索して攻撃可能な情報を探る必要がありますが、一部の手法ではリーク前にポインタを復号化することができる場合もありますが、制約があります。

### **ヒープリークを使用したポインタの復号化**

{% hint style="danger" %}
プロセスの詳細な説明については、[**こちらの元の投稿を確認してください**](https://maxwelldulin.com/BlogPost?post=5445977088)。
{% endhint %}

### アルゴリズムの概要

ポインタの難読化および復号化に使用される式は次のとおりです：&#x20;

**`New_Ptr = (L >> 12) XOR P`**

ここで、**L**は格納場所であり、**P**はFdポインタです。**L**を右に12ビットシフトすることで、**XOR**の性質により、**L**のシフトされた部分がゼロになり、**P**の対応するビットが変更されないため、**P**の上位12ビットが得られます。

**アルゴリズムの主要なステップ:**

1. **最上位ビットの初期リーク**: シフトされた**L**を**P**とXORすることで、**L**のシフトされた部分がゼロになり、**P**の対応するビットが変更されないため、**P**の上位12ビットが得られます。
2. **ポインタビットの回復**: XORが逆向きになるため、結果と1つのオペランドを知っていると、他のオペランドを計算できます。この特性を使用して、既知のビットセットと難読化されたポインタの部分とを繰り返しXORすることで、**P**の全ビットセットを推測できます。
3. **反復的な難読化解除**: このプロセスは繰り返され、前のステップで発見された**P**のビットを使用して、難読化されたポインタの次のセグメントをデコードします。すべてのビットが回復されるまで、このプロセスが繰り返されます。
4. **決定論的ビットの処理**: シフトにより**L**の最後の12ビットが失われますが、これらは決定論的であり、後処理で再構築できます。

このアルゴリズムの実装はこちらで見つけることができます：[https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## ポインターガード

ポインターガードは、glibcで使用されるエクスプロイト緩和技術であり、特に`atexit()`などのライブラリ呼び出しによって登録された関数ポインターを保護するために使用されます。この保護は、ポインターをスクランブルし、スレッドデータ（`fs:0x30`）に格納された秘密とXOR演算を行い、ビット単位の回転を適用することを含みます。このメカニズムは、関数ポインターを上書きして制御フローを乗っ取る攻撃者を防ぐことを目的としています。

### **リークを使用してポインターガードをバイパスする**

1. **ポインターガード操作の理解:** ポインターのスクランブル（マングリング）は、ポインターを64ビットの秘密とXOR演算し、0x11ビットの左回転を行う`PTR_MANGLE`マクロを使用して行われます。元のポインターを回復するための逆操作は`PTR_DEMANGLE`によって処理されます。
2. **攻撃戦略:** この攻撃は既知の平文アプローチに基づいており、攻撃者はマングリングに使用される秘密を推測するためにポインターの元のバージョンとマングリングされたバージョンの両方を知る必要があります。
3. **既知の平文の悪用:**
* **固定関数ポインターの特定:** glibcのソースコードを調査するか、`__libc_pthread_functions`のような初期化された関数ポインターテーブルを調べることで、攻撃者は予測可能な関数ポインターを見つけることができます。
* **秘密の計算:** `__pthread_attr_destroy`などの既知の関数ポインターとその関数ポインターテーブルからのマングリングされたバージョンを使用して、秘密を計算することができます。これは、マングリングされたポインターを逆回転（右回転）し、その後、関数のアドレスとXOR演算することで行われます。
4. **代替平文:** 攻撃者は、0や-1などの既知の値でポインターをマングリングして、これらがメモリ内で識別可能なパターンを生成するかどうかを実験することができます。これらのパターンがメモリダンプで見つかると、秘密が明らかになる可能性があります。
5. **実践的な応用:** 秘密を計算した後、攻撃者は制御された方法でポインターを操作することができ、libcベースアドレスの知識と任意のメモリ位置を読み取る能力を持つ多スレッドアプリケーションでポインターガード保護をバイパスすることができます。

## 参考文献

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
