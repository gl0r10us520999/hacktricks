# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** √® progettato per migliorare l'affidabilit√† e la sicurezza del software **rilevando e prevenendo errori legati alla memoria**, come buffer overflow e vulnerabilit√† use-after-free. MTE, come parte dell'architettura **ARM**, fornisce un meccanismo per allegare un **piccolo tag a ciascuna allocazione di memoria** e un **tag corrispondente a ciascun puntatore** che fa riferimento a quella memoria. Questo approccio consente di rilevare accessi illegali alla memoria durante l'esecuzione, riducendo significativamente il rischio di sfruttare tali vulnerabilit√† per eseguire codice arbitrario.

### **How Memory Tagging Extension Works**

MTE opera **dividendo la memoria in piccoli blocchi di dimensioni fisse, a ciascun blocco viene assegnato un tag,** tipicamente di pochi bit.&#x20;

Quando viene creato un puntatore per puntare a quella memoria, riceve lo stesso tag. Questo tag √® memorizzato nei **bit non utilizzati di un puntatore di memoria**, collegando efficacemente il puntatore al suo corrispondente blocco di memoria.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando un programma accede alla memoria tramite un puntatore, l'hardware MTE verifica che il **tag del puntatore corrisponda al tag del blocco di memoria**. Se i tag **non corrispondono**, indica un **accesso illegale alla memoria.**

### MTE Pointer Tags

I tag all'interno di un puntatore sono memorizzati in 4 bit all'interno del byte superiore:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Pertanto, questo consente fino a **16 valori di tag diversi**.

### MTE Memory Tags

Ogni **16B di memoria fisica** ha un corrispondente **tag di memoria**.

I tag di memoria sono memorizzati in una **regione RAM dedicata** (non accessibile per uso normale). Avere tag di 4 bit per ogni 16B di tag di memoria fino al 3% della RAM.

ARM introduce le seguenti istruzioni per manipolare questi tag nella memoria RAM dedicata:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Controllo delle modalit√†

### Sincrono

La CPU controlla i tag **durante l'esecuzione dell'istruzione**, se c'√® una discrepanza, solleva un'eccezione.\
Questo √® il pi√π lento e il pi√π sicuro.

### Asincrono

La CPU controlla i tag **in modo asincrono**, e quando viene trovata una discrepanza imposta un bit di eccezione in uno dei registri di sistema. √à **pi√π veloce** rispetto al precedente ma √® **incapace di indicare** l'istruzione esatta che causa la discrepanza e non solleva immediatamente l'eccezione, dando un po' di tempo all'attaccante per completare il suo attacco.

### Misto

???

## Esempi di implementazione e rilevamento

Chiamato Hardware Tag-Based KASAN, MTE-based KASAN o in-kernel MTE.\
Gli allocatori del kernel (come `kmalloc`) **chiameranno questo modulo** che preparer√† il tag da utilizzare (in modo casuale) per attaccarlo allo spazio del kernel allocato e al puntatore restituito.

Nota che **contrassegner√† solo granuli di memoria sufficienti** (16B ciascuno) per la dimensione richiesta. Quindi, se la dimensione richiesta era 35 e un blocco di 60B √® stato fornito, contrassegner√† i primi 16\*3 = 48B con questo tag e il **resto** sar√† **contrassegnato** con un cosiddetto **tag non valido (0xE)**.

Il tag **0xF** √® il **puntatore che corrisponde a tutti**. Una memoria con questo puntatore consente **di utilizzare qualsiasi tag** per accedere alla sua memoria (nessuna discrepanza). Questo potrebbe impedire a MET di rilevare un attacco se questo tag viene utilizzato nella memoria attaccata.

Pertanto ci sono solo **14 valori** che possono essere utilizzati per generare tag poich√© 0xE e 0xF sono riservati, dando una probabilit√† di **riutilizzo dei tag** di 1/17 -> circa **7%**.

Se il kernel accede al **granulo di tag non valido**, la **discrepanza** sar√† **rilevata**. Se accede a un'altra posizione di memoria, se la **memoria ha un tag diverso** (o il tag non valido) la discrepanza sar√† **rilevata**. Se l'attaccante √® fortunato e la memoria utilizza lo stesso tag, non sar√† rilevata. Le probabilit√† sono circa 7%.

Un altro bug si verifica nell'**ultimo granulo** della memoria allocata. Se l'applicazione ha richiesto 35B, le √® stato dato il granulo da 32 a 48. Pertanto, i **byte da 36 a 47 utilizzano lo stesso tag** ma non erano stati richiesti. Se l'attaccante accede a **questi byte extra, questo non viene rilevato**.

Quando viene eseguito **`kfree()`**, la memoria viene contrassegnata di nuovo con il tag di memoria non valido, quindi in un **use-after-free**, quando la memoria viene nuovamente accessibile, la **discrepanza viene rilevata**.

Tuttavia, in un use-after-free, se lo stesso **chunk viene riallocato di nuovo con lo STESSO tag** di prima, un attaccante sar√† in grado di utilizzare questo accesso e questo non sar√† rilevato (circa 7% di probabilit√†).

Inoltre, solo **`slab` e `page_alloc`** utilizzano memoria contrassegnata, ma in futuro questo sar√† utilizzato anche in `vmalloc`, `stack` e `globals` (al momento del video questi possono ancora essere abusati).

Quando una **discrepanza viene rilevata**, il kernel andr√† in **panic** per prevenire ulteriori sfruttamenti e tentativi di sfruttamento (MTE non ha falsi positivi).

## Riferimenti

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
