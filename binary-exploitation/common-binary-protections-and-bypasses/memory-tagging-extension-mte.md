# Extensi칩n de Etiquetado de Memoria (MTE)

{% hint style="success" %}
Aprende y practica Hacking en AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci칩n B치sica

**La Extensi칩n de Etiquetado de Memoria (MTE)** est치 dise침ada para mejorar la confiabilidad y seguridad del software mediante la **detecci칩n y prevenci칩n de errores relacionados con la memoria**, como desbordamientos de b칰fer y vulnerabilidades de uso despu칠s de liberar. MTE, como parte de la arquitectura **ARM**, proporciona un mecanismo para adjuntar una **peque침a etiqueta a cada asignaci칩n de memoria** y una **etiqueta correspondiente a cada puntero** que referencia esa memoria. Este enfoque permite la detecci칩n de accesos a memoria ilegales en tiempo de ejecuci칩n, reduciendo significativamente el riesgo de explotar dichas vulnerabilidades para ejecutar c칩digo arbitrario.

### **C칩mo Funciona la Extensi칩n de Etiquetado de Memoria**

MTE opera mediante **la divisi칩n de la memoria en bloques peque침os de tama침o fijo, con cada bloque asignado una etiqueta,** t칤picamente de unos pocos bits de tama침o.&#x20;

Cuando se crea un puntero para apuntar a esa memoria, obtiene la misma etiqueta. Esta etiqueta se almacena en los **bits no utilizados de un puntero de memoria**, vinculando efectivamente el puntero a su bloque de memoria correspondiente.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Cuando un programa accede a la memoria a trav칠s de un puntero, el hardware MTE verifica que la **etiqueta del puntero coincida con la etiqueta del bloque de memoria**. Si las etiquetas **no coinciden**, indica un **acceso a memoria ilegal**.

### Etiquetas de Puntero MTE

Las etiquetas dentro de un puntero se almacenan en 4 bits dentro del byte superior:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Por lo tanto, esto permite hasta **16 valores de etiqueta diferentes**.

### Etiquetas de Memoria MTE

Cada **16B de memoria f칤sica** tiene una **etiqueta de memoria correspondiente**.

Las etiquetas de memoria se almacenan en una **regi칩n de RAM dedicada** (no accesible para uso normal). Teniendo etiquetas de 4 bits para cada 16B de etiquetas de memoria, hasta un 3% de la RAM.

ARM introduce las siguientes instrucciones para manipular estas etiquetas en la memoria RAM dedicada:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modos de Verificaci칩n

### S칤ncrono

La CPU verifica las etiquetas **durante la ejecuci칩n de la instrucci칩n**, si hay una discrepancia, genera una excepci칩n.\
Este es el m치s lento y seguro.

### As칤ncrono

La CPU verifica las etiquetas **asincr칩nicamente**, y cuando se encuentra una discrepancia, establece un bit de excepci칩n en uno de los registros del sistema. Es **m치s r치pido** que el anterior pero es **incapaz de se침alar** la instrucci칩n exacta que caus칩 la discrepancia y no genera la excepci칩n de inmediato, dando tiempo al atacante para completar su ataque.

### Mixto

???

## Ejemplos de Implementaci칩n y Detecci칩n

Llamado KASAN basado en etiquetas de hardware, KASAN basado en MTE o MTE en el kernel.\
Los asignadores de memoria del kernel (como `kmalloc`) **llamar치n a este m칩dulo** que preparar치 la etiqueta a utilizar (aleatoriamente) para adjuntarla al espacio de kernel asignado y al puntero devuelto.

Ten en cuenta que solo marcar치 suficientes gr치nulos de memoria (16B cada uno) para el tama침o solicitado. Entonces, si el tama침o solicitado fue 35 y se dio un bloque de 60B, marcar치 los primeros 16\*3 = 48B con esta etiqueta y el **resto** se marcar치 con una llamada **etiqueta inv치lida (0xE)**.

La etiqueta **0xF** es el **puntero de coincidencia total**. Una memoria con este puntero permite que **se utilice cualquier etiqueta** para acceder a su memoria (sin discrepancias). Esto podr칤a evitar que MTE detecte un ataque si esta etiqueta se est치 utilizando en la memoria atacada.

Por lo tanto, solo hay **14 valores** que se pueden usar para generar etiquetas, ya que 0xE y 0xF est치n reservados, lo que da una probabilidad de **reutilizaci칩n de etiquetas** de 1/17 -> alrededor del **7%**.

Si el kernel accede al **gr치nulo de etiqueta inv치lida**, se detectar치 la **discrepancia**. Si accede a otra ubicaci칩n de memoria, si la **memoria tiene una etiqueta diferente** (o la etiqueta inv치lida), se detectar치 la discrepancia. Si el atacante tiene suerte y la memoria est치 utilizando la misma etiqueta, no se detectar치. Las posibilidades son alrededor del 7%.

Otro error ocurre en el **칰ltimo gr치nulo** de la memoria asignada. Si la aplicaci칩n solicit칩 35B, se le dio el gr치nulo del 32 al 48. Por lo tanto, los **bytes del 36 al 47 est치n utilizando la misma etiqueta** pero no fueron solicitados. Si el atacante accede a **estos bytes adicionales, esto no se detecta**.

Cuando se ejecuta **`kfree()`**, la memoria se etiqueta nuevamente con la etiqueta de memoria inv치lida, por lo que en un **uso despu칠s de liberar**, cuando se accede nuevamente a la memoria, se detecta la **discrepancia**.

Sin embargo, en un uso despu칠s de liberar, si el mismo **bloque se vuelve a asignar con la MISMA etiqueta** que antes, un atacante podr치 utilizar este acceso y esto no se detectar치 (alrededor del 7% de probabilidad).

Adem치s, solo **`slab` y `page_alloc`** utilizan memoria etiquetada, pero en el futuro esto tambi칠n se utilizar치 en `vmalloc`, `stack` y `globals` (en el momento del video, estos a칰n pueden ser abusados).

Cuando se detecta una **discrepancia**, el kernel entrar치 en **p치nico** para evitar una mayor explotaci칩n y reintentos del exploit (MTE no tiene falsos positivos).

## Referencias

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
