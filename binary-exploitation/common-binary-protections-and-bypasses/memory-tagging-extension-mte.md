# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** imeundwa ili kuboresha uaminifu na usalama wa programu kwa **kubaini na kuzuia makosa yanayohusiana na kumbukumbu**, kama vile buffer overflows na matumizi baada ya uhuru. MTE, kama sehemu ya **ARM** architecture, inatoa mekanizma ya kuambatanisha **lebo ndogo kwa kila allocation ya kumbukumbu** na **lebo inayolingana kwa kila pointer** inayorejelea kumbukumbu hiyo. Njia hii inaruhusu kubaini upatikanaji haramu wa kumbukumbu wakati wa utendaji, ikipunguza hatari ya kutumia udhaifu kama huo kwa kutekeleza msimbo usio na mipaka.

### **How Memory Tagging Extension Works**

MTE inafanya kazi kwa **kugawanya kumbukumbu katika blocks ndogo, za ukubwa thabiti, ambapo kila block inapata lebo,** kwa kawaida bits chache kwa ukubwa.&#x20;

Wakati pointer inaundwa kuashiria kumbukumbu hiyo, inapata lebo hiyo hiyo. Lebo hii inahifadhiwa katika **bits zisizotumika za pointer ya kumbukumbu**, ikifunga pointer hiyo na block yake inayolingana ya kumbukumbu.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wakati programu inapata kumbukumbu kupitia pointer, vifaa vya MTE vinakagua kwamba **lebo ya pointer inalingana na lebo ya block ya kumbukumbu**. Ikiwa lebo hizo **hazilingani**, inaashiria **upatikanaji haramu wa kumbukumbu.**

### MTE Pointer Tags

Lebo ndani ya pointer zinahifadhiwa katika bits 4 ndani ya byte ya juu:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Hivyo, hii inaruhusu hadi **maadili tofauti 16 ya lebo**.

### MTE Memory Tags

Kila **16B ya kumbukumbu halisi** ina lebo inayolingana ya **kumbukumbu**.

Lebo za kumbukumbu zinahifadhiwa katika **eneo maalum la RAM** (lisilopatikana kwa matumizi ya kawaida). Kuwa na lebo za bits 4 kwa kila lebo ya kumbukumbu ya 16B hadi 3% ya RAM.

ARM inintroduce maagizo yafuatayo ili kudhibiti lebo hizi katika kumbukumbu maalum ya RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU inakagua lebo **wakati wa kutekeleza maagizo**, ikiwa kuna tofauti, inainua hitilafu.\
Hii ni polepole zaidi na salama zaidi.

### Async

CPU inakagua lebo **kwa njia isiyo ya kawaida**, na wakati tofauti inapatikana inasetisha biti ya hitilafu katika moja ya register za mfumo. Ni **haraka** kuliko ile ya awali lakini haiwezi **kuonyesha** maagizo halisi yanayosababisha tofauti na haionyeshi hitilafu mara moja, ikitoa muda kwa mshambuliaji kukamilisha shambulio lake.

### Mixed

???

## Implementation & Detection Examples

Inaitwa Hardware Tag-Based KASAN, MTE-based KASAN au in-kernel MTE.\
Wagawaji wa kernel (kama `kmalloc`) wata **ita moduli hii** ambayo itajiandaa lebo ya kutumia (kwa bahati nasibu) kuunganisha nayo nafasi ya kernel iliyotolewa na pointer iliyorejeshwa.

Kumbuka kwamba itakuwa **inaashiria granules za kumbukumbu za kutosha tu** (16B kila moja) kwa saizi iliyotolewa. Hivyo ikiwa saizi iliyotolewa ilikuwa 35 na slab ya 60B ilitolewa, itashiria 16\*3 = 48B na lebo hii na **zingine** zita **ashiriwa** na lebo inayoitwa **lebo isiyo sahihi (0xE)**.

Lebo **0xF** ni **pointer inayolingana na zote**. Kumbukumbu yenye pointer hii inaruhusu **lebo yoyote kutumika** kufikia kumbukumbu yake (hakuna tofauti). Hii inaweza kuzuia MET kugundua shambulio ikiwa lebo hizi zinatumika katika kumbukumbu iliyoshambuliwa.

Kwa hivyo kuna **thamani 14** tu zinazoweza kutumika kuunda lebo kwani 0xE na 0xF zimehifadhiwa, ikitoa uwezekano wa **kurudia lebo** kuwa 1/17 -> karibu **7%**.

Ikiwa kernel inapata **granule ya lebo isiyo sahihi**, **tofauti** itagunduliwa. Ikiwa inapata eneo lingine la kumbukumbu, ikiwa **kumbukumbu ina lebo tofauti** (au lebo isiyo sahihi) tofauti itagunduliwa. Ikiwa mshambuliaji ana bahati na kumbukumbu inatumia lebo ile ile, haitagunduliwa. Uwezekano ni karibu 7%.

Kosa lingine linatokea katika **granule ya mwisho** ya kumbukumbu iliyotolewa. Ikiwa programu iliiomba 35B, ilipatiwa granule kutoka 32 hadi 48. Kwa hivyo, **bytes kutoka 36 hadi 47 zinatumia lebo ile ile** lakini hazikuombwa. Ikiwa mshambuliaji anapata **bytes hizi za ziada, hii haitagunduliwa**.

Wakati **`kfree()`** inatekelezwa, kumbukumbu inarejeshwa na lebo isiyo sahihi, hivyo katika **matumizi-baada-ya-kuachiliwa**, wakati kumbukumbu inafikiwa tena, **tofauti inagunduliwa**.

Hata hivyo, katika matumizi-baada-ya-kuachiliwa, ikiwa **kipande kile kile kinarejeshwa tena na lebo ILE ILE** kama awali, mshambuliaji ataweza kutumia ufikiaji huu na hii haitagunduliwa (karibu 7% uwezekano).

Zaidi ya hayo, ni **`slab` na `page_alloc`** pekee zinazotumia kumbukumbu iliyo na lebo lakini katika siku zijazo hii pia itatumika katika `vmalloc`, `stack` na `globals` (wakati wa video hizi bado zinaweza kutumika vibaya).

Wakati **tofauti inagunduliwa** kernel itakuwa **na wasiwasi** ili kuzuia matumizi zaidi na majaribio ya unyakuzi (MTE haina matokeo ya uwongo).

## References

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
