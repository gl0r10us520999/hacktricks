# Proširenje oznake memorije (MTE)

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne informacije

**Proširenje oznake memorije (MTE)** dizajnirano je da poboljša pouzdanost i sigurnost softvera **detektovanjem i sprečavanjem grešaka povezanih sa memorijom**, poput prelivanja bafera i ranjivosti nakon oslobađanja. MTE, kao deo arhitekture **ARM**, pruža mehanizam za pričvršćivanje **male oznake na svaku alokaciju memorije** i **odgovarajuću oznaku na svaki pokazivač** koji se odnosi na tu memoriju. Ovaj pristup omogućava detekciju nelegalnih pristupa memoriji u toku izvršavanja, značajno smanjujući rizik od iskorišćavanja takvih ranjivosti za izvršavanje proizvoljnog koda.

### **Kako radi proširenje oznake memorije**

MTE funkcioniše tako što **deli memoriju na male blokove fiksne veličine, pri čemu se svakom bloku dodeljuje oznaka**, obično nekoliko bitova u veličini.&#x20;

Kada se kreira pokazivač koji pokazuje na tu memoriju, dobija istu oznaku. Ova oznaka se čuva u **neiskorišćenim bitovima pokazivača memorije**, efikasno povezujući pokazivač sa odgovarajućim blokom memorije.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokazivača, MTE hardver proverava da li **oznaka pokazivača odgovara oznaci bloka memorije**. Ako se oznake **ne podudaraju**, to ukazuje na **nelegalan pristup memoriji**.

### Oznake pokazivača MTE

Oznake unutar pokazivača čuvaju se u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogućava do **16 različitih vrednosti oznaka**.

### Oznake memorije MTE

Svaka **16B fizičke memorije** ima odgovarajuću **oznaku memorije**.

Oznake memorije čuvaju se u **dedikovanom RAM regionu** (nije dostupan za normalnu upotrebu). Imajući 4-bitne oznake za svakih 16B oznaka memorije do 3% RAM-a.

ARM uvodi sledeće instrukcije za manipulisanje ovim oznakama u dedikovanom RAM-u:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Provera režima

### Sinkrono

CPU proverava oznake **tokom izvršavanja instrukcija**, ako postoji neslaganje, podiže izuzetak.\
Ovo je najsporije i najsigurnije.

### Asinkrono

CPU proverava oznake **asinhrono**, i kada se pronađe neslaganje, postavlja bit izuzetka u jedan od registara sistema. Brže je od prethodnog, ali **nije u mogućnosti da pokaže** tačnu instrukciju koja je uzrokovala neslaganje i ne podiže izuzetak odmah, pružajući vremena napadaču da završi svoj napad.

### Mešovito

???

## Primeri implementacije i detekcije

Nazvan Hardverski Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (poput `kmalloc`) će **pozvati ovaj modul** koji će pripremiti oznaku za korišćenje (nasumično) i priložiti je na alocirani kernel prostor i na vraćeni pokazivač.

Imajte na umu da će označiti **samo dovoljno memorijskih granula** (svaka 16B) za traženu veličinu. Dakle, ako je tražena veličina bila 35 i dodeljen je blok od 60B, označiće prvih 16\*3 = 48B ovom oznakom, a **ostatak** će biti **označen** tzv. **nevažećom oznakom (0xE)**.

Oznaka **0xF** je **poklapanje svih pokazivača**. Memorija sa ovim pokazivačem dozvoljava **bilo koju oznaku za pristup** svojoj memoriji (bez neslaganja). Ovo bi moglo sprečiti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka jer su 0xE i 0xF rezervisani, dajući verovatnoću **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **nevažećoj memorijskoj granuli**, **neslaganje** će biti **detektovano**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima drugačiju oznaku** (ili nevažeću oznaku), neslaganje će biti **detektovano**. Ako napadač ima sreće i memorija koristi istu oznaku, neće biti detektovano. Verovatnoća je oko 7%.

Još jedan problem se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija zatražila 35B, dodeljena je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu bili traženi. Ako napadač pristupi **ovim dodatnim bajtovima, to neće biti detektovano**.

Kada se izvrši **`kfree()`**, memorija se ponovo označava nevažećom oznakom, tako da u slučaju **ponovnog korišćenja nakon oslobađanja**, kada se memorija ponovo pristupi, **neslaganje se detektuje**.

Međutim, u slučaju ponovnog korišćenja nakon oslobađanja, ako je isti **blok ponovo alociran sa ISTOM oznakom** kao prethodno, napadač će moći da koristi ovaj pristup i to neće biti detektovano (oko 7% šanse).

Osim toga, samo **`slab` i `page_alloc`** koriste označenu memoriju, ali u budućnosti će se ovo koristiti i u `vmalloc`, `stack` i `globals` (u trenutku videa ovo još uvek može biti zloupotrebljeno).

Kada se **detektuje neslaganje**, kernel će **paničiti** kako bi sprečio dalje iskorišćavanje i pokušaje eksploatacije (MTE nema lažnih pozitiva).

## Reference

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
