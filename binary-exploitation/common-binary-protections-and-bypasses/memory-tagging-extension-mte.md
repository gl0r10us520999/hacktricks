# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)**, bellekle ilgili hataları, örneğin tampon taşmaları ve kullanımdan sonra serbest bırakma güvenlik açıklarını **tespit etmek ve önlemek** amacıyla yazılım güvenilirliğini ve güvenliğini artırmak için tasarlanmıştır. MTE, **ARM** mimarisinin bir parçası olarak, her bellek tahsisine **küçük bir etiket eklemek** ve o belleği referans alan her işaretçiye **karşılık gelen bir etiket** sağlamak için bir mekanizma sunar. Bu yaklaşım, çalışma zamanında yasadışı bellek erişimlerinin tespit edilmesine olanak tanır ve bu tür güvenlik açıklarının rastgele kod çalıştırmak için istismar edilme riskini önemli ölçüde azaltır.

### **How Memory Tagging Extension Works**

MTE, **belleği küçük, sabit boyutlu bloklara bölerek çalışır; her blok bir etiketle atanır,** genellikle birkaç bit boyutundadır.&#x20;

Bir işaretçi o belleği işaret etmek için oluşturulduğunda, aynı etiketi alır. Bu etiket, **bir bellek işaretçisinin kullanılmayan bitlerinde** saklanır ve işaretçiyi karşılık gelen bellek bloğuna etkili bir şekilde bağlar.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Bir program bir işaretçi aracılığıyla belleğe eriştiğinde, MTE donanımı **işaretçinin etiketi ile bellek bloğunun etiketinin eşleşip eşleşmediğini** kontrol eder. Eğer etiketler **eşleşmiyorsa**, bu bir **yasadışı bellek erişimi** olduğunu gösterir.

### MTE Pointer Tags

Bir işaretçi içindeki etiketler, en üst byte içinde 4 bit olarak saklanır:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Bu nedenle, bu **16 farklı etiket değeri** olmasına olanak tanır.

### MTE Memory Tags

Her **16B fiziksel bellek** için karşılık gelen bir **bellek etiketi** vardır.

Bellek etiketleri, **normal kullanım için erişilemeyen** bir **özel RAM bölgesinde** saklanır. Her 16B bellek etiketi için 4 bit etiket olması, RAM'in %3'üne kadar çıkabilir.

ARM, bu etiketleri özel RAM belleğinde işlemek için aşağıdaki talimatları tanıtır:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Kontrol Modları

### Senkron

CPU, etiketleri **talimat yürütülürken** kontrol eder, eğer bir uyumsuzluk varsa, bir istisna oluşturur.\
Bu en yavaş ve en güvenli olanıdır.

### Asenkron

CPU, etiketleri **asenkron olarak** kontrol eder ve bir uyumsuzluk bulunduğunda, sistem kayıtlarından birinde bir istisna biti ayarlar. Bu, önceki yöntemden **daha hızlıdır** ancak uyumsuzluğa neden olan tam talimatı **belirleyemez** ve istisnayı hemen oluşturmaz, saldırgana saldırısını tamamlama süresi tanır.

### Karışık

???

## Uygulama ve Tespit Örnekleri

Donanım Etiket Tabanlı KASAN, MTE tabanlı KASAN veya çekirdek içi MTE olarak adlandırılır.\
Çekirdek ayırıcıları (örneğin `kmalloc`), kullanılacak etiketi hazırlamak için **bu modülü çağırır** (rastgele) ve bunu ayrılan çekirdek alanına ve döndürülen işaretçiye ekler.

Talep edilen boyut için **yeterli bellek granüllerini** (her biri 16B) **sadece işaretleyecektir**. Yani, talep edilen boyut 35 ise ve 60B'lik bir slab verilmişse, bu etiketle ilk 16\*3 = 48B'yi işaretleyecek ve **geri kalan** **geçersiz etiket (0xE)** ile **işaretlenecektir**.

Etiket **0xF**, **tüm işaretçileri eşleştiren** etikettir. Bu işaretçiye sahip bir bellek, belleğine erişmek için **herhangi bir etiketin kullanılmasına** izin verir (uyumsuzluk yok). Bu, bu etiketin saldırıya uğramış bellek içinde kullanılması durumunda MET'in bir saldırıyı tespit etmesini engelleyebilir.

Bu nedenle, 0xE ve 0xF rezerve edildiğinden, etiket oluşturmak için yalnızca **14 değer** kullanılabilir, bu da etiketlerin **yeniden kullanılma** olasılığını 1/17 -> yaklaşık **%7** yapar.

Eğer çekirdek **geçersiz etiket granülüne** erişirse, **uyumsuzluk** **tespit edilir**. Eğer başka bir bellek konumuna erişirse, eğer **bellek farklı bir etikete** (veya geçersiz etikete) sahipse, uyumsuzluk **tespit edilir**. Eğer saldırgan şanslıysa ve bellek aynı etiketi kullanıyorsa, bu tespit edilmez. Olasılıklar yaklaşık %7'dir.

Başka bir hata, ayrılan belleğin **son granülünde** meydana gelir. Eğer uygulama 35B talep ettiyse, 32'den 48'e kadar olan granül verilmiştir. Bu nedenle, **36'dan 47'ye kadar olan baytlar aynı etiketi kullanmaktadır** ancak bunlar talep edilmemiştir. Eğer saldırgan **bu ekstra baytlara erişirse, bu tespit edilmez**.

**`kfree()`** çalıştırıldığında, bellek geçersiz bellek etiketi ile yeniden etiketlenir, bu nedenle bir **kullanım-sonrası-serbest** durumunda, bellek tekrar erişildiğinde, **uyumsuzluk tespit edilir**.

Ancak, bir kullanım-sonrası-serbest durumunda, eğer aynı **parça, daha önceki ile AYNI etiketle** yeniden tahsis edilirse, bir saldırgan bu erişimi kullanabilir ve bu tespit edilmez (yaklaşık %7 şans).

Ayrıca, yalnızca **`slab` ve `page_alloc`** etiketli belleği kullanır, ancak gelecekte bu `vmalloc`, `stack` ve `globals` içinde de kullanılacaktır (videonun çekildiği anda bunlar hala kötüye kullanılabilir).

Bir **uyumsuzluk tespit edildiğinde**, çekirdek daha fazla istismar ve istismar denemelerini önlemek için **panik yapacaktır** (MTE'nin yanlış pozitifleri yoktur).

## Referanslar

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
