# メモリタギング拡張（MTE）

{% hint style="success" %}
AWSハッキングの学習と練習：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

- [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
- **HackTricks**と**HackTricks Cloud**のGitHubリポジトリにPRを提出して、ハッキングトリックを共有してください。

</details>
{% endhint %}

## 基本情報

**メモリタギング拡張（MTE）**は、**バッファオーバーフロー**や**解放後使用**の脆弱性などの**メモリ関連エラーを検出および防止**することで、ソフトウェアの信頼性とセキュリティを向上させるために設計されています。**ARM**アーキテクチャの一部であるMTEは、**各メモリ割り当てに小さなタグを添付**し、そのメモリを参照する**各ポインタに対応するタグ**を提供します。このアプローチにより、実行時に不正なメモリアクセスを検出し、そのような脆弱性を悪用して任意のコードを実行するリスクを大幅に低減します。

### **メモリタギング拡張の動作方法**

MTEは、**メモリを小さな固定サイズのブロックに分割し、各ブロックにタグを割り当てる**ことによって動作します。

ポインタがそのメモリを指すように作成されると、同じタグが付与されます。このタグは、**メモリポインタの未使用ビットに格納**され、効果的にポインタを対応するメモリブロックにリンクします。

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

プログラムがポインタを介してメモリにアクセスすると、MTEハードウェアは**ポインタのタグがメモリブロックのタグと一致するかどうか**をチェックします。タグが**一致しない**場合、不正なメモリアクセスを示します。

### MTEポインタタグ

ポインタ内のタグは、トップバイト内の4ビットに格納されます。

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

したがって、これにより最大**16種類の異なるタグ値**が可能となります。

### MTEメモリタグ

**物理メモリの16Bごと**に対応する**メモリタグ**があります。

メモリタグは、**専用のRAM領域**に格納されています（通常の使用ではアクセス不可）。16Bメモリタグごとに4ビットのタグを持つことで、RAMの3%までです。

ARMは、これらのタグを専用のRAMメモリで操作するために次の命令を導入しています。
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## チェックモード

### 同期

CPUは**命令の実行中に**タグをチェックし、不一致があると例外を発生させます。\
これは最も遅くて最も安全です。

### 非同期

CPUは**非同期的に**タグをチェックし、不一致が見つかるとシステムレジスタの1つに例外ビットを設定します。前のものより**速い**ですが、不一致を引き起こす正確な命令を指摘することが**できず**、例外をすぐに発生させず、攻撃者に攻撃を完了する時間を与えます。

### ミックス

???

## 実装と検出の例

ハードウェアタグベースのKASAN、MTEベースのKASAN、またはカーネル内MTEと呼ばれます。\
カーネルアロケータ（`kmalloc`など）は、**このモジュールを呼び出し**、使用するタグを準備し（ランダムに）、カーネルスペースに割り当てられた領域と返されたポインタにそれをアタッチします。

要求されたサイズに十分なメモリグラニュール（それぞれ16B）だけを**マーク**します。したがって、要求されたサイズが35で60Bのスラブが与えられた場合、最初の16\*3 = 48Bをこのタグでマークし、**残り**は**所定の無効なタグ（0xE）**で**マーク**されます。

タグ**0xF**は**すべてのポインタに一致**します。このポインタを持つメモリには、そのメモリにアクセスするために**任意のタグを使用**できます（不一致がありません）。これにより、攻撃が検出されない可能性があります。

したがって、タグを生成するために使用できる**値は14個だけ**であり、0xEと0xFが予約されているため、タグを再利用する確率は1/17 -> 約**7%**です。

カーネルが**無効なタグのグラニュール**にアクセスすると、**不一致**が**検出**されます。別のメモリ位置にアクセスする場合、**メモリに異なるタグ**（または無効なタグ）がある場合、不一致が**検出**されます。攻撃者が幸運でメモリが同じタグを使用している場合、検出されません。確率は約7%です。

もう1つのバグは、割り当てられたメモリの**最後のグラニュール**で発生します。アプリケーションが35Bを要求した場合、32から48までのグラニュールが与えられます。したがって、36から47までのバイトは同じタグを使用していますが、要求されていません。攻撃者が**これらの余分なバイトにアクセスすると、これは検出されません**。

**`kfree()`**が実行されると、メモリは無効なメモリタグで再タグ付けされるため、**再利用後の使用**では、メモリに再度アクセスすると**不一致が検出**されます。

ただし、再利用後の使用では、以前と**同じタグのチャンクが再度割り当てられる場合**、攻撃者はこのアクセスを使用でき、これは検出されません（約7%の確率）。

さらに、**`slab`と`page_alloc`**のみがタグ付きメモリを使用しますが、将来的には`vmalloc`、`stack`、`globals`でも使用される予定です（ビデオの時点ではこれらはまだ悪用される可能性があります）。

**不一致が検出**されると、カーネルは**パニック**して、さらなる悪用や攻撃の再試行を防ぎます（MTEには誤検知がありません）。

## 参考文献

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
