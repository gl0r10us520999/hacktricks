# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** est치 dise침ado para mejorar la fiabilidad y seguridad del software al **detectar y prevenir errores relacionados con la memoria**, como desbordamientos de b칰fer y vulnerabilidades de uso despu칠s de liberar. MTE, como parte de la **arquitectura ARM**, proporciona un mecanismo para adjuntar una **peque침a etiqueta a cada asignaci칩n de memoria** y una **etiqueta correspondiente a cada puntero** que referencia esa memoria. Este enfoque permite la detecci칩n de accesos ilegales a la memoria en tiempo de ejecuci칩n, reduciendo significativamente el riesgo de explotar tales vulnerabilidades para ejecutar c칩digo arbitrario.

### **How Memory Tagging Extension Works**

MTE opera **dividiendo la memoria en peque침os bloques de tama침o fijo, con cada bloque asignado a una etiqueta,** t칤picamente de unos pocos bits de tama침o.&#x20;

Cuando se crea un puntero para apuntar a esa memoria, recibe la misma etiqueta. Esta etiqueta se almacena en los **bits no utilizados de un puntero de memoria**, vinculando efectivamente el puntero a su bloque de memoria correspondiente.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Cuando un programa accede a la memoria a trav칠s de un puntero, el hardware de MTE verifica que la **etiqueta del puntero coincida con la etiqueta del bloque de memoria**. Si las etiquetas **no coinciden**, indica un **acceso ilegal a la memoria.**

### MTE Pointer Tags

Las etiquetas dentro de un puntero se almacenan en 4 bits dentro del byte superior:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Por lo tanto, esto permite hasta **16 valores de etiqueta diferentes**.

### MTE Memory Tags

Cada **16B de memoria f칤sica** tiene una **etiqueta de memoria** correspondiente.

Las etiquetas de memoria se almacenan en una **regi칩n de RAM dedicada** (no accesible para uso normal). Tener etiquetas de 4 bits para cada 16B de etiquetas de memoria hasta el 3% de RAM.

ARM introduce las siguientes instrucciones para manipular estas etiquetas en la memoria RAM dedicada:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modos de Verificaci칩n

### Sincronizado

La CPU verifica las etiquetas **durante la ejecuci칩n de la instrucci칩n**, si hay una discrepancia, genera una excepci칩n.\
Este es el m치s lento y seguro.

### Asincronizado

La CPU verifica las etiquetas **asincr칩nicamente**, y cuando se encuentra una discrepancia, establece un bit de excepci칩n en uno de los registros del sistema. Es **m치s r치pido** que el anterior, pero es **incapaz de se침alar** la instrucci칩n exacta que caus칩 la discrepancia y no genera la excepci칩n de inmediato, dando algo de tiempo al atacante para completar su ataque.

### Mixto

???

## Ejemplos de Implementaci칩n y Detecci칩n

Llamado KASAN basado en etiquetas de hardware, KASAN basado en MTE o MTE en el n칰cleo.\
Los asignadores del n칰cleo (como `kmalloc`) **llamar치n a este m칩dulo** que preparar치 la etiqueta para usar (aleatoriamente) y la adjuntar치 al espacio del n칰cleo asignado y al puntero devuelto.

Ten en cuenta que **solo marcar치 suficientes gr치nulos de memoria** (16B cada uno) para el tama침o solicitado. As칤 que si el tama침o solicitado fue 35 y se dio un bloque de 60B, marcar치 los primeros 16\*3 = 48B con esta etiqueta y el **resto** ser치 **marcado** con una llamada **etiqueta inv치lida (0xE)**.

La etiqueta **0xF** es el **puntero que coincide con todos**. Una memoria con este puntero permite **usar cualquier etiqueta** para acceder a su memoria (sin discrepancias). Esto podr칤a evitar que MET detecte un ataque si esta etiqueta se est치 utilizando en la memoria atacada.

Por lo tanto, solo hay **14 valores** que se pueden usar para generar etiquetas, ya que 0xE y 0xF est치n reservados, dando una probabilidad de **reutilizar etiquetas** de 1/17 -> alrededor del **7%**.

Si el n칰cleo accede al **gr치nulo de etiqueta inv치lida**, la **discrepancia** ser치 **detectada**. Si accede a otra ubicaci칩n de memoria, si la **memoria tiene una etiqueta diferente** (o la etiqueta inv치lida), la discrepancia ser치 **detectada**. Si el atacante tiene suerte y la memoria est치 usando la misma etiqueta, no ser치 detectada. Las probabilidades son alrededor del 7%.

Otro error ocurre en el **칰ltimo gr치nulo** de la memoria asignada. Si la aplicaci칩n solicit칩 35B, se le dio el gr치nulo de 32 a 48. Por lo tanto, los **bytes del 36 al 47 est치n usando la misma etiqueta** pero no fueron solicitados. Si el atacante accede a **estos bytes extra, esto no se detecta**.

Cuando se ejecuta **`kfree()`**, la memoria se vuelve a etiquetar con la etiqueta de memoria inv치lida, por lo que en un **uso despu칠s de liberar**, cuando la memoria se accede nuevamente, la **discrepancia se detecta**.

Sin embargo, en un uso despu칠s de liberar, si el mismo **bloque se vuelve a asignar nuevamente con la MISMA etiqueta** que anteriormente, un atacante podr치 usar este acceso y esto no ser치 detectado (alrededor del 7% de probabilidad).

Adem치s, solo **`slab` y `page_alloc`** utilizan memoria etiquetada, pero en el futuro esto tambi칠n se utilizar치 en `vmalloc`, `stack` y `globals` (en el momento del video, estos a칰n pueden ser abusados).

Cuando se **detecta una discrepancia**, el n칰cleo **se bloquear치** para prevenir una mayor explotaci칩n y reintentos del exploit (MTE no tiene falsos positivos).

## Referencias

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
