# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** √© projetado para aumentar a confiabilidade e seguran√ßa do software, **detectando e prevenindo erros relacionados √† mem√≥ria**, como estouros de buffer e vulnerabilidades de uso ap√≥s a libera√ß√£o. O MTE, como parte da arquitetura **ARM**, fornece um mecanismo para anexar um **pequeno r√≥tulo a cada aloca√ß√£o de mem√≥ria** e um **r√≥tulo correspondente a cada ponteiro** que referencia essa mem√≥ria. Essa abordagem permite a detec√ß√£o de acessos ilegais √† mem√≥ria em tempo de execu√ß√£o, reduzindo significativamente o risco de explorar tais vulnerabilidades para executar c√≥digo arbitr√°rio.

### **How Memory Tagging Extension Works**

O MTE opera **dividindo a mem√≥ria em pequenos blocos de tamanho fixo, com cada bloco atribu√≠do a um r√≥tulo,** tipicamente de alguns bits de tamanho.&#x20;

Quando um ponteiro √© criado para apontar para essa mem√≥ria, ele recebe o mesmo r√≥tulo. Esse r√≥tulo √© armazenado nos **bits n√£o utilizados de um ponteiro de mem√≥ria**, vinculando efetivamente o ponteiro ao seu bloco de mem√≥ria correspondente.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando um programa acessa a mem√≥ria atrav√©s de um ponteiro, o hardware MTE verifica se o **r√≥tulo do ponteiro corresponde ao r√≥tulo do bloco de mem√≥ria**. Se os r√≥tulos **n√£o corresponderem**, isso indica um **acesso ilegal √† mem√≥ria.**

### MTE Pointer Tags

Os r√≥tulos dentro de um ponteiro s√£o armazenados em 4 bits dentro do byte superior:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Portanto, isso permite at√© **16 valores de r√≥tulo diferentes**.

### MTE Memory Tags

Cada **16B de mem√≥ria f√≠sica** tem um **r√≥tulo de mem√≥ria** correspondente.

Os r√≥tulos de mem√≥ria s√£o armazenados em uma **regi√£o de RAM dedicada** (n√£o acess√≠vel para uso normal). Tendo r√≥tulos de 4 bits para cada 16B de r√≥tulos de mem√≥ria, at√© 3% da RAM.

A ARM introduz as seguintes instru√ß√µes para manipular esses r√≥tulos na mem√≥ria RAM dedicada:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

A CPU verifica as tags **durante a execu√ß√£o da instru√ß√£o**, se houver uma incompatibilidade, ela gera uma exce√ß√£o.\
Este √© o mais lento e mais seguro.

### Async

A CPU verifica as tags **ass√≠ncronamente**, e quando uma incompatibilidade √© encontrada, ela define um bit de exce√ß√£o em um dos registradores do sistema. √â **mais r√°pido** do que o anterior, mas √© **incapaz de apontar** a instru√ß√£o exata que causou a incompatibilidade e n√£o gera a exce√ß√£o imediatamente, dando algum tempo ao atacante para completar seu ataque.

### Mixed

???

## Implementation & Detection Examples

Chamado de KASAN baseado em tags de hardware, KASAN baseado em MTE ou MTE em kernel.\
Os alocadores do kernel (como `kmalloc`) **chamar√£o este m√≥dulo** que preparar√° a tag para usar (aleatoriamente) anex√°-la ao espa√ßo do kernel alocado e ao ponteiro retornado.

Note que ele **marcar√° apenas gr√¢nulos de mem√≥ria suficientes** (16B cada) para o tamanho solicitado. Portanto, se o tamanho solicitado foi 35 e um bloco de 60B foi dado, ele marcar√° os primeiros 16\*3 = 48B com esta tag e o **restante** ser√° **marcado** com uma chamada de **tag inv√°lida (0xE)**.

A tag **0xF** √© o **ponteiro que combina com todos**. Uma mem√≥ria com este ponteiro permite que **qualquer tag seja usada** para acessar sua mem√≥ria (sem incompatibilidades). Isso poderia impedir que o MET detectasse um ataque se essas tags estiverem sendo usadas na mem√≥ria atacada.

Portanto, existem apenas **14 valores** que podem ser usados para gerar tags, pois 0xE e 0xF s√£o reservados, dando uma probabilidade de **reutiliza√ß√£o de tags** de 1/17 -> cerca de **7%**.

Se o kernel acessar o **gr√¢nulo de tag inv√°lida**, a **incompatibilidade** ser√° **detectada**. Se acessar outro local de mem√≥ria, se a **mem√≥ria tiver uma tag diferente** (ou a tag inv√°lida), a incompatibilidade ser√° **detectada**. Se o atacante tiver sorte e a mem√≥ria estiver usando a mesma tag, n√£o ser√° detectada. As chances s√£o de cerca de 7%.

Outro bug ocorre no **√∫ltimo gr√¢nulo** da mem√≥ria alocada. Se a aplica√ß√£o solicitou 35B, foi dado o gr√¢nulo de 32 a 48. Portanto, os **bytes de 36 a 47 est√£o usando a mesma tag** mas n√£o foram solicitados. Se o atacante acessar **esses bytes extras, isso n√£o √© detectado**.

Quando **`kfree()`** √© executado, a mem√≥ria √© retagged com a tag de mem√≥ria inv√°lida, ent√£o em um **use-after-free**, quando a mem√≥ria √© acessada novamente, a **incompatibilidade √© detectada**.

No entanto, em um use-after-free, se o mesmo **chunk for realocado novamente com a MESMA tag** que anteriormente, um atacante poder√° usar esse acesso e isso n√£o ser√° detectado (cerca de 7% de chance).

Al√©m disso, apenas **`slab` e `page_alloc`** usam mem√≥ria marcada, mas no futuro isso tamb√©m ser√° usado em `vmalloc`, `stack` e `globals` (no momento do v√≠deo, esses ainda podem ser abusados).

Quando uma **incompatibilidade √© detectada**, o kernel ir√° **panic** para evitar mais explora√ß√£o e tentativas do exploit (MTE n√£o tem falsos positivos).

## References

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
