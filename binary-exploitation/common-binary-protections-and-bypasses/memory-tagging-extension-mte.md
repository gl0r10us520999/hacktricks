# Estensione del Tagging della Memoria (MTE)

{% hint style="success" %}
Impara e pratica l'Hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di Github.

</details>
{% endhint %}

## Informazioni di Base

**Memory Tagging Extension (MTE)** √® progettato per migliorare l'affidabilit√† e la sicurezza del software **rilevando e prevenendo errori legati alla memoria**, come buffer overflow e vulnerabilit√† di uso dopo la liberazione. MTE, come parte dell'architettura **ARM**, fornisce un meccanismo per allegare un **piccolo tag a ogni allocazione di memoria** e un **tag corrispondente a ogni puntatore** che fa riferimento a quella memoria. Questo approccio consente di rilevare gli accessi illegali alla memoria durante l'esecuzione, riducendo significativamente il rischio di sfruttare tali vulnerabilit√† per eseguire codice arbitrario.

### **Come Funziona l'Estensione del Tagging della Memoria**

MTE opera **dividendo la memoria in blocchi di dimensioni fisse**, con ciascun blocco assegnato un tag, tipicamente di pochi bit.

Quando viene creato un puntatore per puntare a quella memoria, ottiene lo stesso tag. Questo tag √® memorizzato nei **bit non utilizzati di un puntatore di memoria**, collegando efficacemente il puntatore al suo blocco di memoria corrispondente.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando un programma accede alla memoria tramite un puntatore, l'hardware MTE controlla che il **tag del puntatore corrisponda al tag del blocco di memoria**. Se i tag **non corrispondono**, indica un **accesso illegale alla memoria**.

### Tag dei Puntatori MTE

I tag all'interno di un puntatore sono memorizzati in 4 bit all'interno del byte superiore:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Ci√≤ consente fino a **16 valori di tag diversi**.

### Tag della Memoria MTE

Ogni **16B di memoria fisica** ha un **tag di memoria corrispondente**.

I tag di memoria sono memorizzati in una **regione RAM dedicata** (non accessibile per un uso normale). Avendo tag di 4 bit per ogni tag di memoria di 16B, fino al 3% di RAM.

ARM introduce le seguenti istruzioni per manipolare questi tag nella memoria RAM dedicata:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modalit√† di controllo

### Sync

La CPU controlla i tag **durante l'esecuzione dell'istruzione**, se c'√® una discrepanza, genera un'eccezione.\
Questa √® la pi√π lenta e sicura.

### Async

La CPU controlla i tag **in modo asincrono**, e quando trova una discrepanza imposta un bit di eccezione in uno dei registri di sistema. √à **pi√π veloce** della precedente ma non √® in grado di indicare l'istruzione esatta che ha causato la discrepanza e non genera immediatamente l'eccezione, dando del tempo all'attaccante per completare il suo attacco.

### Misto

???

## Esempi di Implementazione e Rilevamento

Chiamato KASAN basato su tag hardware, KASAN basato su MTE o MTE nel kernel.\
Gli allocatori del kernel (come `kmalloc`) **chiameranno questo modulo** che preparer√† il tag da utilizzare (casualmente) per attaccarlo allo spazio kernel allocato e al puntatore restituito.

Si noti che verranno **contrassegnati solo abbastanza granuli di memoria** (16B ciascuno) per la dimensione richiesta. Quindi, se la dimensione richiesta era 35 e veniva fornito uno slab di 60B, verranno contrassegnati i primi 16\*3 = 48B con questo tag e il **resto** verr√† **contrassegnato** con un cosiddetto **tag non valido (0xE)**.

Il tag **0xF** √® il **puntatore di corrispondenza totale**. Una memoria con questo puntatore consente **l'uso di qualsiasi tag** per accedere alla sua memoria (nessuna discrepanza). Ci√≤ potrebbe impedire a MET di rilevare un attacco se questo tag viene utilizzato nella memoria attaccata.

Pertanto ci sono solo **14 valori** che possono essere utilizzati per generare tag poich√© 0xE e 0xF sono riservati, dando una probabilit√† di **riutilizzo dei tag** pari a 1/17 -> circa **7%**.

Se il kernel accede al **granulo con tag non valido**, la **discrepanza** verr√† **rilevata**. Se accede a un'altra posizione di memoria, se la **memoria ha un tag diverso** (o il tag non valido) la discrepanza verr√† **rilevata**. Se l'attaccante ha fortuna e la memoria utilizza lo stesso tag, non verr√† rilevata. Le probabilit√† sono circa del 7%.

Un altro bug si verifica nell'**ultimo granulo** della memoria allocata. Se l'applicazione ha richiesto 35B, le √® stato dato il granulo dal 32 al 48. Pertanto, i **byte dal 36 al 47 utilizzano lo stesso tag** ma non sono stati richiesti. Se l'attaccante accede a **questi byte extra, ci√≤ non viene rilevato**.

Quando viene eseguito **`kfree()`**, la memoria viene contrassegnata nuovamente con il tag di memoria non valido, quindi in un **uso dopo la liberazione**, quando la memoria viene nuovamente accessa, la **discrepanza viene rilevata**.

Tuttavia, in un uso dopo la liberazione, se lo stesso **blocco viene riallocato nuovamente con lo STESSO tag** come precedentemente, un attaccante potr√† utilizzare questo accesso e ci√≤ non verr√† rilevato (circa il 7% di probabilit√†).

Inoltre, solo **`slab` e `page_alloc`** utilizzano la memoria contrassegnata ma in futuro verr√† utilizzata anche in `vmalloc`, `stack` e `globals` (al momento del video questi possono ancora essere abusati).

Quando viene rilevata una **discrepanza**, il kernel **va in panico** per impedire ulteriori sfruttamenti e tentativi dell'exploit (MTE non ha falsi positivi).

## Riferimenti

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
