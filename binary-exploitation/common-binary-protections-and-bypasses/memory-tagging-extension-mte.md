# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** je dizajniran da pobolj코a pouzdanost i sigurnost softvera tako 코to **otkriva i spre캜ava gre코ke povezane sa memorijom**, kao 코to su prelivanja bafera i ranjivosti kori코캖enja nakon osloba캠anja. MTE, kao deo **ARM** arhitekture, pru쬬 mehanizam za pridru쬴vanje **malog taga svakoj alokaciji memorije** i **odgovaraju캖eg taga svakom pokaziva캜u** koji referencira tu memoriju. Ovaj pristup omogu캖ava otkrivanje ilegalnih pristupa memoriji u vreme izvo캠enja, zna캜ajno smanjuju캖i rizik od iskori코캖avanja takvih ranjivosti za izvr코avanje proizvoljnog koda.

### **How Memory Tagging Extension Works**

MTE funkcioni코e tako 코to **deliti memoriju na male, fiksne blokove, pri 캜emu je svakom bloku dodeljen tag,** obi캜no veli캜ine nekoliko bita.&#x20;

Kada se kreira pokaziva캜 koji pokazuje na tu memoriju, dobija isti tag. Ovaj tag se 캜uva u **neiskori코캖enim bitovima pokaziva캜a u memoriji**, efektivno povezuju캖i pokaziva캜 sa odgovaraju캖im blokom memorije.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokaziva캜a, MTE hardver proverava da li **tag pokaziva캜a odgovara tagu memorijskog bloka**. Ako se tagovi **ne poklapaju**, to ukazuje na **ilegalan pristup memoriji.**

### MTE Pointer Tags

Tagovi unutar pokaziva캜a se 캜uvaju u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogu캖ava do **16 razli캜itih vrednosti taga**.

### MTE Memory Tags

Svaka **16B fizi캜ke memorije** ima odgovaraju캖i **tag memorije**.

Tagovi memorije se 캜uvaju u **posve캖enoj RAM oblasti** (koja nije dostupna za normalnu upotrebu). Imaju캖i 4bita tagove za svaki 16B tag memorije do 3% RAM-a.

ARM uvodi slede캖e instrukcije za manipulaciju ovim tagovima u posve캖enoj RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU proverava oznake **tokom izvr코avanja instrukcija**, ako do캠e do neslaganja, podi쬰 izuzetak.\
Ovo je najsporije i najbezbednije.

### Async

CPU proverava oznake **asinkrono**, i kada se prona캠e neslaganje, postavlja bit izuzetka u jednom od sistemskih registara. To je **br쬰** od prethodnog, ali je **nesposobno da uka쬰** na ta캜nu instrukciju koja je izazvala neslaganje i ne podi쬰 izuzetak odmah, daju캖i malo vremena napada캜u da zavr코i svoj napad.

### Mixed

???

## Implementation & Detection Examples

Naziva se Hardware Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (kao 코to je `kmalloc`) 캖e **pozvati ovaj modul** koji 캖e pripremiti oznaku za kori코캖enje (slu캜ajno) i prika캜iti je na alocirani kernel prostor i na vra캖eni pokaziva캜.

Napomena da 캖e **ozna캜iti samo dovoljno memorijskih granula** (16B svaka) za tra쬰nu veli캜inu. Dakle, ako je tra쬰na veli캜ina bila 35, a data je granula od 60B, ozna캜i캖e prvih 16\*3 = 48B ovom oznakom, a **ostatak** 캖e biti **ozna캜en** takozvanom **neva쬰캖om oznakom (0xE)**.

Oznaka **0xF** je **pokaziva캜 koji se poklapa sa svime**. Memorija sa ovom oznakom omogu캖ava **bilo koju oznaku da se koristi** za pristup njenoj memoriji (nema neslaganja). Ovo bi moglo spre캜iti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka, jer su 0xE i 0xF rezervisane, 코to daje verovatno캖u **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **neva쬰캖oj granuli oznake**, **neslaganje** 캖e biti **otkriveno**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima druga캜iju oznaku** (ili neva쬰캖u oznaku), neslaganje 캖e biti **otkriveno**. Ako je napada캜 sre캖an i memorija koristi istu oznaku, to ne캖e biti otkriveno. 마nse su oko 7%.

Jo코 jedna gre코ka se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija tra쬴la 35B, data je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu tra쬰ni. Ako napada캜 pristupi **ovim dodatnim bajtovima, to nije otkriveno**.

Kada se izvr코i **`kfree()`**, memorija se ponovo ozna캜ava neva쬰캖om memorijskom oznakom, tako da u **use-after-free**, kada se memorija ponovo pristupi, **neslaganje se otkriva**.

Me캠utim, u use-after-free, ako se isti **deo ponovo alocira sa ISTOM oznakom** kao prethodno, napada캜 캖e mo캖i da iskoristi ovaj pristup i to ne캖e biti otkriveno (oko 7% 코anse).

맚avi코e, samo **`slab` i `page_alloc`** koriste ozna캜enu memoriju, ali u budu캖nosti 캖e se ovo tako캠e koristiti u `vmalloc`, `stack` i `globals` (u trenutku snimanja videa ovo se jo코 uvek mo쬰 zloupotrebiti).

Kada se **neslaganje otkrije**, kernel 캖e **panikovati** da spre캜i dalju eksploataciju i ponovne poku코aje eksploata. (MTE nema la쬹o pozitivne rezultate).

## References

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
