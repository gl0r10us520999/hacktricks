# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** je dizajniran da poboljša pouzdanost i sigurnost softvera tako što **otkriva i sprečava greške povezane sa memorijom**, kao što su prelivanja bafera i ranjivosti korišćenja nakon oslobađanja. MTE, kao deo **ARM** arhitekture, pruža mehanizam za pridruživanje **malog taga svakoj alokaciji memorije** i **odgovarajućeg taga svakom pokazivaču** koji referencira tu memoriju. Ovaj pristup omogućava otkrivanje ilegalnih pristupa memoriji u vreme izvođenja, značajno smanjujući rizik od iskorišćavanja takvih ranjivosti za izvršavanje proizvoljnog koda.

### **How Memory Tagging Extension Works**

MTE funkcioniše tako što **deliti memoriju na male, fiksne blokove, pri čemu je svakom bloku dodeljen tag,** obično veličine nekoliko bita.&#x20;

Kada se kreira pokazivač koji pokazuje na tu memoriju, dobija isti tag. Ovaj tag se čuva u **neiskorišćenim bitovima pokazivača u memoriji**, efektivno povezujući pokazivač sa odgovarajućim blokom memorije.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokazivača, MTE hardver proverava da li **tag pokazivača odgovara tagu memorijskog bloka**. Ako se tagovi **ne poklapaju**, to ukazuje na **ilegalan pristup memoriji.**

### MTE Pointer Tags

Tagovi unutar pokazivača se čuvaju u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogućava do **16 različitih vrednosti taga**.

### MTE Memory Tags

Svaka **16B fizičke memorije** ima odgovarajući **tag memorije**.

Tagovi memorije se čuvaju u **posvećenoj RAM oblasti** (koja nije dostupna za normalnu upotrebu). Imajući 4bita tagove za svaki 16B tag memorije do 3% RAM-a.

ARM uvodi sledeće instrukcije za manipulaciju ovim tagovima u posvećenoj RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU proverava oznake **tokom izvršavanja instrukcija**, ako dođe do neslaganja, podiže izuzetak.\
Ovo je najsporije i najbezbednije.

### Async

CPU proverava oznake **asinkrono**, i kada se pronađe neslaganje, postavlja bit izuzetka u jednom od sistemskih registara. To je **brže** od prethodnog, ali je **nesposobno da ukaže** na tačnu instrukciju koja je izazvala neslaganje i ne podiže izuzetak odmah, dajući malo vremena napadaču da završi svoj napad.

### Mixed

???

## Implementation & Detection Examples

Naziva se Hardware Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (kao što je `kmalloc`) će **pozvati ovaj modul** koji će pripremiti oznaku za korišćenje (slučajno) i prikačiti je na alocirani kernel prostor i na vraćeni pokazivač.

Napomena da će **označiti samo dovoljno memorijskih granula** (16B svaka) za traženu veličinu. Dakle, ako je tražena veličina bila 35, a data je granula od 60B, označiće prvih 16\*3 = 48B ovom oznakom, a **ostatak** će biti **označen** takozvanom **nevažećom oznakom (0xE)**.

Oznaka **0xF** je **pokazivač koji se poklapa sa svime**. Memorija sa ovom oznakom omogućava **bilo koju oznaku da se koristi** za pristup njenoj memoriji (nema neslaganja). Ovo bi moglo sprečiti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka, jer su 0xE i 0xF rezervisane, što daje verovatnoću **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **nevažećoj granuli oznake**, **neslaganje** će biti **otkriveno**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima drugačiju oznaku** (ili nevažeću oznaku), neslaganje će biti **otkriveno**. Ako je napadač srećan i memorija koristi istu oznaku, to neće biti otkriveno. Šanse su oko 7%.

Još jedna greška se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija tražila 35B, data je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu traženi. Ako napadač pristupi **ovim dodatnim bajtovima, to nije otkriveno**.

Kada se izvrši **`kfree()`**, memorija se ponovo označava nevažećom memorijskom oznakom, tako da u **use-after-free**, kada se memorija ponovo pristupi, **neslaganje se otkriva**.

Međutim, u use-after-free, ako se isti **deo ponovo alocira sa ISTOM oznakom** kao prethodno, napadač će moći da iskoristi ovaj pristup i to neće biti otkriveno (oko 7% šanse).

Štaviše, samo **`slab` i `page_alloc`** koriste označenu memoriju, ali u budućnosti će se ovo takođe koristiti u `vmalloc`, `stack` i `globals` (u trenutku snimanja videa ovo se još uvek može zloupotrebiti).

Kada se **neslaganje otkrije**, kernel će **panikovati** da spreči dalju eksploataciju i ponovne pokušaje eksploata. (MTE nema lažno pozitivne rezultate).

## References

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
