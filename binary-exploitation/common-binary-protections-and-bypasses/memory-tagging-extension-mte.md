# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Grundinformationen

**Memory Tagging Extension (MTE)** wurde entwickelt, um die Zuverl√§ssigkeit und Sicherheit von Software zu verbessern, indem **Speicherfehler** wie Puffer√ºberl√§ufe und Use-after-free-Schwachstellen **erkannt und verhindert** werden. MTE, als Teil der **ARM**-Architektur, bietet einen Mechanismus, um **jedem Speicherzuweisung ein kleines Tag zuzuordnen** und ein **entsprechendes Tag jedem Zeiger**, der auf diesen Speicher verweist. Dieser Ansatz erm√∂glicht die Erkennung illegaler Speicherzugriffe zur Laufzeit, wodurch das Risiko, solche Schwachstellen auszunutzen, um beliebigen Code auszuf√ºhren, erheblich verringert wird.

### **Wie die Memory Tagging Extension funktioniert**

MTE funktioniert, indem es den Speicher in kleine, feste Bl√∂cke unterteilt, wobei jedem Block ein Tag zugewiesen wird, typischerweise einige Bits gro√ü.&#x20;

Wenn ein Zeiger erstellt wird, um auf diesen Speicher zu zeigen, erh√§lt er dasselbe Tag. Dieses Tag wird in den **ungenutzten Bits eines Speicherzeigers** gespeichert, wodurch der Zeiger effektiv mit seinem entsprechenden Speicherblock verkn√ºpft wird.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wenn ein Programm √ºber einen Zeiger auf den Speicher zugreift, √ºberpr√ºft die MTE-Hardware, ob das **Tag des Zeigers mit dem Tag des Speicherblocks √ºbereinstimmt**. Wenn die Tags **nicht √ºbereinstimmen**, deutet dies auf einen **illegalen Speicherzugriff** hin.

### MTE-Zeiger-Tags

Tags innerhalb eines Zeigers werden in 4 Bits im obersten Byte gespeichert:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Daher sind bis zu **16 verschiedene Tag-Werte** m√∂glich.

### MTE-Speicher-Tags

Jede **16B physischer Speicher** hat ein entsprechendes **Speicher-Tag**.

Die Speicher-Tags werden in einem **dedizierten RAM-Bereich** gespeichert (nicht f√ºr die normale Nutzung zug√§nglich). Es gibt 4-Bit-Tags f√ºr jede 16B-Speicher-Tags, was bis zu 3% des RAM ausmacht.

ARM f√ºhrt die folgenden Anweisungen ein, um diese Tags im dedizierten RAM-Speicher zu manipulieren:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## √úberpr√ºfungsmodi

### Sync

Die CPU √ºberpr√ºft die Tags **w√§hrend der Ausf√ºhrung der Anweisung**, wenn es eine Diskrepanz gibt, wird eine Ausnahme ausgel√∂st.\
Dies ist die langsamste und sicherste Methode.

### Async

Die CPU √ºberpr√ºft die Tags **asynchron**, und wenn eine Diskrepanz gefunden wird, setzt sie ein Ausnahmebit in einem der Systemregister. Es ist **schneller** als die vorherige Methode, aber es ist **unf√§hig,** die genaue Anweisung anzugeben, die die Diskrepanz verursacht, und es l√∂st die Ausnahme nicht sofort aus, was dem Angreifer etwas Zeit gibt, seinen Angriff abzuschlie√üen.

### Mixed

???

## Implementierungs- & Erkennungsbeispiele

Genannt Hardware-Tag-basiertes KASAN, MTE-basiertes KASAN oder In-Kernel MTE.\
Die Kernel-Allocatoren (wie `kmalloc`) werden **dieses Modul aufrufen**, das das Tag vorbereitet, um es (zuf√§llig) an den zugewiesenen Kernel-Speicher und den zur√ºckgegebenen Zeiger anzuh√§ngen.

Beachten Sie, dass es **nur gen√ºgend Speichergranulate** (jeweils 16B) f√ºr die angeforderte Gr√∂√üe markieren wird. Wenn die angeforderte Gr√∂√üe also 35 war und ein Block von 60B gegeben wurde, wird es die ersten 16\*3 = 48B mit diesem Tag markieren und der **Rest** wird mit einem sogenannten **ung√ºltigen Tag (0xE)** **markiert**.

Das Tag **0xF** ist der **√úbereinstimmungszeiger f√ºr alle**. Ein Speicher mit diesem Zeiger erlaubt es, **jedes Tag zu verwenden**, um auf seinen Speicher zuzugreifen (keine Diskrepanzen). Dies k√∂nnte verhindern, dass MET einen Angriff erkennt, wenn dieses Tag im angegriffenen Speicher verwendet wird.

Daher gibt es nur **14 Werte**, die verwendet werden k√∂nnen, um Tags zu generieren, da 0xE und 0xF reserviert sind, was eine Wahrscheinlichkeit von **Tag-Wiederverwendung** von 1/17 -> etwa **7%** ergibt.

Wenn der Kernel auf das **ung√ºltige Tag-Granulat** zugreift, wird die **Diskrepanz** **erkannt**. Wenn er auf einen anderen Speicherort zugreift, wenn der **Speicher ein anderes Tag hat** (oder das ung√ºltige Tag), wird die Diskrepanz **erkannt**. Wenn der Angreifer Gl√ºck hat und der Speicher dasselbe Tag verwendet, wird es nicht erkannt. Die Chancen liegen bei etwa 7%.

Ein weiterer Fehler tritt im **letzten Granulat** des zugewiesenen Speichers auf. Wenn die Anwendung 35B angefordert hat, wurde das Granulat von 32 bis 48 gegeben. Daher verwenden die **Bytes von 36 bis 47 dasselbe Tag**, wurden jedoch nicht angefordert. Wenn der Angreifer **auf diese zus√§tzlichen Bytes zugreift, wird dies nicht erkannt**.

Wenn **`kfree()`** ausgef√ºhrt wird, wird der Speicher mit dem ung√ºltigen Speichertag neu markiert, sodass bei einem **Use-after-free**, wenn der Speicher erneut zugegriffen wird, die **Diskrepanz erkannt wird**.

Wenn jedoch in einem Use-after-free der gleiche **Block erneut mit dem GLEICHEN Tag** wie zuvor zugewiesen wird, kann ein Angreifer diesen Zugriff nutzen und dies wird nicht erkannt (etwa 7% Chance).

Dar√ºber hinaus verwenden nur **`slab` und `page_alloc`** getaggten Speicher, aber in Zukunft wird dies auch in `vmalloc`, `stack` und `globals` verwendet (zum Zeitpunkt des Videos k√∂nnen diese noch missbraucht werden).

Wenn eine **Diskrepanz erkannt wird**, wird der Kernel **panic** machen, um weitere Ausbeutungen und Wiederholungen des Exploits zu verhindern (MTE hat keine falsch positiven Ergebnisse).

## Referenzen

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
