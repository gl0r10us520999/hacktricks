# Επέκταση Επισήμανσης Μνήμης (MTE)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Κοινοποιήστε κόλπα χάκερ υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Βασικές Πληροφορίες

Η **Επέκταση Επισήμανσης Μνήμης (MTE)** σχεδιάστηκε για να βελτιώσει την αξιοπιστία και την ασφάλεια λογισμικού με το **ανίχνευση και πρόληψη σφαλμάτων σχετικών με τη μνήμη**, όπως buffer overflows και ευπάθειες use-after-free. Η MTE, ως μέρος της αρχιτεκτονικής **ARM**, παρέχει ένα μηχανισμό για να συνδέσει ένα **μικρό ετικέτα σε κάθε δέσμευση μνήμης** και μια **αντίστοιχη ετικέτα σε κάθε δείκτη** που αναφέρεται σε αυτήν τη μνήμη. Αυτή η προσέγγιση επιτρέπει την ανίχνευση παράνομων προσβάσεων μνήμης κατά την εκτέλεση, μειώνοντας σημαντικά τον κίνδυνο εκμετάλλευσης τέτοιων ευπαθειών για την εκτέλεση αυθαίρετου κώδικα.

### **Πώς Λειτουργεί η Επέκταση Επισήμανσης Μνήμης**

Η MTE λειτουργεί με τον **διαχωρισμό της μνήμης σε μικρά, σταθερού μεγέθους τμήματα, με κάθε τμήμα να έχει ανατεθεί μια ετικέτα,** τυπικά μερικών bits σε μέγεθος.&#x20;

Όταν δημιουργείται ένας δείκτης για να δείχνει σε αυτήν τη μνήμη, λαμβάνει την ίδια ετικέτα. Αυτή η ετικέτα αποθηκεύεται στα **αχρησιμοποίητα bits ενός δείκτη μνήμης**, συνδέοντας αποτελεσματικά τον δείκτη με το αντίστοιχο τμήμα μνήμης.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Όταν ένα πρόγραμμα έχει πρόσβαση στη μνήμη μέσω ενός δείκτη, το υλικό MTE ελέγχει ότι η **ετικέτα του δείκτη ταιριάζει με την ετικέτα του τμήματος μνήμης**. Αν οι ετικέτες **δεν ταιριάζουν**, υποδηλώνει μια **παράνομη πρόσβαση μνήμης.**

### Ετικέτες Δεικτών MTE

Οι ετικέτες μέσα σε έναν δείκτη αποθηκεύονται σε 4 bits μέσα στο πάνω byte:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Επομένως, αυτό επιτρέπει μέχρι **16 διαφορετικές τιμές ετικετών**.

### Ετικέτες Μνήμης MTE

Κάθε **16B φυσικής μνήμης** έχουν μια αντίστοιχη **ετικέτα μνήμης**.

Οι ετικέτες μνήμης αποθηκεύονται σε μια **αφιερωμένη περιοχή RAM** (μη προσβάσιμη για κανονική χρήση). Έχοντας ετικέτες 4 bits για κάθε 16B ετικέτες μνήμης μέχρι 3% της RAM.

Η ARM εισάγει τις ακόλουθες οδηγίες για την επεξεργασία αυτών των ετικετών στην αφιερωμένη μνήμη RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Λειτουργίες Ελέγχου

### Συγχρονισμένη

Η CPU ελέγχει τις ετικέτες **κατά την εκτέλεση της εντολής**, αν υπάρχει αναντιστοιχία, εκτοξεύει μια εξαίρεση.\
Αυτή είναι η πιο αργή και ασφαλής μέθοδος.

### Ασύγχρονη

Η CPU ελέγχει τις ετικέτες **ασύγχρονα**, και όταν βρεθεί μια αναντιστοιχία, ορίζει ένα bit εξαίρεσης σε ένα από τα καταχωρητές του συστήματος. Είναι **ταχύτερη** από την προηγούμενη αλλά **δεν μπορεί να εντοπίσει** ακριβώς την εντολή που προκάλεσε την αναντιστοιχία και δεν εκτοξεύει αμέσως την εξαίρεση, δίνοντας χρόνο στον επιτιθέμενο να ολοκληρώσει την επίθεσή του.

### Μικτή

???

## Υλοποίηση & Παραδείγματα Ανίχνευσης

Ονομάζεται Hardware Tag-Based KASAN, MTE-based KASAN ή in-kernel MTE.\
Οι διαχειριστές πυρήνα (όπως το `kmalloc`) θα **καλέσουν αυτή τη μονάδα** η οποία θα προετοιμάσει την ετικέτα που θα χρησιμοποιηθεί (τυχαία) για να την επισυνάψει στον χώρο πυρήνα που έχει εκχωρηθεί και στον επιστρεφόμενο δείκτη.

Σημειώστε ότι θα **επισημάνει μόνο αρκετά κομμάτια μνήμης** (16B το καθένα) για το ζητούμενο μέγεθος. Έτσι, αν το ζητούμενο μέγεθος ήταν 35 και δόθηκε ένα κομμάτι 60B, θα επισημάνει τα πρώτα 16\*3 = 48B με αυτή την ετικέτα και τα **υπόλοιπα** θα είναι **επισημασμένα** με μια τότε ονομαζόμενη **μη έγκυρη ετικέτα (0xE)**.

Η ετικέτα **0xF** είναι το **αντιστοιχίζει όλους τους δείκτες**. Μια μνήμη με αυτόν το δείκτη επιτρέπει τη χρήση **οποιασδήποτε ετικέτας** για την πρόσβαση στη μνήμη της (χωρίς αναντιστοιχίες). Αυτό μπορεί να αποτρέψει το MET από τον εντοπισμό μιας επίθεσης εάν αυτή η ετικέτα χρησιμοποιείται στη μνήμη που επιτίθεται.

Συνεπώς, υπάρχουν μόνο **14 τιμές** που μπορούν να χρησιμοποιηθούν για τη δημιουργία ετικετών, καθώς τα 0xE και 0xF είναι κρατημένα, με πιθανότητα **επαναχρησιμοποίησης ετικετών** 1/17 -> περίπου **7%**.

Εάν ο πυρήνας έχει πρόσβαση στο **κομμάτι μνήμης με τη μη έγκυρη ετικέτα**, η **αναντιστοιχία** θα **ανιχνευθεί**. Εάν έχει πρόσβαση σε άλλη τοποθεσία μνήμης, αν η **μνήμη έχει διαφορετική ετικέτα** (ή τη μη έγκυρη ετικέτα) η αναντιστοιχία θα **ανιχνευθεί**. Εάν ο επιτιθέμενος έχει την τύχη και η μνήμη χρησιμοποιεί την ίδια ετικέτα, δεν θα ανιχνευθεί. Οι πιθανότητες είναι περίπου 7%.

Ένα άλλο σφάλμα συμβαίνει στο **τελευταίο κομμάτι** της εκχωρημένης μνήμης. Αν η εφαρμογή ζήτησε 35B, της δόθηκε το κομμάτι από 32 έως 48. Συνεπώς, τα **bytes από 36 μέχρι 47 χρησιμοποιούν την ίδια ετικέτα** αλλά δεν ζητήθηκαν. Αν ο επιτιθέμενος έχει πρόσβαση **σε αυτά τα επιπλέον bytes, αυτό δεν ανιχνεύεται**.

Όταν εκτελείται το **`kfree()`**, η μνήμη επανασημαίνεται με τη μη έγκυρη ετικέτα μνήμης, έτσι σε ένα **use-after-free**, όταν η μνήμη έχει ξανά πρόσβαση, η **αναντιστοιχία ανιχνεύεται**.

Ωστόσο, σε ένα use-after-free, αν το ίδιο **κομμάτι επανεκχωρηθεί με την ίδια ετικέτα** όπως προηγουμένως, ένας επιτιθέμενος θα μπορεί να χρησιμοποιήσει αυτήν την πρόσβαση και αυτό δεν θα ανιχνευθεί (περίπου 7% πιθανότητα).

Επιπλέον, μόνο οι **`slab` και `page_alloc`** χρησιμοποιούν μνήμη με ετικέτες, αλλά στο μέλλον αυτό θα χρησιμοποιηθεί επίσης σε `vmalloc`, `stack` και `globals` (στη στιγμή του βίντεο αυτά μπορούν ακόμα να καταχραστούνται).

Όταν ανιχνευθεί μια **αναντιστοιχία**, ο πυρήνας θα **πανικοβάλλει** για να αποτρέψει περαιτέρω εκμετάλλευση και επαναλήψεις της εκμετάλλευσης (το MTE δεν έχει ψευδείς θετικές).

## Αναφορές

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
