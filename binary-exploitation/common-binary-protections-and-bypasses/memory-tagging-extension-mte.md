# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)**는 **버퍼 오버플로우 및 사용 후 해제 취약점**과 같은 메모리 관련 오류를 **감지하고 방지**하여 소프트웨어의 신뢰성과 보안을 향상시키기 위해 설계되었습니다. MTE는 **ARM** 아키텍처의 일환으로, **각 메모리 할당에 작은 태그를 부착하고** 해당 메모리를 참조하는 **각 포인터에 해당 태그를 부여하는** 메커니즘을 제공합니다. 이 접근 방식은 런타임에서 불법 메모리 접근을 감지할 수 있게 하여, 임의 코드를 실행하기 위한 이러한 취약점의 악용 위험을 크게 줄입니다.

### **How Memory Tagging Extension Works**

MTE는 **메모리를 작고 고정된 크기의 블록으로 나누고, 각 블록에 태그를 할당하는 방식으로 작동합니다.** 

포인터가 해당 메모리를 가리키도록 생성되면, 동일한 태그가 부여됩니다. 이 태그는 **메모리 포인터의 사용되지 않는 비트에 저장되어**, 포인터를 해당 메모리 블록에 연결합니다.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

프로그램이 포인터를 통해 메모리에 접근할 때, MTE 하드웨어는 **포인터의 태그가 메모리 블록의 태그와 일치하는지 확인합니다.** 태그가 **일치하지 않으면**, 이는 **불법 메모리 접근**을 나타냅니다.

### MTE Pointer Tags

포인터 내부의 태그는 상위 바이트의 4비트에 저장됩니다:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

따라서 최대 **16개의 서로 다른 태그 값**을 허용합니다.

### MTE Memory Tags

모든 **16B의 물리적 메모리**는 해당하는 **메모리 태그**를 가집니다.

메모리 태그는 **전용 RAM 영역**에 저장됩니다(일반 사용을 위해 접근할 수 없음). 16B 메모리 태그마다 4비트 태그를 가지며, 최대 3%의 RAM을 차지합니다.

ARM은 전용 RAM 메모리에서 이러한 태그를 조작하기 위해 다음 명령어를 도입합니다:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU는 **명령어 실행 중** 태그를 확인하며, 불일치가 발견되면 예외를 발생시킵니다.\
가장 느리지만 가장 안전합니다.

### Async

CPU는 **비동기적으로** 태그를 확인하며, 불일치가 발견되면 시스템 레지스터 중 하나에 예외 비트를 설정합니다. 이전 방법보다 **빠르지만** 불일치를 일으킨 정확한 명령어를 **지적할 수 없으며**, 즉시 예외를 발생시키지 않아 공격자가 공격을 완료할 시간을 제공합니다.

### Mixed

???

## Implementation & Detection Examples

하드웨어 태그 기반 KASAN, MTE 기반 KASAN 또는 인커널 MTE라고 불립니다.\
커널 할당자(예: `kmalloc`)는 **이 모듈을 호출**하여 사용할 태그를 준비하고(무작위로) 커널 공간에 할당된 메모리와 반환된 포인터에 연결합니다.

요청된 크기에 대해 **충분한 메모리 단위**(각 16B)만 **표시**합니다. 따라서 요청된 크기가 35이고 60B의 슬랩이 제공되면, 첫 번째 16\*3 = 48B에 이 태그를 표시하고 **나머지**는 **잘못된 태그(0xE)**로 **표시**됩니다.

태그 **0xF**는 **모든 포인터와 일치**합니다. 이 포인터가 있는 메모리는 **어떤 태그도 사용**하여 메모리에 접근할 수 있습니다(불일치 없음). 이 태그가 공격된 메모리에서 사용되면 MET가 공격을 감지하지 못할 수 있습니다.

따라서 **0xE**와 **0xF**가 예약되어 있으므로 태그를 생성하는 데 사용할 수 있는 값은 **14개**뿐이며, 태그를 **재사용할 확률**은 1/17 -> 약 **7%**입니다.

커널이 **잘못된 태그 단위**에 접근하면 **불일치**가 **감지**됩니다. 다른 메모리 위치에 접근할 경우, **메모리에 다른 태그**(또는 잘못된 태그)가 있으면 불일치가 **감지**됩니다. 공격자가 운이 좋고 메모리가 동일한 태그를 사용하고 있다면 감지되지 않습니다. 확률은 약 7%입니다.

또 다른 버그는 할당된 메모리의 **마지막 단위**에서 발생합니다. 애플리케이션이 35B를 요청하면 32에서 48까지의 단위를 받습니다. 따라서 **36에서 47까지의 바이트가 동일한 태그를 사용**하지만 요청되지 않았습니다. 공격자가 **이 추가 바이트에 접근하면 감지되지 않습니다**.

**`kfree()`**가 실행되면 메모리는 잘못된 메모리 태그로 다시 태그가 지정되므로 **use-after-free**에서 메모리에 다시 접근할 때 **불일치가 감지**됩니다.

그러나 use-after-free에서 동일한 **청크가 이전과 동일한 태그**로 다시 할당되면 공격자는 이 접근을 사용할 수 있으며 이는 감지되지 않습니다(약 7% 확률).

게다가 **`slab`와 `page_alloc`**만 태그가 지정된 메모리를 사용하지만, 앞으로는 `vmalloc`, `stack` 및 `globals`에서도 사용될 것입니다(비디오 당시에는 여전히 악용될 수 있습니다).

**불일치가 감지되면** 커널은 추가적인 악용과 공격 재시도를 방지하기 위해 **패닉** 상태에 빠집니다(MTE는 허위 긍정이 없습니다).

## References

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
