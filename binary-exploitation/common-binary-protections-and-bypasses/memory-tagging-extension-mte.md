# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** έχει σχεδιαστεί για να ενισχύει την αξιοπιστία και την ασφάλεια του λογισμικού με την **ανίχνευση και πρόληψη σφαλμάτων που σχετίζονται με τη μνήμη**, όπως οι υπερχειλίσεις buffer και οι ευπάθειες use-after-free. Το MTE, ως μέρος της **ARM** αρχιτεκτονικής, παρέχει έναν μηχανισμό για την προσθήκη ενός **μικρού tag σε κάθε κατανομή μνήμης** και ενός **αντίστοιχου tag σε κάθε δείκτη** που αναφέρεται σε αυτή τη μνήμη. Αυτή η προσέγγιση επιτρέπει την ανίχνευση παράνομων προσβάσεων μνήμης κατά την εκτέλεση, μειώνοντας σημαντικά τον κίνδυνο εκμετάλλευσης τέτοιων ευπαθειών για την εκτέλεση αυθαίρετου κώδικα.

### **How Memory Tagging Extension Works**

Το MTE λειτουργεί με την **κατανομή της μνήμης σε μικρές, σταθερού μεγέθους μπλοκ, με κάθε μπλοκ να έχει ανατεθεί ένα tag,** συνήθως μερικά bits σε μέγεθος.&#x20;

Όταν δημιουργείται ένας δείκτης για να δείχνει σε αυτή τη μνήμη, αποκτά το ίδιο tag. Αυτό το tag αποθηκεύεται στα **αχρησιμοποίητα bits ενός δείκτη μνήμης**, συνδέοντας αποτελεσματικά τον δείκτη με το αντίστοιχο μπλοκ μνήμης.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Όταν ένα πρόγραμμα προσπελάσει τη μνήμη μέσω ενός δείκτη, το υλικό MTE ελέγχει ότι το **tag του δείκτη ταιριάζει με το tag του μπλοκ μνήμης**. Εάν τα tags **δεν ταιριάζουν**, αυτό υποδεικνύει μια **παράνομη πρόσβαση μνήμης.**

### MTE Pointer Tags

Τα tags μέσα σε έναν δείκτη αποθηκεύονται σε 4 bits μέσα στο ανώτερο byte:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Ως εκ τούτου, αυτό επιτρέπει έως **16 διαφορετικές τιμές tag**.

### MTE Memory Tags

Κάθε **16B φυσικής μνήμης** έχει ένα αντίστοιχο **tag μνήμης**.

Τα tags μνήμης αποθηκεύονται σε μια **αφιερωμένη περιοχή RAM** (μη προσβάσιμη για κανονική χρήση). Έχοντας 4 bits tags για κάθε 16B tags μνήμης έως 3% της RAM.

Η ARM εισάγει τις παρακάτω εντολές για να χειριστεί αυτά τα tags στη αφιερωμένη μνήμη RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Έλεγχος Λειτουργιών

### Συγχρονισμένος

Ο επεξεργαστής ελέγχει τις ετικέτες **κατά την εκτέλεση της εντολής**, αν υπάρχει ασυμφωνία, προκαλεί μια εξαίρεση.\
Αυτή είναι η πιο αργή και ασφαλής.

### Ασύγχρονος

Ο επεξεργαστής ελέγχει τις ετικέτες **ασύγχρονα**, και όταν βρεθεί μια ασυμφωνία, θέτει ένα bit εξαίρεσης σε ένα από τα συστήματα καταχωρητών. Είναι **ταχύτερος** από τον προηγούμενο αλλά είναι **ανίκανος να υποδείξει** την ακριβή εντολή που προκαλεί την ασυμφωνία και δεν προκαλεί την εξαίρεση αμέσως, δίνοντας λίγο χρόνο στον επιτιθέμενο να ολοκληρώσει την επίθεσή του.

### Μικτός

???

## Παραδείγματα Υλοποίησης & Ανίχνευσης

Ονομάζεται Hardware Tag-Based KASAN, MTE-based KASAN ή in-kernel MTE.\
Οι κατανεμητές του πυρήνα (όπως το `kmalloc`) θα **καλέσουν αυτό το module** το οποίο θα προετοιμάσει την ετικέτα για χρήση (τυχαία) και θα την επισυνάψει στον κατανεμημένο χώρο του πυρήνα και στον επιστρεφόμενο δείκτη.

Σημειώστε ότι θα **σημειώσει μόνο αρκετές μνήμες** (16B η καθεμία) για το ζητούμενο μέγεθος. Έτσι, αν το ζητούμενο μέγεθος ήταν 35 και δόθηκε μια πλάκα 60B, θα σημειώσει τα πρώτα 16\*3 = 48B με αυτή την ετικέτα και το **υπόλοιπο** θα είναι **σημειωμένο** με μια λεγόμενη **μη έγκυρη ετικέτα (0xE)**.

Η ετικέτα **0xF** είναι ο **δείκτης που ταιριάζει σε όλα**. Μια μνήμη με αυτόν τον δείκτη επιτρέπει **οποιαδήποτε ετικέτα να χρησιμοποιηθεί** για την πρόσβαση στη μνήμη της (χωρίς ασυμφωνίες). Αυτό θα μπορούσε να αποτρέψει το MET από το να ανιχνεύσει μια επίθεση αν αυτή η ετικέτα χρησιμοποιείται στη μνήμη που δέχεται την επίθεση.

Επομένως, υπάρχουν μόνο **14 τιμές** που μπορούν να χρησιμοποιηθούν για τη δημιουργία ετικετών καθώς οι 0xE και 0xF είναι δεσμευμένες, δίνοντας μια πιθανότητα **επανάχρησης ετικετών** 1/17 -> περίπου **7%**.

Αν ο πυρήνας έχει πρόσβαση στη **μη έγκυρη μνήμη**, η **ασυμφωνία** θα **ανιχνευθεί**. Αν έχει πρόσβαση σε άλλη τοποθεσία μνήμης, αν η **μνήμη έχει διαφορετική ετικέτα** (ή τη μη έγκυρη ετικέτα) η ασυμφωνία θα **ανιχνευθεί**. Αν ο επιτιθέμενος είναι τυχερός και η μνήμη χρησιμοποιεί την ίδια ετικέτα, δεν θα ανιχνευθεί. Οι πιθανότητες είναι περίπου 7%.

Ένα άλλο σφάλμα συμβαίνει στην **τελευταία μνήμη** της κατανεμημένης μνήμης. Αν η εφαρμογή ζητήσει 35B, θα της δοθεί η μνήμη από 32 έως 48. Επομένως, τα **bytes από 36 έως 47 χρησιμοποιούν την ίδια ετικέτα** αλλά δεν ζητήθηκαν. Αν ο επιτιθέμενος έχει πρόσβαση **σε αυτά τα επιπλέον bytes, αυτό δεν ανιχνεύεται**.

Όταν εκτελείται το **`kfree()`**, η μνήμη επανασημαίνεται με τη μη έγκυρη ετικέτα μνήμης, έτσι σε μια **χρήση μετά την απελευθέρωση**, όταν η μνήμη προσπελαστεί ξανά, η **ασυμφωνία ανιχνεύεται**.

Ωστόσο, σε μια χρήση μετά την απελευθέρωση, αν το ίδιο **κομμάτι επανακατανεμηθεί ξανά με την ΙΔΙΑ ετικέτα** όπως προηγουμένως, ένας επιτιθέμενος θα μπορέσει να χρησιμοποιήσει αυτή την πρόσβαση και αυτό δεν θα ανιχνευθεί (περίπου 7% πιθανότητα).

Επιπλέον, μόνο οι **`slab` και `page_alloc`** χρησιμοποιούν ετικετοποιημένη μνήμη αλλά στο μέλλον αυτό θα χρησιμοποιηθεί επίσης σε `vmalloc`, `stack` και `globals` (τη στιγμή του βίντεο αυτά μπορούν ακόμα να καταχραστούν).

Όταν ανιχνεύεται μια **ασυμφωνία**, ο πυρήνας θα **πανικοβληθεί** για να αποτρέψει περαιτέρω εκμετάλλευση και επαναλήψεις της εκμετάλλευσης (το MTE δεν έχει ψευδώς θετικά).

## Αναφορές

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
