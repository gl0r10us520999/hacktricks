# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** jest zaprojektowany w celu zwikszenia niezawodnoci i bezpieczestwa oprogramowania poprzez **wykrywanie i zapobieganie bdom zwizanym z pamici**, takim jak przepenienia bufora i luki typu use-after-free. MTE, jako cz architektury **ARM**, zapewnia mechanizm do przypisania **maego tagu do ka偶dej alokacji pamici** oraz **odpowiedniego tagu do ka偶dego wska藕nika** odnoszcego si do tej pamici. Takie podejcie pozwala na wykrywanie nielegalnych dostpu do pamici w czasie rzeczywistym, znacznie zmniejszajc ryzyko wykorzystania takich luk do wykonywania dowolnego kodu.

### **How Memory Tagging Extension Works**

MTE dziaa poprzez **dzielenie pamici na mae, stae bloki, z kt贸rych ka偶dy blok ma przypisany tag,** zazwyczaj o wielkoci kilku bit贸w.&#x20;

Gdy tworzony jest wska藕nik wskazujcy na t pami, otrzymuje ten sam tag. Tag ten jest przechowywany w **niewykorzystanych bitach wska藕nika pamici**, skutecznie czc wska藕nik z odpowiadajcym mu blokiem pamici.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Gdy program uzyskuje dostp do pamici za porednictwem wska藕nika, sprzt MTE sprawdza, czy **tag wska藕nika pasuje do tagu bloku pamici**. Jeli tagi **nie pasuj**, wskazuje to na **nielegalny dostp do pamici.**

### MTE Pointer Tags

Tagi wewntrz wska藕nika s przechowywane w 4 bitach w g贸rnym bajcie:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Dlatego pozwala to na **16 r贸偶nych wartoci tag贸w**.

### MTE Memory Tags

Ka偶de **16B pamici fizycznej** ma odpowiadajcy **tag pamici**.

Tagi pamici s przechowywane w **dedykowanym obszarze RAM** (niedostpnym do normalnego u偶ytku). Posiadajc 4 bity tag贸w dla ka偶dego 16B tag贸w pamici, do 3% RAM.

ARM wprowadza nastpujce instrukcje do manipulacji tymi tagami w dedykowanej pamici RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Sprawdzanie tryb贸w

### Sync

CPU sprawdza tagi **podczas wykonywania instrukcji**, jeli wystpi niezgodno, zgasza wyjtek.\
Jest to najwolniejszy i najbezpieczniejszy tryb.

### Async

CPU sprawdza tagi **asynchronicznie**, a gdy znajdzie niezgodno, ustawia bit wyjtku w jednym z rejestr贸w systemowych. Jest **szybszy** ni偶 poprzedni, ale **nie jest w stanie wskaza** dokadnej instrukcji, kt贸ra spowodowaa niezgodno i nie zgasza wyjtku natychmiast, dajc czas atakujcemu na dokoczenie ataku.

### Mixed

???

## Przykady implementacji i wykrywania

Nazywane KASAN opartym na tagach sprztowych, KASAN opartym na MTE lub MTE w jdrze.\
Alokatory jdra (takie jak `kmalloc`) bd **wywoywa ten modu**, kt贸ry przygotuje tag do u偶ycia (losowo) i doczy go do przydzielonej przestrzeni jdra oraz do zwr贸conego wska藕nika.

Nale偶y zauwa偶y, 偶e **oznaczy tylko wystarczajc ilo granulek pamici** (po 16B ka偶da) dla 偶danej wielkoci. Jeli wic 偶dana wielko wynosia 35, a przydzielono blok 60B, oznaczy pierwsze 16\*3 = 48B tym tagiem, a **reszta** bdzie **oznaczona** tzw. **nieprawidowym tagiem (0xE)**.

Tag **0xF** jest **wska藕nikiem pasujcym do wszystkiego**. Pami z tym wska藕nikiem pozwala na **u偶ycie dowolnego tagu** do uzyskania dostpu do jej pamici (brak niezgodnoci). Mo偶e to uniemo偶liwi MET wykrycie ataku, jeli ten tag jest u偶ywany w zaatakowanej pamici.

Dlatego istnieje tylko **14 wartoci**, kt贸re mo偶na wykorzysta do generowania tag贸w, poniewa偶 0xE i 0xF s zarezerwowane, co daje prawdopodobiestwo **ponownego u偶ycia tag贸w** na poziomie 1/17 -> okoo **7%**.

Jeli jdro uzyska dostp do **nieprawidowej granulki tagu**, **niezgodno** zostanie **wykryta**. Jeli uzyska dostp do innej lokalizacji pamici, jeli **pami ma inny tag** (lub nieprawidowy tag), niezgodno zostanie **wykryta**. Jeli atakujcy ma szczcie i pami u偶ywa tego samego tagu, nie zostanie to wykryte. Szanse wynosz okoo 7%.

Inny bd wystpuje w **ostatniej granulce** przydzielonej pamici. Jeli aplikacja za偶daa 35B, przydzielono jej granul od 32 do 48. Dlatego **bajty od 36 do 47 u偶ywaj tego samego tagu**, ale nie zostay za偶dane. Jeli atakujcy uzyska dostp do **tych dodatkowych bajt贸w, nie zostanie to wykryte**.

Gdy **`kfree()`** jest wykonywane, pami jest ponownie oznaczana nieprawidowym tagiem pamici, wic w przypadku **u偶ycia po zwolnieniu**, gdy pami jest ponownie uzyskiwana, **niezgodno jest wykrywana**.

Jednak w przypadku u偶ycia po zwolnieniu, jeli ten sam **blok jest ponownie przydzielany z TYM SAMYM tagiem** co wczeniej, atakujcy bdzie m贸g wykorzysta ten dostp i nie zostanie to wykryte (okoo 7% szans).

Co wicej, tylko **`slab` i `page_alloc`** u偶ywaj oznaczonej pamici, ale w przyszoci bdzie to r贸wnie偶 u偶ywane w `vmalloc`, `stack` i `globals` (w momencie nagrania te mog by nadal nara偶one na nadu偶ycia).

Gdy **niezgodno jest wykrywana**, jdro **panikuje**, aby zapobiec dalszemu wykorzystywaniu i ponownym pr贸bom wykorzystania (MTE nie ma faszywych pozytyw贸w).

## Odniesienia

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}
