# Memory Tagging Extension (MTE)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Memory Tagging Extension (MTE)** est con√ßu pour am√©liorer la fiabilit√© et la s√©curit√© des logiciels en **d√©tectant et en pr√©venant les erreurs li√©es √† la m√©moire**, telles que les d√©bordements de tampon et les vuln√©rabilit√©s d'utilisation apr√®s lib√©ration. MTE, en tant que partie de l'**architecture ARM**, fournit un m√©canisme pour attacher un **petit tag √† chaque allocation de m√©moire** et un **tag correspondant √† chaque pointeur** r√©f√©rencant cette m√©moire. Cette approche permet de d√©tecter les acc√®s m√©moire ill√©gaux √† l'ex√©cution, r√©duisant ainsi consid√©rablement le risque d'exploiter de telles vuln√©rabilit√©s pour ex√©cuter du code arbitraire.

### **How Memory Tagging Extension Works**

MTE fonctionne en **divisant la m√©moire en petits blocs de taille fixe, chaque bloc se voyant attribuer un tag,** g√©n√©ralement de quelques bits de taille.&#x20;

Lorsqu'un pointeur est cr√©√© pour pointer vers cette m√©moire, il re√ßoit le m√™me tag. Ce tag est stock√© dans les **bits inutilis√©s d'un pointeur m√©moire**, liant efficacement le pointeur √† son bloc de m√©moire correspondant.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Lorsqu'un programme acc√®de √† la m√©moire via un pointeur, le mat√©riel MTE v√©rifie que le **tag du pointeur correspond au tag du bloc de m√©moire**. Si les tags **ne correspondent pas**, cela indique un **acc√®s m√©moire ill√©gal.**

### MTE Pointer Tags

Les tags √† l'int√©rieur d'un pointeur sont stock√©s dans 4 bits √† l'int√©rieur du byte sup√©rieur :

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Par cons√©quent, cela permet jusqu'√† **16 valeurs de tag diff√©rentes**.

### MTE Memory Tags

Chaque **16B de m√©moire physique** a un **tag de m√©moire** correspondant.

Les tags de m√©moire sont stock√©s dans une **r√©gion RAM d√©di√©e** (non accessible pour un usage normal). Avoir des tags de 4 bits pour chaque tag de m√©moire de 16B jusqu'√† 3% de la RAM.

ARM introduit les instructions suivantes pour manipuler ces tags dans la m√©moire RAM d√©di√©e :
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modes de v√©rification

### Sync

Le CPU v√©rifie les tags **pendant l'ex√©cution de l'instruction**, s'il y a un d√©calage, il l√®ve une exception.\
C'est le plus lent et le plus s√©curis√©.

### Async

Le CPU v√©rifie les tags **asynchrone**, et lorsqu'un d√©calage est trouv√©, il d√©finit un bit d'exception dans l'un des registres syst√®me. C'est **plus rapide** que le pr√©c√©dent mais il est **incapable de pointer** l'instruction exacte qui cause le d√©calage et il ne l√®ve pas l'exception imm√©diatement, donnant un peu de temps √† l'attaquant pour compl√©ter son attaque.

### Mixed

???

## Exemples d'impl√©mentation et de d√©tection

Appel√© KASAN bas√© sur des tags mat√©riels, KASAN bas√© sur MTE ou MTE dans le noyau.\
Les allocateurs du noyau (comme `kmalloc`) vont **appeler ce module** qui pr√©parera le tag √† utiliser (de mani√®re al√©atoire) pour l'attacher √† l'espace noyau allou√© et au pointeur retourn√©.

Notez qu'il **marquera uniquement suffisamment de granules de m√©moire** (16B chacune) pour la taille demand√©e. Donc, si la taille demand√©e √©tait de 35 et qu'une plaque de 60B √©tait donn√©e, il marquera les premiers 16\*3 = 48B avec ce tag et le **reste** sera **marqu√©** avec un soi-disant **tag invalide (0xE)**.

Le tag **0xF** est le **pointeur qui correspond √† tout**. Une m√©moire avec ce pointeur permet **d'utiliser n'importe quel tag** pour acc√©der √† sa m√©moire (pas de d√©calages). Cela pourrait emp√™cher le MET de d√©tecter une attaque si ce tag est utilis√© dans la m√©moire attaqu√©e.

Par cons√©quent, il n'y a que **14 valeurs** qui peuvent √™tre utilis√©es pour g√©n√©rer des tags car 0xE et 0xF sont r√©serv√©s, donnant une probabilit√© de **r√©utilisation des tags** de 1/17 -> environ **7%**.

Si le noyau acc√®de √† la **granule de tag invalide**, le **d√©calage** sera **d√©tect√©**. S'il acc√®de √† un autre emplacement m√©moire, si la **m√©moire a un tag diff√©rent** (ou le tag invalide), le d√©calage sera **d√©tect√©**. Si l'attaquant a de la chance et que la m√©moire utilise le m√™me tag, cela ne sera pas d√©tect√©. Les chances sont d'environ 7%.

Un autre bug se produit dans la **derni√®re granule** de la m√©moire allou√©e. Si l'application a demand√© 35B, elle a re√ßu la granule de 32 √† 48. Par cons√©quent, les **octets de 36 √† 47 utilisent le m√™me tag** mais n'ont pas √©t√© demand√©s. Si l'attaquant acc√®de **√† ces octets suppl√©mentaires, cela n'est pas d√©tect√©**.

Lorsque **`kfree()`** est ex√©cut√©, la m√©moire est re-tag√©e avec le tag de m√©moire invalide, donc dans un **use-after-free**, lorsque la m√©moire est √† nouveau acc√©d√©e, le **d√©calage est d√©tect√©**.

Cependant, dans un use-after-free, si le m√™me **chunk est r√©allou√© √† nouveau avec le M√äME tag** qu'auparavant, un attaquant pourra utiliser cet acc√®s et cela ne sera pas d√©tect√© (environ 7% de chance).

De plus, seuls **`slab` et `page_alloc`** utilisent de la m√©moire tagu√©e mais √† l'avenir, cela sera √©galement utilis√© dans `vmalloc`, `stack` et `globals` (au moment de la vid√©o, ceux-ci peuvent encore √™tre abus√©s).

Lorsqu'un **d√©calage est d√©tect√©**, le noyau va **panic** pour pr√©venir toute exploitation suppl√©mentaire et les tentatives de l'exploit (MTE n'a pas de faux positifs).

## R√©f√©rences

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
