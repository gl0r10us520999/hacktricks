# Geheue Merkuitbreiding (MTE)

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## Basiese Inligting

**Geheue Merkuitbreiding (MTE)** is ontwerp om sagteware-betroubaarheid en -veiligheid te verbeter deur **geheueverwante foute op te spoor en te voorkom**, soos buffer-oorvloeie en gebruik-na-vry kwesbaarhede. MTE, as deel van die **ARM**-argitektuur, bied 'n meganisme om 'n **klein merk aan elke geheue-toewysing te heg** en 'n **ooreenstemmende merk aan elke wyser** wat na daardie geheue verwys. Hierdie benadering maak die opsporing van onwettige geheuetoevalle tydens uitvoering moontlik, wat die risiko van die uitbuiting van sulke kwesbaarhede vir die uitvoering van willekeurige kode aansienlik verminder.

### **Hoe Geheue Merkuitbreiding Werk**

MTE werk deur **geheue in klein, vasgestelde blokke te verdeel, met elke blok wat 'n merk toegewys kry,** tipies 'n paar bietjies groot.&#x20;

Wanneer 'n wyser geskep word om na daardie geheue te wys, kry dit dieselfde merk. Hierdie merk word gestoor in die **ongebruikte bietjies van 'n geheue-wyser**, wat die wyser effektief koppel aan sy ooreenstemmende geheueblok.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wanneer 'n program geheue deur 'n wyser toegang, kontroleer die MTE-hardeware dat die **merk van die wyser ooreenstem met die merk van die geheueblok**. As die merke **nie ooreenstem nie**, dui dit op 'n **onwettige geheuetoegang.**

### MTE Wysmerke

Merke binne 'n wyser word gestoor in 4 bietjies binne die boonste byte:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Dit maak dus tot **16 verskillende merkwaardes** moontlik.

### MTE Geheue Merke

Elke **16B van fisiese geheue** het 'n ooreenstemmende **geheue-merk**.

Die geheue-merke word gestoor in 'n **toegewyde RAM-gebied** (nie toeganklik vir normale gebruik nie). Met 4 bietjies merke vir elke 16B geheue-merke tot 3% van RAM.

ARM introduceer die volgende instruksies om hierdie merke in die toegewyde RAM-geheue te manipuleer:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Kontroleer Modusse

### Sync

Die CPU kontroleer die etikette **tydens die instruksie-uitvoering**, as daar 'n wanpassing is, veroorsaak dit 'n uitsondering.\
Dit is die stadigste en mees veilige.

### Async

Die CPU kontroleer die etikette **asinkroon**, en wanneer 'n wanpassing gevind word, stel dit 'n uitsonderingsbit in een van die stelselregisters in. Dit is **vinniger** as die vorige een, maar dit is **nie in staat om** die presiese instruksie aan te dui wat die wanpassing veroorsaak nie en dit veroorsaak nie onmiddellik 'n uitsondering nie, wat die aanvaller tyd gee om sy aanval te voltooi.

### Gemeng

???

## Implementering & Opmerkingsvoorbeelde

Genoem Hardware Etiket-Gebaseerde KASAN, MTE-gebaseerde KASAN of in-kernel MTE.\
Die kernel-allocators (soos `kmalloc`) sal **hierdie module aanroep** wat die etiket voorberei om te gebruik (willekeurig) dit aan die toegewysde kernel-spasie heg en aan die teruggekeerde wyser.

Let daarop dat dit slegs genoeg geheuekorrels (16B elk) vir die gevraagde grootte sal **merk**. Dus, as die gevraagde grootte 35 was en 'n slob van 60B gegee is, sal dit die eerste 16\*3 = 48B met hierdie etiket merk en die **res** sal met 'n sogenaamde **ongeldige etiket (0xE)** gemerk word.

Die etiket **0xF** is die **pas alle wyser**. 'n Geheue met hierdie wyser laat **enige etiket toe om** toegang tot sy geheue te verkry (geen wanpassings). Dit kan voorkom dat MET 'n aanval opspoor as hierdie etikette in die aangevalle geheue gebruik word.

Daarom is daar slegs **14 waardes** wat gebruik kan word om etikette te genereer aangesien 0xE en 0xF gereserveer is, wat 'n hergebruikswaarskynlikheid van etikette van 1/17 -> ongeveer **7%** gee.

As die kernel toegang tot die **ongeldige etiketkorrel** verkry, sal die **wanpassing** opgespoor word. As dit toegang tot 'n ander geheueplek verkry, as die **geheue 'n ander etiket** (of die ongeldige etiket) het, sal die wanpassing opgespoor word. As die aanvaller gelukkig is en die geheue dieselfde etiket gebruik, sal dit nie opgespoor word nie. Die kanse is ongeveer 7%.

'n Ander fout kom voor in die **laaste korrel** van die toegewysde geheue. As die aansoek 35B versoek het, is die korrel van 32 tot 48 gegee. Daarom gebruik die **byte vanaf 36 tot 47 dieselfde etiket** maar dit is nie versoek nie. As die aanvaller toegang tot **hierdie ekstra bytes verkry, word dit nie opgespoor** nie.

Wanneer **`kfree()`** uitgevoer word, word die geheue heretiketteer met die ongeldige geheue-etiket, sodat in 'n **gebruik-na-vry**, wanneer die geheue weer benader word, die **wanpassing opgespoor word**.

Tog, in 'n gebruik-na-vry, as dieselfde **blok weer met dieselfde etiket toegewys word** as voorheen, sal 'n aanvaller hierdie toegang kan gebruik en dit sal nie opgespoor word nie (ongeveer 7% kans).

Verder, slegs **`slab` en `page_alloc`** gebruik ge√´tiketteerde geheue, maar in die toekoms sal dit ook in `vmalloc`, `stack` en `globals` gebruik word (op die oomblik van die video kan hierdie steeds misbruik word).

Wanneer 'n **wanpassing opgespoor word**, sal die kernel **paniek** veroorsaak om verdere uitbuiting en herhalings van die aanval te voorkom (MTE het nie vals positiewe nie).

## Verwysings

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
