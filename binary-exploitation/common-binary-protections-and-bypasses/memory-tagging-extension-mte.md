# Extension de balisage m√©moire (MTE)

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Informations de base

**L'extension de balisage m√©moire (MTE)** est con√ßue pour am√©liorer la fiabilit√© et la s√©curit√© des logiciels en **d√©tectant et en pr√©venant les erreurs li√©es √† la m√©moire**, telles que les d√©bordements de tampon et les vuln√©rabilit√©s d'utilisation apr√®s lib√©ration. MTE, faisant partie de l'architecture **ARM**, fournit un m√©canisme pour attacher un **petit balisage √† chaque allocation m√©moire** et un **balisage correspondant √† chaque pointeur** faisant r√©f√©rence √† cette m√©moire. Cette approche permet de d√©tecter les acc√®s m√©moire ill√©gaux √† l'ex√©cution, r√©duisant ainsi consid√©rablement le risque d'exploitation de telles vuln√©rabilit√©s pour ex√©cuter du code arbitraire.

### **Fonctionnement de l'extension de balisage m√©moire**

MTE fonctionne en **divisant la m√©moire en petits blocs de taille fixe, chaque bloc se voyant attribuer un balisage,** g√©n√©ralement de quelques bits de taille.&#x20;

Lorsqu'un pointeur est cr√©√© pour pointer vers cette m√©moire, il re√ßoit le m√™me balisage. Ce balisage est stock√© dans les **bits inutilis√©s d'un pointeur m√©moire**, liant efficacement le pointeur √† son bloc m√©moire correspondant.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Lorsqu'un programme acc√®de √† la m√©moire via un pointeur, le mat√©riel MTE v√©rifie que le **balisage du pointeur correspond au balisage du bloc m√©moire**. Si les balisages **ne correspondent pas**, cela indique un **acc√®s m√©moire ill√©gal**.

### Balisage des pointeurs MTE

Les balisages √† l'int√©rieur d'un pointeur sont stock√©s sur 4 bits √† l'int√©rieur de l'octet sup√©rieur :

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Par cons√©quent, cela permet jusqu'√† **16 valeurs de balisage diff√©rentes**.

### Balisage m√©moire MTE

Chaque **16B de m√©moire physique** a un **balisage m√©moire correspondant**.

Les balisages m√©moire sont stock√©s dans une **zone de RAM d√©di√©e** (non accessible pour une utilisation normale). Avec des balisages de 4 bits pour chaque balisage m√©moire de 16B, jusqu'√† 3% de la RAM.

ARM introduit les instructions suivantes pour manipuler ces balisages dans la m√©moire RAM d√©di√©e :
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modes de v√©rification

### Sync

Le CPU v√©rifie les tags **pendant l'ex√©cution de l'instruction**, s'il y a une incoh√©rence, il d√©clenche une exception.\
C'est le plus lent et le plus s√©curis√©.

### Async

Le CPU v√©rifie les tags **de mani√®re asynchrone**, et lorsqu'une incoh√©rence est trouv√©e, il d√©finit un bit d'exception dans l'un des registres syst√®me. C'est **plus rapide** que le pr√©c√©dent mais il est **incapable de pointer** l'instruction exacte qui a caus√© l'incoh√©rence et il ne d√©clenche pas imm√©diatement l'exception, laissant ainsi du temps √† l'attaquant pour mener √† bien son attaque.

### Mixte

???

## Exemples d'impl√©mentation et de d√©tection

Appel√© KASAN bas√© sur les balises mat√©rielles, KASAN bas√© sur MTE ou MTE dans le noyau.\
Les allocateurs du noyau (comme `kmalloc`) vont **appeler ce module** qui pr√©parera le tag √† utiliser (de mani√®re al√©atoire) pour l'attacher √† l'espace noyau allou√© et au pointeur retourn√©.

Notez qu'il ne marquera **que suffisamment de granules de m√©moire** (16B chacun) pour la taille demand√©e. Donc, si la taille demand√©e √©tait de 35 et qu'un bloc de 60B a √©t√© donn√©, il marquera les premiers 16\*3 = 48B avec ce tag et le **reste** sera **marqu√©** avec un soi-disant **tag invalide (0xE)**.

Le tag **0xF** est le **pointeur de correspondance**. Une m√©moire avec ce pointeur permet **d'utiliser n'importe quel tag** pour acc√©der √† sa m√©moire (pas d'incoh√©rences). Cela pourrait emp√™cher le MET de d√©tecter une attaque si ce tag est utilis√© dans la m√©moire attaqu√©e.

Par cons√©quent, il n'y a que **14 valeurs** qui peuvent √™tre utilis√©es pour g√©n√©rer des tags car 0xE et 0xF sont r√©serv√©s, donnant une probabilit√© de **r√©utilisation des tags** de 1/17 -> environ **7%**.

Si le noyau acc√®de au **granule de tag invalide**, l'**incoh√©rence** sera **d√©tect√©e**. S'il acc√®de √† un autre emplacement m√©moire, si la **m√©moire a un tag diff√©rent** (ou le tag invalide), l'incoh√©rence sera **d√©tect√©e**. Si l'attaquant a de la chance et que la m√©moire utilise le m√™me tag, cela ne sera pas d√©tect√©. Les chances sont d'environ 7%.

Un autre bug se produit dans le **dernier granule** de la m√©moire allou√©e. Si l'application a demand√© 35B, elle a re√ßu le granule de 32 √† 48. Par cons√©quent, les **octets de 36 √† 47 utilisent le m√™me tag** mais n'ont pas √©t√© demand√©s. Si l'attaquant acc√®de √† **ces octets suppl√©mentaires, cela ne sera pas d√©tect√©**.

Lorsque **`kfree()`** est ex√©cut√©, la m√©moire est retagu√©e avec le tag de m√©moire invalide, donc dans un **utilisation apr√®s lib√©ration**, lorsque la m√©moire est √† nouveau acc√©d√©e, l'**incoh√©rence est d√©tect√©e**.

Cependant, dans un utilisation apr√®s lib√©ration, si le m√™me **bloc est r√©allou√© avec le M√äME tag** qu'auparavant, un attaquant pourra utiliser cet acc√®s et cela ne sera pas d√©tect√© (environ 7% de chances).

De plus, seuls **`slab` et `page_alloc`** utilisent une m√©moire tagu√©e mais √† l'avenir cela sera √©galement utilis√© dans `vmalloc`, `stack` et `globals` (au moment de la vid√©o, ces derniers peuvent encore √™tre exploit√©s).

Lorsqu'une **incoh√©rence est d√©tect√©e**, le noyau **panique** pour emp√™cher toute exploitation ult√©rieure et toute tentative de l'exploit (MTE n'a pas de faux positifs).

## R√©f√©rences

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
