# Montón

## Conceptos básicos del montón

El montón es básicamente el lugar donde un programa podrá almacenar datos cuando solicite datos llamando a funciones como **`malloc`**, `calloc`... Además, cuando esta memoria ya no sea necesaria, estará disponible llamando a la función **`free`**.

Como se muestra, está justo después de donde se carga el binario en la memoria (ver la sección `[heap]`):

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### Asignación básica de fragmentos

Cuando se solicita almacenar algunos datos en el montón, se asigna un espacio del montón para ello. Este espacio pertenecerá a un bin y solo se reservará para el fragmento la cantidad de datos solicitada + el espacio de los encabezados del bin + el desplazamiento mínimo del tamaño del bin. El objetivo es reservar la menor cantidad de memoria posible sin complicar la búsqueda de cada fragmento. Para esto, se utiliza la información de metadatos del fragmento para saber dónde está cada fragmento usado/libre.

Existen diferentes formas de reservar el espacio, principalmente dependiendo del bin utilizado, pero una metodología general es la siguiente:

* El programa comienza solicitando cierta cantidad de memoria.
* Si en la lista de fragmentos hay alguno disponible lo suficientemente grande para cumplir con la solicitud, se utilizará.
* Esto incluso puede significar que parte del fragmento disponible se utilizará para esta solicitud y el resto se agregará a la lista de fragmentos.
* Si no hay ningún fragmento disponible en la lista pero aún hay espacio en la memoria del montón asignada, el administrador del montón crea un nuevo fragmento.
* Si no hay suficiente espacio en el montón para asignar el nuevo fragmento, el administrador del montón solicita al kernel que expanda la memoria asignada al montón y luego utiliza esta memoria para generar el nuevo fragmento.
* Si todo falla, `malloc` devuelve nulo.

Tenga en cuenta que si la memoria solicitada **supera un umbral**, se utilizará **`mmap`** para asignar la memoria solicitada.

### Arenas

En aplicaciones **multihilo**, el administrador del montón debe evitar **condiciones de carrera** que podrían provocar bloqueos. Inicialmente, esto se hacía utilizando un **mutex global** para garantizar que solo un hilo pudiera acceder al montón a la vez, pero esto causaba **problemas de rendimiento** debido al cuello de botella inducido por el mutex.

Para abordar esto, el asignador de montón ptmalloc2 introdujo "arenas", donde **cada arena** actúa como un **montón separado** con sus **propias** estructuras de datos y **mutex**, permitiendo que múltiples hilos realicen operaciones de montón sin interferir entre sí, siempre y cuando utilicen arenas diferentes.

La arena "principal" predeterminada maneja las operaciones de montón para aplicaciones de un solo hilo. Cuando se agregan **nuevos hilos**, el administrador del montón les asigna **arenas secundarias** para reducir la contención. Primero intenta adjuntar cada nuevo hilo a una arena no utilizada, creando nuevas si es necesario, hasta un límite de 2 veces los núcleos de la CPU para sistemas de 32 bits y 8 veces para sistemas de 64 bits. Una vez que se alcanza el límite, los **hilos deben compartir arenas**, lo que puede provocar contención potencial.

A diferencia de la arena principal, que se expande utilizando la llamada al sistema `brk`, las arenas secundarias crean "submontones" utilizando `mmap` y `mprotect` para simular el comportamiento del montón, lo que permite flexibilidad en la gestión de la memoria para operaciones multihilo.

### Submontones

Los submontones sirven como reservas de memoria para las arenas secundarias en aplicaciones multihilo, lo que les permite crecer y gestionar sus propias regiones de montón de forma independiente al montón principal. Así es como los submontones difieren del montón inicial y cómo operan:

1. **Montón inicial vs. Submontones**:
* El montón inicial se encuentra directamente después del binario del programa en la memoria, y se expande utilizando la llamada al sistema `sbrk`.
* Los submontones, utilizados por las arenas secundarias, se crean a través de `mmap`, una llamada al sistema que asigna una región de memoria especificada.
2. **Reserva de memoria con `mmap`**:
* Cuando el administrador del montón crea un submontón, reserva un bloque grande de memoria a través de `mmap`. Esta reserva no asigna memoria de inmediato; simplemente designa una región que otros procesos del sistema o asignaciones no deben utilizar.
* Por defecto, el tamaño reservado para un submontón es de 1 MB para procesos de 32 bits y 64 MB para procesos de 64 bits.
3. **Expansión gradual con `mprotect`**:
* La región de memoria reservada inicialmente se marca como `PROT_NONE`, lo que indica que el kernel no necesita asignar memoria física a este espacio aún.
* Para "expandir" el submontón, el administrador del montón utiliza `mprotect` para cambiar los permisos de página de `PROT_NONE` a `PROT_READ | PROT_WRITE`, lo que hace que el kernel asigne memoria física a las direcciones reservadas anteriormente. Este enfoque paso a paso permite que el submontón se expanda según sea necesario.
* Una vez que se agota todo el submontón, el administrador del montón crea un nuevo submontón para continuar con la asignación.

### malloc\_state

**Cada montón** (arena principal u otras arenas de hilos) tiene una **estructura `malloc_state`.**\
Es importante tener en cuenta que la estructura **`malloc_state`** de la **arena principal** es una **variable global en la libc** (por lo tanto, ubicada en el espacio de memoria de la libc).\
En el caso de las estructuras **`malloc_state`** de los montones de hilos, se encuentran **dentro del "montón" del hilo propio**.

Hay algunas cosas interesantes que destacar de esta estructura (ver código en C a continuación):

* El `mchunkptr bins[NBINS * 2 - 2];` contiene **punteros** a los **primeros y últimos fragmentos** de los **bins** pequeños, grandes y desordenados (el -2 es porque el índice 0 no se utiliza)
* Por lo tanto, el **primer fragmento** de estos bins tendrá un **puntero hacia atrás a esta estructura** y el **último fragmento** de estos bins tendrá un **puntero hacia adelante** a esta estructura. Lo que básicamente significa que si puedes **filtrar estas direcciones en la arena principal** tendrás un puntero a la estructura en la **libc**.
* Las estructuras `struct malloc_state *next;` y `struct malloc_state *next_free;` son listas enlazadas de arenas.
* El fragmento `top` es el último "fragmento", que básicamente es **todo el espacio restante del montón**. Una vez que el fragmento superior está "vacío", el montón está completamente utilizado y necesita solicitar más espacio.
* El fragmento de `last reminder` proviene de casos en los que no está disponible un fragmento de tamaño exacto y, por lo tanto, se divide un fragmento más grande, colocando una parte restante del puntero aquí.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_state
struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);
/* Flags (formerly in max_fast).  */
int flags;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];
/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;
/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;
/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;
/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;
/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */

INTERNAL_SIZE_T attached_threads;
/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};

typedef struct malloc_state *mstate;
```
### malloc\_chunk

Esta estructura representa un fragmento particular de memoria. Los diversos campos tienen diferentes significados para fragmentos asignados y no asignados.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Como se comentó anteriormente, estos fragmentos también tienen metadatos, muy bien representados en esta imagen:

<figure><img src="../../.gitbook/assets/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Los metadatos suelen ser 0x08B indicando el tamaño actual del fragmento utilizando los últimos 3 bits para indicar:

* `A`: Si es 1, proviene de un submontón; si es 0, está en la arena principal
* `M`: Si es 1, este fragmento es parte de un espacio asignado con mmap y no es parte de un montón
* `P`: Si es 1, el fragmento anterior está en uso

Luego, el espacio para los datos del usuario, y finalmente 0x08B para indicar el tamaño del fragmento anterior cuando el fragmento está disponible (o para almacenar los datos del usuario cuando está asignado).

Además, cuando está disponible, los datos del usuario se utilizan para contener también algunos datos:

* Puntero al siguiente fragmento
* Puntero al fragmento anterior
* Tamaño del siguiente fragmento en la lista
* Tamaño del fragmento anterior en la lista



<figure><img src="../../.gitbook/assets/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

{% hint style="info" %}
Observa cómo al vincular la lista de esta manera se evita la necesidad de tener una matriz donde se registra cada fragmento individualmente.
{% endhint %}

### Ejemplo Rápido de Montón

Ejemplo rápido de montón de [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) pero en arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Establece un punto de interrupción al final de la función principal y descubramos dónde se almacenó la información:

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

Es posible ver que la cadena panda se almacenó en `0xaaaaaaac12a0` (que fue la dirección dada como respuesta por malloc dentro de `x0`). Revisando 0x10 bytes antes, es posible ver que el `0x0` representa que el **fragmento anterior no está en uso** (longitud 0) y que la longitud de este fragmento es `0x21`.

Los espacios adicionales reservados (0x21-0x10=0x11) provienen de los **encabezados añadidos** (0x10) y 0x1 no significa que se reservaron 0x21B, sino que los últimos 3 bits de la longitud del encabezado actual tienen algunos significados especiales. Dado que la longitud siempre está alineada en bloques de 16 bytes (en máquinas de 64 bits), estos bits en realidad nunca se van a utilizar en el número de longitud.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
## Bins y Asignaciones/Liberaciones de Memoria

Verifique cuáles son los bins y cómo están organizados, así como cómo se asigna y libera memoria en:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

## Verificaciones de Seguridad de Funciones de Heap

Las funciones involucradas en el heap realizarán ciertas verificaciones antes de realizar sus acciones para intentar asegurarse de que el heap no esté corrompido:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referencias

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
