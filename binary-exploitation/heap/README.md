# Tas de données

## Bases du tas

Le tas est essentiellement l'endroit où un programme pourra stocker des données lorsqu'il demande des données en appelant des fonctions telles que **`malloc`**, `calloc`... De plus, lorsque cette mémoire n'est plus nécessaire, elle est libérée en appelant la fonction **`free`**.

Comme le montre l'image ci-dessous, le tas se situe juste après le chargement du binaire en mémoire (vérifiez la section `[heap]`):

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### Allocation de morceaux de base

Lorsqu'il est demandé de stocker des données dans le tas, un espace du tas lui est alloué. Cet espace appartiendra à un bac et seuls les données demandées + l'espace des en-têtes de bac + le décalage de taille de bac minimum seront réservés pour le morceau. Le but est de réserver autant de mémoire que possible sans compliquer la recherche de chaque morceau. Pour cela, les informations de métadonnées de morceau sont utilisées pour savoir où se trouve chaque morceau utilisé/libre.

Il existe différentes façons de réserver l'espace principalement en fonction du bac utilisé, mais une méthodologie générale est la suivante :

* Le programme commence par demander une certaine quantité de mémoire.
* S'il y a quelqu'un dans la liste des morceaux qui est assez grand pour répondre à la demande, il sera utilisé.
* Cela peut même signifier que partie du morceau disponible sera utilisée pour cette demande et le reste sera ajouté à la liste des morceaux.
* S'il n'y a aucun morceau disponible dans la liste mais qu'il reste de l'espace dans la mémoire allouée du tas, le gestionnaire de tas crée un nouveau morceau.
* S'il n'y a pas assez d'espace de tas pour allouer le nouveau morceau, le gestionnaire de tas demande au noyau d'étendre la mémoire allouée au tas, puis utilise cette mémoire pour générer le nouveau morceau.
* Si tout échoue, `malloc` renvoie null.

Notez que si la mémoire demandée **dépasse un seuil**, **`mmap`** sera utilisé pour mapper la mémoire demandée.

### Arènes

Dans les applications **multithread**, le gestionnaire de tas doit prévenir les **conditions de concurrence** qui pourraient entraîner des plantages. Initialement, cela était fait en utilisant un **mutex global** pour garantir qu'un seul thread pouvait accéder au tas à la fois, mais cela causait des **problèmes de performance** en raison de l'engorgement induit par le mutex.

Pour remédier à cela, l'allocateur de tas ptmalloc2 a introduit des "arènes", où **chaque arène** agit comme un **tas séparé** avec ses **propres** structures de données et **mutex**, permettant à plusieurs threads d'effectuer des opérations de tas sans interférer les uns avec les autres, tant qu'ils utilisent des arènes différentes.

L'arène "principale" par défaut gère les opérations de tas pour les applications monofils. Lorsque de **nouveaux threads** sont ajoutés, le gestionnaire de tas leur attribue des **arènes secondaires** pour réduire les conflits. Il tente d'abord d'attacher chaque nouveau thread à une arène inutilisée, en en créant de nouvelles si nécessaire, jusqu'à une limite de 2 fois le nombre de cœurs CPU pour les systèmes 32 bits et 8 fois pour les systèmes 64 bits. Une fois la limite atteinte, les **threads doivent partager des arènes**, entraînant des conflits potentiels.

Contrairement à l'arène principale, qui s'étend en utilisant l'appel système `brk`, les arènes secondaires créent des "sous-tas" en utilisant `mmap` et `mprotect` pour simuler le comportement du tas, permettant une flexibilité dans la gestion de la mémoire pour les opérations multithread.

### Sous-tas

Les sous-tas servent de réserves de mémoire pour les arènes secondaires dans les applications multithread, leur permettant de croître et de gérer leurs propres régions de tas séparément du tas principal. Voici comment les sous-tas diffèrent du tas initial et comment ils fonctionnent :

1. **Tas initial vs sous-tas** :
* Le tas initial se trouve directement après le binaire du programme en mémoire, et il s'étend en utilisant l'appel système `sbrk`.
* Les sous-tas, utilisés par les arènes secondaires, sont créés via `mmap`, un appel système qui mappe une région mémoire spécifiée.
2. **Réservation de mémoire avec `mmap`** :
* Lorsque le gestionnaire de tas crée un sous-tas, il réserve un grand bloc de mémoire via `mmap`. Cette réservation n'alloue pas immédiatement de mémoire ; elle désigne simplement une région que d'autres processus système ou allocations ne doivent pas utiliser.
* Par défaut, la taille réservée pour un sous-tas est de 1 Mo pour les processus 32 bits et de 64 Mo pour les processus 64 bits.
3. **Expansion progressive avec `mprotect`** :
* La région mémoire réservée est initialement marquée comme `PROT_NONE`, indiquant que le noyau n'a pas besoin d'allouer de mémoire physique à cet espace pour le moment.
* Pour "étendre" le sous-tas, le gestionnaire de tas utilise `mprotect` pour changer les autorisations de page de `PROT_NONE` à `PROT_READ | PROT_WRITE`, incitant le noyau à allouer de la mémoire physique aux adresses précédemment réservées. Cette approche pas à pas permet au sous-tas de s'étendre selon les besoins.
* Une fois que tout le sous-tas est épuisé, le gestionnaire de tas crée un nouveau sous-tas pour continuer l'allocation.

### État malloc

**Chaque tas** (arène principale ou arènes des autres threads) a une **structure `malloc_state`.**\
Il est important de noter que la structure **`malloc_state` de l'arène principale** est une **variable globale dans la libc** (donc située dans l'espace mémoire de la libc).\
Dans le cas des structures **`malloc_state`** des tas des threads, elles sont situées **à l'intérieur du "tas" du thread**.

Il y a quelques points intéressants à noter dans cette structure (voir le code C ci-dessous) :

* Le `mchunkptr bins[NBINS * 2 - 2];` contient des **pointeurs** vers les **premiers et derniers morceaux** des **bacs** petits, grands et non triés (le -2 est dû au fait que l'index 0 n'est pas utilisé).
* Par conséquent, le **premier morceau** de ces bacs aura un **pointeur arrière vers cette structure** et le **dernier morceau** de ces bacs aura un **pointeur avant** vers cette structure. Ce qui signifie essentiellement que si vous pouvez **fuir ces adresses dans l'arène principale**, vous aurez un pointeur vers la structure dans la **libc**.
* Les structures `struct malloc_state *next;` et `struct malloc_state *next_free;` sont des listes chaînées d'arènes.
* Le morceau `top` est le dernier "morceau", qui est essentiellement **tout l'espace restant du tas**. Une fois que le morceau supérieur est "vide", le tas est complètement utilisé et doit demander plus d'espace.
* Le morceau de **dernier rappel** provient des cas où un morceau de taille exacte n'est pas disponible et donc un morceau plus grand est divisé, une partie restante du pointeur est placée ici.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_state
struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);
/* Flags (formerly in max_fast).  */
int flags;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];
/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;
/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;
/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;
/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;
/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */

INTERNAL_SIZE_T attached_threads;
/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};

typedef struct malloc_state *mstate;
```
### malloc\_chunk

Cette structure représente un morceau particulier de mémoire. Les différents champs ont des significations différentes pour les morceaux alloués et non alloués.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Comme commenté précédemment, ces morceaux ont également des métadonnées, très bien représentées dans cette image:

<figure><img src="../../.gitbook/assets/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Les métadonnées sont généralement 0x08B indiquant la taille actuelle du morceau en utilisant les 3 derniers bits pour indiquer:

* `A`: Si 1, il provient d'un sous-ensemble, si 0, il est dans l'arène principale
* `M`: Si 1, ce morceau fait partie d'un espace alloué avec mmap et non d'un tas
* `P`: Si 1, le morceau précédent est en cours d'utilisation

Ensuite, l'espace pour les données utilisateur, et enfin 0x08B pour indiquer la taille du morceau précédent lorsque le morceau est disponible (ou pour stocker les données utilisateur lorsqu'il est alloué).

De plus, lorsque disponible, les données utilisateur sont également utilisées pour contenir certaines données:

* Pointeur vers le prochain morceau
* Pointeur vers le morceau précédent
* Taille du prochain morceau dans la liste
* Taille du morceau précédent dans la liste



<figure><img src="../../.gitbook/assets/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

{% hint style="info" %}
Notez comment aimer la liste de cette manière évite d'avoir besoin d'un tableau où chaque morceau est enregistré.
{% endhint %}

### Exemple rapide de tas

Exemple rapide de tas provenant de [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) mais en arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Placez un point d'arrêt à la fin de la fonction principale et découvrons où les informations ont été stockées :

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

Il est possible de voir que la chaîne panda a été stockée à `0xaaaaaaac12a0` (qui était l'adresse donnée en réponse par malloc à l'intérieur de `x0`). En vérifiant les 0x10 octets précédents, on peut voir que le `0x0` représente que le **chunk précédent n'est pas utilisé** (longueur 0) et que la longueur de ce chunk est `0x21`.

Les espaces supplémentaires réservés (0x21-0x10=0x11) proviennent des **en-têtes ajoutés** (0x10) et 0x1 ne signifie pas qu'il a été réservé 0x21B mais les 3 derniers bits de la longueur de l'en-tête actuel ont des significations spéciales. Comme la longueur est toujours alignée sur 16 octets (sur les machines 64 bits), ces bits ne seront en réalité jamais utilisés par le nombre de longueur.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
## Bins & Allocations/Libérations de Mémoire

Vérifiez ce que sont les bacs, comment ils sont organisés et comment la mémoire est allouée et libérée dans :

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

## Contrôles de Sécurité des Fonctions du Tas

Les fonctions impliquées dans le tas effectueront certaines vérifications avant d'effectuer leurs actions pour essayer de s'assurer que le tas n'a pas été corrompu :

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Références

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
