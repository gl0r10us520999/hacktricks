# Bins & 메모리 할당

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 영웅이 될 때까지 AWS 해킹을 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>

## 기본 정보

각 청크가 저장되는 효율성을 향상시키기 위해 모든 청크가 하나의 연결된 목록에만 있는 것이 아니라 여러 유형의 bin이 있습니다. 이러한 bin은 5 종류이며, [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407)개의 small bin, 63개의 large bin, 1개의 unsorted bin, 10개의 fast bin 및 스레드당 64개의 tcache bin이 있습니다.

각 unsorted, small 및 large bin에 대한 초기 주소는 동일한 배열 내에 있습니다. 인덱스 0은 사용되지 않으며, 1은 unsorted bin, 2-64는 small bin, 65-127는 large bin입니다.

### Tcache (스레드별 캐시) Bins

스레드가 자체 힙을 갖도록 노력하더라도 (Arenas 및 Subheaps 참조), 많은 스레드(예: 웹 서버)를 가진 프로세스가 다른 스레드와 힙을 공유할 수 있습니다. 이 경우, 주요 해결책은 **lockers**의 사용이며, 이는 스레드를 **상당히 느리게 만들 수 있습니다**.

따라서 tcache는 각 스레드당 하나의 fast bin과 유사하며, 청크를 병합하지 않는 **단일 연결된 목록**입니다. 각 스레드에는 **64개의 단일 링크드 tcache bin**이 있습니다. 각 bin은 [64비트 시스템에서 24에서 1032B, 32비트 시스템에서 12에서 516B](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) 범위 내의 최대 [7개의 동일한 크기 청크](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323)를 가질 수 있습니다.

**스레드가** 청크를 해제할 때, 해당 청크가 tcache에 할당되기에 충분히 크지 않고 해당 tcache bin이 **가득 차 있지 않으면** (이미 7개의 청크가 있는 경우), **거기에 할당됩니다**. tcache로 이동할 수 없는 경우, 전역 bin에서 하나를 찾거나 새로 만들기 위해 힙 잠금을 기다려야 합니다.

청크가 할당될 때, **Tcache에 필요한 크기의 무료 청크가 있는 경우** 사용하고, 그렇지 않으면 힙 잠금을 기다려 전역 bin에서 하나를 찾거나 새로 만들어야 합니다.\
또한 이 경우 최적화가 있으며, 힙 잠금을 사용하는 동안 스레드는 요청된 크기의 힙 청크(7개)로 Tcache를 채우므로 필요한 경우 Tcache에서 찾을 수 있습니다.

<details>

<summary>tcache 청크 예제 추가</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
free(chunk);
return 0;
}
```
컴파일하고 메인 함수의 ret 옵코드에 중단점을 설정하여 디버깅합니다. 그런 다음 gef를 사용하여 사용 중인 tcache bin을 볼 수 있습니다:
```bash
gef➤  heap bins
──────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=0, size=0x20, count=1] ←  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```
</details>

#### Tcache 구조체 및 함수

다음 코드에서는 **최대 bins** 및 **인덱스 당 청크 수**, 이중 해제를 피하기 위해 생성된 **`tcache_entry`** 구조체 및 각 스레드가 각 bin의 주소를 저장하는 데 사용하는 **`tcache_perthread_struct`** 구조체를 볼 수 있습니다.

<details>

<summary><code>tcache_entry</code> 및 <code>tcache_perthread_struct</code></summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c

/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

/* Only used to pre-fill the tunables.  */
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

/* When "x" is from chunksize().  */
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
/* When "x" is a user-provided size.  */
# define usize2tidx(x) csize2tidx (request2size (x))

/* With rounding and alignment, the bins are...
idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
idx 1   bytes 25..40 or 13..20
idx 2   bytes 41..56 or 21..28
etc.  */

/* This is another arbitrary limit, which tunables can change.  Each
tcache bin will hold at most this number of chunks.  */
# define TCACHE_FILL_COUNT 7

/* Maximum chunks in tcache bins for tunables.  This value must fit the range
of tcache->counts[] entries, else they may overflow.  */
# define MAX_TCACHE_COUNT UINT16_MAX

[...]

typedef struct tcache_entry
{
struct tcache_entry *next;
/* This field exists to detect double frees.  */
uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
per-thread cache (hence "tcache_perthread_struct").  Keeping
overall size low is mildly important.  Note that COUNTS and ENTRIES
are redundant (we could have just counted the linked list each
time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
uint16_t counts[TCACHE_MAX_BINS];
tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
</details>

`__tcache_init` 함수는 `tcache_perthread_struct` obj의 공간을 생성하고 할당하는 함수입니다.

<details>

<summary>tcache_init 코드</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3241C1-L3274C2

static void
tcache_init(void)
{
mstate ar_ptr;
void *victim = 0;
const size_t bytes = sizeof (tcache_perthread_struct);

if (tcache_shutting_down)
return;

arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}


if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

/* In a low memory situation, we may not be able to allocate memory
- in which case, we just keep trying later.  However, we
typically do this very early, so either there is sufficient
memory, or there isn't enough memory to do non-trivial
allocations anyway.  */
if (victim)
{
tcache = (tcache_perthread_struct *) victim;
memset (tcache, 0, sizeof (tcache_perthread_struct));
}

}
```
</details>

#### Tcache Indexes

Tcache에는 크기에 따라 여러 개의 bin이 있으며, 각 인덱스의 첫 번째 청크를 가리키는 초기 포인터와 인덱스 당 청크 수가 청크 내부에 위치합니다. 이는 이 정보를 포함하는 청크(보통 첫 번째 청크)를 찾으면 모든 tcache 초기 지점과 Tcache 청크 수를 찾을 수 있다는 것을 의미합니다.

### Fast bins

Fast bins는 최근에 해제된 청크를 빠르게 액세스할 수 있는 구조에 유지하여 작은 청크에 대한 메모리 할당 속도를 높이도록 설계되었습니다. 이러한 bin은 후입선출(LIFO) 방식을 사용하며, 가장 최근에 해제된 청크가 새로운 할당 요청이 있을 때 재사용되는 첫 번째로 사용됩니다. 이 동작은 속도 측면에서 유리하며, 후입선출(LIFO) 스택의 맨 위에 삽입하고 제거하는 것이 선입선출(FIFO) 큐보다 빠릅니다.

게다가, fast bins는 단일 연결 목록을 사용하며 이는 속도를 더 향상시킵니다. Fast bins의 청크는 이웃과 병합되지 않기 때문에 중간에서 제거할 수 있는 복잡한 구조가 필요하지 않습니다. 단일 연결 목록은 이러한 작업에 대해 더 간단하고 빠릅니다.

기본적으로 여기서 발생하는 일은 헤더(확인할 첫 번째 청크를 가리키는 포인터)가 항상 해당 크기의 최근에 해제된 청크를 가리키고 있다는 것입니다. 그래서:

- 해당 크기의 새로운 청크가 할당되면, 헤더는 사용할 수 있는 무료 청크를 가리킵니다. 이 무료 청크가 사용할 다음 청크를 가리키고 있으므로, 이 주소는 헤더에 저장되어 다음 할당이 어디에서 사용 가능한 청크를 가져올지 알 수 있습니다.
- 청크가 해제되면, 무료 청크는 현재 사용 가능한 청크의 주소를 저장하고, 이 새로 해제된 청크의 주소가 헤더에 넣어집니다.

연결 목록의 최대 크기는 `0x80`이며, 청크 크기 `0x20-0x2f`는 인덱스 `0`에, 청크 크기 `0x30-0x3f`는 `idx` `1`에 있게 구성됩니다.

{% hint style="danger" %}
Fast bins의 청크는 사용 가능하게 설정되지 않으므로 주변의 다른 무료 청크와 병합할 수 있는 대신 어느 정도의 시간 동안 fast bin 청크로 유지됩니다.
{% endhint %}
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Fastbins

An array of lists holding recently freed small chunks.  Fastbins
are not doubly linked.  It is faster to single-link them, and
since chunks are never removed from the middles of these lists,
double linking is not necessary. Also, unlike regular bins, they
are not even processed in FIFO order (they use faster LIFO) since
ordering doesn't much matter in the transient contexts in which
fastbins are normally used.

Chunks in fastbins keep their inuse bit set, so they cannot
be consolidated with other free chunks. malloc_consolidate
releases all chunks in fastbins and consolidates them with
other free chunks.
*/

typedef struct malloc_chunk *mfastbinptr;
#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)


/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
```
<details>

<summary>빠른 바인 청크 예시 추가</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[8];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 8; i++) {
chunks[i] = malloc(24);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
참고로 동일한 크기의 8개 청크를 할당하고 해제하여 tcache를 채우고 여덟 번째 청크는 fast 청크에 저장되도록합니다.

컴파일하고 메인 함수의 ret 옵코드에 중단점을 설정하여 디버깅합니다. 그런 다음 gef를 사용하여 tcache bin이 채워지고 fast bin에 하나의 청크가 있는 것을 볼 수 있습니다:
```bash
gef➤  heap bins
──────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=0, size=0x20, count=7] ←  Chunk(addr=0xaaaaaaac1770, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1750, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1730, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1710, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac16f0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac16d0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
───────────────────────────────────────────────────────────────────────── Fastbins for arena at 0xfffff7f90b00 ─────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20]  ←  Chunk(addr=0xaaaaaaac1790, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
Fastbins[idx=1, size=0x30] 0x00
```
</details>

### Unsorted bin

Unsorted bin은 힙 매니저가 메모리 할당을 빠르게 만들기 위해 사용하는 **캐시**입니다. 작동 방식은 다음과 같습니다: 프로그램이 청크를 해제하면서, 이 청크가 tcache나 fast bin에 할당될 수 없고 상단 청크와 충돌하지 않는 경우, 힙 매니저는 즉시 특정 small 또는 large bin에 넣지 않습니다. 대신, 먼저 이 청크를 주변의 다른 빈 공간과 **병합하여** 더 큰 빈 메모리 블록을 만듭니다. 그런 다음, 이 새로운 청크를 "unsorted bin"이라고 불리는 일반적인 bin에 배치합니다.

프로그램이 **메모리를 요청**할 때, 힙 매니저는 unsorted bin을 **확인하여** 충분한 크기의 청크가 있는지 확인합니다. 발견하면 즉시 사용합니다. unsorted bin에서 적합한 청크를 찾지 못하면, 이 목록의 모든 청크를 해당 크기에 따라 소형 또는 대형 bin으로 이동시킵니다.

더 큰 청크가 2개의 반으로 나뉘고 나머지가 MINSIZE보다 크면, 다시 unsorted bin에 넣을 것입니다.&#x20;

따라서 unsorted bin은 최근에 해제된 메모리를 빠르게 재사용하여 메모리 할당 속도를 높이고, 시간이 많이 소요되는 검색과 병합이 필요한 경우를 줄입니다.

{% hint style="danger" %}
다른 카테고리의 청크이더라도 사용 가능한 청크가 다른 사용 가능한 청크와 충돌하는 경우 (원래 서로 다른 bin에 속해 있더라도), 병합됩니다.
{% endhint %}

<details>

<summary>unsorted chunk 예제 추가</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[9];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
참고로 동일한 크기의 9개 청크를 할당하고 해제하여 **tcache를 채우도록**하고 여덟 번째 청크는 **fastbin에 너무 크기 때문에** unsorted bin에 저장되며 아홉 번째 청크는 해제되지 않아 아홉 번째와 여덟 번째가 **top 청크와 병합되지 않도록**합니다.

이를 컴파일하고 main 함수의 ret 옵코드에 중단점을 걸어 디버깅합니다. 그런 다음 gef를 사용하여 tcache bin이 채워지고 unsorted bin에 하나의 청크가 있는 것을 볼 수 있습니다:
```bash
gef➤  heap bins
──────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=15, size=0x110, count=7] ←  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
───────────────────────────────────────────────────────────────────────── Fastbins for arena at 0xfffff7f90b00 ─────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────── Unsorted Bin for arena at 0xfffff7f90b00 ───────────────────────────────────────────────────────────────────────
[+] unsorted_bins[0]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
→   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
```
</details>

### 작은 Bins

작은 Bins은 큰 Bins보다 빠르지만 fast bins보다는 느립니다.

62개의 각 bin은 **동일한 크기의 청크**를 가집니다: 16, 24, ... (32비트 시스템에서는 최대 504바이트, 64비트 시스템에서는 최대 1024바이트). 이는 공간이 할당되어야 하는 bin을 찾고 이러한 목록에 항목을 삽입하고 제거하는 속도에 도움이 됩니다.

작은 bin의 크기는 bin의 인덱스에 따라 다음과 같이 계산됩니다:

* 가장 작은 크기: 2\*4\*인덱스 (예: 인덱스 5 -> 40)
* 가장 큰 크기: 2\*8\*인덱스 (예: 인덱스 5 -> 80)
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
+ SMALLBIN_CORRECTION)
```
작은 바이너리와 큰 바이너리 중에서 선택하는 함수:
```c
#define bin_index(sz) \
((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
```
<details>

<summary>작은 청크 예시 추가</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[10];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

chunks[9] = malloc(0x110);

return 0;
}
```
9개의 동일한 크기의 청크를 할당하고 해제하는 방법에 주목하세요. 이렇게 하면 **tcache를 채우게** 되고 여덟 번째 청크는 **fastbin에 너무 크기 때문에 unsorted bin에 저장**되며 아홉 번째 청크는 해제되지 않아서 아홉 번째와 여덟 번째가 **top 청크와 병합되지 않습니다**. 그런 다음 0x110 크기의 더 큰 청크를 할당하여 **unsorted bin에 있는 청크가 small bin으로 이동**하게 됩니다.

이를 컴파일하고 main 함수의 ret 옵코드에 중단점을 걸어 디버깅합니다. 그런 다음 gef를 사용하여 tcache bin이 채워지고 small bin에 하나의 청크가 있는 것을 볼 수 있습니다:
```bash
gef➤  heap bins
──────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=15, size=0x110, count=7] ←  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
───────────────────────────────────────────────────────────────────────── Fastbins for arena at 0xfffff7f90b00 ─────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────── Unsorted Bin for arena at 0xfffff7f90b00 ───────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────── Small Bins for arena at 0xfffff7f90b00 ────────────────────────────────────────────────────────────────────────
[+] small_bins[16]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
→   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 small non-empty bins.
```
</details>

### 대형 bins

작은 bins가 고정 크기의 청크를 관리하는 반면, **각 대형 bin은 청크 크기 범위를 처리**합니다. 이는 더 유연하며, 시스템이 **여러 가지 크기**를 별도의 각 크기에 대한 bin이 필요하지 않고 수용할 수 있도록 합니다.

메모리 할당기에서 대형 bins는 작은 bins가 끝나는 곳에서 시작합니다. 대형 bins의 범위는 점진적으로 커지며, 첫 번째 bin은 512에서 576바이트의 청크를 포함할 수 있지만, 다음 bin은 576에서 640바이트의 청크를 포함합니다. 이 패턴은 계속되며, 가장 큰 bin에는 1MB 이상의 모든 청크가 포함됩니다.

대형 bins는 작은 bins보다 작업 속도가 느립니다. 왜냐하면 할당에 최적의 적합한 청크를 찾기 위해 **다양한 청크 크기 목록을 정렬하고 검색**해야하기 때문입니다. 대형 bin에 청크가 삽입되면 정렬해야 하며, 메모리가 할당될 때 시스템은 적절한 청크를 찾아야 합니다. 이 추가 작업으로 인해 대형 bins는 **느립니다**. 그러나 대형 할당이 작은 할당보다 적기 때문에 이는 허용할 수 있는 교환입니다.

다음과 같은 것들이 있습니다:

* 64B 범위의 32개 bins (작은 bins와 충돌)
* 512B 범위의 16개 bins (작은 bins와 충돌)
* 4096B 범위의 8개 bins (일부는 작은 bins와 충돌)
* 32768B 범위의 4개 bins
* 262144B 범위의 2개 bins
* 나머지 크기를 위한 1개 bin

<details>

<summary>대형 bin 크기 코드</summary>
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

#define largebin_index_32(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index_32_big(sz)                                            \
(((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index(sz) \
(SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
: largebin_index_32 (sz))
```
</details>

<details>

<summary>대규모 청크 예제 추가</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[2];

chunks[0] = malloc(0x1500);
chunks[1] = malloc(0x1500);
free(chunks[0]);
chunks[0] = malloc(0x2000);

return 0;
}
```
2개의 큰 할당이 수행되고, 그 중 하나가 해제됩니다 (unsorted bin에 넣음) 그리고 더 큰 할당이 이루어집니다 (unsorted bin에서 large bin으로 이동됨).

이를 컴파일하고 main 함수의 ret 옵코드에 중단점을 걸어 디버깅합니다. 그런 다음 gef를 사용하여 tcache bin이 채워지고 large bin에 하나의 청크가 있는 것을 볼 수 있습니다:
```bash
gef➤  heap bin
──────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────────
All tcachebins are empty
───────────────────────────────────────────────────────────────────────── Fastbins for arena at 0xfffff7f90b00 ─────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────── Unsorted Bin for arena at 0xfffff7f90b00 ───────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────── Small Bins for arena at 0xfffff7f90b00 ────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────────────────────────────────────────── Large Bins for arena at 0xfffff7f90b00 ────────────────────────────────────────────────────────────────────────
[+] large_bins[100]: fw=0xaaaaaaac1290, bk=0xaaaaaaac1290
→   Chunk(addr=0xaaaaaaac12a0, size=0x1510, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 large non-empty bins.
```
</details>

### 최상 청크
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Top

The top-most available chunk (i.e., the one bordering the end of
available memory) is treated specially. It is never included in
any bin, is used only if no other chunk is available, and is
released back to the system if it is very large (see
M_TRIM_THRESHOLD).  Because top initially
points to its own bin with initial zero size, thus forcing
extension on the first malloc request, we avoid having any special
code in malloc to check whether it even exists yet. But we still
need to do so when getting memory from system, so we make
initial_top treat the bin as a legal but unusable chunk during the
interval between initialization and the first call to
sysmalloc. (This is somewhat delicate, since it relies on
the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
```
기본적으로, 현재 사용 가능한 힙을 모두 포함한 청크입니다. malloc이 수행될 때 사용 가능한 빈 청크가 없으면 이 최상위 청크는 필요한 공간을 제공하기 위해 크기를 줄일 것입니다. Top Chunk에 대한 포인터는 `malloc_state` 구조체에 저장됩니다.

또한, 처음에는 정렬되지 않은 청크를 최상위 청크로 사용할 수 있습니다.

<details>

<summary>Top Chunk 예시 확인</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
return 0;
}
```
컴파일하고 메인 함수의 ret 옵코드에 중단점을 걸어 디버깅한 후 malloc이 반환한 주소는 `0xaaaaaaac12a0`이고 이것이 청크입니다:
```bash
gef➤  heap chunks
Chunk(addr=0xaaaaaaac1010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac1010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12a0     41 41 41 41 41 41 41 00 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac12c0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12c0     41 64 64 72 65 73 73 20 6f 66 20 74 68 65 20 63    Address of the c]
Chunk(addr=0xaaaaaaac16d0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac16d0     41 41 41 41 41 41 41 0a 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac1ae0, size=0x20530, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  top chunk
```
최상위 청크가 주소 `0xaaaaaaac1ae0`에 있는 것을 확인할 수 있습니다. 최근 할당된 청크가 `0xaaaaaaac12a0`에 크기가 `0x410`인 것이었기 때문에 이는 놀라운 일이 아닙니다. `0xaaaaaaac12a0 + 0x410 = 0xaaaaaaac1ae0`입니다.\
또한 최상위 청크의 길이를 청크 헤더에서 확인할 수도 있습니다:
```bash
gef➤  x/8wx 0xaaaaaaac1ae0 - 16
0xaaaaaaac1ad0:	0x00000000	0x00000000	0x00020531	0x00000000
0xaaaaaaac1ae0:	0x00000000	0x00000000	0x00000000	0x00000000
```
</details>

### 마지막 알림

`malloc`이 사용되고 청크가 분할될 때 (예: 링크되지 않은 목록이나 상단 청크에서), 나누어진 청크의 나머지에서 생성된 청크를 **마지막 알림(Last Reminder)**이라고 하며 그 포인터는 `malloc_state` 구조체에 저장됩니다.

## 할당 흐름

다음을 확인하세요:

{% content-ref url="heap-memory-functions/malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](heap-memory-functions/malloc-and-sysmalloc.md)
{% endcontent-ref %}

## 해제 흐름

다음을 확인하세요:

{% content-ref url="heap-memory-functions/free.md" %}
[free.md](heap-memory-functions/free.md)
{% endcontent-ref %}

## 힙 함수 보안 검사

힙에서 자주 사용되는 함수들에 의해 수행되는 보안 검사를 확인하세요:

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## 참고 자료

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/)

<details>

<summary><strong>제로부터 AWS 해킹을 전문가로 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>
