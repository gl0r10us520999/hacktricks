# House of Force



<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di Base

### Codice

* Questa tecnica √® stata corretta ([**qui**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) e produce questo errore: `malloc(): corrupted top size`
* Puoi provare il [**codice da qui**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) per testarlo se vuoi.

### Obiettivo

* L'obiettivo di questo attacco √® quello di poter allocare un chunk in un indirizzo specifico.

### Requisiti

* Un overflow che permette di sovrascrivere la dimensione dell'intestazione del top chunk (es. -1).
* Essere in grado di controllare la dimensione dell'allocazione dell'heap

### Attacco

Se un attaccante vuole allocare un chunk nell'indirizzo P per sovrascrivere un valore qui. Inizia sovrascrivendo la dimensione del top chunk con `-1` (forse con un overflow). Questo garantisce che malloc non utilizzer√† mmap per nessuna allocazione poich√© il Top chunk avr√† sempre abbastanza spazio.

Quindi, calcola la distanza tra l'indirizzo del top chunk e lo spazio target da allocare. Questo perch√© verr√† eseguita un'allocazione malloc con quella dimensione per spostare il top chunk in quella posizione. Ecco come pu√≤ essere facilmente calcolata la differenza/dimensione:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Quindi, allocare una dimensione di `target - old_top - 4*sizeof(long)` (i 4 long sono a causa dei metadati del chunk superiore e del nuovo chunk quando allocato) sposter√† il chunk superiore all'indirizzo che vogliamo sovrascrivere.\
Successivamente, fare un altro malloc per ottenere un chunk contenente l'inizio dei dati da scrivere all'indirizzo target.

### Riferimenti ed Altri Esempi

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* L'obiettivo di questo scenario √® un ret2win dove √® necessario modificare l'indirizzo di una funzione che verr√† chiamata dall'indirizzo della funzione ret2win
* Il binario ha un overflow che pu√≤ essere sfruttato per modificare la dimensione del top chunk, che viene modificata in -1 o p64(0xffffffffffffffff)
* Quindi, viene calcolato l'indirizzo del luogo in cui esiste il puntatore da sovrascrivere e la differenza dalla posizione attuale del top chunk a quel punto viene allocata con `malloc`
* Infine viene allocato un nuovo chunk che conterr√† questo target desiderato all'interno che viene sovrascritto dalla funzione ret2win
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* Nel `Input your name:` c'√® una vulnerabilit√† iniziale che consente di ottenere un leak di un indirizzo dall'heap
* Poi nelle funzionalit√† `Org:` e `Host:`, √® possibile riempire i 64B del puntatore `s` quando viene richiesto il **nome dell'org**, che nello stack √® seguito dall'indirizzo di v2, che √® poi seguito dal **nome dell'host** indicato. Poich√© poi, strcpy copier√† i contenuti di s in un chunk di dimensione 64B, √® possibile **sovrascrivere la dimensione del top chunk** con i dati inseriti nel **nome dell'host**.
* Ora che √® possibile una scrittura arbitraria, il GOT di `atoi` √® stato sovrascritto con l'indirizzo di printf. √® possibile ottenere il leak dell'indirizzo di `IO_2_1_stderr` _con_ `%24$p`. E con questo leak di libc √® stato possibile sovrascrivere di nuovo il GOT di `atoi` con l'indirizzo di `system` e chiamarlo passando come parametro `/bin/sh`
* Un metodo alternativo [proposto in questo altro writeup](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), √® sovrascrivere `free` con `puts`, e quindi aggiungere l'indirizzo di `atoi@got`, nel puntatore che verr√† successivamente liberato in modo che venga leakato e con questo leak sovrascrivere di nuovo `atoi@got` con `system` e chiamarlo con `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* C'√® un UAF che consente di riutilizzare un chunk che √® stato liberato senza cancellare il puntatore. Poich√© ci sono alcuni metodi di lettura, √® possibile ottenere un leak di un indirizzo libc scrivendo un puntatore alla funzione free nel GOT qui e quindi chiamando la funzione di lettura.
* Quindi, √® stato utilizzato House of force (abusando dell'UAF) per sovrascrivere la dimensione dello spazio sinistro con un -1, allocare un chunk abbastanza grande per arrivare al free hook, e quindi allocare un altro chunk che conterr√† il free hook. Quindi, scrivere nel hook l'indirizzo di `system`, scrivere in un chunk `"/bin/sh"` e infine liberare il chunk con quel contenuto di stringa.
