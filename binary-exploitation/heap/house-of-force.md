# House of Force



<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

### 코드

* 이 기술은 ([**여기**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c))에서 패치되었으며 다음 오류를 생성합니다: `malloc(): corrupted top size`
* 테스트하려면 [**여기에서 코드를**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) 사용할 수 있습니다.

### 목표

* 이 공격의 목표는 특정 주소에 청크를 할당할 수 있는 것입니다.

### 요구 사항

* 상단 청크 헤더의 크기를 덮어쓸 수 있는 오버플로우가 필요합니다 (예: -1).
* 힙 할당의 크기를 제어할 수 있어야 합니다.

### 공격

공격자가 특정 주소 P에 청크를 할당하여 여기 값을 덮어쓰려면 다음과 같이 시작합니다. 상단 청크 크기를 `-1`로 덮어쓰기(오버플로우를 사용할 수도 있음)하여 malloc이 어떤 할당에도 mmap을 사용하지 않도록 합니다. 왜냐하면 상단 청크는 항상 충분한 공간을 갖게 될 것이기 때문입니다.

그런 다음 상단 청크의 주소와 대상 공간을 할당하기 위한 거리를 계산합니다. 이는 해당 크기로 malloc이 수행되어 상단 청크가 해당 위치로 이동되기 때문에 차이/크기를 쉽게 계산할 수 있습니다:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
따라서 `target - old_top - 4*sizeof(long)` 크기를 할당하면 (4개의 long은 top 청크의 메타데이터와 할당된 새 청크의 메타데이터 때문입니다) top 청크를 덮어쓰고자 하는 주소로 이동시킵니다.\
그런 다음, 데이터의 시작 부분을 포함하는 청크를 얻기 위해 다른 malloc을 수행합니다.

### 참고 자료 및 다른 예시

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* 이 시나리오의 목표는 호출될 함수의 주소를 ret2win 함수의 주소로 수정해야 하는 ret2win입니다.
* 이진 파일에는 top 청크 크기를 수정할 수 있는 오버플로우가 있으며, 이는 -1 또는 p64(0xffffffffffffffff)로 수정됩니다.
* 그런 다음 덮어쓸 포인터가 존재하는 위치로 주소를 계산하고 현재 top 청크 위치부터 해당 위치까지의 차이가 `malloc`으로 할당됩니다.
* 마지막으로 원하는 대상을 포함하는 새로운 청크가 할당되며, 이는 ret2win 함수에 의해 덮어쓰입니다.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* `Input your name:`에는 힙에서 주소를 누출할 수 있는 초기 취약점이 있습니다.
* 그런 다음 `Org:` 및 `Host:` 기능에서 **org name**을 요청할 때 `s` 포인터의 64B를 채울 수 있으며, 이는 스택에서 v2의 주소 뒤에 따르는 것이며, 그 다음에는 지정된 **host name**이 따릅니다. 그런 다음 strcpy가 s의 내용을 64B 크기의 청크로 복사하려고 하기 때문에 **host name**에 입력된 데이터로 top 청크의 크기를 덮어쓸 수 있습니다.
* 이제 임의 쓰기가 가능하므로 `atoi`의 GOT를 printf의 주소로 덮어씁니다. 그런 다음 `%24$p`로 `IO_2_1_stderr`의 주소를 누출할 수 있습니다. 이 libc 누출로 `atoi`의 GOT를 다시 `system`의 주소로 덮어쓰고 `/bin/sh`를 매개변수로 전달하여 호출할 수 있습니다.
* [이 다른 설명서에서 제안된 대체 방법](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud)은 `free`를 `puts`로 덮어쓰고, 나중에 해제될 포인터에 `atoi@got`의 주소를 추가하여 누출하고 이 누출로 다시 `atoi@got`을 `system`으로 덮어쓰고 `/bin/sh`로 호출할 수 있습니다.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* 포인터를 지우지 않고 해제된 청크를 재사용할 수 있는 UAF가 있습니다. 일부 읽기 방법이 있기 때문에 여기서 GOT에 free 함수를 가리키는 포인터를 쓰고 나중에 read 함수를 호출하여 libc 주소를 누출할 수 있습니다.
* 그런 다음 UAF를 악용하여 House of force를 사용하여 왼쪽 공간의 크기를 -1로 덮어쓰고, free 후크에 도달할 수 있는 충분히 큰 청크를 할당한 다음 free 후크를 포함하는 다른 청크를 할당합니다. 그런 다음 후크에 `system`의 주소를 쓰고, 청크에 `"/bin/sh"`를 쓰고, 그 문자열 내용을 포함하는 청크를 해제합니다.
