# Dom Siły

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe Informacje

### Kod

* Ta technika została załatana ([**tutaj**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) i powoduje ten błąd: `malloc(): corrupted top size`
* Możesz wypróbować [**kod stąd**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html), jeśli chcesz go przetestować.

### Cel

* Celem tego ataku jest możliwość alokacji fragmentu pamięci w określonym adresie.

### Wymagania

* Przepełnienie, które pozwala nadpisać rozmiar nagłówka top chunk (np. -1).
* Możliwość kontrolowania rozmiaru alokacji sterty

### Atak

Jeśli atakujący chce zaalokować fragment pamięci pod adresem P w celu nadpisania wartości, zaczyna od nadpisania rozmiaru top chunk `-1` (może to być wykonane poprzez przepełnienie). Zapewnia to, że malloc nie będzie używał mmap do żadnej alokacji, ponieważ Top chunk zawsze będzie miał wystarczająco dużo miejsca.

Następnie oblicz odległość między adresem top chunk a docelowym miejscem alokacji. Jest to konieczne, ponieważ alokacja malloc o takim rozmiarze zostanie wykonana w celu przeniesienia top chunk do tej pozycji. Tak można łatwo obliczyć różnicę/rozmiar:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Dlatego alokując rozmiar `cel - old_top - 4*sizeof(long)` (4 longi, ponieważ metadane top chunk i nowego chunka po alokacji) przesunie top chunk na adres, który chcemy nadpisać.\
Następnie wykonaj kolejne malloc, aby uzyskać chunk zawierający na początku danych do zapisania docelowego adresu.

### Odnośniki i Inne Przykłady

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* Celem tego scenariusza jest ret2win, gdzie musimy zmodyfikować adres funkcji, która zostanie wywołana przez funkcję ret2win.
* Binarny plik ma przepełnienie, które można wykorzystać do zmodyfikowania rozmiaru top chunk, który jest zmieniony na -1 lub p64(0xffffffffffffffff).
* Następnie obliczany jest adres miejsca, gdzie istnieje wskaźnik do nadpisania, a różnica od bieżącej pozycji top chunk do tego miejsca jest alokowana za pomocą `malloc`.
* Na koniec alokowany jest nowy chunk, który będzie zawierał ten pożądany cel, w który zostanie nadpisany przez funkcję ret2win.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* W `Wprowadź swoje imię:` istnieje początkowa podatność, która pozwala na wyciek adresu z heap.
* Następnie w funkcjonalności `Org:` i `Host:` można wypełnić 64B wskaźnika `s`, gdy zostanie zapytane o **nazwę org**, która na stosie jest następnie śledzona przez adres v2, a następnie wskazaną **nazwę hosta**. Ponieważ strcpy będzie kopiować zawartość s do chunka o rozmiarze 64B, możliwe jest **nadpisanie rozmiaru top chunk** danymi umieszczonymi w **nazwie hosta**.
* Teraz, gdy możliwe jest dowolne zapisywanie, GOT `atoi` został nadpisany adresem printf. Następnie możliwe było wyciek adresu `IO_2_1_stderr` _z_ `%24$p`. I dzięki temu wyciekowi libc możliwe było ponowne nadpisanie GOT `atoi` adresem `system` i wywołanie go, przekazując jako parametr `/bin/sh`.
* Alternatywna metoda [zapropnowana w tym innym rozwiązaniu](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), polega na nadpisaniu `free` z `puts`, a następnie dodaniu adresu `atoi@got` w wskaźniku, który zostanie później zwolniony, aby został wycieknięty, a dzięki temu wyciekowi ponownie nadpisać `atoi@got` z `system` i wywołać go z `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Istnieje UAF, który pozwala na ponowne użycie zwolnionego chunka bez wyczyszczenia wskaźnika. Ponieważ są tu pewne metody odczytu, możliwe jest wyciekanie adresu libc, zapisując wskaźnik do funkcji free w GOT i następnie wywołując funkcję odczytu.
* Następnie, użyto House of force (wykorzystując UAF) do nadpisania rozmiaru pozostałej przestrzeni na -1, alokowania wystarczająco dużego chunka, aby dotrzeć do free hook, a następnie alokowania innego chunka, który będzie zawierał free hook. Następnie, w hooku zapisano adres `system`, w chunku zapisano `"/bin/sh"` i na koniec zwolniono chunk z tym zawartością ciągu znaków.
