# Casa de la Fuerza



<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Información Básica

### Código

* Esta técnica fue parcheada ([**aquí**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) y produce este error: `malloc(): corrupted top size`
* Puedes probar el [**código desde aquí**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) para probarlo si lo deseas.

### Objetivo

* El objetivo de este ataque es poder asignar un fragmento en una dirección específica.

### Requisitos

* Un desbordamiento que permita sobrescribir el tamaño del encabezado del fragmento superior (por ejemplo, -1).
* Ser capaz de controlar el tamaño de la asignación del montón

### Ataque

Si un atacante desea asignar un fragmento en la dirección P para sobrescribir un valor aquí. Comienza sobrescribiendo el tamaño del fragmento superior con `-1` (quizás con un desbordamiento). Esto asegura que malloc no utilizará mmap para ninguna asignación, ya que el fragmento superior siempre tendrá suficiente espacio.

Luego, calcula la distancia entre la dirección del fragmento superior y el espacio objetivo para asignar. Esto se debe a que se realizará una asignación malloc con ese tamaño para mover el fragmento superior a esa posición. Así es como se puede calcular fácilmente la diferencia/tamaño:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Por lo tanto, asignar un tamaño de `objetivo - old_top - 4*sizeof(long)` (los 4 longs son debido a los metadatos del chunk superior y del nuevo chunk cuando se asigna) moverá el chunk superior a la dirección que queremos sobrescribir.\
Luego, hacer otro malloc para obtener un chunk que contenga al principio los datos a escribir en la dirección objetivo.

### Referencias y Otros Ejemplos

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* El objetivo de este escenario es un ret2win donde necesitamos modificar la dirección de una función que será llamada por la dirección de la función ret2win
* El binario tiene un desbordamiento que puede ser abusado para modificar el tamaño del chunk superior, que se modifica a -1 o p64(0xffffffffffffffff)
* Luego, se calcula la dirección donde existe el puntero a sobrescribir, y la diferencia desde la posición actual del chunk superior hasta allí se asigna con `malloc`
* Finalmente se asigna un nuevo chunk que contendrá este objetivo deseado en el que se sobrescribirá con la función ret2win
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* En `Input your name:` hay una vulnerabilidad inicial que permite filtrar una dirección del heap
* Luego en la funcionalidad `Org:` y `Host:`, es posible llenar los 64B del puntero `s` cuando se solicita el **nombre de la organización**, que en la pila es seguido por la dirección de v2, que luego es seguido por el **nombre del host** indicado. Como entonces, strcpy va a copiar el contenido de s a un chunk de tamaño 64B, es posible **sobrescribir el tamaño del chunk superior** con los datos introducidos dentro del **nombre del host**.
* Ahora que es posible la escritura arbitraria, el GOT de `atoi` fue sobrescrito a la dirección de printf. entonces fue posible filtrar la dirección de `IO_2_1_stderr` _con_ `%24$p`. Y con esta filtración de libc fue posible sobrescribir nuevamente el GOT de `atoi` con la dirección de `system` y llamarlo pasando como parámetro `/bin/sh`
* Un método alternativo [propuesto en este otro writeup](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), es sobrescribir `free` con `puts`, y luego agregar la dirección de `atoi@got`, en el puntero que luego será liberado para que se filtre y con esta filtración sobrescribir nuevamente `atoi@got` con `system` y llamarlo con `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Hay un UAF que permite reutilizar un chunk que fue liberado sin borrar el puntero. Debido a que hay algunos métodos de lectura, es posible filtrar una dirección de libc escribiendo un puntero a la función free en el GOT aquí y luego llamando a la función de lectura.
* Luego, se utilizó House of force (abusando del UAF) para sobrescribir el tamaño del espacio izquierdo con un -1, asignar un chunk lo suficientemente grande para llegar al hook de free, y luego asignar otro chunk que contendrá el hook de free. Luego, escribir en el hook la dirección de `system`, escribir en un chunk `"/bin/sh"` y finalmente liberar el chunk con ese contenido de cadena.
