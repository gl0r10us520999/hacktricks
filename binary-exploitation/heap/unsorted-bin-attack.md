# Attacco al Bin non ordinato

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di base

Per ulteriori informazioni su cosa sia un bin non ordinato, controlla questa pagina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Le liste non ordinate sono in grado di scrivere l'indirizzo in `unsorted_chunks (av)` nell'indirizzo `bk` del chunk. Pertanto, se un attaccante pu√≤ **modificare l'indirizzo del puntatore bk** in un chunk all'interno del bin non ordinato, potrebbe essere in grado di **scrivere quell'indirizzo in un indirizzo arbitrario** che potrebbe essere utile per ottenere un indirizzo libc o bypassare alcune difese.

Quindi, fondamentalmente, questo attacco permette di **sovrascrivere un indirizzo arbitrario con un numero grande** (un indirizzo che potrebbe essere un indirizzo di heap o un indirizzo libc) come un indirizzo di stack che potrebbe essere rivelato o una restrizione come la variabile globale **`global_max_fast`** per consentire di creare bin veloci con dimensioni maggiori (e passare da un attacco al bin non ordinato a un attacco al bin veloce).

{% hint style="success" %}
Guardando l'esempio fornito in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e utilizzando 0x4000 e 0x5000 invece di 0x400 e 0x500 come dimensioni dei chunk (per evitare tcaches) √® possibile vedere che **oggi** l'errore **`malloc(): unsorted double linked list corrupted`** viene attivato.

Pertanto, questo attacco al bin non ordinato ora (tra altri controlli) richiede anche di essere in grado di correggere la lista doppiamente collegata in modo che venga bypassato `victim->bck->fd == victim` o non `victim->fd == av (arena)`. Ci√≤ significa che l'indirizzo in cui vogliamo scrivere deve avere l'indirizzo del chunk falso nella sua posizione `fd` e che il `fd` del chunk falso punti all'arena.
{% endhint %}

{% hint style="danger" %}
Nota che questo attacco corrompe il bin non ordinato (quindi anche piccolo e grande). Quindi possiamo **usare solo allocazioni dal bin veloce ora** (un programma pi√π complesso potrebbe fare altre allocazioni e bloccarsi), e per attivare questo dobbiamo **allocare la stessa dimensione o il programma si bloccher√†.**

Nota che rendere **`global_max_fast`** potrebbe aiutare in questo caso fidandosi che il bin veloce sar√† in grado di gestire tutte le altre allocazioni fino a quando l'exploit non √® completato.
{% endhint %}

Il codice di [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo spiega molto bene, anche se se si modificano le malloc per allocare memoria sufficientemente grande in modo che non finisca in un tcache, si pu√≤ vedere che compare l'errore precedentemente menzionato impedendo questa tecnica: **`malloc(): unsorted double linked list corrupted`**

## Attacco di Infoleak al Bin non ordinato

Questo √® in realt√† un concetto molto basilare. I chunk nel bin non ordinato avranno puntatori doppi per creare il bin. Il primo chunk nel bin non ordinato avr√† effettivamente i collegamenti **FD** e **BK** **che puntano a una parte dell'arena principale (libc)**.\
Pertanto, se puoi **mettere un chunk all'interno di un bin non ordinato e leggerlo** (uso dopo la liberazione) o **allocarlo di nuovo senza sovrascrivere almeno 1 dei puntatori** per poi **leggerlo**, puoi ottenere un **leak di info libc**.

Un [**attacco simile usato in questo articolo**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), √® stato quello di abusare di una struttura a 4 chunk (A, B, C e D - D serve solo per evitare la consolidazione con il chunk superiore) in modo che un overflow di byte nullo in B fosse usato per far s√¨ che C indicasse che B non era utilizzato. Inoltre, in B √® stata modificata la data `prev_size` in modo che la dimensione anzich√© essere la dimensione di B fosse A+B.\
Quindi C √® stata deallocata e consolidata con A+B (ma B era ancora in uso). √à stato allocato un nuovo chunk di dimensione A e quindi gli indirizzi libc trapelati sono stati scritti in B da dove sono trapelati.

## Riferimenti e Altri esempi

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* L'obiettivo √® sovrascrivere una variabile globale con un valore maggiore di 4869 in modo da poter ottenere il flag e PIE non √® abilitato.
* √à possibile generare chunk di dimensioni arbitrarie e c'√® un overflow di heap con la dimensione desiderata.
* L'attacco inizia creando 3 chunk: chunk0 per sfruttare l'overflow, chunk1 per essere sovraffollato e chunk2 in modo che il chunk superiore non consolidi quelli precedenti.
* Quindi, chunk1 viene liberato e chunk0 viene sovraffollato in modo che il puntatore `bk` di chunk1 punti a: `bk = magic - 0x10`
* Quindi, chunk3 viene allocato con la stessa dimensione di chunk1, il che attiver√† l'attacco al bin non ordinato e modificher√† il valore della variabile globale, rendendo possibile ottenere il flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funzione di merge √® vulnerabile perch√© se entrambi gli indici passati sono gli stessi, realloc su di esso e quindi lo libera ma restituisce un puntatore a quella regione liberata che pu√≤ essere utilizzato.
* Pertanto, **vengono creati 2 chunk**: **chunk0** che verr√† unito con se stesso e chunk1 per evitare la consolidazione con il chunk superiore. Quindi, la **funzione di merge viene chiamata con chunk0** due volte, il che causer√† un uso dopo la liberazione.
* Quindi, la funzione **`view`** viene chiamata con l'indice 2 (che √® l'indice del chunk in uso dopo la liberazione), che **far√† trapelare un indirizzo libc**.
* Poich√© il binario ha protezioni per allocare solo dimensioni maggiori di **`global_max_fast`** quindi nessun fastbin viene utilizzato, verr√† utilizzato un attacco al bin non ordinato per sovrascrivere la variabile globale `global_max_fast`.
* Quindi, √® possibile chiamare la funzione di modifica con l'indice 2 (il puntatore in uso dopo la liberazione) e sovrascrivere il puntatore `bk` per puntare a `p64(global_max_fast-0x10)`. Quindi, creando un nuovo chunk user√† l'indirizzo di free compromesso in precedenza (0x20) attiver√† l'attacco al bin non ordinato sovrascrivendo il `global_max_fast` con un valore molto grande, consentendo ora di creare chunk nei bin veloci.
* Ora viene eseguito un **attacco al fast bin**:
* Prima di tutto √® stato scoperto che √® possibile lavorare con **chunk veloci di dimensione 200** nella posizione di **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se riusciamo a ottenere un chunk veloce di dimensione 0x200 in questa posizione, sar√† possibile sovrascrivere un puntatore di funzione che verr√† eseguito
* Per fare ci√≤, viene creato un nuovo chunk di dimensione `0xfc` e la funzione unita viene chiamata con quel puntatore due volte, in questo modo otteniamo un puntatore a un chunk liberato di dimensione `0xfc*2 = 0x1f8` nel fast bin.
* Successivamente, la funzione di modifica viene chiamata in questo chunk per modificare l'indirizzo **`fd`** di questo fast bin in modo che punti alla funzione precedente **`__free_hook`**.
* Quindi, viene creato un chunk con dimensione `0x1f8` per recuperare dal fast bin il chunk inutile precedente, quindi viene creato un altro chunk di dimensione `0x1f8` per ottenere un chunk fast bin nel **`__free_hook`** che viene sovrascritto con l'indirizzo della funzione **`system`**.
* Infine, viene liberato un chunk contenente la stringa `/bin/sh\x00` chiamando la funzione di eliminazione, attivando la funzione **`__free_hook`** che punta a system con `/bin/sh\x00` come parametro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Un altro esempio di abuso di un overflow di 1B per consolidare i chunk nel bin non ordinato e ottenere un infoleak della libc e quindi eseguire un attacco fast bin per sovrascrivere l'hook di malloc con un indirizzo one gadget

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
