# Ataque ao Unsorted Bin

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informa√ß√µes B√°sicas

Para mais informa√ß√µes sobre o que √© um unsorted bin, consulte esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

As listas n√£o ordenadas s√£o capazes de escrever o endere√ßo para `unsorted_chunks (av)` no endere√ßo `bk` do chunk. Portanto, se um atacante puder **modificar o endere√ßo do ponteiro bk** em um chunk dentro do unsorted bin, ele poderia ser capaz de **escrever esse endere√ßo em um endere√ßo arbitr√°rio** que poderia ser √∫til para vazar endere√ßos de libc ou contornar algumas defesas.

Portanto, basicamente, esse ataque permite **sobrescrever um endere√ßo arbitr√°rio com um n√∫mero grande** (um endere√ßo que poderia ser um endere√ßo de heap ou um endere√ßo de libc) como algum endere√ßo de pilha que poderia ser vazado ou alguma restri√ß√£o como a vari√°vel global **`global_max_fast`** para permitir a cria√ß√£o de fast bin bins com tamanhos maiores (e passar de um ataque unsorted bin para um ataque fast bin).

{% hint style="success" %}
Analisando o exemplo fornecido em [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e usando 0x4000 e 0x5000 em vez de 0x400 e 0x500 como tamanhos de chunk (para evitar tcaches), √© poss√≠vel ver que **atualmente** o erro **`malloc(): unsorted double linked list corrupted`** √© acionado.

Portanto, esse ataque ao unsorted bin agora (entre outras verifica√ß√µes) tamb√©m requer ser capaz de corrigir a lista duplamente encadeada para que isso seja contornado `victim->bck->fd == victim` ou n√£o `victim->fd == av (arena)`. O que significa que o endere√ßo onde queremos escrever deve ter o endere√ßo do chunk falso em sua posi√ß√£o `fd` e que o `fd` do chunk falso est√° apontando para a arena.
{% endhint %}

{% hint style="danger" %}
Observe que esse ataque corrompe o unsorted bin (portanto, tamb√©m o small e o large). Portanto, agora s√≥ podemos **usar aloca√ß√µes do fast bin** (um programa mais complexo pode fazer outras aloca√ß√µes e travar), e para acionar isso devemos **alocar o mesmo tamanho ou o programa travar√°.**

Observe que fazer **`global_max_fast`** pode ajudar nesse caso, confiando que o fast bin ser√° capaz de lidar com todas as outras aloca√ß√µes at√© que a explora√ß√£o seja conclu√≠da.
{% endhint %}

O c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) explica muito bem, embora se voc√™ modificar os mallocs para alocar mem√≥ria grande o suficiente para n√£o terminar em um tcache, voc√™ ver√° que o erro mencionado anteriormente aparece, impedindo essa t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Ataque de Vazamento de Informa√ß√µes do Unsorted Bin

Este √© na verdade um conceito muito b√°sico. Os chunks no unsorted bin ter√£o ponteiros duplos para criar o bin. O primeiro chunk no unsorted bin ter√° na verdade os links **FD** e **BK** **apontando para uma parte da arena principal (libc)**.\
Portanto, se voc√™ pode **colocar um chunk dentro de um unsorted bin e l√™-lo** (uso ap√≥s libera√ß√£o) ou **aloc√°-lo novamente sem sobrescrever pelo menos 1 dos ponteiros** para ent√£o **ler** ele, voc√™ pode ter um **vazamento de informa√ß√µes da libc**.

Um [**ataque semelhante usado neste artigo**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), foi abusar de uma estrutura de 4 chunks (A, B, C e D - D √© apenas para evitar a consolida√ß√£o com o chunk superior) ent√£o um estouro de byte nulo em B foi usado para fazer C indicar que B estava inutilizado. Al√©m disso, em B os dados `prev_size` foram modificados para que o tamanho, em vez de ser o tamanho de B, fosse A+B.\
Ent√£o C foi desalocado e consolidado com A+B (mas B ainda estava em uso). Um novo chunk de tamanho A foi alocado e ent√£o os endere√ßos vazados da libc foram escritos em B de onde foram vazados.

## Refer√™ncias e Outros Exemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* O objetivo √© sobrescrever uma vari√°vel global com um valor maior que 4869 para ser poss√≠vel obter a flag e o PIE n√£o estar habilitado.
* √â poss√≠vel gerar chunks de tamanhos arbitr√°rios e h√° um estouro de heap com o tamanho desejado.
* O ataque come√ßa criando 3 chunks: chunk0 para abusar do estouro, chunk1 para ser estourado e chunk2 para que o chunk superior n√£o consolide os anteriores.
* Em seguida, o chunk1 √© liberado e o chunk0 √© estourado para que o ponteiro `bk` do chunk1 aponte para: `bk = m√°gica - 0x10`
* Em seguida, o chunk3 √© alocado com o mesmo tamanho que o chunk1, o que acionar√° o ataque ao unsorted bin e modificar√° o valor da vari√°vel global, tornando poss√≠vel obter a flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* A fun√ß√£o de mesclagem √© vulner√°vel porque se ambos os √≠ndices passados forem iguais, ele realocar√° nele e ent√£o o liberar√°, mas retornando um ponteiro para essa regi√£o liberada que pode ser usada.
* Portanto, **2 chunks s√£o criados**: **chunk0** que ser√° mesclado consigo mesmo e chunk1 para evitar a consolida√ß√£o com o chunk superior. Em seguida, a **fun√ß√£o de mesclagem √© chamada com o chunk0** duas vezes, o que causar√° um uso ap√≥s a libera√ß√£o.
* Em seguida, a fun√ß√£o **`view`** √© chamada com o √≠ndice 2 (que √© o √≠ndice do chunk usado ap√≥s a libera√ß√£o), que ir√° **vazar um endere√ßo da libc**.
* Como o bin√°rio tem prote√ß√µes para alocar apenas tamanhos maiores que **`global_max_fast`** para que nenhum fastbin seja usado, um ataque ao unsorted bin ser√° usado para sobrescrever a vari√°vel global `global_max_fast`.
* Em seguida, √© poss√≠vel chamar a fun√ß√£o de edi√ß√£o com o √≠ndice 2 (o ponteiro usado ap√≥s a libera√ß√£o) e sobrescrever o ponteiro `bk` para apontar para `p64(global_max_fast-0x10)`. Em seguida, criando um novo chunk usar√° o endere√ßo de libera√ß√£o comprometido anteriormente (0x20) e **acionar√° o ataque ao unsorted bin** sobrescrevendo o `global_max_fast` com um valor muito grande, permitindo agora criar chunks em fast bins.
* Agora um **ataque ao fast bin** √© realizado:
* Primeiramente, √© descoberto que √© poss√≠vel trabalhar com **chunks fast de tamanho 200** na localiza√ß√£o de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200</code></pre>
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se conseguirmos obter um fast chunk de tamanho 0x200 nessa localiza√ß√£o, ser√° poss√≠vel sobrescrever um ponteiro de fun√ß√£o que ser√° executado
* Para isso, um novo chunk de tamanho `0xfc` √© criado e a fun√ß√£o mesclada √© chamada com esse ponteiro duas vezes, dessa forma obtemos um ponteiro para um chunk liberado de tamanho `0xfc*2 = 0x1f8` no fast bin.
* Em seguida, a fun√ß√£o edit √© chamada nesse chunk para modificar o endere√ßo **`fd`** desse fast bin para apontar para a fun√ß√£o **`__free_hook`** anterior.
* Depois, um chunk com tamanho `0x1f8` √© criado para recuperar do fast bin o chunk in√∫til anterior, ent√£o outro chunk de tamanho `0x1f8` √© criado para obter um chunk fast bin no **`__free_hook`** que √© sobrescrito com o endere√ßo da fun√ß√£o **`system`**.
* E finalmente um chunk contendo a string `/bin/sh\x00` √© liberado chamando a fun√ß√£o delete, acionando a fun√ß√£o **`__free_hook`** que aponta para system com `/bin/sh\x00` como par√¢metro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Outro exemplo de abuso de um overflow de 1B para consolidar chunks no unsorted bin e obter um vazamento de informa√ß√µes da libc e depois realizar um ataque fast bin para sobrescrever o hook malloc com um endere√ßo de one gadget

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
