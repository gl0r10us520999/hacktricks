# Attaque Unlink

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de Base

Lorsque cette attaque a √©t√© d√©couverte, elle permettait principalement un WWW (Write What Where), cependant, certaines **v√©rifications ont √©t√© ajout√©es** rendant la nouvelle version de l'attaque plus int√©ressante mais plus complexe et **inutile**.

### Exemple de Code:

<details>

<summary>Code</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* L'attaque ne fonctionne pas si les tcaches sont utilis√©s (apr√®s 2.26)

### Objectif

Cette attaque permet de **changer un pointeur vers un chunk pour le faire pointer 3 adresses avant lui-m√™me**. Si ce nouvel emplacement (alentours de l'endroit o√π se trouvait le pointeur) contient des √©l√©ments int√©ressants, comme d'autres allocations contr√¥lables / la pile..., il est possible de les lire/√©craser pour causer un plus grand dommage.

* Si ce pointeur √©tait situ√© dans la pile, car il pointe maintenant 3 adresses avant lui-m√™me et que l'utilisateur peut potentiellement le lire et le modifier, il sera possible de divulguer des informations sensibles de la pile ou m√™me de modifier l'adresse de retour (peut-√™tre) sans toucher au canary
* Dans les exemples de CTF, ce pointeur est situ√© dans un tableau de pointeurs vers d'autres allocations, donc, en le faisant pointer 3 adresses avant et en √©tant capable de le lire et de l'√©crire, il est possible de faire pointer les autres pointeurs vers d'autres adresses.\
Comme potentiellement l'utilisateur peut √©galement lire/√©crire les autres allocations, il peut divulguer des informations ou √©craser de nouvelles adresses √† des emplacements arbitraires (comme dans la GOT).

### Pr√©requis

* Un certain contr√¥le dans une m√©moire (par exemple la pile) pour cr√©er quelques chunks en donnant des valeurs √† certaines des attributs.
* Fuite de pile pour d√©finir les pointeurs du faux chunk.

### Attaque

* Il y a quelques chunks (chunk1 et chunk2)
* L'attaquant contr√¥le le contenu de chunk1 et les en-t√™tes de chunk2.
* Dans chunk1, l'attaquant cr√©e la structure d'un faux chunk :
* Pour contourner les protections, il s'assure que le champ `size` est correct pour √©viter l'erreur : `corrupted size vs. prev_size while consolidating`
* et les champs `fd` et `bk` du faux chunk pointent l√† o√π le pointeur de chunk1 est stock√© avec des d√©calages de -3 et -2 respectivement, donc `fake_chunk->fd->bk` et `fake_chunk->bk->fd` pointent vers la position en m√©moire (pile) o√π se trouve l'adresse r√©elle de chunk1 :

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Les en-t√™tes du chunk2 sont modifi√©s pour indiquer que le chunk pr√©c√©dent n'est pas utilis√© et que la taille est la taille du faux chunk contenu.
* Lorsque le deuxi√®me chunk est lib√©r√©, ce faux chunk est d√©sencha√Æn√© se produisant :
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Auparavant, il a √©t√© fait en sorte que `fake_chunk->fd->bk` et `fake_chunk->fd->bk` pointent vers le m√™me endroit (l'emplacement dans la pile o√π `chunk1` √©tait stock√©, donc c'√©tait une liste cha√Æn√©e valide). Comme **les deux pointent vers le m√™me endroit**, seul le dernier (`fake_chunk->bk->fd = fake_chunk->fd`) aura **effet**.
* Cela va **√©craser le pointeur vers chunk1 dans la pile vers l'adresse (ou les octets) stock√©s 3 adresses avant dans la pile**.
* Par cons√©quent, si un attaquant pouvait contr√¥ler √† nouveau le contenu du chunk1, il pourra **√©crire dans la pile** en √©tant potentiellement capable d'√©craser l'adresse de retour en sautant le canary et de modifier les valeurs et les points des variables locales. M√™me en modifiant √† nouveau l'adresse de chunk1 stock√©e dans la pile vers un emplacement diff√©rent o√π si l'attaquant pouvait contr√¥ler √† nouveau le contenu de chunk1, il pourra √©crire n'importe o√π.
* Notez que cela √©tait possible car les **adresses sont stock√©es dans la pile**. Le risque et l'exploitation peuvent d√©pendre de **l'endroit o√π les adresses du faux chunk sont stock√©es**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## R√©f√©rences

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Bien qu'il soit √©trange de trouver une attaque de d√©sencha√Ænement m√™me dans un CTF, voici quelques writeups o√π cette attaque a √©t√© utilis√©e :
* Exemple de CTF : [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* Dans cet exemple, au lieu de la pile, il y a un tableau d'adresses malloc'√©es. L'attaque de d√©sencha√Ænement est effectu√©e pour pouvoir allouer un chunk ici, permettant ainsi de contr√¥ler les pointeurs du tableau d'adresses malloc'√©es. Ensuite, il y a une autre fonctionnalit√© qui permet de modifier le contenu des chunks dans ces adresses, ce qui permet de pointer des adresses vers la GOT, de modifier les adresses de fonction pour obtenir des fuites de libc et RCE.
* Autre exemple de CTF : [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Tout comme dans l'exemple pr√©c√©dent, il y a un tableau d'adresses d'allocations. Il est possible d'effectuer une attaque de d√©sencha√Ænement pour faire pointer l'adresse de la premi√®re allocation quelques positions avant le d√©but du tableau et d'√©craser ensuite cette allocation √† la nouvelle position. Par cons√©quent, il est possible d'√©craser les pointeurs d'autres allocations pour pointer vers la GOT de atoi, l'imprimer pour obtenir une fuite de libc, puis √©craser atoi GOT avec l'adresse d'un one gadget.
* Exemple de CTF avec des fonctions malloc et free personnalis√©es qui exploitent une vuln√©rabilit√© tr√®s similaire √† l'attaque de d√©sencha√Ænement : [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Il y a un d√©bordement qui permet de contr√¥ler les pointeurs FD et BK du malloc personnalis√© qui sera (personnalis√©) lib√©r√©. De plus, le tas a le bit exec, il est donc possible de divulguer une adresse de tas et de pointer une fonction de la GOT vers un chunk de tas avec un shellcode √† ex√©cuter.

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
