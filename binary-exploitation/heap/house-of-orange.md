# Dom Pomarańczowy

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>

## Podstawowe Informacje

### Kod

* Znajdź przykład w [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* Technika eksploatacji została naprawiona w tym [patchu](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) więc już nie działa (działa w wersjach wcześniejszych niż 2.26)
* Ten sam przykład **z większą ilością komentarzy** w [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Cel

* Wykorzystanie funkcji `malloc_printerr`

### Wymagania

* Nadpisanie rozmiaru top chunk
* Wycieki libc i heap

### Tło

Potrzebne tło z komentarzy z [**tego przykładu**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

Rzecz w tym, że w starszych wersjach libc, gdy wywoływana była funkcja `malloc_printerr`, **iterowała przez listę struktur `_IO_FILE` przechowywanych w `_IO_list_all`**, i faktycznie **wykonywała** wskaźnik instrukcji w tej strukturze.\
Ten atak sfałszuje **fałszywą strukturę `_IO_FILE`**, którą zapiszemy do **`_IO_list_all`**, i spowoduje uruchomienie `malloc_printerr`.\
Następnie **wykona adres**, który mamy zapisany w strukturach **`_IO_FILE`**, a następnie uzyskamy wykonanie kodu

### Atak

Atak rozpoczyna się od uzyskania **top chunk** wewnątrz **unsorted bin**. Osiąga się to poprzez wywołanie `malloc` z rozmiarem większym niż aktualny rozmiar top chunk, ale mniejszym niż **`mmp_.mmap_threshold`** (domyślnie 128K), co w przeciwnym razie spowodowałoby alokację `mmap`. Gdy rozmiar top chunk jest modyfikowany, ważne jest zapewnienie, że **top chunk + jego rozmiar** jest wyrównany do strony i że bit **prev\_inuse** top chunk zawsze jest ustawiony.

Aby uzyskać top chunk wewnątrz unsorted bin, alokuj kawałek, aby utworzyć top chunk, zmień rozmiar top chunk (z przepełnieniem w przydzielonym kawałku), aby **top chunk + rozmiar** był wyrównany do strony z bitem **prev\_inuse** ustawionym. Następnie zaalokuj kawałek większy niż nowy rozmiar top chunk. Należy zauważyć, że `free` nigdy nie jest wywoływane, aby umieścić top chunk w unsorted bin.

Stary top chunk jest teraz w unsorted bin. Zakładając, że możemy odczytać dane wewnątrz niego (możliwe z powodu podatności, która również spowodowała przepełnienie), możliwe jest wyciekanie adresów libc z niego i uzyskanie adresu **\_IO\_list\_all**.

Atak na unsorted bin jest wykonywany poprzez nadużycie przepełnienia, aby zapisać `topChunk->bk->fwd = _IO_list_all - 0x10`. Gdy zostanie przydzielony nowy kawałek, stary top chunk zostanie podzielony, a wskaźnik do unsorted bin zostanie zapisany do **`_IO_list_all`**.

Następnym krokiem jest zmniejszenie rozmiaru starego top chunk, aby pasował do małego binu, ustawiając specjalnie jego rozmiar na **0x61**. Służy to dwóm celom:

1. **Wstawienie do Small Bin 4**: Gdy `malloc` przegląda unsorted bin i widzi ten kawałek, spróbuje wstawić go do małego binu 4 ze względu na jego mały rozmiar. Powoduje to, że kawałek trafia na początek listy małego binu 4, który jest miejscem wskaźnika FD kawałka **`_IO_list_all`**, ponieważ zapisaliśmy bliski adres w **`_IO_list_all`** poprzez atak na unsorted bin.
2. **Wywołanie Malloc Check**: Manipulacja rozmiarem tego kawałka spowoduje, że `malloc` wykona wewnętrzne sprawdzenia. Gdy sprawdza rozmiar fałszywego kawałka do przodu, który będzie wynosił zero, wywołuje błąd i wywołuje `malloc_printerr`.

Manipulacja małym binem pozwoli ci kontrolować wskaźnik do przodu kawałka. Nakładanie się z **\_IO\_list\_all** jest wykorzystywane do sfałszowania fałszywej struktury **\_IO\_FILE**. Struktura jest starannie opracowana, aby zawierać kluczowe pola takie jak `_IO_write_base` i `_IO_write_ptr` ustawione na wartości, które przechodzą wewnętrzne sprawdzenia w libc. Dodatkowo tworzona jest tablica skoków wewnątrz fałszywej struktury, gdzie wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod (np. funkcja `system`).

Podsumowując pozostałą część techniki:

* **Zmniejsz stary top chunk**: Dostosuj rozmiar starego top chunk do **0x61**, aby pasował do małego binu.
* **Ustaw fałszywą strukturę `_IO_FILE`**: Nakładaj stary top chunk na fałszywą strukturę **\_IO\_FILE** i ustaw pola odpowiednio, aby przejąć kontrolę nad przepływem wykonania.

Następnym krokiem jest sfałszowanie fałszywej struktury **\_IO\_FILE**, która nakłada się na stary top chunk obecnie w unsorted bin. Pierwsze bajty tej struktury są starannie opracowane, aby zawierać wskaźnik do polecenia (np. "/bin/sh"), które zostanie wykonane.

Kluczowe pola w fałszywej strukturze **\_IO\_FILE**, takie jak `_IO_write_base` i `_IO_write_ptr`, są ustawione na wartości, które przechodzą wewnętrzne sprawdzenia w libc. Dodatkowo tworzona jest tablica skoków wewnątrz fałszywej struktury, gdzie wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod. Zazwyczaj będzie to adres funkcji `system` lub innej funkcji, która może wykonywać polecenia powłoki.

Atak kulminuje, gdy wywołanie `malloc` powoduje wykonanie kodu poprzez sfałszowaną strukturę **\_IO\_FILE**. Pozwala to efektywnie na wykonanie dowolnego kodu, zwykle prowadząc do uruchomienia powłoki lub innego złośliwego ładunku.

**Podsumowanie Ataku:**

1. **Ustaw top chunk**: Zaalokuj kawałek i zmodyfikuj rozmiar top chunk.
2. **Wymuś top chunk do unsorted bin**: Zaalokuj większy kawałek.
3. **Wyciek adresów libc**: Użyj podatności do odczytu z unsorted bin.
4. **Wykonaj atak na unsorted bin**: Zapisz do **\_IO\_list\_all** poprzez przepełnienie.
5. **Zmniejsz stary top chunk**: Dostosuj jego rozmiar, aby pasował do małego binu.
6. **Ustaw fałszywą strukturę \_IO\_FILE**: Sfałszuj fałszywą strukturę pliku, aby przejąć kontrolę nad przepływem wykonania.
7. **Wywołaj wykonanie kodu**: Zaalokuj kawałek do wykonania ataku i uruchom dowolny kod.

Ta metoda wykorzystuje mechanizmy zarządzania stosem, wycieki informacji libc i przepełnienia sterty, aby osiągnąć wykonanie kodu bez bezpośredniego wywoływania `free`. Staranne opracowanie fałszywej struktury **\_IO\_FILE** i umieszczenie jej we właściwym miejscu pozwala na przejęcie kontroli podczas standardowych operacji alokacji pamięci. Umożliwia to wykonanie dowolnego kodu, potencjalnie prowadząc do uruchomienia powłoki lub innych złośliwych działań.
## Odnośniki

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

<details>

<summary><strong>Zacznij od zera i zostań mistrzem hakowania AWS dzięki</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
