# House of Orange

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

### 코드

* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)에서 예제 찾기
* 이 [패치](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0)에서 공격 기술이 수정되었으므로 더 이상 작동하지 않음 (2.26 이전 버전에서 작동)
* 더 많은 주석이 달린 동일한 예제는 [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)에 있음

### 목표

* `malloc_printerr` 함수 남용

### 요구 사항

* 최상위 청크 크기 덮어쓰기
* Libc 및 힙 누출

### 배경

[**이 예제**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)의 주석에서 필요한 배경 사항:

이전 버전의 libc에서 `malloc_printerr` 함수가 호출될 때 `_IO_list_all`에 저장된 `_IO_FILE` 구조체 목록을 **반복**하고 실제로 그 구조체 내의 명령 포인터를 **실행**했습니다.\
이 공격은 **가짜 `_IO_FILE` 구조체**를 위조하여 **`_IO_list_all`**에 쓰고 `malloc_printerr`를 실행하도록 만듭니다.\
그런 다음 **`_IO_FILE`** 구조체의 점프 테이블에 저장된 주소를 **실행**하고 코드 실행을 얻을 수 있습니다.

### 공격

공격은 **정렬되지 않은 bin** 내부에 **최상위 청크**를 가져오는 것으로 시작합니다. 현재 최상위 청크 크기보다 크지만 **`mmp_.mmap_threshold`** (기본값은 128K)보다 작은 크기로 `malloc`를 호출하여 이루어집니다. 최상위 청크 크기가 수정될 때는 항상 **최상위 청크 + 크기**가 페이지 정렬되어 있고 **prev\_inuse** 비트가 항상 설정되어 있는지 확인하는 것이 중요합니다.

정렬되지 않은 bin 내부에 최상위 청크를 가져오려면 최상위 청크를 만들기 위해 청크를 할당하고 새로운 최상위 청크 크기보다 큰 크기로 변경해야 합니다. `free`를 호출하지 않고 최상위 청크를 정렬되지 않은 bin으로 가져오려면 이 단계를 수행해야 합니다.

이제 이전 최상위 청크는 정렬되지 않은 bin에 있습니다. 이를 통해 해당 내부 데이터를 읽을 수 있다고 가정하면 (오버플로우를 일으킨 취약점 때문에 가능할 수 있음), libc 주소를 누출하고 **\_IO\_list\_all**의 주소를 얻을 수 있습니다.

정렬되지 않은 bin 공격은 오버플로우를 악용하여 `topChunk->bk->fwd = _IO_list_all - 0x10`를 쓰는 것으로 수행됩니다. 새로운 청크가 할당되면 이전 최상위 청크가 분할되고 정렬되지 않은 bin에 대한 포인터가 **`_IO_list_all`**에 쓰입니다.

다음 단계는 이전 최상위 청크의 크기를 작은 bin에 맞게 줄이는 것입니다. 특히 크기를 **0x61**로 설정해야 합니다. 이는 두 가지 목적을 가집니다:

1. **Small Bin 4에 삽입**: `malloc`이 정렬되지 않은 bin을 스캔하고 이 청크를 볼 때 크기가 작기 때문에 이를 Small Bin 4에 삽입하려고 시도합니다. 이로 인해 이 청크는 Small Bin 4 목록의 헤드에 끝에 도달하게 되며 이는 우리가 정렬되지 않은 bin 공격을 통해 **`_IO_list_all`**의 청크의 FD 포인터 위치에 가까운 주소를 썼기 때문입니다.
2. **Malloc Check 트리거**: 이 청크 크기 조작은 `malloc`이 내부적인 체크를 수행하도록 만듭니다. 거짓 포워드 청크의 크기를 확인할 때, 이는 0이 되어 오류를 일으키고 `malloc_printerr`를 호출합니다.

Small bin의 조작을 통해 청크의 포워드 포인터를 제어할 수 있습니다. **\_IO\_list\_all**과의 중첩은 가짜 **\_IO\_FILE** 구조체를 위조하는 데 사용됩니다. 이 구조체는 `_IO_write_base` 및 `_IO_write_ptr`와 같은 주요 필드를 포함하여 libc의 내부 체크를 통과하는 값으로 설정됩니다. 또한 가짜 구조체 내에 점프 테이블이 생성되며, 명령 포인터가 임의의 코드 (예: `system` 함수)가 실행될 수 있는 주소로 설정됩니다.

기술의 나머지 부분을 요약하면:

* **이전 최상위 청크 축소**: 이전 최상위 청크의 크기를 **0x61**로 조정하여 작은 bin에 맞춥니다.
* **가짜 `_IO_FILE` 구조체 설정**: 이전 최상위 청크와 중첩된 가짜 **\_IO\_FILE** 구조체를 설정하고 제어 흐름을 탈취합니다.

다음 단계는 현재 정렬되지 않은 bin에 있는 이전 최상위 청크와 중첩되는 가짜 **\_IO\_FILE** 구조체를 위조하는 것입니다. 이 구조체의 처음 바이트는 조심스럽게 설정되어야 하며, 실행될 명령 (예: "/bin/sh")을 가리키는 포인터를 포함해야 합니다.

가짜 **\_IO\_FILE** 구조체의 주요 필드인 `_IO_write_base` 및 `_IO_write_ptr`와 같은 필드는 libc의 내부 체크를 통과하는 값으로 설정됩니다. 또한 가짜 구조체 내에 점프 테이블이 생성되며, 명령 포인터가 임의의 코드가 실행될 수 있는 주소로 설정됩니다. 일반적으로 이는 `system` 함수의 주소 또는 쉘 명령을 실행할 수 있는 다른 함수의 주소일 것입니다.

공격은 `malloc` 호출이 조작된 **\_IO\_FILE** 구조체를 통해 코드 실행을 트리거할 때 절정에 이릅니다. 이를 통해 임의의 코드 실행이 가능해지며, 일반적으로 쉘이 생성되거나 다른 악의적인 페이로드가 실행됩니다.

**공격 요약:**

1. **최상위 청크 설정**: 청크를 할당하고 최상위 청크 크기를 수정합니다.
2. **최상위 청크를 정렬되지 않은 bin으로 강제**: 더 큰 청크를 할당합니다.
3. **Libc 주소 누출**: 정렬되지 않은 bin에서 읽기 위해 취약점 사용
4. **정렬되지 않은 bin 공격 수행**: 오버플로우를 사용하여 **\_IO\_list\_all**에 쓰기
5. **이전 최상위 청크 축소**: 작은 bin에 맞게 크기 조정
6. **가짜 \_IO\_FILE 구조체 설정**: 제어 흐름을 탈취하기 위해 가짜 파일 구조체를 위조
7. **코드 실행 트리거**: 공격을 실행하고 임의의 코드 실행

이 접근 방식은 `free`를 직접 호출하지 않고도 코드 실행을 달성하기 위해 힙 관리 메커니즘, libc 정보 누출 및 힙 오버플로우를 악용합니다. 가짜 **\_IO\_FILE** 구조체를 신중하게 제작하고 올바른 위치에 배치하여 표준 메모리 할당 작업 중에 제어 흐름을 탈취할 수 있습니다. 이를 통해 임의의 코드 실행이 가능해지며, 일반적으로 쉘 또는 다른 악의적인 활동이 실행됩니다.
## 참고 자료

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 영웅이 되는 AWS 해킹을 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하길 원한다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 우리의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **당신의 해킹 기술을 공유**하세요.

</details>
