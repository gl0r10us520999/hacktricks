# Maison d'Orange

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert Red Team AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

### Code

* Trouvez un exemple dans [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* La technique d'exploitation a √©t√© corrig√©e dans ce [correctif](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) donc cela ne fonctionne plus (fonctionne dans les versions ant√©rieures √† 2.26)
* M√™me exemple **avec plus de commentaires** dans [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Objectif

* Abuser de la fonction `malloc_printerr`

### Exigences

* √âcraser la taille du chunk sup√©rieur
* Fuites de libc et de tas

### Contexte

Certains ant√©c√©dents n√©cessaires des commentaires de [**cet exemple**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

Le probl√®me est que, dans les anciennes versions de libc, lorsque la fonction `malloc_printerr` √©tait appel√©e, elle **it√©rait √† travers une liste de structures `_IO_FILE` stock√©es dans `_IO_list_all`**, et ex√©cutait en fait un pointeur d'instruction dans cette structure.\
Cette attaque forg√©e une **fausse structure `_IO_FILE`** que nous √©crirons dans **`_IO_list_all`**, et provoquera l'ex√©cution de `malloc_printerr`.\
Ensuite, il ex√©cutera **n'importe quelle adresse** que nous avons stock√©e dans les **structures `_IO_FILE`**, et nous obtiendrons une ex√©cution de code

### Attaque

L'attaque commence par parvenir √† obtenir le **chunk sup√©rieur** √† l'int√©rieur du **tas non tri√©**. Cela est r√©alis√© en appelant `malloc` avec une taille sup√©rieure √† la taille actuelle du chunk sup√©rieur mais plus petite que **`mmp_.mmap_threshold`** (par d√©faut 128K), ce qui d√©clencherait autrement une allocation `mmap`. Chaque fois que la taille du chunk sup√©rieur est modifi√©e, il est important de s'assurer que le **chunk sup√©rieur + sa taille** est align√© sur la page et que le bit **prev\_inuse** du chunk sup√©rieur est toujours d√©fini.

Pour obtenir le chunk sup√©rieur √† l'int√©rieur du tas non tri√©, allouez un chunk pour cr√©er le chunk sup√©rieur, modifiez la taille du chunk sup√©rieur (avec un d√©bordement dans le chunk allou√©) de sorte que **le chunk sup√©rieur + la taille** soit align√© sur la page avec le bit **prev\_inuse** d√©fini. Ensuite, allouez un chunk plus grand que la nouvelle taille du chunk sup√©rieur. Notez que `free` n'est jamais appel√© pour placer le chunk sup√©rieur dans le tas non tri√©.

L'ancien chunk sup√©rieur est maintenant dans le tas non tri√©. En supposant que nous puissions lire des donn√©es √† l'int√©rieur (√©ventuellement en raison d'une vuln√©rabilit√© ayant √©galement provoqu√© le d√©bordement), il est possible de fuiter des adresses de libc √† partir de celui-ci et d'obtenir l'adresse de **\_IO\_list\_all**.

Une attaque sur le tas non tri√© est effectu√©e en abusant du d√©bordement pour √©crire `topChunk->bk->fwd = _IO_list_all - 0x10`. Lorsqu'un nouveau chunk est allou√©, l'ancien chunk sup√©rieur sera divis√©, et un pointeur vers le tas non tri√© sera √©crit dans **`_IO_list_all`**.

L'√©tape suivante consiste √† r√©duire la taille de l'ancien chunk sup√©rieur pour qu'il rentre dans un petit bin, en r√©glant sp√©cifiquement sa taille sur **0x61**. Cela sert √† deux fins :

1. **Insertion dans le petit bin 4** : Lorsque `malloc` parcourt le tas non tri√© et voit ce chunk, il essaiera de l'ins√©rer dans le petit bin 4 en raison de sa petite taille. Cela fait que le chunk se retrouve en t√™te de la liste du petit bin 4, qui est l'emplacement du pointeur FD du chunk de **`_IO_list_all`** car nous avons √©crit une adresse proche dans **`_IO_list_all`** via l'attaque sur le tas non tri√©.
2. **D√©clenchement d'une v√©rification de malloc** : Cette manipulation de la taille du chunk provoquera des v√©rifications internes de `malloc`. Lorsqu'il v√©rifie la taille du faux chunk suivant, qui sera nulle, cela d√©clenche une erreur et appelle `malloc_printerr`.

La manipulation du petit bin vous permettra de contr√¥ler le pointeur avant du chunk. Le chevauchement avec **\_IO\_list\_all** est utilis√© pour forger une fausse structure **\_IO\_FILE**. La structure est soigneusement con√ßue pour inclure des champs cl√©s comme `_IO_write_base` et `_IO_write_ptr` d√©finis sur des valeurs qui passent les v√©rifications internes de libc. De plus, une table de saut est cr√©√©e √† l'int√©rieur de la fausse structure, o√π un pointeur d'instruction est d√©fini sur l'adresse o√π un code arbitraire (par exemple, la fonction `system`) peut √™tre ex√©cut√©.

Pour r√©sumer la partie restante de la technique :

* **R√©duire l'ancien chunk sup√©rieur** : Ajustez la taille de l'ancien chunk sup√©rieur √† **0x61** pour le faire rentrer dans un petit bin.
* **Configurer la fausse structure `_IO_FILE`** : Faites chevaucher l'ancien chunk sup√©rieur avec la fausse structure **\_IO\_FILE** et d√©finissez les champs de mani√®re appropri√©e pour d√©tourner le flux d'ex√©cution.

L'√©tape suivante consiste √† forger une fausse structure **\_IO\_FILE** qui chevauche l'ancien chunk sup√©rieur actuellement dans le tas non tri√©. Les premiers octets de cette structure sont soigneusement con√ßus pour inclure un pointeur vers une commande (par exemple, "/bin/sh") qui sera ex√©cut√©e.

Les champs cl√©s de la fausse structure **\_IO\_FILE**, tels que `_IO_write_base` et `_IO_write_ptr`, sont d√©finis sur des valeurs qui passent les v√©rifications internes de libc. De plus, une table de saut est cr√©√©e √† l'int√©rieur de la fausse structure, o√π un pointeur d'instruction est d√©fini sur l'adresse o√π un code arbitraire peut √™tre ex√©cut√©. Typiquement, il s'agirait de l'adresse de la fonction `system` ou d'une autre fonction pouvant ex√©cuter des commandes shell.

L'attaque culmine lorsque l'appel √† `malloc` d√©clenche l'ex√©cution du code √† travers la structure **\_IO\_FILE** manipul√©e. Cela permet efficacement l'ex√©cution de code arbitraire, aboutissant g√©n√©ralement √† un shell ou √† l'ex√©cution d'une autre charge malveillante.

**R√©sum√© de l'attaque :**

1. **Configurer le chunk sup√©rieur** : Allouer un chunk et modifier la taille du chunk sup√©rieur.
2. **Forcer le chunk sup√©rieur dans le tas non tri√©** : Allouer un chunk plus grand.
3. **Fuite des adresses de libc** : Utiliser la vuln√©rabilit√© pour lire √† partir du tas non tri√©.
4. **Effectuer l'attaque sur le tas non tri√©** : √âcrire dans **\_IO\_list\_all** en utilisant un d√©bordement.
5. **R√©duire l'ancien chunk sup√©rieur** : Ajustez sa taille pour qu'il rentre dans un petit bin.
6. **Configurer une fausse structure \_IO\_FILE** : Forger une fausse structure de fichier pour d√©tourner le flux de contr√¥le.
7. **D√©clencher l'ex√©cution de code** : Allouer un chunk pour ex√©cuter l'attaque et ex√©cuter du code arbitraire.

Cette approche exploite les m√©canismes de gestion du tas, les fuites d'informations libc et les d√©bordements de tas pour parvenir √† une ex√©cution de code sans appeler directement `free`. En concevant soigneusement la fausse structure **\_IO\_FILE** et en la pla√ßant au bon endroit, l'attaque peut d√©tourner le flux de contr√¥le lors des op√©rations standard d'allocation de m√©moire. Cela permet l'ex√©cution de code arbitraire, aboutissant potentiellement √† un shell ou √† d'autres activit√©s malveillantes.
## R√©f√©rences

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert Red Team AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
