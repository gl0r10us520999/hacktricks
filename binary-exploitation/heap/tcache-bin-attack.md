# Tcache Bin Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 제로에서 히어로까지 AWS 해킹 배우기</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com) 받기
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소로 **PR 제출**하여 해킹 요령 공유하기.

</details>

## 기본 정보

Tcache bin이 무엇인지에 대한 자세한 정보는 다음 페이지를 확인하세요:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

먼저, Tcache는 glibc 버전 2.26에서 소개되었음을 유의하십시오.

[**guyinatuxido 페이지**](https://guyinatuxedo.github.io/29-tcache/tcache\_explanation/index.html)에서 제안된 **Tcache** 공격은 목표로 하는 것이 해제된 청크 내부의 bin 안의 다음 청크를 가리키는 포인터를 임의의 주소로 덮어쓰기하여 나중에 **해당 특정 주소를 할당하고 포인터를 덮어쓸 수 있도록** 하는 fast bin 공격과 매우 유사합니다.

그러나 현재는 해당 코드를 실행하면 **`malloc(): unaligned tcache chunk detected`** 오류가 발생합니다. 따라서 새 포인터에 정렬된 주소를 쓰거나 (또는 쓴 주소가 실제로 정렬된 주소인지 확인하기 위해 이진을 충분히 실행해야 함)해야 합니다.

### Tcache 인덱스 공격

일반적으로 힙의 시작 부분에는 tcache 내의 **인덱스 당 청크 수**를 포함하고 있으며 각 tcache 인덱스의 **헤드 청크 주소**를 포함하는 청크가 있습니다. 이 정보를 수정할 수 있는 경우, 특정 주소(예: malloc 후크)를 가리키도록 **일부 인덱스의 헤드 청크를 만들 수 있습니다**. 그런 다음 해당 인덱스의 크기로 청크를 할당하고 이 경우 malloc 후크의 내용을 덮어쓸 수 있습니다.

## 예시

* CTF [https://guyinatuxedo.github.io/29-tcache/dcquals19\_babyheap/index.html](https://guyinatuxedo.github.io/29-tcache/dcquals19\_babyheap/index.html)
* **Libc 정보 누출**: tcache를 채우고 unsorted 리스트에 청크를 추가한 다음 tcache를 비우고 **unsorted bin에서 청크를 다시 할당**하여 처음 8B만 덮어쓰고 **청크의 두 번째 주소를 유지하여 libc 주소를 읽을 수 있습니다**.
* **Tcache 공격**: 바이너리가 1B 힙 오버플로우에 취약합니다. 이를 악용하여 할당된 청크의 **크기 헤더**를 변경하여 크게 만듭니다. 그런 다음 이 청크를 **해제**하여 가짜 크기의 tcache 청크에 추가합니다. 그런 다음 가짜 크기로 청크를 할당하고 이전 청크가 실제로 더 작았음을 알고 **다음 청크를 덮어쓸 수 있는 기회**를 얻습니다.\
이를 악용하여 **다음 청크의 FD 포인터를 덮어쓰기**하여 **`malloc_hook`**을 가리키도록 만들어 첫 번째로 수정한 합법적인 포인터를 할당하고, 두 번째 할당은 **`malloc_hook`**에 청크를 반환하여 **원 가젯을 작성할 수 있는** 기회를 제공합니다.
* CTF [https://guyinatuxedo.github.io/29-tcache/plaid19\_cpp/index.html](https://guyinatuxedo.github.io/29-tcache/plaid19\_cpp/index.html)
* **Libc 정보 누출**: 사용 후 무료 및 이중 무료가 있습니다. 이 글에서 작성자는 작은 bin에 배치된 청크의 주소를 읽어 libc 주소를 유출했습니다 (unsorted bin에서 누출하는 것처럼 작은 bin에서 누출).
* **Tcache 공격**: **이중 해제**를 통해 Tcache가 수행됩니다. 동일한 청크가 두 번 해제되므로 Tcache 내에서 청크가 자신을 가리킵니다. 그런 다음 할당되고 FD 포인터가 수정되어 **free 후크를 가리키도록**하고 다시 할당되어 목록의 다음 청크가 free 후크에 있게됩니다. 그런 다음 이것도 할당되어 `system` 주소를 여기에 쓸 수 있으므로 `"/bin/sh"`를 포함하는 malloc이 해제될 때 쉘을 얻을 수 있습니다.
* CTF [https://guyinatuxedo.github.io/44-more\_tcache/csaw19\_popping\_caps0/index.html](https://guyinatuxedo.github.io/44-more\_tcache/csaw19\_popping\_caps0/index.html)
* 여기서 주요 취약점은 오프셋을 지정하여 힙에서 **모든 주소를 `free`**할 수 있는 능력입니다.
* **Tcache 인덱스 공격**: tcache 청크(각 bin의 청크 수를 저장하는 청크)에 저장될 때 **값이 0x100인 주소를 생성하는 크기의 청크를 할당하고 해제**할 수 있습니다. 이는 tcache가 각 bin의 청크 수를 다른 바이트에 저장하기 때문에 특정 인덱스의 한 청크가 값 0x100을 생성합니다.
* 그런 다음 이 값은 크기가 0x100인 청크가 있는 것처럼 보입니다. 이 주소를 `free`하여 해당 주소를 tcache의 크기가 0x100인 청크 인덱스에 추가할 수 있습니다.
* 그런 다음 크기가 **0x100인 청크를 할당**하면 이전 주소가 청크로 반환되어 다른 tcache 인덱스를 덮어쓸 수 있습니다.\
예를 들어 malloc 후크의 주소를 하나에 넣고 해당 인덱스의 크기로 청크를 할당하면 calloc 후크에 청크가 제공되어 원 가젯을 작성할 수 있습니다.
* CTF [https://guyinatuxedo.github.io/44-more\_tcache/csaw19\_popping\_caps1/index.html](https://guyinatuxedo.github.io/44-more\_tcache/csaw19\_popping\_caps1/index.html)
* 이전과 동일한 취약점이지만 추가 제한이 있습니다.
* **Tcache 인덱스 공격**: 이전 공격과 유사하지만 **tcache 정보를 포함하는 청크를 해제**하여 해당 주소가 해당 크기의 tcache 인덱스에 추가되어 해당 크기를 할당하고 tcache 청크 정보를 얻을 수 있으므로 free 후크를 하나의 인덱스 주소로 추가하고 할당하여 원 가젯을 작성할 수 있습니다.
