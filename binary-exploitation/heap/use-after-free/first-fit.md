# İlk Uygun

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **İlk Uygun**

Bir programda glibc kullanarak belleği serbest bıraktığınızda, bellek parçalarını yönetmek için farklı "kutular" kullanılır. İşte iki yaygın senaryonun basitleştirilmiş bir açıklaması: sıralanmamış kutular ve hızlı kutular.

### Sıralanmamış Kutular

Hızlı bir parça olmayan bir bellek parçasını serbest bıraktığınızda, bu parça sıralanmamış kutuya gider. Bu kutu, yeni serbest bırakılan parçaların önüne (başa) eklenen bir liste gibi davranır. Yeni bir bellek parçası istediğinizde, tahsisatçı, istediğinizden yeterince büyük bir parça bulmak için sıralanmamış kutuya arkadan (kuyruk) bakar. Eğer sıralanmamış kutudan bir parça isteğinizden büyükse, bölünür; ön kısmı geri döndürülür ve geri kalan kısım kutuda kalır.

Örnek:

* 300 bayt (`a`) tahsis edersiniz, ardından 250 bayt (`b`) tahsis edersiniz, `a`'yı serbest bırakırsınız ve tekrar 250 bayt (`c`) istersiniz.
* `a`'yı serbest bıraktığınızda, sıralanmamış kutuya gider.
* Sonra 250 bayt daha isterseniz, tahsisatçı `a`'yı kuyrukta bulur ve bölerek, isteğinize uygun olan kısmı geri döndürür ve geri kalanı kutuda tutar.
* `c`, önceki `a`'ya işaret edecek ve `a`'ların içeriğiyle dolacak.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins küçük bellek parçaları için kullanılır. Sıralanmamış kovaların aksine, fastbins yeni parçaları başa ekler ve son giren-ilk çıkan (LIFO) davranışı oluşturur. Eğer küçük bir bellek parçası isterseniz, ayırıcı fastbin'in başından alacaktır.

Örnek:

* 20 baytlık dört parça (`a`, `b`, `c`, `d`) ayırırsınız.
* Onları herhangi bir sırayla serbest bıraktığınızda, serbest bırakılan parçalar fastbin'in başına eklenir.
* Sonra 20 baytlık bir parça isterseniz, ayırıcı en son serbest bırakılan parçayı fastbin'in başından döndürecektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Diğer Referanslar ve Örnekler

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Bir kullanıcı nesnesi oluştur, serbest bırak, serbest bırakılan parçayı alan bir nesne oluştur ve ona yazma izni ver, **önceki kullanıcı->şifre** konumunu üzerine yaz. Kullanıcıyı tekrar kullanarak **şifre kontrolünü atla**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program notlar oluşturmaya izin verir. Bir not, not bilgisini içeren malloc(8) (çağrılabilen bir işlevin işaretçisiyle) ve notun içeriğini içeren başka bir malloc(\<boyut>) işaretçisine sahip olacaktır.
* Saldırı, not bilgi boyutundan daha büyük malloc içeriğine sahip 2 not (not0 ve not1) oluşturmak ve ardından bunları serbest bırakarak hızlı bin (veya tcache) içine almaktır.
* Sonra, içerik boyutu 8 olan başka bir not (not2) oluşturun. İçerik, parçanın yeniden kullanılacağı not1'de olacak, burada işlev işaretçisini win işlevine yönlendirebilir ve ardından not1'i Use-After-Free yaparak yeni işlev işaretçisini çağırabilirsiniz.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Bazı bellek ayırmak, istenen değeri yazmak, serbest bırakmak, yeniden boyutlandırmak mümkündür ve önceki veriler hala orada olduğundan, parçadaki yeni beklenen yapıya göre işlem görecektir, bu da değeri ayarlamayı veya bayrağı almayı mümkün kılar.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Bu durumda, belirli bir parçanın içine 4 yazmak gereklidir, bu ilk ayrılan parçadır (hepsini zorla serbest bıraktıktan sonra bile). Her yeni ayrılan parçada, dizin içindeki numarası saklanır. Sonra, 4 parça (+ başlangıçta ayrılan) tahsis edin, sonuncusu içinde 4 bulunacak, onları serbest bırakın ve ilk parçanın yeniden tahsisini zorlayın, bu da içinde 4 olan son parçayı kullanacaktır.
