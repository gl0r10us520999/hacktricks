# First Fit

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## **First Fit**

Cuando liberas memoria en un programa que utiliza glibc, se utilizan diferentes "bins" para gestionar los fragmentos de memoria. Aqu칤 tienes una explicaci칩n simplificada de dos escenarios comunes: bins desordenados y fastbins.

### Bins Desordenados

Cuando liberas un fragmento de memoria que no es un fragmento r치pido, este va al bin desordenado. Este bin act칰a como una lista donde se a침aden los nuevos fragmentos liberados al principio (la "cabeza"). Cuando solicitas un nuevo fragmento de memoria, el asignador mira el bin desordenado desde el final (la "cola") para encontrar un fragmento lo suficientemente grande. Si un fragmento del bin desordenado es m치s grande de lo que necesitas, se divide, devolviendo la parte delantera y manteniendo la parte restante en el bin.

Ejemplo:

* Asignas 300 bytes (`a`), luego 250 bytes (`b`), liberas `a` y solicitas de nuevo 250 bytes (`c`).
* Cuando liberas `a`, va al bin desordenado.
* Si luego solicitas 250 bytes de nuevo, el asignador encuentra `a` en la cola y lo divide, devolviendo la parte que se ajusta a tu solicitud y manteniendo el resto en el bin.
* `c` apuntar치 al `a` anterior y estar치 lleno con los datos de `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se utilizan para peque침os fragmentos de memoria. A diferencia de los bines desordenados, los fastbins a침aden nuevos fragmentos al principio, creando un comportamiento de 칰ltimo en entrar, primero en salir (LIFO). Si solicitas un peque침o fragmento de memoria, el asignador tomar치 del principio del fastbin.

Ejemplo:

* Asignas cuatro fragmentos de 20 bytes cada uno (`a`, `b`, `c`, `d`).
* Cuando los liberas en cualquier orden, los fragmentos liberados se a침aden al principio del fastbin.
* Si luego solicitas un fragmento de 20 bytes, el asignador devolver치 el fragmento liberado m치s recientemente del principio del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Otras Referencias y Ejemplos

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Generar un objeto de usuario, liberarlo, generar un objeto que obtiene el fragmento liberado y permite escribir en 칠l, **sobrescribiendo la posici칩n de la contrase침a de usuario** de la anterior. Reutilizar el usuario para **burlar la verificaci칩n de la contrase침a**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* El programa permite crear notas. Una nota tendr치 la informaci칩n de la nota en un malloc(8) (con un puntero a una funci칩n que podr칤a ser llamada) y un puntero a otro malloc(\<size>) con el contenido de la nota.
* El ataque consistir칤a en crear 2 notas (nota0 y nota1) con contenidos de malloc m치s grandes que el tama침o de la informaci칩n de la nota y luego liberarlas para que entren en el fast bin (o tcache).
* Luego, crear otra nota (nota2) con tama침o de contenido 8. El contenido estar치 en nota1 ya que el fragmento se reutilizar치, donde podr칤amos modificar el puntero de la funci칩n para que apunte a la funci칩n de victoria y luego Use-After-Free en la nota1 para llamar al nuevo puntero de funci칩n.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Es posible asignar algo de memoria, escribir el valor deseado, liberarlo, realojarlo y como los datos anteriores siguen all칤, se tratar치 seg칰n la nueva estructura esperada en el fragmento, lo que hace posible establecer el valor o obtener la bandera.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* En este caso es necesario escribir 4 dentro de un fragmento espec칤fico que es el primero que se asigna (incluso despu칠s de liberarlos forzosamente todos). En cada nuevo fragmento asignado se almacena su n칰mero en el 칤ndice del array. Luego, asignar 4 fragmentos (+ el inicialmente asignado), el 칰ltimo tendr치 4 en su interior, liberarlos y forzar la reasignaci칩n del primero, que utilizar치 el 칰ltimo fragmento liberado que es el que tiene 4 en su interior.
