# First Fit

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## **First Fit**

Quando liberi la memoria in un programma usando glibc, vengono utilizzati diversi "bin" per gestire i blocchi di memoria. Ecco una spiegazione semplificata di due scenari comuni: unsorted bins e fastbins.

### Unsorted Bins

Quando liberi un blocco di memoria che non √® un blocco veloce, va al bin non ordinato. Questo bin funziona come una lista in cui i nuovi blocchi liberati vengono aggiunti all'inizio (la "testa"). Quando richiedi un nuovo blocco di memoria, l'allocatore guarda il bin non ordinato dalla fine (la "coda") per trovare un blocco abbastanza grande. Se un blocco dal bin non ordinato √® pi√π grande di quanto necessiti, viene diviso, con la parte anteriore restituita e la parte rimanente rimane nel bin.

Esempio:

* Alloci 300 byte (`a`), poi 250 byte (`b`), liberi `a` e richiedi di nuovo 250 byte (`c`).
* Quando liberi `a`, va al bin non ordinato.
* Se poi richiedi di nuovo 250 byte, l'allocatore trova `a` in coda e lo divide, restituendo la parte che soddisfa la tua richiesta e mantenendo il resto nel bin.
* `c` punter√† al precedente `a` e sar√† riempito con i dati di `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

I fastbins sono utilizzati per piccoli blocchi di memoria. A differenza dei blocchi non ordinati, i fastbins aggiungono nuovi blocchi all'inizio, creando un comportamento di tipo ultimo ad entrare, primo ad uscire (LIFO). Se richiedi un piccolo blocco di memoria, l'allocatore prelever√† dalla testa del fastbin.

Esempio:

* Alloci quattro blocchi da 20 byte ciascuno (`a`, `b`, `c`, `d`).
* Quando li liberi in qualsiasi ordine, i blocchi liberati vengono aggiunti alla testa del fastbin.
* Se successivamente richiedi un blocco da 20 byte, l'allocatore restituir√† il blocco liberato pi√π di recente dalla testa del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Altri riferimenti ed esempi

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Uso dopo la liberazione: Generare un oggetto utente, liberarlo, generare un oggetto che ottiene il chunk liberato e consente di scriverci sopra, **sovrascrivendo la posizione di user->password** da quello precedente. Riutilizzare l'utente per **bypassare il controllo della password**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Il programma consente di creare note. Una nota avr√† le informazioni della nota in un malloc(8) (con un puntatore a una funzione che potrebbe essere chiamata) e un puntatore a un altro malloc(\<size>) con il contenuto della nota.
* L'attacco consisterebbe nel creare 2 note (nota0 e nota1) con contenuti malloc pi√π grandi della dimensione delle informazioni della nota e quindi liberarle in modo che entrino nel fast bin (o tcache).
* Successivamente, creare un'altra nota (nota2) con dimensione del contenuto 8. Il contenuto sar√† nella nota1 poich√© il chunk verr√† riutilizzato, dove potremmo modificare il puntatore della funzione per puntare alla funzione win e quindi Usare-Dopo-Liberazione la nota1 per chiamare il nuovo puntatore della funzione.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* √à possibile allocare della memoria, scrivere il valore desiderato, liberarla, reallocarla e poich√© i dati precedenti sono ancora l√¨, verranno trattati secondo la nuova struttura prevista nel chunk, rendendo possibile impostare il valore o ottenere il flag.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* In questo caso √® necessario scrivere 4 all'interno di un chunk specifico che √® il primo ad essere allocato (anche dopo averli liberati forzatamente tutti). Su ciascun nuovo chunk allocato viene memorizzato il suo numero nell'indice dell'array. Quindi, allocare 4 chunk (+ quello allocato inizialmente), l'ultimo avr√† 4 al suo interno, liberarli e forzare la riallocazione del primo, che utilizzer√† l'ultimo chunk liberato che √® quello con 4 al suo interno.
