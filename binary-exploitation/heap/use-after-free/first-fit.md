# First Fit

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **First Fit**

Lorsque vous lib√©rez de la m√©moire dans un programme utilisant glibc, diff√©rents "bacs" sont utilis√©s pour g√©rer les morceaux de m√©moire. Voici une explication simplifi√©e de deux sc√©narios courants : les bacs non tri√©s et les fastbins.

### Bacs non tri√©s

Lorsque vous lib√©rez un morceau de m√©moire qui n'est pas un morceau rapide, il va dans le bac non tri√©. Ce bac agit comme une liste o√π les nouveaux morceaux lib√©r√©s sont ajout√©s √† l'avant (la "t√™te"). Lorsque vous demandez un nouveau morceau de m√©moire, l'allocateur regarde le bac non tri√© depuis l'arri√®re (la "queue") pour trouver un morceau suffisamment grand. Si un morceau du bac non tri√© est plus grand que ce dont vous avez besoin, il est divis√©, la partie avant √©tant renvoy√©e et la partie restante restant dans le bac.

Exemple :

* Vous allouez 300 octets (`a`), puis 250 octets (`b`), lib√©rez `a` et demandez √† nouveau 250 octets (`c`).
* Lorsque vous lib√©rez `a`, il va dans le bac non tri√©.
* Si vous demandez ensuite √† nouveau 250 octets, l'allocateur trouve `a` √† la queue et le divise, renvoyant la partie qui correspond √† votre demande et conservant le reste dans le bac.
* `c` pointera vers le `a` pr√©c√©dent et sera rempli avec les `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Les fastbins sont utilis√©s pour de petits morceaux de m√©moire. Contrairement aux bacs non tri√©s, les fastbins ajoutent de nouveaux morceaux √† la t√™te, cr√©ant un comportement de dernier entr√©, premier sorti (LIFO). Si vous demandez un petit morceau de m√©moire, l'allocateur le prendra √† partir de la t√™te du fastbin.

Exemple :

* Vous allouez quatre morceaux de 20 octets chacun (`a`, `b`, `c`, `d`).
* Lorsque vous les lib√©rez dans n'importe quel ordre, les morceaux lib√©r√©s sont ajout√©s √† la t√™te du fastbin.
* Si vous demandez ensuite un morceau de 20 octets, l'allocateur renverra le morceau le plus r√©cemment lib√©r√© de la t√™te du fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Autres r√©f√©rences et exemples

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Utilisation apr√®s lib√©ration : G√©n√©rer un objet utilisateur, le lib√©rer, g√©n√©rer un objet qui r√©cup√®re le morceau lib√©r√© et permet d'√©crire dedans, **√©crasant la position de user->password** de l'objet pr√©c√©dent. R√©utiliser l'utilisateur pour **contourner la v√©rification du mot de passe**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Le programme permet de cr√©er des notes. Une note aura les informations de la note dans un malloc(8) (avec un pointeur vers une fonction qui pourrait √™tre appel√©e) et un pointeur vers un autre malloc(\<size>) avec le contenu de la note.
* L'attaque consisterait √† cr√©er 2 notes (note0 et note1) avec des contenus malloc plus grands que la taille des informations de la note, puis √† les lib√©rer pour qu'elles entrent dans le fast bin (ou tcache).
* Ensuite, cr√©er une autre note (note2) avec une taille de contenu de 8. Le contenu va √™tre dans note1 car le morceau va √™tre r√©utilis√©, o√π nous pourrions modifier le pointeur de fonction pour pointer vers la fonction win et ensuite Utiliser-Apr√®s-Libre la note1 pour appeler le nouveau pointeur de fonction.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Il est possible d'allouer de la m√©moire, d'√©crire la valeur souhait√©e, de la lib√©rer, de la r√©allouer et comme les donn√©es pr√©c√©dentes sont toujours l√†, elles seront trait√©es selon la nouvelle structure attendue dans le morceau, ce qui permet de d√©finir la valeur ou d'obtenir le drapeau.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Dans ce cas, il est n√©cessaire d'√©crire 4 √† l'int√©rieur d'un morceau sp√©cifique qui est le premier √† √™tre allou√© (m√™me apr√®s les avoir tous lib√©r√©s de force). √Ä chaque nouveau morceau allou√©, son num√©ro dans l'index du tableau est stock√©. Ensuite, allouez 4 morceaux (+ celui initialement allou√©), le dernier aura 4 √† l'int√©rieur, lib√©rez-les et forcez la r√©affectation du premier, qui utilisera le dernier morceau lib√©r√© qui est celui avec 4 √† l'int√©rieur.
