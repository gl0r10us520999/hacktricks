# First Fit

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## **First Fit**

Όταν απελευθερώνετε μνήμη σε ένα πρόγραμμα που χρησιμοποιεί το glibc, χρησιμοποιούνται διαφορετικοί "κάδοι" για τη διαχείριση των κομματιών μνήμης. Εδώ υπάρχει μια απλουστευμένη εξήγηση δύο συνηθισμένων σεναρίων: μη ταξινομημένοι κάδοι και γρήγοροι κάδοι.

### Μη Ταξινομημένοι Κάδοι

Όταν απελευθερώνετε ένα κομμάτι μνήμης που δεν είναι ένα γρήγορο κομμάτι, πηγαίνει στον μη ταξινομημένο κάδο. Αυτός ο κάδος λειτουργεί σαν μια λίστα όπου τα νέα απελευθερωμένα κομμάτια προστίθενται στην αρχή (το "κεφάλι"). Όταν ζητάτε ένα νέο κομμάτι μνήμης, ο διαχειριστής κοιτά στον μη ταξινομημένο κάδο από το πίσω μέρος (τη "ουρά") για να βρει ένα κομμάτι που είναι αρκετά μεγάλο. Αν ένα κομμάτι από τον μη ταξινομημένο κάδο είναι μεγαλύτερο από αυτό που χρειάζεστε, τότε γίνεται διαίρεση, με το μέρος μπροστά να επιστρέφεται και το υπόλοιπο μέρος να παραμένει στον κάδο.

Παράδειγμα:

* Δεσμεύετε 300 bytes (`a`), στη συνέχεια 250 bytes (`b`), απελευθερώνετε το `a` και ζητάτε ξανά 250 bytes (`c`).
* Όταν απελευθερώνετε το `a`, πηγαίνει στον μη ταξινομημένο κάδο.
* Αν στη συνέχεια ζητήσετε ξανά 250 bytes, ο διαχειριστής βρίσκει το `a` στην ουρά και το διαιρεί, επιστρέφοντας το μέρος που ταιριάζει στο αίτημά σας και κρατώντας το υπόλοιπο στον κάδο.
* Το `c` θα δείχνει στο προηγούμενο `a` και θα είναι γεμάτο με τα δεδομένα του `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Τα Fastbins χρησιμοποιούνται για μικρά κομμάτια μνήμης. Αντίθετα με τα unsorted bins, τα fastbins προσθέτουν νέα κομμάτια στην αρχή, δημιουργώντας ένα συμπεριφορά last-in-first-out (LIFO). Αν ζητήσετε ένα μικρό κομμάτι μνήμης, ο allocator θα το πάρει από την αρχή του fastbin.

Παράδειγμα:

* Δεσμεύετε τέσσερα κομμάτια των 20 bytes το καθένα (`a`, `b`, `c`, `d`).
* Όταν τα ελευθερώσετε με οποιαδήποτε σειρά, τα ελευθερωμένα κομμάτια προστίθενται στην αρχή του fastbin.
* Αν στη συνέχεια ζητήσετε ένα κομμάτι 20 bytes, ο allocator θα επιστρέψει το πιο πρόσφατα ελευθερωμένο κομμάτι από την αρχή του fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Άλλες Αναφορές & Παραδείγματα

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Δημιουργία ενός αντικειμένου χρήστη, απελευθέρωσή του, δημιουργία ενός αντικειμένου που παίρνει το απελευθερωμένο κομμάτι και επιτρέπει την εγγραφή σε αυτό, **αντικαθιστώντας τη θέση του user->password** από το προηγούμενο. Χρησιμοποιήστε ξανά τον χρήστη για **παράκαμψη του ελέγχου κωδικού πρόσβασης**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Το πρόγραμμα επιτρέπει τη δημιουργία σημειώσεων. Μια σημείωση θα έχει τις πληροφορίες της σημείωσης σε ένα malloc(8) (με ένα δείκτη προς μια συνάρτηση που θα μπορούσε να κληθεί) και ένα δείκτη προς ένα άλλο malloc(\<size>) με τα περιεχόμενα της σημείωσης.
* Η επίθεση θα είναι να δημιουργηθούν 2 σημειώσεις (note0 και note1) με μεγαλύτερο μέγεθος περιεχομένου malloc από το μέγεθος των πληροφοριών της σημείωσης και στη συνέχεια να τις απελευθερώσουν ώστε να μπουν στο fast bin (ή tcache).
* Στη συνέχεια, δημιουργήστε μια άλλη σημείωση (note2) με μέγεθος περιεχομένου 8. Το περιεχόμενο θα βρίσκεται στη note1 καθώς το κομμάτι θα επαναχρησιμοποιηθεί, όπου θα μπορούσαμε να τροποποιήσουμε το δείκτη της συνάρτησης ώστε να δείχνει στη συνάρτηση win και στη συνέχεια να γίνει Use-After-Free η note1 για να κληθεί ο νέος δείκτης συνάρτησης.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Είναι δυνατόν να δεσμευτεί μνήμη, να γραφτεί η επιθυμητή τιμή, να απελευθερωθεί, να επαναδεσμευτεί και καθώς τα προηγούμενα δεδομένα εξακολουθούν να υπάρχουν, θα χειριστούν σύμφωνα με τη νέα αναμενόμενη δομή στο κομμάτι, κάνοντας δυνατή την ορισμό της τιμής ή την απόκτηση της σημαίας.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Σε αυτήν την περίπτωση είναι απαραίτητο να γραφτεί το 4 μέσα σε ένα συγκεκριμένο κομμάτι που είναι το πρώτο που δεσμεύεται (ακόμα και μετά από την αναγκαστική απελευθέρωση όλων τους). Σε κάθε νέο δεσμευμένο κομμάτι αποθηκεύεται ο αριθμός του στον πίνακα δείκτη. Στη συνέχεια, δεσμεύστε 4 κομμάτια (+ το αρχικά δεσμευμένο), το τελευταίο θα έχει μέσα του το 4, απελευθερώστε τα και αναγκάστε την επαναδέσμευση του πρώτου, το οποίο θα χρησιμοποιήσει το τελευταίο κομμάτι που απελευθερώθηκε, το οποίο έχει μέσα του το 4.
