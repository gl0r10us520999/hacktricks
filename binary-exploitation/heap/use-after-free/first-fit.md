# Prva Fit

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJEM**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Prva Fit**

Kada oslobađate memoriju u programu koristeći glibc, različite "kante" se koriste za upravljanje delovima memorije. Evo pojednostavljena objašnjenja dva uobičajena scenarija: nesortirane kante i brze kante.

### Nesortirane Kante

Kada oslobodite deo memorije koji nije brzi deo, on ide u nesortiranu kantu. Ova kanta deluje kao lista gde se novi oslobođeni delovi dodaju na početak („glavu“). Kada zatražite novi deo memorije, alokator gleda u nesortiranu kantu sa zadnje strane („rep“) kako bi pronašao deo dovoljno velik. Ako je deo iz nesortirane kante veći od onoga što vam je potrebno, deo se deli, sa prednjim delom koji se vraća i preostalim delom koji ostaje u kanti.

Primer:

* Alokujete 300 bajtova (`a`), zatim 250 bajtova (`b`), oslobodite `a` i zatim ponovo zatražite 250 bajtova (`c`).
* Kada oslobodite `a`, ide u nesortiranu kantu.
* Ako zatim ponovo zatražite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraćajući deo koji odgovara vašem zahtevu i zadržavajući ostatak u kanti.
* `c` će pokazivati na prethodni `a` i biti popunjen sa `a`-ima.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male memorijske blokove. Za razliku od nesortiranih kanti, fastbins dodaju nove blokove na početak, stvarajući ponašanje poslednji unutra - prvi napolje (LIFO). Ako zatražite mali blok memorije, alokator će uzeti blok sa početka fastbina.

Primer:

* Alokujete četiri bloka od po 20 bajtova svaki (`a`, `b`, `c`, `d`).
* Kada ih oslobodite u bilo kom redosledu, oslobođeni blokovi se dodaju na početak fastbina.
* Ako zatim zatražite blok od 20 bajtova, alokator će vratiti najskorije oslobođeni blok sa početka fastbina.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Ostale reference i primeri

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Korišćenje nakon oslobađanja: Generisanje korisničkog objekta, oslobađanje istog, generisanje objekta koji dobija oslobođeni blok i omogućava pisanje u njega, **prepisivanje pozicije korisnikovog->šifra** iz prethodnog. Ponovno korišćenje korisnika za **zaobilaženje provere šifre**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program omogućava kreiranje beleški. Beleška će imati informacije o belešci u malloc(8) (sa pokazivačem na funkciju koja može biti pozvana) i pokazivač na drugi malloc(\<size>) sa sadržajem beleške.
* Napad bi bio da se kreiraju 2 beleške (beleška0 i beleška1) sa većim sadržajem malloc-a od veličine informacija o belešci, a zatim ih oslobode kako bi bile smeštene u brzi bin (ili tcache).
* Zatim, kreirajte još jednu belešku (beleška2) sa veličinom sadržaja 8. Sadržaj će biti u belešci1 jer će se blok ponovo koristiti, gde bismo mogli izmeniti pokazivač funkcije da pokazuje na funkciju za pobedu, a zatim koristiti Nakon-Oslobađanja belešku1 da pozove novi pokazivač funkcije.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Moguće je alocirati nešto memorije, upisati željenu vrednost, osloboditi je, ponovo alocirati i pošto su prethodni podaci i dalje tu, biće tretirani prema novom očekivanom strukturi u bloku što omogućava postavljanje vrednosti ili dobijanje zastave.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* U ovom slučaju je potrebno upisati 4 unutar specifičnog bloka koji je prvi alociran (čak i nakon prinudnog oslobađanja svih njih). Na svakom novom alociranom bloku čuva se njegov broj u indeksu niza. Zatim, alocirajte 4 bloka (+ početno alociran), poslednji će imati unutar sebe 4, oslobodite ih i prinudno ponovo alocirajte prvi, koji će koristiti poslednji oslobođeni blok koji je onaj sa 4 unutar sebe.
