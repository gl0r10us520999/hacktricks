# Heap Taşması

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bir heap taşması, heap'te bir [**yığın taşması**](../stack-overflow/) gibi. Temelde, heap'te bazı verileri depolamak için bir alan ayrılmış ve **depolanan veriler ayrılan alandan daha büyük olmuş.**

Yığın taşmalarında bazı kayıtların, örneğin yönlendirme işaretçisi veya yığın çerçevesinin yığından geri yükleneceğini ve bunun istismar edilebileceğini biliyoruz. Heap taşmalarında, taşınabilecek bir heap parçasında varsayılan olarak **duyarlı bilgi depolanmaz.** Bununla birlikte, hassas bilgi veya işaretçiler olabilir, bu nedenle bu zafiyetin **kritikliği**, bu zafiyetin **hangi verilerin üzerine yazılabileceğine** ve bir saldırganın bunu nasıl istismar edebileceğine bağlıdır.

{% hint style="success" %}
Taşma ofsetlerini bulmak için [**yığın taşmalarında**](../stack-overflow/#finding-stack-overflows-offsets) olduğu gibi aynı desenleri kullanabilirsiniz.
{% endhint %}

### Yığın Taşmaları vs. Heap Taşmaları

Yığın taşmalarında, zafiyet tetiklendiğinde yığında bulunacak düzen ve veriler oldukça güvenilirdir. Bu, yığının lineer olduğu, belleğin çarpışma noktalarında her zaman artan, programın belirli yerlerinde yığın belleğinin genellikle benzer türde verileri depoladığı ve her işlev tarafından kullanılan yığın kısmının sonunda bazı işaretçilerle belirli bir yapıya sahip olduğu için geçerlidir.

Ancak, bir heap taşması durumunda, kullanılan belleğin lineer olmadığı, **ayrılmış bellek pozisyonlarında genellikle ayrılmış parçaların** (birbirine bitişik olmayan) olduğu, boyuta göre ayrımlar yapan **kutular ve bölgeler** nedeniyle ve **önceki serbest bırakılan belleğin** yeni parçalar ayrılmadan önce kullanılması nedeniyle olduğu unutulmamalıdır. Bir heap taşması bulunduğunda, taşınabilecek nesnenin, taşan nesneye çarpışacak nesnenin **güvenilir bir şekilde bulunması gerekmektedir**.

Bunun için kullanılan tekniklerden biri **Heap Grooming**dir ve örneğin [**bu yazıda**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) kullanılmaktadır. Yazıda, iOS çekirdeğinde bir bölgenin bellekteki bellek parçalarını depolamak için hafızasının tükendiğinde, bir çekirdek sayfası ile genişletildiği ve bu sayfanın beklenen boyutlardaki parçalara bölündüğü ve bu parçaların sırayla kullanılacağı açıklanmaktadır (iOS sürüm 9.2'ye kadar, ardından bu parçaların bu saldırıların zorlaştırılması için rastgele bir şekilde kullanıldığı).

Bu nedenle, bir heap taşması gerçekleştiğinde, taşan nesnenin çarpışacak bir kurban sırayla zorlanması için birkaç **`kalloc`'un** birkaç iş parçası tarafından zorlanması gerekmektedir ve tüm boş parçaların doldurulduğundan ve yeni bir sayfa oluşturulduğundan emin olunması gerekmektedir.

Belirli bir boyuttaki nesnelerle bu doldurmayı zorlamak için, **iOS mach port ile ilişkilendirilmiş dış hattan tahsis** ideal bir adaydır. Mesajın boyutunu şekillendirerek, `kalloc` tahsisinin boyutunu tam olarak belirlemek mümkündür ve karşılık gelen mach portu yok edildiğinde, karşılık gelen tahsis hemen `kfree`'ye geri bırakılacaktır.

Ardından, bazı bu yer tutucular **serbest bırakılabilir**. **`kalloc.4096` serbest listesi, öğeleri son giren-ilk çıkan düzeninde serbest bırakır**, bu da temelde bazı yer tutucuların serbest bırakıldığı ve saldırının taşma nesnesini almaya çalışırken birkaç kurban nesne almaya çalışırken, bu nesnenin bir kurban nesne tarafından takip edileceği olasılığının yüksek olduğu anlamına gelir.

### Örnek libc

[**Bu sayfada**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html), bir kullanılmış parçayı **birleştirmek** için bir sonraki parçanın kullanımdaki önceki bitini ve önceki boyutun konumunu değiştirerek nasıl temel bir Heap taşması emülasyonu bulunabileceğini gösteren bir örnek bulunabilir ve bu sayede farklı bir işaretçide kullanılan verileri **tekrar tahsis edebilir** ve üzerine yazabilirsiniz.

[**Protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) örneğinde, bir **heap taşmasının** bayrağı **almak için kazan fonksiyonunu** çağırmak için bir **heap taşmasının** nasıl istismar edilebileceğini gösteren temel bir CTF örneği bulunmaktadır.

[**Protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) örneğinde, bir tampon taşmasının istismar edilerek, **kullanıcıdan gelen keyfi verilerin yazılacağı bir adrese yakın bir parçada bir adresin üzerine yazılması** nasıl mümkün olduğunu görebilirsiniz.

### Örnek ARM64

[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) sayfasında, bir komutun taşan parçadan bir sonraki parçada saklandığı bir heap taşması örneği bulabilirsiniz. Bu nedenle, basit bir saldırı ile komutu değiştirerek yürütülecek komutu değiştirmek mümkündür.
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na (https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
