# Heap Oorloop

<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basiese Inligting

'n Heap oorloop is soos 'n [**stapel oorloop**](../stack-overflow/) maar in die heap. Dit beteken basies dat 'n sekere spasie in die heap gereserveer was om data te stoor en dat die **gestoorde data groter was as die gereserveerde spasie.**

In stapeloorlope weet ons dat sekere registers soos die instruksie-aanwyser of die stapelraam van die stapel herstel gaan word en dit moontlik is om dit te misbruik. In die geval van heap oorlope, is daar **nie enige sensitiewe inligting wat standaard in die heapstuk gestoor word nie** wat oorloop kan word. Dit kan egter sensitiewe inligting of aanwysers wees, dus die **kritikaliteit** van hierdie kwesbaarheid **hang af** van **watter data oorskryf kan word** en hoe 'n aanvaller dit kan misbruik.

{% hint style="success" %}
Om oorloopafsette te vind, kan jy dieselfde patrone gebruik as in [**stapeloorlope**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stapeloorlope vs Heapoorlope

In stapeloorlope is die rangskikking en data wat teenwoordig gaan wees in die stapel op die oomblik wanneer die kwesbaarheid geaktiveer kan word, redelik betroubaar. Dit is omdat die stapel line√™r is, altyd toeneem in botsende geheue, in **spesifieke plekke van die programloop word die stapelgeheue gewoonlik soortgelyke data gestoor** en dit het 'n spesifieke struktuur met 'n paar aanwysers aan die einde van die stapelgedeelte wat deur elke funksie gebruik word.

In die geval van 'n heap oorloop, omdat die gebruikte geheue nie line√™r is nie maar **toegewysde stukke is gewoonlik in afsonderlike posisies van geheue** (nie een langs die ander nie) as gevolg van **bins en sones** wat toewysings volgens grootte skei en omdat **vorige vrygemaakte geheue gebruik word** voordat nuwe stukke toegewys word. Dit is **ingewikkeld om die voorwerp te ken wat met die een wat vatbaar is vir 'n heap oorloop gaan bots**. Dus, wanneer 'n heap oorloop gevind word, moet 'n **betroubare manier gevind word om te verseker dat die gewenste voorwerp volgende in die geheue is** van die een wat oorloop kan word.

Een van die tegnieke wat hiervoor gebruik word, is **Heap Grooming** wat byvoorbeeld gebruik word [**in hierdie pos**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). In die pos word verduidelik hoe wanneer in die iOS-kernel 'n sone uit geheue raak om stukke geheue te stoor, dit uitgebrei word met 'n kernbladsy, en hierdie bladsy word verdeel in stukke van die verwagte groottes wat in orde gebruik sou word (tot iOS weergawe 9.2, dan word hierdie stukke op 'n willekeurige manier gebruik om die uitbuiting van hierdie aanvalle te bemoeilik).

Daarom, in die vorige pos waar 'n heap oorloop plaasvind, moet verskeie **`kallocs` afgedwing word deur verskeie drade om te verseker dat al die vry stukke gevul word en dat 'n nuwe bladsy geskep word**.

Om hierdie vulling met voorwerpe van 'n spesifieke grootte af te dwing, is die **uitlynstoewysing wat met 'n iOS mach-poort geassosieer word** 'n ideale kandidaat. Deur die grootte van die boodskap te skep, is dit moontlik om presies die grootte van `kalloc` toewysing te spesifiseer en wanneer die ooreenstemmende mach-poort vernietig word, sal die ooreenstemmende toewysing dadelik terug na `kfree` vrygestel word.

Dan kan sommige van hierdie plekhouers **vrygestel** word. Die **`kalloc.4096` vrylys vry elemente in 'n laaste-in-eerste-uit-orde**, wat basies beteken dat as sommige plekhouers vrygestel word en die aanval probeer om verskeie slagoffers voorwerpe toe te ken terwyl die voorwerp wat vatbaar is vir oorloop toegewys word, is dit waarskynlik dat hierdie voorwerp deur 'n slagoffer voorwerp gevolg sal word.

### Voorbeeld libc

[**Op hierdie bladsy**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) is dit moontlik om 'n basiese Heap oorloop-emulasie te vind wat wys hoe deur die oorskrywing van die vorig in gebruik bit van die volgende stuk en die posisie van die vorige grootte dit moontlik is om **'n gebruikte stuk te konsolideer** (deur dit te laat dink dit is ongebruik) en dit dan weer toe te ken deur data wat in 'n ander aanwyser gebruik word, ook te oorskryf.

'n Ander voorbeeld van [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) wys 'n baie basiese voorbeeld van 'n CTF waar 'n **heap oorloop** misbruik kan word om die wennerfunksie te roep om **die vlag te kry**.

In die [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) voorbeeld is dit moontlik om te sien hoe deur 'n buffer oorloop te misbruik, dit moontlik is om **in 'n nabygele√´ stuk 'n adres oor te skryf** waar **willekeurige data van die gebruiker** geskryf gaan word.

### Voorbeeld ARM64

Op die bladsy [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) kan jy 'n voorbeeld van 'n heap oorloop vind waar 'n bevel wat uitgevoer gaan word in die volgende stuk vanaf die oorvloeiende stuk gestoor word. Dus, dit is moontlik om die uitgevoerde bevel te wysig deur dit te oorskryf met 'n maklike uitbuit soos:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<besonderhede>

<opsomming><sterk>Leer AWS-hacking vanaf nul tot held met</sterk> <a href="https://training.hacktricks.xyz/courses/arte"><sterk>htARTE (HackTricks AWS Red Team Expert)</sterk></a><sterk>!</sterk></opsomming>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</besonderhede>
