# Prekoračenje hipa

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodiču PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Prekoračenje hipa je poput [**prekoračenja steka**](../stack-overflow/), ali u hipu. U osnovi to znači da je neki prostor rezervisan u hipu za čuvanje podataka i **čuvani podaci su bili veći od rezervisanog prostora.**

Kod prekoračenja steka znamo da će neki registri poput pokazivača instrukcija ili okvira steka biti obnovljeni sa steka i moguće je zloupotrebiti to. U slučaju prekoračenja hipa, **nema podataka osetljivih podataka koji se podrazumevano čuvaju u hipu koji može biti prekoračen.** Međutim, mogu biti osetljive informacije ili pokazivači, pa **kritičnost** ove ranjivosti **zavisi** o **kojim podacima mogu biti prepisani** i kako napadač može to zloupotrebiti.

{% hint style="success" %}
Da biste pronašli ofsete prekoračenja, možete koristiti iste obrasce kao kod [**prekoračenja steka**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Prekoračenje steka vs prekoračenje hipa

Kod prekoračenja steka, organizacija i podaci koji će biti prisutni na steku u trenutku kada se može pokrenuti ranjivost su prilično pouzdani. To je zato što je stek linearan, uvek se povećava u koliziji memorije, na **specifičnim mestima izvršavanja programa stek memorija obično čuva slične vrste podataka** i ima određenu strukturu sa nekim pokazivačima na kraju dela steka koji koristi svaka funkcija.

Međutim, u slučaju prekoračenja hipa, jer se korišćena memorija ne povećava linearno već su **dodeljeni delovi obično na odvojenim pozicijama memorije** (ne jedan pored drugog) zbog **binova i zona** koji razdvajaju alokacije po veličini i zbog toga što se **prethodno oslobođena memorija koristi** pre nego što se dodele novi delovi. **Komplikovano je znati koji objekat će se sudariti sa onim koji je ranjiv** na prekoračenje hipa. Dakle, kada se pronađe prekoračenje hipa, potrebno je pronaći **pouzdan način da se željeni objekat nađe odmah u memoriji** pored onog koji može biti prekoračen.

Jedna od tehnika koja se koristi za to je **Heap Grooming** koja se koristi na primer [**u ovom postu**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). U postu je objašnjeno kako kada u iOS kernelu jedna zona ostane bez memorije za čuvanje delova memorije, proširuje se za jednu stranicu kernela, a ova stranica se deli na delove očekivanih veličina koji će se koristiti redom (do verzije iOS 9.2, zatim se ovi delovi koriste na nasumičan način kako bi se otežala eksploatacija ovih napada).

Stoga, u prethodnom postu gde se dešava prekoračenje hipa, kako bi se naterao prekoračeni objekat da se sudari sa žrtvom, nekoliko **`kallocs` se forsira pomoću nekoliko niti kako bi se osiguralo da su svi slobodni delovi popunjeni i da je kreirana nova stranica**.

Da bi se prisililo popunjavanje ovim objektima određene veličine, **vanlinijska alokacija povezana sa iOS mach portom** je idealan kandidat. Oblikovanjem veličine poruke, moguće je tačno odrediti veličinu alokacije `kalloc` i kada odgovarajući mach port bude uništen, odgovarajuća alokacija će odmah biti oslobođena natrag `kfree`.

Zatim, neki od ovih čuvara mogu biti **oslobođeni**. Lista oslobođenih **`kalloc.4096`** elemenata oslobađa elemente po principu poslednji unutra, prvi napolje, što u osnovi znači da ako su neki čuvari oslobođeni i eksploatacija pokuša da alocira nekoliko žrtvenih objekata dok pokušava da alocira objekat ranjiv na prekoračenje, verovatno je da će ovaj objekat biti praćen žrtvenim objektom.

### Primer libc

[**Na ovoj stranici**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) moguće je pronaći osnovnu emulaciju prekoračenja hipa koja pokazuje kako prekoračenjem prethodnog u upotrebi bita sledećeg dela i pozicije prethodne veličine moguće je **konsolidovati korišćeni deo** (praveći da misli da nije u upotrebi) i **zatim ga ponovo alocirati** kako bi se mogli prepisati podaci koji se koriste u drugom pokazivaču.

Još jedan primer sa [**protostar hip 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje vrlo osnovan primer CTF-a gde se **prekoračenje hipa** može zloupotrebiti kako bi se pozvala funkcija pobednika i **dobila zastava**.

U primeru [**protostar hip 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) moguće je videti kako zloupotrebom prekoračenja bafera moguće je **prepisati u blizak deo adrese** gde će **proizvoljni podaci od korisnika** biti upisani.

### Primer ARM64

Na stranici [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) možete pronaći primer prekoračenja hipa gde je komanda koja će biti izvršena smeštena u sledećem delu od prekoračenog dela. Dakle, moguće je izmeniti izvršenu komandu prepisivanjem je jednostavnim eksploatacijama kao što su:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
