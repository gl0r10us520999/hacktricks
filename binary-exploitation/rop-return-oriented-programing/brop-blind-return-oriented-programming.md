# BROP - Blind Return Oriented Programming

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}

## Podstawowe informacje

Celem tego ataku jest **wykorzystanie ROP za pomocą przepełnienia bufora bez żadnych informacji o podatnym binarnym**.\
Atak oparty jest na następującym scenariuszu:

* Wrażliwość na stosie i wiedza o tym, jak ją wywołać.
* Aplikacja serwerowa, która restartuje się po awarii.

## Atak

### **1. Znajdź wrażliwy offset** wysyłając jeden dodatkowy znak, aż wykryta zostanie awaria serwera

### **2. Bruteforce canary** aby go wyciekł

### **3. Bruteforce przechowywanych adresów RBP i RIP** na stosie, aby je wyciekł

Więcej informacji na temat tych procesów można znaleźć [tutaj (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) oraz [tutaj (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Znajdź gadget stop**

Ten gadget zasadniczo pozwala potwierdzić, że coś interesującego zostało wykonane przez gadget ROP, ponieważ wykonanie nie spowodowało awarii. Zwykle ten gadget będzie czymś, co **zatrzymuje wykonanie** i jest umieszczone na końcu łańcucha ROP, gdy szuka się gadgetów ROP, aby potwierdzić, że konkretny gadget ROP został wykonany.

### **5. Znajdź gadget BROP**

Ta technika wykorzystuje gadget [**ret2csu**](ret2csu.md). I to dlatego, że jeśli uzyskasz dostęp do tego gadgetu w środku jakichś instrukcji, otrzymasz gadgety do kontrolowania **`rsi`** i **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

To byłyby gadgety:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Zauważ, jak z tymi gadgetami można **kontrolować 2 argumenty** funkcji do wywołania.

Zauważ również, że gadget ret2csu ma **bardzo unikalny podpis**, ponieważ będzie wyciągał 6 rejestrów ze stosu. Więc wysyłając łańcuch taki jak:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Jeśli **STOP zostanie wykonany**, oznacza to zasadniczo, że **adres, który wyciąga 6 rejestrów** ze stosu został użyty. Lub że użyty adres był również adresem STOP.

Aby **usunąć tę ostatnią opcję**, wykonuje się nowy łańcuch taki jak poniżej i nie powinien on wykonać gadgetu STOP, aby potwierdzić, że poprzedni rzeczywiście wyciągnął 6 rejestrów:

`'A' * offset + canary + rbp + ADDR`

Znając adres gadgetu ret2csu, można **wnioskować adres gadgetów do kontrolowania `rsi` i `rdi`**.

### 6. Znajdź PLT

Tabela PLT może być przeszukiwana od 0x400000 lub z **wyciekłego adresu RIP** ze stosu (jeśli **PIE** jest używane). **Wpisy** tabeli są **oddzielone o 16B** (0x10B), a gdy wywoływana jest jedna funkcja, serwer nie zawiesza się, nawet jeśli argumenty nie są poprawne. Ponadto, sprawdzanie adresu wpisu w **PLT + 6B również nie powoduje awarii**, ponieważ jest to pierwszy kod wykonywany.

Dlatego można znaleźć tabelę PLT, sprawdzając następujące zachowania:

* `'A' * offset + canary + rbp + ADDR + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> brak awarii

### 7. Znajdowanie strcmp

Funkcja **`strcmp`** ustawia rejestr **`rdx`** na długość porównywanego ciągu. Zauważ, że **`rdx`** jest **trzecim argumentem** i musimy, aby był **większy niż 0**, aby później użyć `write`, aby wyciekł program.

Można znaleźć lokalizację **`strcmp`** w PLT na podstawie jej zachowania, wykorzystując fakt, że teraz możemy kontrolować 2 pierwsze argumenty funkcji:

* strcmp(\<non read addr>, \<non read addr>) -> awaria
* strcmp(\<non read addr>, \<read addr>) -> awaria
* strcmp(\<read addr>, \<non read addr>) -> awaria
* strcmp(\<read addr>, \<read addr>) -> brak awarii

Można to sprawdzić, wywołując każdy wpis w tabeli PLT lub używając **wolnej ścieżki PLT**, która zasadniczo polega na **wywołaniu wpisu w tabeli PLT + 0xb** (co wywołuje **`dlresolve`**) a następnie na stosie przez **numer wpisu, który chce się zbadać** (zaczynając od zera), aby przeskanować wszystkie wpisy PLT od pierwszego:

* strcmp(\<non read addr>, \<read addr>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Spowoduje awarię
* strcmp(\<read addr>, \<non read addr>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<read addr>, \<read addr>) -> brak awarii
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Pamiętaj, że:

* BROP + 0x7 wskazuje na **`pop RSI; pop R15; ret;`**
* BROP + 0x9 wskazuje na **`pop RDI; ret;`**
* PLT + 0xb wskazuje na wywołanie **dl\_resolve**.

Mając znaleziony `strcmp`, można ustawić **`rdx`** na wartość większą niż 0.

{% hint style="success" %}
Zauważ, że zazwyczaj `rdx` będzie już miało wartość większą niż 0, więc ten krok może nie być konieczny.
{% endhint %}

### 8. Znajdowanie Write lub ekwiwalent

Na koniec potrzebny jest gadget, który eksfiltruje dane, aby wyeksfiltrować binarny. A w tym momencie można **kontrolować 2 argumenty i ustawić `rdx` większe niż 0.**

Istnieją 3 powszechne funkcje, które można wykorzystać do tego:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Jednak oryginalny dokument wspomina tylko o funkcji **`write`**, więc porozmawiajmy o niej:

Obecnym problemem jest to, że nie wiemy **gdzie funkcja write znajduje się w PLT** i nie znamy **numeru fd, aby wysłać dane do naszego gniazda**.

Jednak wiemy **gdzie znajduje się tabela PLT** i można znaleźć write na podstawie jej **zachowania**. Możemy stworzyć **wiele połączeń** z serwerem i użyć **wysokiego FD**, mając nadzieję, że pasuje do niektórych z naszych połączeń.

Podpisy zachowań do znalezienia tych funkcji:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Jeśli dane są drukowane, to znaczy, że znaleziono puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Jeśli dane są drukowane, to znaczy, że znaleziono dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Jeśli dane są drukowane, to znaczy, że znaleziono write

## Automatyczna eksploatacja

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Odniesienia

* Oryginalny dokument: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
