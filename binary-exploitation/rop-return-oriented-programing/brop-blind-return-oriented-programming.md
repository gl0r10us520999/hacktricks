# BROP - Blind Return Oriented Programming

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informations de base

Le but de cette attaque est de pouvoir **abuser d'un ROP via un d√©bordement de tampon sans aucune information sur le binaire vuln√©rable**.\
Cette attaque est bas√©e sur le sc√©nario suivant :

* Une vuln√©rabilit√© de pile et la connaissance de la fa√ßon de la d√©clencher.
* Une application serveur qui red√©marre apr√®s un crash.

## Attaque

### **1. Trouver l'offset vuln√©rable** en envoyant un caract√®re de plus jusqu'√† ce qu'un dysfonctionnement du serveur soit d√©tect√©

### **2. Brute-force canary** pour le divulguer

### **3. Brute-force des adresses RBP et RIP** stock√©es dans la pile pour les divulguer

Vous pouvez trouver plus d'informations sur ces processus [ici (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) et [ici (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Trouver le gadget d'arr√™t**

Ce gadget permet essentiellement de confirmer que quelque chose d'int√©ressant a √©t√© ex√©cut√© par le gadget ROP car l'ex√©cution n'a pas plant√©. En g√©n√©ral, ce gadget va √™tre quelque chose qui **arr√™te l'ex√©cution** et il est positionn√© √† la fin de la cha√Æne ROP lors de la recherche de gadgets ROP pour confirmer qu'un gadget ROP sp√©cifique a √©t√© ex√©cut√©.

### **5. Trouver le gadget BROP**

Cette technique utilise le gadget [**ret2csu**](ret2csu.md). Et cela est d√ª au fait que si vous acc√©dez √† ce gadget au milieu de certaines instructions, vous obtenez des gadgets pour contr√¥ler **`rsi`** et **`rdi`** :

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Ce seraient les gadgets :

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Remarquez comment avec ces gadgets, il est possible de **contr√¥ler 2 arguments** d'une fonction √† appeler.

De plus, notez que le gadget ret2csu a une **signature tr√®s unique** car il va poper 6 registres de la pile. Donc, en envoyant une cha√Æne comme :

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Si le **STOP est ex√©cut√©**, cela signifie essentiellement qu'une **adresse qui pop 6 registres** de la pile a √©t√© utilis√©e. Ou que l'adresse utilis√©e √©tait √©galement une adresse STOP.

Pour **√©liminer cette derni√®re option**, une nouvelle cha√Æne comme suit est ex√©cut√©e et elle ne doit pas ex√©cuter le gadget STOP pour confirmer que le pr√©c√©dent a bien pop√© 6 registres :

`'A' * offset + canary + rbp + ADDR`

Sachant l'adresse du gadget ret2csu, il est possible de **d√©duire l'adresse des gadgets pour contr√¥ler `rsi` et `rdi`**.

### 6. Trouver le PLT

La table PLT peut √™tre recherch√©e √† partir de 0x400000 ou de l'**adresse RIP divulgu√©e** de la pile (si **PIE** est utilis√©). Les **entr√©es** de la table sont **s√©par√©es par 16B** (0x10B), et lorsqu'une fonction est appel√©e, le serveur ne plante pas m√™me si les arguments ne sont pas corrects. De plus, v√©rifier l'adresse d'une entr√©e dans le **PLT + 6B ne plante √©galement pas** car c'est le premier code ex√©cut√©.

Par cons√©quent, il est possible de trouver la table PLT en v√©rifiant les comportements suivants :

* `'A' * offset + canary + rbp + ADDR + STOP` -> pas de crash
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> pas de crash
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> pas de crash

### 7. Trouver strcmp

La fonction **`strcmp`** d√©finit le registre **`rdx`** √† la longueur de la cha√Æne compar√©e. Notez que **`rdx`** est le **troisi√®me argument** et nous avons besoin qu'il soit **plus grand que 0** afin de pouvoir utiliser `write` pour divulguer le programme par la suite.

Il est possible de trouver l'emplacement de **`strcmp`** dans le PLT en fonction de son comportement en utilisant le fait que nous pouvons maintenant contr√¥ler les 2 premiers arguments des fonctions :

* strcmp(\<adresse non lue>, \<adresse non lue>) -> crash
* strcmp(\<adresse non lue>, \<adresse lue>) -> crash
* strcmp(\<adresse lue>, \<adresse non lue>) -> crash
* strcmp(\<adresse lue>, \<adresse lue>) -> pas de crash

Il est possible de v√©rifier cela en appelant chaque entr√©e de la table PLT ou en utilisant le **chemin lent du PLT** qui consiste essentiellement √† **appeler une entr√©e dans la table PLT + 0xb** (ce qui appelle **`dlresolve`**) suivi dans la pile par le **num√©ro d'entr√©e que l'on souhaite sonder** (commen√ßant √† z√©ro) pour scanner toutes les entr√©es PLT √† partir de la premi√®re :

* strcmp(\<adresse non lue>, \<adresse lue>) -> crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Va planter
* strcmp(\<adresse lue>, \<adresse non lue>) -> crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<adresse lue>, \<adresse lue>) -> pas de crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Rappelez-vous que :

* BROP + 0x7 pointe vers **`pop RSI; pop R15; ret;`**
* BROP + 0x9 pointe vers **`pop RDI; ret;`**
* PLT + 0xb pointe vers un appel √† **dl\_resolve**.

Ayant trouv√© `strcmp`, il est possible de d√©finir **`rdx`** √† une valeur sup√©rieure √† 0.

{% hint style="success" %}
Notez qu'en g√©n√©ral, `rdx` contiendra d√©j√† une valeur sup√©rieure √† 0, donc cette √©tape pourrait ne pas √™tre n√©cessaire.
{% endhint %}

### 8. Trouver Write ou √©quivalent

Enfin, il faut un gadget qui exfiltre des donn√©es afin d'exfiltrer le binaire. Et √† ce moment, il est possible de **contr√¥ler 2 arguments et de d√©finir `rdx` sup√©rieur √† 0.**

Il existe 3 fonctions courantes qui pourraient √™tre abus√©es pour cela :

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Cependant, l'article original ne mentionne que la fonction **`write`**, alors parlons-en :

Le probl√®me actuel est que nous ne savons pas **o√π se trouve la fonction write dans le PLT** et nous ne savons pas **un num√©ro de fd pour envoyer les donn√©es √† notre socket**.

Cependant, nous savons **o√π se trouve la table PLT** et il est possible de trouver write en fonction de son **comportement**. Et nous pouvons cr√©er **plusieurs connexions** avec le serveur et utiliser un **FD √©lev√©** en esp√©rant qu'il corresponde √† certaines de nos connexions.

Signatures de comportement pour trouver ces fonctions :

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> S'il y a des donn√©es imprim√©es, alors puts a √©t√© trouv√©
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> S'il y a des donn√©es imprim√©es, alors dprintf a √©t√© trouv√©
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> S'il y a des donn√©es imprim√©es, alors write a √©t√© trouv√©

## Exploitation automatique

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## R√©f√©rences

* Article original : [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
