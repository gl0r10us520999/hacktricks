# BROP - Blind Return Oriented Programming

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ sztuczkami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}

## Podstawowe informacje

Celem tego ataku jest **wykorzystanie ROP za pomocÄ… przepeÅ‚nienia bufora bez Å¼adnych informacji o podatnym binarnym**.\
Atak oparty jest na nastÄ™pujÄ…cym scenariuszu:

* WraÅ¼liwoÅ›Ä‡ na stosie i wiedza o tym, jak jÄ… wywoÅ‚aÄ‡.
* Aplikacja serwerowa, ktÃ³ra restartuje siÄ™ po awarii.

## Atak

### **1. ZnajdÅº wraÅ¼liwy offset** wysyÅ‚ajÄ…c jeden dodatkowy znak, aÅ¼ wykryta zostanie awaria serwera

### **2. Bruteforce canary** aby go wyciekÅ‚

### **3. Bruteforce przechowywanych adresÃ³w RBP i RIP** na stosie, aby je wyciekÅ‚

WiÄ™cej informacji na temat tych procesÃ³w moÅ¼na znaleÅºÄ‡ [tutaj (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) oraz [tutaj (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. ZnajdÅº gadget stop**

Ten gadget zasadniczo pozwala potwierdziÄ‡, Å¼e coÅ› interesujÄ…cego zostaÅ‚o wykonane przez gadget ROP, poniewaÅ¼ wykonanie nie spowodowaÅ‚o awarii. Zwykle ten gadget bÄ™dzie czymÅ›, co **zatrzymuje wykonanie** i jest umieszczone na koÅ„cu Å‚aÅ„cucha ROP, gdy szuka siÄ™ gadgetÃ³w ROP, aby potwierdziÄ‡, Å¼e konkretny gadget ROP zostaÅ‚ wykonany.

### **5. ZnajdÅº gadget BROP**

Ta technika wykorzystuje gadget [**ret2csu**](ret2csu.md). I to dlatego, Å¼e jeÅ›li uzyskasz dostÄ™p do tego gadgetu w Å›rodku jakichÅ› instrukcji, otrzymasz gadgety do kontrolowania **`rsi`** i **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

To byÅ‚yby gadgety:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

ZauwaÅ¼, jak z tymi gadgetami moÅ¼na **kontrolowaÄ‡ 2 argumenty** funkcji do wywoÅ‚ania.

ZauwaÅ¼ rÃ³wnieÅ¼, Å¼e gadget ret2csu ma **bardzo unikalny podpis**, poniewaÅ¼ bÄ™dzie wyciÄ…gaÅ‚ 6 rejestrÃ³w ze stosu. WiÄ™c wysyÅ‚ajÄ…c Å‚aÅ„cuch taki jak:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

JeÅ›li **STOP zostanie wykonany**, oznacza to zasadniczo, Å¼e **adres, ktÃ³ry wyciÄ…ga 6 rejestrÃ³w** ze stosu zostaÅ‚ uÅ¼yty. Lub Å¼e uÅ¼yty adres byÅ‚ rÃ³wnieÅ¼ adresem STOP.

Aby **usunÄ…Ä‡ tÄ™ ostatniÄ… opcjÄ™**, wykonuje siÄ™ nowy Å‚aÅ„cuch taki jak poniÅ¼ej i nie powinien on wykonaÄ‡ gadgetu STOP, aby potwierdziÄ‡, Å¼e poprzedni rzeczywiÅ›cie wyciÄ…gnÄ…Å‚ 6 rejestrÃ³w:

`'A' * offset + canary + rbp + ADDR`

ZnajÄ…c adres gadgetu ret2csu, moÅ¼na **wnioskowaÄ‡ adres gadgetÃ³w do kontrolowania `rsi` i `rdi`**.

### 6. ZnajdÅº PLT

Tabela PLT moÅ¼e byÄ‡ przeszukiwana od 0x400000 lub z **wyciekÅ‚ego adresu RIP** ze stosu (jeÅ›li **PIE** jest uÅ¼ywane). **Wpisy** tabeli sÄ… **oddzielone o 16B** (0x10B), a gdy wywoÅ‚ywana jest jedna funkcja, serwer nie zawiesza siÄ™, nawet jeÅ›li argumenty nie sÄ… poprawne. Ponadto, sprawdzanie adresu wpisu w **PLT + 6B rÃ³wnieÅ¼ nie powoduje awarii**, poniewaÅ¼ jest to pierwszy kod wykonywany.

Dlatego moÅ¼na znaleÅºÄ‡ tabelÄ™ PLT, sprawdzajÄ…c nastÄ™pujÄ…ce zachowania:

* `'A' * offset + canary + rbp + ADDR + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> brak awarii

### 7. Znajdowanie strcmp

Funkcja **`strcmp`** ustawia rejestr **`rdx`** na dÅ‚ugoÅ›Ä‡ porÃ³wnywanego ciÄ…gu. ZauwaÅ¼, Å¼e **`rdx`** jest **trzecim argumentem** i musimy, aby byÅ‚ **wiÄ™kszy niÅ¼ 0**, aby pÃ³Åºniej uÅ¼yÄ‡ `write`, aby wyciekÅ‚ program.

MoÅ¼na znaleÅºÄ‡ lokalizacjÄ™ **`strcmp`** w PLT na podstawie jej zachowania, wykorzystujÄ…c fakt, Å¼e teraz moÅ¼emy kontrolowaÄ‡ 2 pierwsze argumenty funkcji:

* strcmp(\<non read addr>, \<non read addr>) -> awaria
* strcmp(\<non read addr>, \<read addr>) -> awaria
* strcmp(\<read addr>, \<non read addr>) -> awaria
* strcmp(\<read addr>, \<read addr>) -> brak awarii

MoÅ¼na to sprawdziÄ‡, wywoÅ‚ujÄ…c kaÅ¼dy wpis w tabeli PLT lub uÅ¼ywajÄ…c **wolnej Å›cieÅ¼ki PLT**, ktÃ³ra zasadniczo polega na **wywoÅ‚aniu wpisu w tabeli PLT + 0xb** (co wywoÅ‚uje **`dlresolve`**) a nastÄ™pnie na stosie przez **numer wpisu, ktÃ³ry chce siÄ™ zbadaÄ‡** (zaczynajÄ…c od zera), aby przeskanowaÄ‡ wszystkie wpisy PLT od pierwszego:

* strcmp(\<non read addr>, \<read addr>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Spowoduje awariÄ™
* strcmp(\<read addr>, \<non read addr>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<read addr>, \<read addr>) -> brak awarii
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

PamiÄ™taj, Å¼e:

* BROP + 0x7 wskazuje na **`pop RSI; pop R15; ret;`**
* BROP + 0x9 wskazuje na **`pop RDI; ret;`**
* PLT + 0xb wskazuje na wywoÅ‚anie **dl\_resolve**.

MajÄ…c znaleziony `strcmp`, moÅ¼na ustawiÄ‡ **`rdx`** na wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 0.

{% hint style="success" %}
ZauwaÅ¼, Å¼e zazwyczaj `rdx` bÄ™dzie juÅ¼ miaÅ‚o wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 0, wiÄ™c ten krok moÅ¼e nie byÄ‡ konieczny.
{% endhint %}

### 8. Znajdowanie Write lub ekwiwalent

Na koniec potrzebny jest gadget, ktÃ³ry eksfiltruje dane, aby wyeksfiltrowaÄ‡ binarny. A w tym momencie moÅ¼na **kontrolowaÄ‡ 2 argumenty i ustawiÄ‡ `rdx` wiÄ™ksze niÅ¼ 0.**

IstniejÄ… 3 powszechne funkcje, ktÃ³re moÅ¼na wykorzystaÄ‡ do tego:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Jednak oryginalny dokument wspomina tylko o funkcji **`write`**, wiÄ™c porozmawiajmy o niej:

Obecnym problemem jest to, Å¼e nie wiemy **gdzie funkcja write znajduje siÄ™ w PLT** i nie znamy **numeru fd, aby wysÅ‚aÄ‡ dane do naszego gniazda**.

Jednak wiemy **gdzie znajduje siÄ™ tabela PLT** i moÅ¼na znaleÅºÄ‡ write na podstawie jej **zachowania**. MoÅ¼emy stworzyÄ‡ **wiele poÅ‚Ä…czeÅ„** z serwerem i uÅ¼yÄ‡ **wysokiego FD**, majÄ…c nadziejÄ™, Å¼e pasuje do niektÃ³rych z naszych poÅ‚Ä…czeÅ„.

Podpisy zachowaÅ„ do znalezienia tych funkcji:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> JeÅ›li dane sÄ… drukowane, to znaczy, Å¼e znaleziono puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> JeÅ›li dane sÄ… drukowane, to znaczy, Å¼e znaleziono dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> JeÅ›li dane sÄ… drukowane, to znaczy, Å¼e znaleziono write

## Automatyczna eksploatacja

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Odniesienia

* Oryginalny dokument: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ sztuczkami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}
