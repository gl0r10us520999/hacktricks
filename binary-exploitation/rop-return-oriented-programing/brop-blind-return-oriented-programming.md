# BROP - Blind Return Oriented Programming

{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}

## 基本信息

此攻击的目标是能够**通过缓冲区溢出滥用 ROP，而无需任何关于易受攻击二进制文件的信息**。\
此攻击基于以下场景：

* 一个栈漏洞和触发它的知识。
* 一个在崩溃后重启的服务器应用程序。

## 攻击

### **1. 找到易受攻击的偏移** 发送一个字符，直到检测到服务器故障

### **2. 暴力破解 canary** 以泄露它

### **3. 暴力破解存储的 RBP 和 RIP** 地址以泄露它们

您可以在 [这里 (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) 和 [这里 (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md) 找到有关这些过程的更多信息。

### **4. 找到停止 gadget**

这个 gadget 基本上允许确认 ROP gadget 执行了某些有趣的内容，因为执行没有崩溃。通常，这个 gadget 将是**停止执行**的内容，并且在寻找 ROP gadget 时位于 ROP 链的末尾，以确认特定的 ROP gadget 被执行。

### **5. 找到 BROP gadget**

此技术使用 [**ret2csu**](ret2csu.md) gadget。这是因为如果您在某些指令中间访问此 gadget，您将获得控制**`rsi`**和**`rdi`**的 gadget：

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

这些将是 gadget：

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

注意，通过这些 gadget 可以**控制 2 个参数**的函数调用。

此外，请注意 ret2csu gadget 具有**非常独特的签名**，因为它将从栈中弹出 6 个寄存器。因此，发送一个链如：

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

如果**STOP 被执行**，这基本上意味着使用了一个**从栈中弹出 6 个寄存器的地址**。或者使用的地址也是一个 STOP 地址。

为了**消除这个最后的选项**，执行一个新的链，如下所示，并且它必须不执行 STOP gadget 以确认前一个确实弹出了 6 个寄存器：

`'A' * offset + canary + rbp + ADDR`

知道 ret2csu gadget 的地址，可以**推断出控制 `rsi` 和 `rdi` 的 gadget 的地址**。

### 6. 找到 PLT

PLT 表可以从 0x400000 或从栈中**泄露的 RIP 地址**进行搜索（如果**PIE**正在使用）。表的**条目**是**每 16B 分隔**（0x10B），当调用一个函数时，即使参数不正确，服务器也不会崩溃。此外，检查一个条目的地址在**PLT + 6B 也不会崩溃**，因为这是执行的第一段代码。

因此，可以通过检查以下行为找到 PLT 表：

* `'A' * offset + canary + rbp + ADDR + STOP` -> 不崩溃
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> 不崩溃
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> 不崩溃

### 7. 找到 strcmp

**`strcmp`** 函数将寄存器 **`rdx`** 设置为正在比较的字符串的长度。请注意，**`rdx`** 是**第三个参数**，我们需要它**大于 0**，以便稍后使用 `write` 来泄露程序。

可以根据其行为在 PLT 中找到 **`strcmp`** 的位置，利用我们现在可以控制函数的前两个参数的事实：

* strcmp(\<非读取地址>, \<非读取地址>) -> 崩溃
* strcmp(\<非读取地址>, \<读取地址>) -> 崩溃
* strcmp(\<读取地址>, \<非读取地址>) -> 崩溃
* strcmp(\<读取地址>, \<读取地址>) -> 不崩溃

可以通过调用 PLT 表的每个条目或使用**PLT 慢路径**来检查这一点，慢路径基本上是**调用 PLT 表中的一个条目 + 0xb**（这会调用**`dlresolve`**），然后在栈中跟随**希望探测的条目编号**（从零开始）以扫描所有 PLT 条目：

* strcmp(\<非读取地址>, \<读取地址>) -> 崩溃
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> 将崩溃
* strcmp(\<读取地址>, \<非读取地址>) -> 崩溃
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<读取地址>, \<读取地址>) -> 不崩溃
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

请记住：

* BROP + 0x7 指向 **`pop RSI; pop R15; ret;`**
* BROP + 0x9 指向 **`pop RDI; ret;`**
* PLT + 0xb 指向对 **dl\_resolve** 的调用。

找到 `strcmp` 后，可以将 **`rdx`** 设置为大于 0 的值。

{% hint style="success" %}
请注意，通常 `rdx` 会已经包含一个大于 0 的值，因此这一步可能不是必要的。
{% endhint %}

### 8. 找到 Write 或等效函数

最后，需要一个 gadget 来外泄数据，以便外泄二进制文件。在此时，可以**控制 2 个参数并将 `rdx` 设置为大于 0**。

有 3 个常见的函数可以被滥用：

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

然而，原始论文只提到**`write`**，所以让我们谈谈它：

当前的问题是我们不知道**write 函数在 PLT 中的位置**，也不知道**发送数据到我们套接字的 fd 号码**。

然而，我们知道**PLT 表的位置**，并且可以根据其**行为**找到 write。我们可以与服务器创建**多个连接**，并使用一个**高 FD**，希望它与我们的一些连接匹配。

找到这些函数的行为签名：

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> 如果有数据打印，则找到了 puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> 如果有数据打印，则找到了 dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> 如果有数据打印，则找到了 write

## 自动利用

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## 参考文献

* 原始论文：[https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
