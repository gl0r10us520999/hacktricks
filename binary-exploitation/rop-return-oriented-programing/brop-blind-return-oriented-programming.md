# BROP - Blind Return Oriented Programming

{% hint style="success" %}
AWS Hacking Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

## Temel Bilgiler

Bu saldÄ±rÄ±nÄ±n amacÄ±, **savunmasÄ±z ikili hakkÄ±nda herhangi bir bilgi olmadan bir ROP'u kÃ¶tÃ¼ye kullanabilmektir**.\
Bu saldÄ±rÄ± aÅŸaÄŸÄ±daki senaryoya dayanmaktadÄ±r:

* Bir yÄ±ÄŸÄ±n zafiyeti ve bunu tetikleme bilgisi.
* Ã‡Ã¶ktÃ¼kten sonra yeniden baÅŸlatÄ±lan bir sunucu uygulamasÄ±.

## SaldÄ±rÄ±

### **1. HatalÄ± sunucu tespit edilene kadar bir karakter daha gÃ¶ndererek savunmasÄ±z ofseti bulma**

### **2. Canary'yi brute-force ile sÄ±zdÄ±rma**

### **3. YÄ±ÄŸÄ±n iÃ§indeki saklanan RBP ve RIP adreslerini brute-force ile sÄ±zdÄ±rma**

Bu sÃ¼reÃ§ler hakkÄ±nda daha fazla bilgi bulabilirsiniz [burada (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) ve [burada (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Durdurma gadget'Ä±nÄ± bulma**

Bu gadget, ROP gadget'Ä± tarafÄ±ndan ilginÃ§ bir ÅŸeyin Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nÄ± doÄŸrulamayÄ± saÄŸlar Ã§Ã¼nkÃ¼ yÃ¼rÃ¼tme Ã§Ã¶kmez. Genellikle, bu gadget **yÃ¼rÃ¼tmeyi durduran** bir ÅŸey olacak ve belirli bir ROP gadget'Ä±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in ROP zincirinin sonunda yer alacaktÄ±r.

### **5. BROP gadget'Ä±nÄ± bulma**

Bu teknik, [**ret2csu**](ret2csu.md) gadget'Ä±nÄ± kullanÄ±r. Bunun nedeni, bu gadget'a bazÄ± talimatlarÄ±n ortasÄ±nda eriÅŸirseniz **`rsi`** ve **`rdi`**'yi kontrol eden gadget'lar elde etmenizdir:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Bunlar gadget'lar olacaktÄ±r:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Bu gadget'lar ile bir fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n **2 argÃ¼manÄ±nÄ± kontrol etmenin** mÃ¼mkÃ¼n olduÄŸunu unutmayÄ±n.

AyrÄ±ca, ret2csu gadget'Ä±nÄ±n **Ã§ok benzersiz bir imzasÄ±** olduÄŸunu ve yÄ±ÄŸÄ±ndan 6 kayÄ±t pop edeceÄŸini unutmayÄ±n. Bu nedenle, ÅŸÃ¶yle bir zincir gÃ¶nderilir:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

EÄŸer **STOP Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa**, bu temelde yÄ±ÄŸÄ±ndan 6 kayÄ±t pop eden bir **adresin kullanÄ±ldÄ±ÄŸÄ±** anlamÄ±na gelir. Ya da kullanÄ±lan adres de bir STOP adresiydi.

Bu son seÃ§eneÄŸi **kaldÄ±rmak iÃ§in** aÅŸaÄŸÄ±daki gibi yeni bir zincir Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ve Ã¶nceki zincirin 6 kayÄ±t pop ettiÄŸini doÄŸrulamak iÃ§in STOP gadget'Ä±nÄ± Ã§alÄ±ÅŸtÄ±rmamalÄ±dÄ±r:

`'A' * offset + canary + rbp + ADDR`

ret2csu gadget'Ä±nÄ±n adresini bilerek, **`rsi` ve `rdi`'yi kontrol etmek iÃ§in gadget'larÄ±n adresini Ã§Ä±karmak** mÃ¼mkÃ¼ndÃ¼r.

### 6. PLT'yi bulma

PLT tablosu 0x400000 adresinden veya yÄ±ÄŸÄ±ndan **sÄ±zdÄ±rÄ±lan RIP adresinden** (eÄŸer **PIE** kullanÄ±lÄ±yorsa) aranabilir. Tablo **giriÅŸleri** **16B** (0x10B) ile ayrÄ±lmÄ±ÅŸtÄ±r ve bir fonksiyon Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda sunucu Ã§Ã¶kmez, hatta argÃ¼manlar doÄŸru olmasa bile. AyrÄ±ca, bir giriÅŸin adresini kontrol etmek **PLT + 6B** ile de Ã§Ã¶kmez Ã§Ã¼nkÃ¼ bu ilk Ã§alÄ±ÅŸtÄ±rÄ±lan koddur.

Bu nedenle, PLT tablosunu aÅŸaÄŸÄ±daki davranÄ±ÅŸlarÄ± kontrol ederek bulmak mÃ¼mkÃ¼ndÃ¼r:

* `'A' * offset + canary + rbp + ADDR + STOP` -> Ã§Ã¶kme yok
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> Ã§Ã¶kme yok
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> Ã§Ã¶kme yok

### 7. strcmp bulma

**`strcmp`** fonksiyonu **`rdx`** kaydÄ±nÄ± karÅŸÄ±laÅŸtÄ±rÄ±lan stringin uzunluÄŸuna ayarlar. **`rdx`**'nin **Ã¼Ã§Ã¼ncÃ¼ argÃ¼man** olduÄŸunu ve daha sonra `write` kullanarak programÄ± sÄ±zdÄ±rmak iÃ§in **0'dan bÃ¼yÃ¼k** olmasÄ± gerektiÄŸini unutmayÄ±n.

**`strcmp`**'nin PLT'deki yerini bulmak, artÄ±k fonksiyonlarÄ±n ilk 2 argÃ¼manÄ±nÄ± kontrol edebildiÄŸimiz gerÃ§eÄŸine dayanarak mÃ¼mkÃ¼ndÃ¼r:

* strcmp(\<okunmayan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* strcmp(\<okunmayan adres>, \<okunan adres>) -> Ã§Ã¶kme
* strcmp(\<okunan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* strcmp(\<okunan adres>, \<okunan adres>) -> Ã§Ã¶kme yok

Bunu, PLT tablosundaki her giriÅŸi Ã§aÄŸÄ±rarak veya **PLT yavaÅŸ yolu** kullanarak kontrol etmek mÃ¼mkÃ¼ndÃ¼r; bu, temelde **PLT tablosundaki bir giriÅŸi + 0xb** (bu **`dlresolve`**'a Ã§aÄŸrÄ±dÄ±r) Ã§aÄŸÄ±rarak ve ardÄ±ndan yÄ±ÄŸÄ±nda **sorgulamak istediÄŸiniz giriÅŸ numarasÄ±nÄ±** (sÄ±fÄ±rdan baÅŸlayarak) ekleyerek tÃ¼m PLT giriÅŸlerini taramak anlamÄ±na gelir:

* strcmp(\<okunmayan adres>, \<okunan adres>) -> Ã§Ã¶kme
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Ã‡Ã¶kecek
* strcmp(\<okunan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<okunan adres>, \<okunan adres>) -> Ã§Ã¶kme yok
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

UnutmayÄ±n ki:

* BROP + 0x7 **`pop RSI; pop R15; ret;`**'ye iÅŸaret eder
* BROP + 0x9 **`pop RDI; ret;`**'ye iÅŸaret eder
* PLT + 0xb **dl\_resolve**'a bir Ã§aÄŸrÄ±ya iÅŸaret eder.

`strcmp`'yi bulduktan sonra, **`rdx`**'yi 0'dan bÃ¼yÃ¼k bir deÄŸere ayarlamak mÃ¼mkÃ¼ndÃ¼r.

{% hint style="success" %}
Genellikle `rdx`'nin zaten 0'dan bÃ¼yÃ¼k bir deÄŸeri barÄ±ndÄ±racaÄŸÄ±nÄ± unutmayÄ±n, bu nedenle bu adÄ±m gerekli olmayabilir.
{% endhint %}

### 8. Write veya eÅŸdeÄŸerini bulma

Son olarak, ikiliyi sÄ±zdÄ±rmak iÃ§in verileri dÄ±ÅŸarÄ± sÄ±zdÄ±ran bir gadget'a ihtiyaÃ§ vardÄ±r. Ve bu noktada **2 argÃ¼manÄ± kontrol edebiliriz ve `rdx`'yi 0'dan bÃ¼yÃ¼k ayarlayabiliriz.**

Bunu kÃ¶tÃ¼ye kullanmak iÃ§in 3 yaygÄ±n fonksiyon vardÄ±r:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Ancak, orijinal makalede yalnÄ±zca **`write`**'den bahsedilmektedir, bu nedenle bunun hakkÄ±nda konuÅŸalÄ±m:

Mevcut sorun, **write fonksiyonunun PLT iÃ§indeki yerini** bilmememiz ve **verileri soketimize gÃ¶ndermek iÃ§in bir fd numarasÄ±nÄ±** bilmememizdir.

Ancak, **PLT tablosunun nerede olduÄŸunu** biliyoruz ve **davranÄ±ÅŸÄ±na** dayanarak write'Ä± bulmak mÃ¼mkÃ¼ndÃ¼r. Ve sunucu ile **birÃ§ok baÄŸlantÄ±** oluÅŸturabiliriz ve bazÄ± baÄŸlantÄ±larÄ±mÄ±zla eÅŸleÅŸmesini umarak **yÃ¼ksek bir FD** kullanabiliriz.

Bu fonksiyonlarÄ± bulmak iÃ§in davranÄ±ÅŸ imzalarÄ±:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> EÄŸer veri yazdÄ±rÄ±lÄ±rsa, puts bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> EÄŸer veri yazdÄ±rÄ±lÄ±rsa, dprintf bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> EÄŸer veri yazdÄ±rÄ±lÄ±rsa, write bulundu

## Otomatik SÃ¶mÃ¼rÃ¼

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referanslar

* Orijinal makale: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
AWS Hacking Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
