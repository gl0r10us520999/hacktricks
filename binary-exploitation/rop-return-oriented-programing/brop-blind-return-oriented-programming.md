# BROP - Blind Return Oriented Programming

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## Temel Bilgiler

Bu saldırının amacı, **savunmasız ikili hakkında herhangi bir bilgi olmadan bir ROP'u kötüye kullanabilmektir**.\
Bu saldırı aşağıdaki senaryoya dayanmaktadır:

* Bir yığın zafiyeti ve bunu tetikleme bilgisi.
* Çöktükten sonra yeniden başlatılan bir sunucu uygulaması.

## Saldırı

### **1. Hatalı sunucu tespit edilene kadar bir karakter daha göndererek savunmasız ofseti bulma**

### **2. Canary'yi brute-force ile sızdırma**

### **3. Yığın içindeki saklanan RBP ve RIP adreslerini brute-force ile sızdırma**

Bu süreçler hakkında daha fazla bilgi bulabilirsiniz [burada (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) ve [burada (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Durdurma gadget'ını bulma**

Bu gadget, ROP gadget'ı tarafından ilginç bir şeyin çalıştırıldığını doğrulamayı sağlar çünkü yürütme çökmez. Genellikle, bu gadget **yürütmeyi durduran** bir şey olacak ve belirli bir ROP gadget'ının çalıştırıldığını doğrulamak için ROP zincirinin sonunda yer alacaktır.

### **5. BROP gadget'ını bulma**

Bu teknik, [**ret2csu**](ret2csu.md) gadget'ını kullanır. Bunun nedeni, bu gadget'a bazı talimatların ortasında erişirseniz **`rsi`** ve **`rdi`**'yi kontrol eden gadget'lar elde etmenizdir:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Bunlar gadget'lar olacaktır:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Bu gadget'lar ile bir fonksiyon çağrısının **2 argümanını kontrol etmenin** mümkün olduğunu unutmayın.

Ayrıca, ret2csu gadget'ının **çok benzersiz bir imzası** olduğunu ve yığından 6 kayıt pop edeceğini unutmayın. Bu nedenle, şöyle bir zincir gönderilir:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Eğer **STOP çalıştırılırsa**, bu temelde yığından 6 kayıt pop eden bir **adresin kullanıldığı** anlamına gelir. Ya da kullanılan adres de bir STOP adresiydi.

Bu son seçeneği **kaldırmak için** aşağıdaki gibi yeni bir zincir çalıştırılır ve önceki zincirin 6 kayıt pop ettiğini doğrulamak için STOP gadget'ını çalıştırmamalıdır:

`'A' * offset + canary + rbp + ADDR`

ret2csu gadget'ının adresini bilerek, **`rsi` ve `rdi`'yi kontrol etmek için gadget'ların adresini çıkarmak** mümkündür.

### 6. PLT'yi bulma

PLT tablosu 0x400000 adresinden veya yığından **sızdırılan RIP adresinden** (eğer **PIE** kullanılıyorsa) aranabilir. Tablo **girişleri** **16B** (0x10B) ile ayrılmıştır ve bir fonksiyon çağrıldığında sunucu çökmez, hatta argümanlar doğru olmasa bile. Ayrıca, bir girişin adresini kontrol etmek **PLT + 6B** ile de çökmez çünkü bu ilk çalıştırılan koddur.

Bu nedenle, PLT tablosunu aşağıdaki davranışları kontrol ederek bulmak mümkündür:

* `'A' * offset + canary + rbp + ADDR + STOP` -> çökme yok
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> çökme yok
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> çökme yok

### 7. strcmp bulma

**`strcmp`** fonksiyonu **`rdx`** kaydını karşılaştırılan stringin uzunluğuna ayarlar. **`rdx`**'nin **üçüncü argüman** olduğunu ve daha sonra `write` kullanarak programı sızdırmak için **0'dan büyük** olması gerektiğini unutmayın.

**`strcmp`**'nin PLT'deki yerini bulmak, artık fonksiyonların ilk 2 argümanını kontrol edebildiğimiz gerçeğine dayanarak mümkündür:

* strcmp(\<okunmayan adres>, \<okunmayan adres>) -> çökme
* strcmp(\<okunmayan adres>, \<okunan adres>) -> çökme
* strcmp(\<okunan adres>, \<okunmayan adres>) -> çökme
* strcmp(\<okunan adres>, \<okunan adres>) -> çökme yok

Bunu, PLT tablosundaki her girişi çağırarak veya **PLT yavaş yolu** kullanarak kontrol etmek mümkündür; bu, temelde **PLT tablosundaki bir girişi + 0xb** (bu **`dlresolve`**'a çağrıdır) çağırarak ve ardından yığında **sorgulamak istediğiniz giriş numarasını** (sıfırdan başlayarak) ekleyerek tüm PLT girişlerini taramak anlamına gelir:

* strcmp(\<okunmayan adres>, \<okunan adres>) -> çökme
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Çökecek
* strcmp(\<okunan adres>, \<okunmayan adres>) -> çökme
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<okunan adres>, \<okunan adres>) -> çökme yok
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Unutmayın ki:

* BROP + 0x7 **`pop RSI; pop R15; ret;`**'ye işaret eder
* BROP + 0x9 **`pop RDI; ret;`**'ye işaret eder
* PLT + 0xb **dl\_resolve**'a bir çağrıya işaret eder.

`strcmp`'yi bulduktan sonra, **`rdx`**'yi 0'dan büyük bir değere ayarlamak mümkündür.

{% hint style="success" %}
Genellikle `rdx`'nin zaten 0'dan büyük bir değeri barındıracağını unutmayın, bu nedenle bu adım gerekli olmayabilir.
{% endhint %}

### 8. Write veya eşdeğerini bulma

Son olarak, ikiliyi sızdırmak için verileri dışarı sızdıran bir gadget'a ihtiyaç vardır. Ve bu noktada **2 argümanı kontrol edebiliriz ve `rdx`'yi 0'dan büyük ayarlayabiliriz.**

Bunu kötüye kullanmak için 3 yaygın fonksiyon vardır:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Ancak, orijinal makalede yalnızca **`write`**'den bahsedilmektedir, bu nedenle bunun hakkında konuşalım:

Mevcut sorun, **write fonksiyonunun PLT içindeki yerini** bilmememiz ve **verileri soketimize göndermek için bir fd numarasını** bilmememizdir.

Ancak, **PLT tablosunun nerede olduğunu** biliyoruz ve **davranışına** dayanarak write'ı bulmak mümkündür. Ve sunucu ile **birçok bağlantı** oluşturabiliriz ve bazı bağlantılarımızla eşleşmesini umarak **yüksek bir FD** kullanabiliriz.

Bu fonksiyonları bulmak için davranış imzaları:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Eğer veri yazdırılırsa, puts bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Eğer veri yazdırılırsa, dprintf bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Eğer veri yazdırılırsa, write bulundu

## Otomatik Sömürü

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referanslar

* Orijinal makale: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
