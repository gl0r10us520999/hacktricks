# BROP - Blind Return Oriented Programming

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

O objetivo deste ataque √© ser capaz de **abusar de um ROP via um buffer overflow sem qualquer informa√ß√£o sobre o bin√°rio vulner√°vel**.\
Este ataque √© baseado no seguinte cen√°rio:

* Uma vulnerabilidade na pilha e conhecimento de como acion√°-la.
* Uma aplica√ß√£o de servidor que reinicia ap√≥s uma falha.

## Ataque

### **1. Encontrar o offset vulner√°vel** enviando um caractere a mais at√© que uma falha do servidor seja detectada

### **2. Brute-force can√°rio** para vaz√°-lo

### **3. Brute-force endere√ßos RBP e RIP** armazenados na pilha para vaz√°-los

Voc√™ pode encontrar mais informa√ß√µes sobre esses processos [aqui (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) e [aqui (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Encontrar o gadget de parada**

Este gadget basicamente permite confirmar que algo interessante foi executado pelo gadget ROP porque a execu√ß√£o n√£o falhou. Normalmente, este gadget ser√° algo que **para a execu√ß√£o** e est√° posicionado no final da cadeia ROP ao procurar gadgets ROP para confirmar que um gadget ROP espec√≠fico foi executado.

### **5. Encontrar o gadget BROP**

Esta t√©cnica usa o gadget [**ret2csu**](ret2csu.md). E isso ocorre porque, se voc√™ acessar este gadget no meio de algumas instru√ß√µes, voc√™ obt√©m gadgets para controlar **`rsi`** e **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Esses seriam os gadgets:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Note como com esses gadgets √© poss√≠vel **controlar 2 argumentos** de uma fun√ß√£o a ser chamada.

Al√©m disso, note que o gadget ret2csu tem uma **assinatura muito √∫nica** porque vai estar popando 6 registradores da pilha. Portanto, enviando uma cadeia como:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Se o **STOP for executado**, isso basicamente significa que um **endere√ßo que est√° popando 6 registradores** da pilha foi usado. Ou que o endere√ßo usado tamb√©m era um endere√ßo STOP.

Para **remover esta √∫ltima op√ß√£o**, uma nova cadeia como a seguinte √© executada e n√£o deve executar o gadget STOP para confirmar que o anterior popou 6 registradores:

`'A' * offset + canary + rbp + ADDR`

Sabendo o endere√ßo do gadget ret2csu, √© poss√≠vel **inferir o endere√ßo dos gadgets para controlar `rsi` e `rdi`**.

### 6. Encontrar PLT

A tabela PLT pode ser pesquisada a partir de 0x400000 ou do **endere√ßo RIP vazado** da pilha (se **PIE** estiver sendo usado). As **entradas** da tabela s√£o **separadas por 16B** (0x10B), e quando uma fun√ß√£o √© chamada, o servidor n√£o falha mesmo que os argumentos n√£o estejam corretos. Al√©m disso, verificar o endere√ßo de uma entrada na **PLT + 6B tamb√©m n√£o falha** pois √© o primeiro c√≥digo executado.

Portanto, √© poss√≠vel encontrar a tabela PLT verificando os seguintes comportamentos:

* `'A' * offset + canary + rbp + ADDR + STOP` -> sem falha
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> sem falha
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> sem falha

### 7. Encontrando strcmp

A fun√ß√£o **`strcmp`** define o registrador **`rdx`** para o comprimento da string sendo comparada. Note que **`rdx`** √© o **terceiro argumento** e precisamos que ele seja **maior que 0** para depois usar `write` para vazar o programa.

√â poss√≠vel encontrar a localiza√ß√£o de **`strcmp`** na PLT com base em seu comportamento usando o fato de que agora podemos controlar os 2 primeiros argumentos das fun√ß√µes:

* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo n√£o lido>) -> falha
* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo lido>) -> falha
* strcmp(\<endere√ßo lido>, \<endere√ßo n√£o lido>) -> falha
* strcmp(\<endere√ßo lido>, \<endere√ßo lido>) -> sem falha

√â poss√≠vel verificar isso chamando cada entrada da tabela PLT ou usando o **caminho lento da PLT**, que basicamente consiste em **chamar uma entrada na tabela PLT + 0xb** (que chama **`dlresolve`**) seguido na pilha pelo **n√∫mero da entrada que se deseja sondar** (come√ßando em zero) para escanear todas as entradas PLT a partir da primeira:

* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo lido>) -> falha
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Vai falhar
* strcmp(\<endere√ßo lido>, \<endere√ßo n√£o lido>) -> falha
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<endere√ßo lido>, \<endere√ßo lido>) -> sem falha
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Lembre-se que:

* BROP + 0x7 aponta para **`pop RSI; pop R15; ret;`**
* BROP + 0x9 aponta para **`pop RDI; ret;`**
* PLT + 0xb aponta para uma chamada para **dl\_resolve**.

Tendo encontrado `strcmp`, √© poss√≠vel definir **`rdx`** para um valor maior que 0.

{% hint style="success" %}
Note que geralmente `rdx` j√° ter√° um valor maior que 0, ent√£o este passo pode n√£o ser necess√°rio.
{% endhint %}

### 8. Encontrando Write ou equivalente

Finalmente, √© necess√°rio um gadget que exfiltra dados para exfiltrar o bin√°rio. E neste momento √© poss√≠vel **controlar 2 argumentos e definir `rdx` maior que 0.**

Existem 3 fun√ß√µes comuns que poderiam ser abusadas para isso:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

No entanto, o artigo original menciona apenas a **`write`**, ent√£o vamos falar sobre isso:

O problema atual √© que n√£o sabemos **onde a fun√ß√£o write est√° dentro da PLT** e n√£o sabemos **um n√∫mero fd para enviar os dados para nosso socket**.

No entanto, sabemos **onde est√° a tabela PLT** e √© poss√≠vel encontrar write com base em seu **comportamento**. E podemos criar **v√°rias conex√µes** com o servidor e usar um **FD alto** esperando que ele corresponda a algumas de nossas conex√µes.

Assinaturas de comportamento para encontrar essas fun√ß√µes:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Se houver dados impressos, ent√£o puts foi encontrado
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Se houver dados impressos, ent√£o dprintf foi encontrado
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Se houver dados impressos, ent√£o write foi encontrado

## Explora√ß√£o Autom√°tica

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Refer√™ncias

* Artigo original: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
