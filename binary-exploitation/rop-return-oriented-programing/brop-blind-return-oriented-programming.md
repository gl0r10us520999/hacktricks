# BROP - Blind Return Oriented Programming

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne informacije

Cilj ovog napada je da se **zloupotrebi ROP putem prelivanja bafera bez ikakvih informacija o ranjivom binarnom fajlu**.\
Ovaj napad se zasniva na sledeÄ‡em scenariju:

* Ranjivost na steku i znanje o tome kako je aktivirati.
* Serverska aplikacija koja se ponovo pokreÄ‡e nakon pada.

## Napad

### **1. PronaÄ‘ite ranjivi offset** slanjem jednog dodatnog karaktera dok se ne otkrije kvar servera

### **2. Brute-force canary** da biste ga otkrili

### **3. Brute-force saÄuvanih RBP i RIP** adresa na steku da biste ih otkrili

MoÅ¾ete pronaÄ‡i viÅ¡e informacija o ovim procesima [ovde (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) i [ovde (BF Adrese na Steku)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. PronaÄ‘ite stop gadget**

Ovaj gadget u suÅ¡tini omoguÄ‡ava da se potvrdi da je neÅ¡to zanimljivo izvrÅ¡eno putem ROP gadgeta jer izvrÅ¡enje nije sruÅ¡eno. ObiÄno, ovaj gadget Ä‡e biti neÅ¡to Å¡to **zaustavlja izvrÅ¡enje** i pozicioniran je na kraju ROP lanca kada se traÅ¾e ROP gadgeti da bi se potvrdilo da je odreÄ‘eni ROP gadget izvrÅ¡en.

### **5. PronaÄ‘ite BROP gadget**

Ova tehnika koristi [**ret2csu**](ret2csu.md) gadget. I to je zato Å¡to, ako pristupite ovom gadgetu usred nekih instrukcija, dobijate gadgete za kontrolu **`rsi`** i **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Ovo bi bili gadgeti:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Primetite kako je sa tim gadgetima moguÄ‡e **kontrolisati 2 argumenta** funkcije koju pozivate.

TakoÄ‘e, primetite da ret2csu gadget ima **veoma jedinstvenu potpis** jer Ä‡e izbacivati 6 registara sa steka. Dakle, slanjem lanca poput:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Ako je **STOP izvrÅ¡en**, to u suÅ¡tini znaÄi da je koriÅ¡Ä‡ena **adresa koja izbacuje 6 registara** sa steka. Ili da je koriÅ¡Ä‡ena adresa koja je takoÄ‘e STOP adresa.

Da bi se **uklonila ova poslednja opcija**, izvrÅ¡ava se novi lanac poput sledeÄ‡eg i ne sme izvrÅ¡iti STOP gadget da bi se potvrdilo da je prethodni izbacivao 6 registara:

`'A' * offset + canary + rbp + ADDR`

PoznavajuÄ‡i adresu ret2csu gadgeta, moguÄ‡e je **izvesti adresu gadgeta za kontrolu `rsi` i `rdi`**.

### 6. PronaÄ‘ite PLT

PLT tabela se moÅ¾e pretraÅ¾ivati od 0x400000 ili od **otkrivene RIP adrese** sa steka (ako se koristi **PIE**). **Unosi** tabele su **razdvojeni po 16B** (0x10B), i kada se pozove jedna funkcija, server se ne sruÅ¡i Äak i ako argumenti nisu taÄni. TakoÄ‘e, provera adrese unosa u **PLT + 6B takoÄ‘e ne sruÅ¡i** jer je to prvi kod koji se izvrÅ¡ava.

Stoga, moguÄ‡e je pronaÄ‡i PLT tabelu proverom sledeÄ‡ih ponaÅ¡anja:

* `'A' * offset + canary + rbp + ADDR + STOP` -> nema ruÅ¡enja
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> nema ruÅ¡enja
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> nema ruÅ¡enja

### 7. Pronalazak strcmp

Funkcija **`strcmp`** postavlja registar **`rdx`** na duÅ¾inu stringa koji se uporeÄ‘uje. Imajte na umu da je **`rdx`** **treÄ‡i argument** i treba da bude **veÄ‡i od 0** kako bismo kasnije koristili `write` da otkrijemo program.

MoguÄ‡e je pronaÄ‡i lokaciju **`strcmp`** u PLT-u na osnovu njenog ponaÅ¡anja koristeÄ‡i Äinjenicu da sada moÅ¾emo kontrolisati prva 2 argumenta funkcija:

* strcmp(\<non read addr>, \<non read addr>) -> ruÅ¡enje
* strcmp(\<non read addr>, \<read addr>) -> ruÅ¡enje
* strcmp(\<read addr>, \<non read addr>) -> ruÅ¡enje
* strcmp(\<read addr>, \<read addr>) -> nema ruÅ¡enja

MoguÄ‡e je proveriti ovo pozivajuÄ‡i svaki unos PLT tabele ili koristeÄ‡i **PLT spor put** koji se u suÅ¡tini sastoji od **pozivanja unosa u PLT tabeli + 0xb** (Å¡to poziva **`dlresolve`**) praÄ‡eno na steku sa **brojem unosa koji Å¾elite da proverite** (poÄinjajuÄ‡i od nule) da skenirate sve PLT unose od prvog:

* strcmp(\<non read addr>, \<read addr>) -> ruÅ¡enje
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> RuÅ¡iÄ‡e
* strcmp(\<read addr>, \<non read addr>) -> ruÅ¡enje
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<read addr>, \<read addr>) -> nema ruÅ¡enja
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Zapamtite da:

* BROP + 0x7 ukazuje na **`pop RSI; pop R15; ret;`**
* BROP + 0x9 ukazuje na **`pop RDI; ret;`**
* PLT + 0xb ukazuje na poziv **dl\_resolve**.

Nakon Å¡to je pronaÄ‘en `strcmp`, moguÄ‡e je postaviti **`rdx`** na vrednost veÄ‡u od 0.

{% hint style="success" %}
Imajte na umu da obiÄno `rdx` veÄ‡ sadrÅ¾i vrednost veÄ‡u od 0, tako da ovaj korak moÅ¾da nije neophodan.
{% endhint %}

### 8. Pronalazak Write ili ekvivalentnog

Na kraju, potreban je gadget koji eksfiltrira podatke kako bi se eksfiltrirao binarni fajl. I u ovom trenutku je moguÄ‡e **kontrolisati 2 argumenta i postaviti `rdx` veÄ‡i od 0.**

Postoje 3 uobiÄajene funkcije koje bi mogle biti zloupotrebljene za ovo:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

MeÄ‘utim, originalni rad pominje samo funkciju **`write`**, pa hajde da priÄamo o tome:

Trenutni problem je Å¡to ne znamo **gde se funkcija write nalazi unutar PLT-a** i ne znamo **fd broj da poÅ¡aljemo podatke naÅ¡em soketu**.

MeÄ‘utim, znamo **gde se nalazi PLT tabela** i moguÄ‡e je pronaÄ‡i write na osnovu njenog **ponaÅ¡anja**. I moÅ¾emo stvoriti **nekoliko veza** sa serverom i koristiti **visok FD** nadajuÄ‡i se da Ä‡e se poklopiti sa nekim od naÅ¡ih veza.

Potpis ponaÅ¡anja za pronalaÅ¾enje tih funkcija:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronaÄ‘en puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronaÄ‘en dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronaÄ‘en write

## Automatska Eksploatacija

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Reference

* Originalni rad: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
