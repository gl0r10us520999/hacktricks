# BROP - Blind Return Oriented Programming

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Grundinformationen

Das Ziel dieses Angriffs ist es, **einen ROP √ºber einen Buffer Overflow ohne Informationen √ºber die verwundbare Bin√§rdatei auszunutzen**.\
Dieser Angriff basiert auf folgendem Szenario:

* Eine Stack-Sicherheitsanf√§lligkeit und Wissen dar√ºber, wie man sie ausl√∂st.
* Eine Serveranwendung, die nach einem Absturz neu startet.

## Angriff

### **1. Finde verwundbaren Offset** indem du ein weiteres Zeichen sendest, bis ein Fehler des Servers erkannt wird

### **2. Brute-Force Canary** um ihn zu leaken

### **3. Brute-Force gespeicherte RBP- und RIP-Adressen** im Stack, um sie zu leaken

Weitere Informationen zu diesen Prozessen findest du [hier (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) und [hier (BF Adressen im Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Finde das Stop-Gadget**

Dieses Gadget erm√∂glicht es im Grunde, zu best√§tigen, dass etwas Interessantes durch das ROP-Gadget ausgef√ºhrt wurde, da die Ausf√ºhrung nicht abgest√ºrzt ist. Normalerweise wird dieses Gadget etwas sein, das **die Ausf√ºhrung stoppt** und es befindet sich am Ende der ROP-Kette, wenn nach ROP-Gadgets gesucht wird, um zu best√§tigen, dass ein bestimmtes ROP-Gadget ausgef√ºhrt wurde.

### **5. Finde BROP-Gadget**

Diese Technik verwendet das [**ret2csu**](ret2csu.md) Gadget. Und das liegt daran, dass du, wenn du auf dieses Gadget in der Mitte einiger Anweisungen zugreifst, Gadgets erh√§ltst, um **`rsi`** und **`rdi`** zu steuern:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Das w√§ren die Gadgets:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Beachte, wie es mit diesen Gadgets m√∂glich ist, **2 Argumente** einer Funktion zu steuern.

Beachte auch, dass das ret2csu-Gadget eine **sehr einzigartige Signatur** hat, da es 6 Register vom Stack poppt. Daher wird eine Kette wie folgt gesendet:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Wenn das **STOP ausgef√ºhrt wird**, bedeutet das im Grunde, dass eine **Adresse, die 6 Register** vom Stack poppt, verwendet wurde. Oder dass die verwendete Adresse auch eine STOP-Adresse war.

Um diese letzte Option **zu entfernen**, wird eine neue Kette wie folgt ausgef√ºhrt, und sie darf das STOP-Gadget nicht ausf√ºhren, um zu best√§tigen, dass das vorherige 6 Register gepoppt hat:

`'A' * offset + canary + rbp + ADDR`

Wenn die Adresse des ret2csu-Gadgets bekannt ist, ist es m√∂glich, die Adresse der Gadgets zu **inferieren, um `rsi` und `rdi` zu steuern**.

### 6. Finde PLT

Die PLT-Tabelle kann von 0x400000 oder von der **geleakten RIP-Adresse** aus dem Stack (wenn **PIE** verwendet wird) durchsucht werden. Die **Eintr√§ge** der Tabelle sind **durch 16B** (0x10B) getrennt, und wenn eine Funktion aufgerufen wird, st√ºrzt der Server nicht ab, selbst wenn die Argumente nicht korrekt sind. Au√üerdem st√ºrzt das √úberpr√ºfen der Adresse eines Eintrags in der **PLT + 6B ebenfalls nicht ab**, da es der erste ausgef√ºhrte Code ist.

Daher ist es m√∂glich, die PLT-Tabelle zu finden, indem man die folgenden Verhaltensweisen √ºberpr√ºft:

* `'A' * offset + canary + rbp + ADDR + STOP` -> kein Absturz
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> kein Absturz
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> kein Absturz

### 7. Finden von strcmp

Die **`strcmp`** Funktion setzt das Register **`rdx`** auf die L√§nge des zu vergleichenden Strings. Beachte, dass **`rdx`** das **dritte Argument** ist und wir es **gr√∂√üer als 0** haben m√ºssen, um sp√§ter `write` zu verwenden, um das Programm zu leaken.

Es ist m√∂glich, den Standort von **`strcmp`** in der PLT basierend auf seinem Verhalten zu finden, indem wir die Tatsache nutzen, dass wir jetzt die 2 ersten Argumente von Funktionen steuern k√∂nnen:

* strcmp(\<nicht lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* strcmp(\<nicht lesbare Adresse>, \<lesbare Adresse>) -> Absturz
* strcmp(\<lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* strcmp(\<lesbare Adresse>, \<lesbare Adresse>) -> kein Absturz

Es ist m√∂glich, dies zu √ºberpr√ºfen, indem man jeden Eintrag der PLT-Tabelle aufruft oder den **PLT-Slow-Path** verwendet, der im Grunde darin besteht, **einen Eintrag in der PLT-Tabelle + 0xb** (was zu **`dlresolve`** aufruft) gefolgt im Stack von der **Eintragsnummer, die man testen m√∂chte** (beginnend bei null), um alle PLT-Eintr√§ge vom ersten an zu scannen:

* strcmp(\<nicht lesbare Adresse>, \<lesbare Adresse>) -> Absturz
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Wird abst√ºrzen
* strcmp(\<lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
* strcmp(\<lesbare Adresse>, \<lesbare Adresse>) -> kein Absturz
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Denke daran, dass:

* BROP + 0x7 auf **`pop RSI; pop R15; ret;`** zeigt
* BROP + 0x9 auf **`pop RDI; ret;`** zeigt
* PLT + 0xb auf einen Aufruf zu **dl\_resolve** zeigt.

Nachdem `strcmp` gefunden wurde, ist es m√∂glich, **`rdx`** auf einen Wert gr√∂√üer als 0 zu setzen.

{% hint style="success" %}
Beachte, dass `rdx` normalerweise bereits einen Wert gr√∂√üer als 0 haben wird, sodass dieser Schritt m√∂glicherweise nicht notwendig ist.
{% endhint %}

### 8. Finden von Write oder √Ñquivalent

Schlie√ülich wird ein Gadget ben√∂tigt, das Daten exfiltriert, um die Bin√§rdatei zu exfiltrieren. Und zu diesem Zeitpunkt ist es m√∂glich, **2 Argumente zu steuern und `rdx` gr√∂√üer als 0 zu setzen.**

Es gibt 3 g√§ngige Funktionen, die daf√ºr ausgenutzt werden k√∂nnten:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data))`

Das urspr√ºngliche Papier erw√§hnt jedoch nur die **`write`**-Funktion, also lass uns dar√ºber sprechen:

Das aktuelle Problem ist, dass wir nicht wissen, **wo sich die Write-Funktion innerhalb der PLT befindet** und wir wissen nicht, **eine fd-Nummer, um die Daten an unseren Socket zu senden**.

Wir wissen jedoch, **wo sich die PLT-Tabelle befindet**, und es ist m√∂glich, Write basierend auf seinem **Verhalten** zu finden. Und wir k√∂nnen **mehrere Verbindungen** mit dem Server herstellen und eine **hohe FD** verwenden, in der Hoffnung, dass sie mit einigen unserer Verbindungen √ºbereinstimmt.

Verhaltenssignaturen, um diese Funktionen zu finden:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Wenn Daten gedruckt werden, wurde puts gefunden
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Wenn Daten gedruckt werden, wurde dprintf gefunden
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Wenn Daten gedruckt werden, wurde write gefunden

## Automatische Ausnutzung

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referenzen

* Originalpapier: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
