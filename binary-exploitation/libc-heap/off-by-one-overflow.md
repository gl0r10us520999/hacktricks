# Estouro por um byte

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

Ter apenas acesso a um estouro de 1 byte permite a um atacante modificar o campo `size` do pr√≥ximo chunk. Isso permite manipular quais chunks s√£o realmente liberados, potencialmente gerando um chunk que cont√©m outro chunk leg√≠timo. A explora√ß√£o √© semelhante a [double free](double-free.md) ou chunks sobrepostos.

Existem 2 tipos de vulnerabilidades de estouro por um byte:

* Byte arbitr√°rio: Esse tipo permite sobrescrever esse byte com qualquer valor
* Byte nulo (off-by-null): Esse tipo permite sobrescrever esse byte apenas com 0x00
* Um exemplo comum dessa vulnerabilidade pode ser visto no c√≥digo a seguir, onde o comportamento de `strlen` e `strcpy` √© inconsistente, o que permite definir um byte 0x00 no in√≠cio do pr√≥ximo chunk.
* Isso pode ser explorado com o [House of Einherjar](house-of-einherjar.md).
* Se estiver usando Tcache, isso pode ser aproveitado para uma situa√ß√£o de [double free](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre outras verifica√ß√µes, agora sempre que um chunk √© liberado, o tamanho anterior √© comparado com o tamanho configurado nos metadados do chunk, tornando esse ataque bastante complexo a partir da vers√£o 2.28.

### Exemplo de c√≥digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque n√£o est√° mais funcionando devido ao uso de Tcaches.
* Al√©m disso, se voc√™ tentar abusar dele usando chunks maiores (para que as tcaches n√£o estejam envolvidas), voc√™ receber√° o erro: `malloc(): invalid next size (unsorted)`

### Objetivo

* Fazer um chunk estar contido dentro de outro chunk, de modo que o acesso de escrita sobre esse segundo chunk permita sobrescrever o contido

### Requisitos

* Estouro de buffer por um para modificar as informa√ß√µes de metadados de tamanho

### Ataque geral de off-by-one

* Aloque tr√™s chunks `A`, `B` e `C` (digamos tamanhos 0x20), e outro para evitar a consolida√ß√£o com o chunk superior.
* Libere `C` (inserido na lista de libera√ß√£o Tcache de 0x20).
* Use o chunk `A` para transbordar em `B`. Abusa do off-by-one para modificar o campo `size` de `B` de 0x21 para 0x41.
* Agora temos `B` contendo o chunk livre `C`
* Libere `B` e aloque um chunk de 0x40 (ele ser√° colocado aqui novamente)
* Podemos modificar o ponteiro `fd` de `C`, que ainda est√° livre (envenenamento de Tcache)

### Ataque off-by-null

* 3 chunks de mem√≥ria (a, b, c) s√£o reservados um ap√≥s o outro. Em seguida, o do meio √© liberado. O primeiro cont√©m uma vulnerabilidade de estouro por um e o atacante a abusa com um 0x00 (se o byte anterior fosse 0x10, faria com que o chunk do meio indicasse que √© 0x10 menor do que realmente √©).
* Em seguida, 2 chunks menores s√£o alocados no meio do chunk liberado (b), no entanto, como `b + b->size` nunca atualiza o chunk c porque o endere√ßo apontado √© menor do que deveria.
* Em seguida, b1 e c s√£o liberados. Como `c - c->prev_size` ainda aponta para b (agora b1), ambos s√£o consolidados em um √∫nico chunk. No entanto, b2 ainda est√° dentro entre b1 e c.
* Finalmente, √© feito um novo malloc para recuperar esta √°rea de mem√≥ria que na verdade vai conter b2, permitindo ao propriet√°rio do novo malloc controlar o conte√∫do de b2.

Esta imagem explica perfeitamente o ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Outros Exemplos e Refer√™ncias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one devido ao `strlen` considerando o campo `size` do pr√≥ximo chunk.
* Tcache est√° sendo usado, ent√£o ataques gerais de off-by-one funcionam para obter um primitivo de escrita arbitr√°rio com envenenamento de Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √â poss√≠vel abusar de um off-by-one para vazar um endere√ßo do heap porque o byte 0x00 do final de uma string est√° sendo sobrescrito pelo pr√≥ximo campo.
* A escrita arbitr√°ria √© obtida abusando do off-by-one para fazer o ponteiro apontar para outro lugar onde uma estrutura falsa com ponteiros falsos ser√° constru√≠da. Em seguida, √© poss√≠vel seguir o ponteiro desta estrutura para obter uma escrita arbitr√°ria.
* O endere√ßo do libc √© vazado porque se o heap for estendido usando mmap, a mem√≥ria alocada por mmap tem um deslocamento fixo do libc.
* Finalmente, a escrita arbitr√°ria √© abusada para escrever no endere√ßo de \_\_free\_hook com um one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Existe uma vulnerabilidade de off-by-one NULL na fun√ß√£o `getline` que l√™ linhas de entrada do usu√°rio. Esta fun√ß√£o √© usada para ler a "chave" do conte√∫do e n√£o o conte√∫do.
* **Compartilhe truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **reposit√≥rios do Github.**
