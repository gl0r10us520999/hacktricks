# Off by one overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Ter apenas acesso a um overflow de 1B permite que um atacante modifique o campo `size` do pr√≥ximo chunk. Isso permite manipular quais chunks s√£o realmente liberados, potencialmente gerando um chunk que cont√©m outro chunk leg√≠timo. A explora√ß√£o √© semelhante a [double free](double-free.md) ou chunks sobrepostos.

Existem 2 tipos de vulnerabilidades off by one:

* Byte arbitr√°rio: Este tipo permite sobrescrever esse byte com qualquer valor
* Byte nulo (off-by-null): Este tipo permite sobrescrever esse byte apenas com 0x00
* Um exemplo comum dessa vulnerabilidade pode ser visto no seguinte c√≥digo onde o comportamento de `strlen` e `strcpy` √© inconsistente, o que permite definir um byte 0x00 no in√≠cio do pr√≥ximo chunk.
* Isso pode ser explorado com a [House of Einherjar](house-of-einherjar.md).
* Se usando Tcache, isso pode ser aproveitado para uma situa√ß√£o de [double free](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre outras verifica√ß√µes, agora sempre que um chunk √© liberado, o tamanho anterior √© comparado com o tamanho configurado nos metadados do chunk, tornando esse ataque bastante complexo a partir da vers√£o 2.28.

### Exemplo de c√≥digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque n√£o est√° mais funcionando devido ao uso de Tcaches.
* Al√©m disso, se voc√™ tentar abusar dele usando chunks maiores (para que os tcaches n√£o estejam envolvidos), voc√™ receber√° o erro: `malloc(): invalid next size (unsorted)`

### Objetivo

* Fazer um chunk ser contido dentro de outro chunk, de modo que o acesso de escrita sobre esse segundo chunk permita sobrescrever o contido.

### Requisitos

* Off by one overflow para modificar as informa√ß√µes de metadados de tamanho.

### Ataque geral off-by-one

* Alocar tr√™s chunks `A`, `B` e `C` (digamos tamanhos 0x20), e outro para evitar a consolida√ß√£o com o top-chunk.
* Liberar `C` (inserido na lista de chunks livres do Tcache de 0x20).
* Usar o chunk `A` para transbordar sobre `B`. Abusar do off-by-one para modificar o campo `size` de `B` de 0x21 para 0x41.
* Agora temos `B` contendo o chunk livre `C`.
* Liberar `B` e alocar um chunk de 0x40 (ele ser√° colocado aqui novamente).
* Podemos modificar o ponteiro `fd` de `C`, que ainda est√° livre (envenenamento do Tcache).

### Ataque off-by-null

* 3 chunks de mem√≥ria (a, b, c) s√£o reservados um ap√≥s o outro. Em seguida, o do meio √© liberado. O primeiro cont√©m uma vulnerabilidade de off by one e o atacante a abusa com um 0x00 (se o byte anterior fosse 0x10, isso faria o chunk do meio indicar que √© 0x10 menor do que realmente √©).
* Em seguida, mais 2 chunks menores s√£o alocados no chunk liberado do meio (b), no entanto, como `b + b->size` nunca atualiza o chunk c porque o endere√ßo apontado √© menor do que deveria.
* Ent√£o, b1 e c s√£o liberados. Como `c - c->prev_size` ainda aponta para b (b1 agora), ambos s√£o consolidados em um chunk. No entanto, b2 ainda est√° entre b1 e c.
* Finalmente, um novo malloc √© realizado reclamando esta √°rea de mem√≥ria que na verdade vai conter b2, permitindo que o propriet√°rio do novo malloc controle o conte√∫do de b2.

Esta imagem explica perfeitamente o ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Outros Exemplos & Refer√™ncias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one devido ao `strlen` considerar o campo `size` do pr√≥ximo chunk.
* Tcache est√° sendo usado, ent√£o um ataque geral off-by-one funciona para obter uma primitiva de escrita arbitr√°ria com envenenamento do Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √â poss√≠vel abusar de um off by one para vazar um endere√ßo do heap porque o byte 0x00 do final de uma string est√° sendo sobrescrito pelo pr√≥ximo campo.
* A escrita arbitr√°ria √© obtida abusando da escrita off by one para fazer o ponteiro apontar para outro lugar onde uma estrutura falsa com ponteiros falsos ser√° constru√≠da. Em seguida, √© poss√≠vel seguir o ponteiro desta estrutura para obter escrita arbitr√°ria.
* O endere√ßo da libc √© vazado porque se o heap for estendido usando mmap, a mem√≥ria alocada por mmap tem um deslocamento fixo em rela√ß√£o √† libc.
* Finalmente, a escrita arbitr√°ria √© abusada para escrever no endere√ßo de \_\_free\_hook com um one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* H√° uma vulnerabilidade de off by one NULL na fun√ß√£o `getline` que l√™ linhas de entrada do usu√°rio. Esta fun√ß√£o √© usada para ler a "chave" do conte√∫do e n√£o o conte√∫do.
* No writeup, 5 chunks iniciais s√£o criados:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) para evitar a consolida√ß√£o com o top chunk.
* Ent√£o, os chunks 1, 5 e 3 s√£o liberados, ent√£o:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Ent√£o, abusando do chunk3 (0x1f8), o off-by-one nulo √© abusado escrevendo o prev\_size para `0x4e0`.
* Note como os tamanhos dos chunks inicialmente alocados 1, 2, 5 e 3 mais os cabe√ßalhos de 4 desses chunks somam `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Em seguida, o chunk 4 √© liberado, gerando um chunk que consome todos os chunks at√© o in√≠cio:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Ent√£o, `0x200` bytes s√£o alocados preenchendo o chunk original 1.
* E mais 0x200 bytes s√£o alocados e o chunk2 √© destru√≠do e, portanto, n√£o h√° vazamento e isso n√£o funciona? Talvez isso n√£o devesse ser feito.
* Em seguida, aloca outro chunk com 0x58 "a"s (sobrescrevendo o chunk2 e alcan√ßando o chunk5) e modifica o `fd` do chunk de fast bin do chunk5 apontando para `__malloc_hook`.
* Em seguida, um chunk de 0x68 √© alocado para que o chunk de fast bin falso em `__malloc_hook` seja o pr√≥ximo chunk de fast bin.
* Finalmente, um novo chunk de fast bin de 0x68 √© alocado e `__malloc_hook` √© sobrescrito com um endere√ßo de `one_gadget`.

{% hint style="success" %}
Aprenda e pratique AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-nos no** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
