# Afstand van een oorvloed

{% hint style="success" %}
Leer en oefen AWS-hacking: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer en oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Controleer de [**abonnementsplannen**](https://github.com/sponsors/carlospolop)!
* **Sluit je aan bij de** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of de [**telegramgroep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktrucs door PR's in te dienen bij de** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
{% endhint %}

## Basiese Inligting

As 'n aanvaller net toegang het tot 'n 1B-oorvloed, kan dit die `grootte`-veld van die volgende blok wysig. Dit maak dit moontlik om te manipuleer watter blokke eintlik vrygestel word, wat moontlik 'n blok genereer wat 'n ander legitieme blok bevat. Die uitbuiting is soortgelyk aan [dubbele vrystelling](double-free.md) of oorvleuelende blokke.

Daar is 2 tipes afstand van een kwesbaarhede:

* Willekeurige byte: Hierdie soort maak dit moontlik om daardie byte met enige waarde te oorskryf
* Nul byte (afstand-van-nul): Hierdie soort maak dit moontlik om daardie byte slegs met 0x00 te oorskryf
* 'n Algemene voorbeeld van hierdie kwesbaarheid kan gesien word in die volgende kode waar die gedrag van `strlen` en `strcpy` inkonsekwent is, wat dit moontlik maak om 'n 0x00 byte aan die begin van die volgende blok in te stel.
* Dit kan uitgebuit word met die [House of Einherjar](house-of-einherjar.md).
* As Tcache gebruik word, kan dit uitgebuit word tot 'n [dubbele vrystelling](double-free.md) situasie.

<details>

<summary>Afstand-van-nul</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Onder andere kontroles, word nou elke keer as 'n stuk vrygelaat word, die vorige grootte vergelyk met die grootte wat in die metadata se stuk geconfigureer is, wat hierdie aanval redelik kompleks maak vanaf weergawe 2.28.

### Kodevoorbeeld:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Hierdie aanval werk nie meer as gevolg van die gebruik van Tcaches nie.
* Verder, as jy probeer om dit te misbruik deur groter stukke te gebruik (sodat tcaches nie betrokke is nie), sal jy die fout kry: `malloc(): invalid next size (unsorted)`

### Doel

* Maak 'n stuk binne 'n ander stuk sodat skryftoegang oor daardie tweede stuk toelaat om die ingeslote een te oorskryf

### Vereistes

* Off by one-oorvloei om die grootte metadata-inligting te wysig

### Algemene off-by-one-aanval

* Allokeer drie stukke `A`, `B` en `C` (s√™ groottes 0x20), en nog een om konsolidasie met die boonste stuk te voorkom.
* Maak `C` vry (ingevoeg in 0x20 Tcache-vrylys).
* Gebruik stuk `A` om oor te vloei na `B`. Misbruik off-by-one om die `grootte`-veld van `B` te wysig van 0x21 na 0x41.
* Nou het ons `B` wat die vrye stuk `C` bevat
* Maak `B` vry en allokeer 'n 0x40-stuk (dit sal weer hier geplaas word)
* Ons kan die `fd`-aanwyser van `C` wysig, wat nog steeds vry is (Tcache-vergiftiging)

### Off-by-null-aanval

* 3 stukke geheue (a, b, c) word een na die ander gereserveer. Dan word die middelste een vrygelaat. Die eerste een bevat 'n off by one-oorvloei kwesbaarheid en die aanvaller misbruik dit met 'n 0x00 (as die vorige byte 0x10 was, sou dit die middelste stuk aandui dat dit 0x10 kleiner is as wat dit werklik is).
* Dan word nog 2 kleiner stukke toegewys in die middelste vrygemaakte stuk (b), maar aangesien `b + b->grootte` nooit die c-stuk opdateer nie omdat die aangewese adres kleiner is as wat dit behoort te wees.
* Dan word b1 en c vrygelaat. Aangesien `c - c->prev_size` steeds na b wys (nou b1), word beide gekonsolideer in een stuk. Tog is b2 nog binne in tussen b1 en c.
* Laastens word 'n nuwe malloc uitgevoer wat hierdie geheuegebied herwin wat eintlik b2 gaan bevat, wat die eienaar van die nuwe malloc toelaat om die inhoud van b2 te beheer.

Hierdie beeld verduidelik perfek die aanval:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Ander Voorbeelde & Verwysings

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one as gevolg van `strlen` wat die volgende stuk se `grootte`-veld oorweeg.
* Tcache word gebruik, so 'n algemene off-by-one-aanvalle werk om 'n willekeurige skryfprimitief met Tcache-vergiftiging te kry.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Dit is moontlik om 'n off by one te misbruik om 'n adres van die heap te lek omdat die byte 0x00 aan die einde van 'n string oorskryf word deur die volgende veld.
* Willekeurige skryf word verkry deur die off by one-skryf te misbruik om die aanwyser te maak wat na 'n ander plek wys waar 'n vals struktuur met valse aanwysers gebou sal word. Dan is dit moontlik om die aanwyser van hierdie struktuur te volg om willekeurige skryf te verkry.
* Die libc-adres word gelek omdat as die heap uitgebrei word deur mmap te gebruik, het die geheue wat deur mmap toegewys is 'n vaste verskuiwing vanaf libc.
* Laastens word die willekeurige skryf misbruik om in die adres van \_\_free\_hook te skryf met 'n een gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Daar is 'n NULL off by one-kwesbaarheid in die `getline`-funksie wat gebruikersinvoerlyne lees. Hierdie funksie word gebruik om die "sleutel" van die inhoud te lees en nie die inhoud nie.
* In die writeup word 5 aanvanklike stukke geskep:
* stuk1 (0x200)
* stuk2 (0x50)
* stuk5 (0x68)
* stuk3 (0x1f8)
* stuk4 (0xf0)
* stuk verdediging (0x400) om konsolidasie met die boonste stuk te voorkom
* Dan word stuk 1, 5 en 3 vrygelaat, so:
* ```python
[ 0x200 Stuk 1 (vry) ] [ 0x50 Stuk 2 ] [ 0x68 Stuk 5 (vry) ] [ 0x1f8 Stuk 3 (vry) ] [ 0xf0 Stuk 4 ] [ 0x400 Stuk verdediging ]
```
* Dan word die null off-by-one misbruik deur stuk3 (0x1f8) te misbruik deur die prev\_size na `0x4e0` te skryf.
* Let op hoe die groottes van die aanvanklik toegewysde stukke 1, 2, 5 en 3 plus die koppe van 4 van daardie stukke gelyk is aan `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Dan word stuk 4 vrygelaat, wat 'n stuk genereer wat al die stukke tot by die begin verbruik:
* ```python
[ 0x4e0 Stuk 1-2-5-3 (vry) ] [ 0xf0 Stuk 4 (beskadig) ] [ 0x400 Stuk verdediging ]
```
* ```python
[ 0x200 Stuk 1 (vry) ] [ 0x50 Stuk 2 ] [ 0x68 Stuk 5 (vry) ] [ 0x1f8 Stuk 3 (vry) ] [ 0xf0 Stuk 4 ] [ 0x400 Stuk verdediging ]
```
* Dan word `0x200` byte toegewys wat die oorspronklike stuk 1 vul
* En nog 0x200 byte word toegewys en stuk2 word vernietig en daar is dus geen lek nie en dit werk nie? Miskien moet dit nie gedoen word nie
* Dan word 'n ander stuk met 0x58 "a"s toegewys (wat stuk2 oorskryf en stuk5 bereik) en die `fd` van die vinnige bin-stuk van stuk5 word gewysig sodat dit na `__malloc_hook` wys
* Dan word 'n stuk van 0x68 toegewys sodat die vals vinnige bin-stuk in `__malloc_hook` die volgende vinnige bin-stuk is
* Laastens word 'n nuwe vinnige bin-stuk van 0x68 toegewys en `__malloc_hook` word oorskryf met 'n `one_gadget`-adres

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
