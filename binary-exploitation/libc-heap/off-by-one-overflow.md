# Off by one overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Grundinformationen

Der Zugriff auf einen 1B Overflow erm√∂glicht es einem Angreifer, das `size`-Feld des n√§chsten Chunks zu √§ndern. Dies erm√∂glicht es, zu manipulieren, welche Chunks tats√§chlich freigegeben werden, was potenziell einen Chunk erzeugt, der einen anderen legitimen Chunk enth√§lt. Die Ausnutzung ist √§hnlich wie bei [double free](double-free.md) oder √ºberlappenden Chunks.

Es gibt 2 Arten von Off-by-One-Sicherheitsanf√§lligkeiten:

* Arbitrary byte: Diese Art erlaubt es, dieses Byte mit einem beliebigen Wert zu √ºberschreiben.
* Null byte (off-by-null): Diese Art erlaubt es, dieses Byte nur mit 0x00 zu √ºberschreiben.
* Ein h√§ufiges Beispiel f√ºr diese Sicherheitsanf√§lligkeit kann im folgenden Code gesehen werden, wo das Verhalten von `strlen` und `strcpy` inkonsistent ist, was es erm√∂glicht, ein 0x00-Byte am Anfang des n√§chsten Chunks zu setzen.
* Dies kann mit dem [House of Einherjar](house-of-einherjar.md) ausgenutzt werden.
* Wenn Tcache verwendet wird, kann dies zu einer [double free](double-free.md) Situation ausgenutzt werden.

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Unter anderen √úberpr√ºfungen wird jetzt, wann immer ein Chunk freigegeben wird, die vorherige Gr√∂√üe mit der in den Metadaten des Chunks konfigurierten Gr√∂√üe verglichen, was diesen Angriff ab Version 2.28 recht komplex macht.

### Codebeispiel:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Dieser Angriff funktioniert nicht mehr aufgrund der Verwendung von Tcaches.
* Dar√ºber hinaus, wenn Sie versuchen, es mit gr√∂√üeren Chunks auszunutzen (so dass Tcaches nicht beteiligt sind), erhalten Sie den Fehler: `malloc(): invalid next size (unsorted)`

### Ziel

* Einen Chunk in einen anderen Chunk einzuf√ºgen, sodass der Schreibzugriff auf diesen zweiten Chunk es erm√∂glicht, den enthaltenen zu √ºberschreiben.

### Anforderungen

* Off-by-one-Overflow, um die Gr√∂√üenmetadateninformationen zu √§ndern.

### Allgemeiner Off-by-One-Angriff

* Drei Chunks `A`, `B` und `C` (sagen wir Gr√∂√üen 0x20) zuweisen und einen weiteren, um die Konsolidierung mit dem Top-Chunk zu verhindern.
* `C` freigeben (in die 0x20 Tcache-Freiliste eingef√ºgt).
* Chunk `A` verwenden, um auf `B` zu √ºberlaufen. Off-by-one ausnutzen, um das `size`-Feld von `B` von 0x21 auf 0x41 zu √§ndern.
* Jetzt haben wir `B`, das den freien Chunk `C` enth√§lt.
* `B` freigeben und einen 0x40 Chunk zuweisen (er wird hier wieder platziert).
* Wir k√∂nnen den `fd`-Zeiger von `C` √§ndern, der immer noch frei ist (Tcache-Poisoning).

### Off-by-Null-Angriff

* 3 Chunks Speicher (a, b, c) werden nacheinander reserviert. Dann wird der mittlere freigegeben. Der erste enth√§lt eine Off-by-One-Overflow-Schwachstelle, und der Angreifer nutzt dies mit einem 0x00 aus (wenn das vorherige Byte 0x10 war, w√ºrde es den mittleren Chunk anzeigen, dass er 0x10 kleiner ist, als er tats√§chlich ist).
* Dann werden 2 weitere kleinere Chunks im freigegebenen Chunk (b) zugewiesen, jedoch wird `b + b->size` den Chunk c nie aktualisieren, da die angegebene Adresse kleiner ist, als sie sein sollte.
* Dann werden b1 und c freigegeben. Da `c - c->prev_size` immer noch auf b (jetzt b1) zeigt, werden beide in einem Chunk konsolidiert. b2 befindet sich jedoch immer noch zwischen b1 und c.
* Schlie√ülich wird ein neues malloc durchgef√ºhrt, das diesen Speicherbereich zur√ºckgewinnt, der tats√§chlich b2 enthalten wird, wodurch der Besitzer des neuen malloc den Inhalt von b2 kontrollieren kann.

Dieses Bild erkl√§rt den Angriff perfekt:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Weitere Beispiele & Referenzen

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one aufgrund von `strlen`, das das `size`-Feld des n√§chsten Chunks ber√ºcksichtigt.
* Tcache wird verwendet, sodass ein allgemeiner Off-by-One-Angriff funktioniert, um eine willk√ºrliche Schreibprimitive mit Tcache-Poisoning zu erhalten.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es ist m√∂glich, einen Off-by-One auszunutzen, um eine Adresse aus dem Heap zu leaken, da das Byte 0x00 am Ende eines Strings vom n√§chsten Feld √ºberschrieben wird.
* Willk√ºrliches Schreiben wird durch den Missbrauch des Off-by-One-Schreibens erreicht, um den Zeiger auf einen anderen Ort zu lenken, an dem eine gef√§lschte Struktur mit gef√§lschten Zeigern erstellt wird. Dann ist es m√∂glich, dem Zeiger dieser Struktur zu folgen, um willk√ºrlich zu schreiben.
* Die libc-Adresse wird geleakt, weil, wenn der Heap mit mmap erweitert wird, der von mmap zugewiesene Speicher einen festen Offset von libc hat.
* Schlie√ülich wird das willk√ºrliche Schreiben ausgenutzt, um in die Adresse von \_\_free\_hook mit einem One-Gadget zu schreiben.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Es gibt eine NULL Off-by-One-Schwachstelle in der Funktion `getline`, die Benutzereingabezeilen liest. Diese Funktion wird verwendet, um den "Schl√ºssel" des Inhalts und nicht den Inhalt selbst zu lesen.
* Im Writeup werden 5 anf√§ngliche Chunks erstellt:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400), um die Konsolidierung mit dem Top-Chunk zu vermeiden.
* Dann werden Chunk 1, 5 und 3 freigegeben, sodass:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Dann wird Chunk3 (0x1f8) ausgenutzt, um den null Off-by-One auszunutzen, indem `prev_size` auf `0x4e0` geschrieben wird.
* Beachten Sie, wie die Gr√∂√üen der urspr√ºnglich zugewiesenen Chunks 1, 2, 5 und 3 sowie die Header von 4 dieser Chunks gleich `0x4e0` sind:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Dann wird Chunk 4 freigegeben, wodurch ein Chunk entsteht, der alle Chunks bis zum Anfang verbraucht:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Dann werden `0x200` Bytes zugewiesen, die den urspr√ºnglichen Chunk 1 f√ºllen.
* Und weitere 0x200 Bytes werden zugewiesen, und Chunk2 wird zerst√∂rt, und daher gibt es keinen fucking leak und das funktioniert nicht? Vielleicht sollte das nicht gemacht werden.
* Dann wird ein weiterer Chunk mit 0x58 "a"s zugewiesen (der Chunk2 √ºberschreibt und Chunk5 erreicht) und √§ndert den `fd` des Fast-Bin-Chunks von Chunk5, sodass er auf `__malloc_hook` zeigt.
* Dann wird ein Chunk von 0x68 zugewiesen, sodass der gef√§lschte Fast-Bin-Chunk in `__malloc_hook` der folgende Fast-Bin-Chunk ist.
* Schlie√ülich wird ein neuer Fast-Bin-Chunk von 0x68 zugewiesen und `__malloc_hook` wird mit einer `one_gadget`-Adresse √ºberschrieben.

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
