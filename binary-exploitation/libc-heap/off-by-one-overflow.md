# Desbordamiento por uno

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

## Informaci칩n B치sica

Tener acceso a un desbordamiento de 1B permite a un atacante modificar el campo `size` del siguiente chunk. Esto permite manipular qu칠 chunks est치n realmente liberados, potencialmente generando un chunk que contiene otro chunk leg칤timo. La explotaci칩n es similar a [double free](double-free.md) o chunks superpuestos.

Hay 2 tipos de vulnerabilidades de desbordamiento por uno:

* Byte arbitrario: Este tipo permite sobrescribir ese byte con cualquier valor.
* Byte nulo (off-by-null): Este tipo permite sobrescribir ese byte solo con 0x00.
* Un ejemplo com칰n de esta vulnerabilidad se puede ver en el siguiente c칩digo donde el comportamiento de `strlen` y `strcpy` es inconsistente, lo que permite establecer un byte 0x00 al principio del siguiente chunk.
* Esto puede ser explotado con la [House of Einherjar](house-of-einherjar.md).
* Si se usa Tcache, esto puede aprovecharse para una situaci칩n de [double free](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre otras verificaciones, ahora cada vez que un bloque se libera, el tama침o anterior se compara con el tama침o configurado en el bloque de metadatos, lo que hace que este ataque sea bastante complejo a partir de la versi칩n 2.28.

### Ejemplo de c칩digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque ya no funciona debido al uso de Tcaches.
* Adem치s, si intentas abusar de 칠l usando bloques m치s grandes (para que no se involucren los tcaches), recibir치s el error: `malloc(): invalid next size (unsorted)`

### Objetivo

* Hacer que un bloque est칠 contenido dentro de otro bloque, de modo que el acceso de escritura sobre ese segundo bloque permita sobrescribir el contenido del primero.

### Requisitos

* Desbordamiento off by one para modificar la informaci칩n de metadatos del tama침o.

### Ataque general off-by-one

* Asignar tres bloques `A`, `B` y `C` (digamos tama침os 0x20), y otro para evitar la consolidaci칩n con el bloque superior.
* Liberar `C` (insertado en la lista de bloques libres de 0x20 Tcache).
* Usar el bloque `A` para desbordar sobre `B`. Abusar del off-by-one para modificar el campo `size` de `B` de 0x21 a 0x41.
* Ahora tenemos `B` conteniendo el bloque libre `C`.
* Liberar `B` y asignar un bloque de 0x40 (se colocar치 aqu칤 nuevamente).
* Podemos modificar el puntero `fd` de `C`, que sigue estando libre (envenenamiento de Tcache).

### Ataque off-by-null

* Se reservan 3 bloques de memoria (a, b, c) uno tras otro. Luego se libera el del medio. El primero contiene una vulnerabilidad de desbordamiento off by one y el atacante abusa de ella con un 0x00 (si el byte anterior era 0x10, har칤a que el bloque del medio indicara que es 0x10 m치s peque침o de lo que realmente es).
* Luego, se asignan 2 bloques m치s peque침os en el bloque liberado del medio (b), sin embargo, como `b + b->size` nunca actualiza el bloque c porque la direcci칩n apuntada es m치s peque침a de lo que deber칤a.
* Luego, b1 y c se liberan. Como `c - c->prev_size` a칰n apunta a b (b1 ahora), ambos se consolidan en un solo bloque. Sin embargo, b2 sigue estando entre b1 y c.
* Finalmente, se realiza un nuevo malloc reclamando esta 치rea de memoria que en realidad contendr치 b2, permitiendo al propietario del nuevo malloc controlar el contenido de b2.

Esta imagen explica perfectamente el ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Otros Ejemplos y Referencias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one debido a que `strlen` considera el campo `size` del siguiente bloque.
* Se est치 utilizando Tcache, por lo que un ataque general off-by-one funciona para obtener una primitiva de escritura arbitraria con envenenamiento de Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es posible abusar de un off by one para filtrar una direcci칩n del heap porque el byte 0x00 al final de una cadena est치 siendo sobrescrito por el siguiente campo.
* La escritura arbitraria se obtiene abusando del off by one para hacer que el puntero apunte a otro lugar donde se construir치 una estructura falsa con punteros falsos. Luego, es posible seguir el puntero de esta estructura para obtener escritura arbitraria.
* La direcci칩n de libc se filtra porque si el heap se extiende usando mmap, la memoria asignada por mmap tiene un desplazamiento fijo desde libc.
* Finalmente, se abusa de la escritura arbitraria para escribir en la direcci칩n de \_\_free\_hook con un one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Hay una vulnerabilidad off by one NULL en la funci칩n `getline` que lee l칤neas de entrada del usuario. Esta funci칩n se utiliza para leer la "clave" del contenido y no el contenido.
* En el informe se crean 5 bloques iniciales:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) para evitar la consolidaci칩n con el bloque superior.
* Luego, se liberan los bloques 1, 5 y 3, as칤 que:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Luego, abusando del chunk3 (0x1f8), se abusa del off-by-one nulo escribiendo el prev\_size a `0x4e0`.
* Nota c칩mo los tama침os de los bloques inicialmente asignados 1, 2, 5 y 3 m치s los encabezados de 4 de esos bloques suman `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Luego, se libera el bloque 4, generando un bloque que consume todos los bloques hasta el principio:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Luego, se asignan `0x200` bytes llenando el bloque original 1.
* Y se asignan otros 0x200 bytes y se destruye el chunk2 y por lo tanto no hay ninguna filtraci칩n y esto no funciona? Quiz치s esto no deber칤a hacerse.
* Luego, se asigna otro bloque con 0x58 "a"s (sobrescribiendo chunk2 y alcanzando chunk5) y se modifica el `fd` del bloque r치pido de chunk5 apuntando a `__malloc_hook`.
* Luego, se asigna un bloque de 0x68 para que el bloque r치pido falso en `__malloc_hook` sea el siguiente bloque r치pido.
* Finalmente, se asigna un nuevo bloque r치pido de 0x68 y `__malloc_hook` se sobrescribe con una direcci칩n de `one_gadget`.

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
