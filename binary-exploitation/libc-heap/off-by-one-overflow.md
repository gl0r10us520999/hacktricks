# Przepełnienie o jeden

{% hint style="success" %}
Dowiedz się i ćwicz hakowanie AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz hakowanie GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
{% endhint %}

## Podstawowe informacje

Mając dostęp tylko do przepełnienia o jeden bajt, atakujący może modyfikować pole `size` z następnego fragmentu. Pozwala to manipulować, które fragmenty są faktycznie zwalniane, potencjalnie generując fragment zawierający inny prawidłowy fragment. Wykorzystanie jest podobne do [podwójnego zwalniania pamięci](double-free.md) lub nakładających się fragmentów.

Istnieją 2 rodzaje podatności na przepełnienie o jeden:

* Dowolny bajt: Ten rodzaj pozwala nadpisać ten bajt dowolną wartością
* Bajt zerowy (off-by-null): Ten rodzaj pozwala nadpisać ten bajt tylko wartością 0x00
* Powszechnym przykładem tej podatności jest poniższy kod, w którym zachowanie `strlen` i `strcpy` jest niekonsekwentne, co pozwala ustawić bajt 0x00 na początku następnego fragmentu.
* Można to wykorzystać za pomocą [House of Einherjar](house-of-einherjar.md).
* Jeśli używany jest Tcache, można to wykorzystać do sytuacji [podwójnego zwalniania pamięci](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Wśród innych sprawdzeń, teraz za każdym razem, gdy kawałek jest zwalniany, rozmiar poprzedni jest porównywany z rozmiarem skonfigurowanym w metadanych kawałka, co sprawia, że ten atak jest dość skomplikowany od wersji 2.28.

### Przykład kodu:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ten atak już nie działa ze względu na użycie Tcaches.
* Ponadto, jeśli spróbujesz go wykorzystać, używając większych kawałków (aby tcaches nie były zaangażowane), otrzymasz błąd: `malloc(): invalid next size (unsorted)`

### Cel

* Umieść kawałek wewnątrz innego kawałka, dzięki czemu dostęp do zapisu na ten drugi kawałek pozwala nadpisać zawarty w nim kawałek

### Wymagania

* Przepełnienie o jeden, aby zmodyfikować informacje o metadanych rozmiaru

### Ogólny atak off-by-one

* Zaalokuj trzy kawałki `A`, `B` i `C` (powiedzmy rozmiary 0x20), oraz kolejny, aby zapobiec konsolidacji z kawałkiem górnym.
* Zwolnij `C` (wstawiony do listy wolnych Tcache 0x20).
* Użyj kawałka `A`, aby przepełnić `B`. Wykorzystaj off-by-one, aby zmodyfikować pole `size` `B` z 0x21 na 0x41.
* Teraz mamy `B` zawierający wolny kawałek `C`
* Zwolnij `B` i zaalokuj kawałek 0x40 (zostanie tu ponownie umieszczony)
* Możemy zmodyfikować wskaźnik `fd` z `C`, który nadal jest wolny (zatrucie Tcache)

### Atak off-by-null

* Rezerwuje się 3 kawałki pamięci (a, b, c) jeden po drugim. Następnie środkowy jest zwalniany. Pierwszy zawiera podatność na przepełnienie o jeden, a atakujący ją z 0x00 (jeśli poprzedni bajt był 0x10, sprawi, że środkowy kawałek wskaże, że jest o 0x10 mniejszy, niż naprawdę jest).
* Następnie, w środku zwolnionego kawałka (b) są przydzielane 2 mniejsze kawałki, jednakże, ponieważ `b + b->size` nigdy nie aktualizuje kawałka c, ponieważ adres wskazywany jest mniejszy, niż powinien.
* Następnie, b1 i c są zwalniane. Ponieważ `c - c->prev_size` wciąż wskazuje na b (teraz b1), oba są konsolidowane w jeden kawałek. Jednakże, b2 nadal znajduje się wewnątrz pomiędzy b1 i c.
* W końcu, wykonywane jest nowe przydział pamięci malloc, odzyskując ten obszar pamięci, który faktycznie będzie zawierał b2, pozwalając właścicielowi nowego malloc kontrolować zawartość b2.

To zdjęcie doskonale wyjaśnia atak:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Inne Przykłady & Referencje

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one z powodu `strlen` uwzględniający pole `size` następnego kawałka.
* Używany jest Tcache, więc ogólne ataki off-by-one działają, aby uzyskać arbitralne pisanie zatruciem Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Możliwe jest wykorzystanie off-by-one do wycieku adresu z heap, ponieważ bajt 0x00 na końcu łańcucha znaków jest nadpisywany przez następne pole.
* Pisanie arbitralne jest uzyskiwane poprzez wykorzystanie off-by-one write, aby wskaźnik wskazywał na inne miejsce, gdzie zostanie zbudowana fałszywa struktura z fałszywymi wskaźnikami. Następnie możliwe jest śledzenie wskaźnika tej struktury, aby uzyskać arbitralne pisanie.
* Adres libc jest wyciekany, ponieważ jeśli sterta jest rozszerzana za pomocą mmap, pamięć przydzielona przez mmap ma stały przesunięcie od libc.
* W końcu, arbitralne pisanie jest wykorzystywane do zapisania w adresie \_\_free\_hook z jednym gadżetem.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Istnieje podatność NULL off-by-one w funkcji `getline`, która czyta linie wejściowe użytkownika. Ta funkcja służy do odczytywania "klucza" zawartości, a nie samej zawartości.
* **Udostępniaj sztuczki hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów na GitHubie.**
