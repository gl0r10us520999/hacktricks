# Kujaza kwa kosa moja

{% hint style="success" %}
Jifunze & zoezi AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Timu Nyekundu Mtaalam (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & zoezi GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Timu Nyekundu Mtaalam (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Taarifa Msingi

Kwa kupata kujaza 1B tu, mshambuliaji anaweza kubadilisha uga wa `size` kutoka kwa kipande kinachofuata. Hii inaruhusu kuharibu ni vipande vipi ambavyo kimsingi vinaweza kuachiliwa, ikisababisha kipande kinachojumuisha kipande kingine halali. Udukuzi huu ni sawa na [kufungua mara mbili](double-free.md) au vipande vinavyopishana.

Kuna aina 2 za udhaifu wa kujaza kwa kosa moja:

* Bayt ya kiholela: Aina hii inaruhusu kubadilisha bayt hiyo na thamani yoyote
* Bayt ya Null (kujaza-kwa-null): Aina hii inaruhusu kubadilisha bayt hiyo tu na 0x00
* Mfano wa kawaida wa udhaifu huu unaweza kuonekana kwenye nambari ifuatayo ambapo tabia ya `strlen` na `strcpy` ni tofauti, ambayo inaruhusu kuweka bayt ya 0x00 mwanzoni mwa kipande kinachofuata.
* Hii inaweza kudukuliwa na [Nyumba ya Einherjar](house-of-einherjar.md).
* Ikiwa unatumia Tcache, hii inaweza kutumika kwa hali ya [kufungua mara mbili](double-free.md). 

<details>

<summary>Kujaza-kwa-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Miongoni mwa ukaguzi mwingine, sasa kila wakati kipande kinapokuwa huru ukubwa wa awali unalinganishwa na ukubwa uliowekwa katika kipande cha metadata, hii inafanya shambulio hili kuwa ngumu kutoka kwa toleo la 2.28.

### Mfano wa Kanuni:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Shambulio hili halifanyi kazi tena kutokana na matumizi ya Tcaches.
* Zaidi ya hayo, ukijaribu kulitumia kwa kutumia vipande vikubwa (hivyo tcaches havihusiki), utapata kosa: `malloc(): invalid next size (unsorted)`

### Lengo

* Fanya kipande kiwe kimejumuishwa ndani ya kipande kingine ili upate ufikiaji wa kuandika juu ya kipande cha pili kuruhusu kubadilisha kile kilichomo

### Mahitaji

* Kuvuja kwa kipande kimoja ili kurekebisha habari ya metadata ya ukubwa

### Shambulio la kawaida la off-by-one

* Tenga vipande vitatu `A`, `B` na `C` (semaje ukubwa 0x20), na kingine kuzuia kujumuishwa na kipande cha juu.
* Fungua `C` (imeingizwa kwenye orodha ya Tcache ya 0x20).
* Tumia kipande `A` kumwaga kwenye `B`. Tumia off-by-one kubadilisha uga wa `ukubwa` wa `B` kutoka 0x21 hadi 0x41.
* Sasa tuna `B` inayojumuisha kipande huru `C`
* Fungua `B` na tenganisha kipande cha 0x40 (kitawekwa hapa tena)
* Tunaweza kubadilisha kielekezi cha `fd` kutoka kwa `C`, ambayo bado ni huru (Tcache poisoning)

### Shambulio la off-by-null

* Vipande 3 vya kumbukumbu (a, b, c) vinahifadhiwa mfululizo. Kisha kati yake inafutwa. Cha kwanza kina kasoro ya kumwaga kwa moja na muhusika anaitumia na 0x00 (ikiwa kibajeti kilichopita kilikuwa 0x10 itafanya kipande cha kati kiashiria kuwa ni kidogo kwa 0x10 kuliko ilivyo kweli).
* Kisha, vipande vidogo 2 zaidi vinatengwa katika kipande kilichofutwa kati (b), hata hivyo, kama `b + b->ukubwa` kamwe haifanyi kipande c kwa sababu anwani iliyoelekezwa ni ndogo kuliko inavyopaswa.
* Kisha, b1 na c vinatengwa. Kwa kuwa `c - c->ukubwa_uliotangulia` bado inaelekeza kwa b (sasa b1), vyote viunganishwa katika kipande kimoja. Hata hivyo, b2 bado iko ndani kati ya b1 na c.
* Hatimaye, malloc mpya inafanywa kurudisha eneo hili la kumbukumbu ambalo kimsingi litakuwa na b2, kuruhusu mmiliki wa malloc mpya kudhibiti maudhui ya b2.

Picha hii inaelezea kikamilifu shambulio:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Mifano na Marejeleo Mengine

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one kwa sababu ya `strlen` inayozingatia uga wa `ukubwa` wa kipande cha pili.
* Tcache inatumika, hivyo mashambulio ya kawaida ya off-by-one yanafanya kazi kupata msingi wa kuandika wa kiholela na Tcache poisoning.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Inawezekana kutumia off-by-one kuvuja anwani kutoka kwa kipande cha kumbukumbu kwa sababu ya baiti 0x00 mwishoni mwa mnyororo inayobadilishwa na uga ufuatao.
* Kuandika kiholela kunapatikana kwa kutumia off-by-one kuunda kielekezi kionyeshe mahali pengine ambapo muundo wa uwongo na kielekezi cha uwongo vitajengwa. Kisha, inawezekana kufuata kielekezi cha muundo huu ili kupata kuandika kiholela.
* Anwani ya libc inavuja kwa sababu ikiwa kipande cha kumbukumbu kinaongezwa kwa kutumia mmap, kumbukumbu iliyotengwa na mmap ina mbadala wa kudumu kutoka kwa libc.
* Hatimaye kuandika kiholela kunatumika kuandika kwenye anwani ya \_\_free\_hook na kifaa cha moja.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Kuna udhaifu wa off-by-one wa NULL katika kazi ya `getline` inayosoma mistari ya mwingiliano wa mtumiaji. Kazi hii hutumika kusoma "funguo" ya maudhui na sio maudhui.
* Katika mwongozo 5 wa awali wa vipande vinavyoundwa:
* kipande1 (0x200)
* kipande2  (0x50)
* kipande5 (0x68)
* kipande3 (0x1f8)
* kipande4 (0xf0)
* ulinzi wa kipande (0x400) ili kuepuka kujumuishwa na kipande cha juu
* Kisha kipande 1, 5 na 3 vinatengwa, hivyo:
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Kipande la ulinzi ]
```
* Kisha kwa kutumia kipande3 (0x1f8) udhaifu wa off-by-null unatumika kuandika prev\_size hadi `0x4e0`.
* Angalia jinsi vipande vilivyotengwa awali vya kipande1, 2, 5 na 3 pamoja na vichwa vya 4 vya vipande hivyo vinavyolingana na `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Kisha, kipande 4 kinatengwa, kuzalisha kipande kinachotumia vipande vyote hadi mwanzo:
* ```python
[ 0x4e0 Kipande 1-2-5-3 (huru) ] [ 0xf0 Kipande 4 (haribika) ] [ 0x400 Kipande la ulinzi ]
```
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Kipande la ulinzi ]
```
* Kisha, `0x200` baiti zinatengwa kujaza kipande cha awali 1
* Na baiti nyingine 0x200 zinatengwa na kipande2 kuharibiwa na kwa hivyo hakuna uvujaji wa kufanya kazi na hii haifanyi kazi? Labda hii haipaswi kufanywa
* Kisha, inatenga kipande kingine na 0x58 "a"s (ikiharibu kipande2 na kufikia kipande5) na kubadilisha `fd` ya kipande cha bin haraka cha kipande5 ikielekeza kwa `__malloc_hook`
* Kisha, kipande cha 0x68 kinatengwa hivyo kipande cha bandia cha bin haraka katika `__malloc_hook` ni kipande cha bin haraka kinachofuata
* Hatimaye, kipande kipya cha bin haraka cha 0x68 kinatengwa na `__malloc_hook` inaharibiwa na anwani ya `one_gadget`

{% hint style="success" %}
Jifunze & fanye Mazoezi ya Kuvamia AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & fanye Mazoezi ya Kuvamia GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
