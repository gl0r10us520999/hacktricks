# Off by one overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Kuwa na ufikiaji wa overflow wa 1B inaruhusu mshambuliaji kubadilisha uwanja wa `size` kutoka kwa kipande kinachofuata. Hii inaruhusu kubadilisha ni vipande vipi ambavyo vimeachiliwa, na huenda ikazalisha kipande kinachojumuisha kipande kingine halali. Utekelezaji ni sawa na [double free](double-free.md) au vipande vinavyovutana.

Kuna aina 2 za udhaifu wa off by one:

* Byte isiyo na mpangilio: Aina hii inaruhusu kuandika byte hiyo kwa thamani yoyote
* Byte ya Null (off-by-null): Aina hii inaruhusu kuandika byte hiyo tu kwa 0x00
* Mfano wa kawaida wa udhaifu huu unaweza kuonekana katika msimbo ufuatao ambapo tabia ya `strlen` na `strcpy` haiko sawa, ambayo inaruhusu kuweka byte ya 0x00 mwanzoni mwa kipande kinachofuata.
* Hii inaweza kutumiwa na [House of Einherjar](house-of-einherjar.md).
* Ikiwa unatumia Tcache, hii inaweza kutumika katika hali ya [double free](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Kati ya ukaguzi mwingine, sasa kila wakati kipande kinapokuwa huru, ukubwa wa awali unalinganishwa na ukubwa uliowekwa katika metadata ya kipande, na kufanya shambulio hili kuwa gumu sana kuanzia toleo la 2.28.

### Mfano wa msimbo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Shambulio hili halifanyi kazi tena kutokana na matumizi ya Tcaches.
* Zaidi ya hayo, ikiwa unajaribu kulitumia kwa kutumia vipande vikubwa (hivyo tcaches hazihusiki), utapata kosa: `malloc(): invalid next size (unsorted)`

### Lengo

* Fanya kipande kiwe ndani ya kipande kingine ili kuandika ufikiaji juu ya kipande hicho cha pili kuruhusu kuandika juu ya kile kilichomo

### Mahitaji

* Off by one overflow kubadilisha taarifa za metadata ya ukubwa

### Shambulio la jumla la off-by-one

* Panga vipande vitatu `A`, `B` na `C` (sema ukubwa 0x20), na kingine ili kuzuia kuunganishwa na kipande cha juu.
* Fungua `C` (iliyoingizwa kwenye orodha ya bure ya 0x20 Tcache).
* Tumia kipande `A` kujaa kwenye `B`. Dhulumu off-by-one kubadilisha uwanja wa `size` wa `B` kutoka 0x21 hadi 0x41.
* Sasa tuna `B` inayoshikilia kipande huru `C`
* Fungua `B` na panga kipande cha 0x40 (kitakuwa kimewekwa hapa tena)
* Tunaweza kubadilisha kiashiria cha `fd` kutoka `C`, ambacho bado ni huru (Tcache poisoning)

### Shambulio la off-by-null

* Vipande 3 vya kumbukumbu (a, b, c) vinahifadhiwa moja baada ya nyingine. Kisha kipande cha kati kinafunguliwa. Kipande cha kwanza kina udhaifu wa off by one overflow na mshambuliaji anautumia kwa 0x00 (ikiwa byte ya awali ilikuwa 0x10 ingesababisha kipande cha kati kuonyesha kwamba ni 0x10 kidogo kuliko ilivyo).
* Kisha, vipande viwili vidogo zaidi vinapangwa katika kipande cha kati kilichofunguliwa (b), hata hivyo, kama `b + b->size` kamwe havisasisha kipande c kwa sababu anwani iliyoonyeshwa ni ndogo kuliko inavyopaswa.
* Kisha, b1 na c vinafunguliwa. Kama `c - c->prev_size` bado inaonyesha b (b1 sasa), vyote vinaundwa katika kipande kimoja. Hata hivyo, b2 bado kiko kati ya b1 na c.
* Hatimaye, malloc mpya inafanywa ikirejesha eneo hili la kumbukumbu ambalo kwa kweli litakuwa na b2, ikiruhusu mmiliki wa malloc mpya kudhibiti maudhui ya b2.

Picha hii inaelezea shambulio kwa ukamilifu:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Mifano Mingine & Marejeleo

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one kwa sababu ya `strlen` ikizingatia uwanja wa `size` wa kipande kinachofuata.
* Tcache inatumika, hivyo shambulio la jumla la off-by-one linafanya kazi kupata primitive ya kuandika isiyo na mipaka na Tcache poisoning.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Inawezekana kudhulumu off by one ili kuvuja anwani kutoka kwenye heap kwa sababu byte 0x00 ya mwisho wa mfuatano inayoandikwa na uwanja unaofuata.
* Kuandika isiyo na mipaka kunapatikana kwa kudhulumu kuandika off by one ili kufanya kiashiria kiashirie mahali pengine ambapo muundo wa uwongo na viashiria vya uwongo vitajengwa. Kisha, inawezekana kufuata kiashiria cha muundo huu ili kupata kuandika isiyo na mipaka.
* Anwani ya libc inavuja kwa sababu ikiwa heap inapanuliwa kwa kutumia mmap, kumbukumbu iliyopangwa na mmap ina offset iliyowekwa kutoka libc.
* Hatimaye, kuandika isiyo na mipaka kunadhulumiwa kuandika kwenye anwani ya \_\_free\_hook na gadget moja.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Kuna udhaifu wa NULL off by one katika kazi ya `getline` inayosoma mistari ya ingizo la mtumiaji. Kazi hii inatumika kusoma "funguo" ya maudhui na sio maudhui.
* Katika andiko la 5, vipande vya awali vinaundwa:
* kipande1 (0x200)
* kipande2  (0x50)
* kipande5 (0x68)
* kipande3 (0x1f8)
* kipande4 (0xf0)
* kipande cha ulinzi (0x400) ili kuepuka kuunganishwa na kipande cha juu
* Kisha kipande 1, 5 na 3 vinafunguliwa, hivyo:
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Kipande cha ulinzi ]
```
* Kisha kwa kudhulumu kipande3 (0x1f8) off-by-one ya null inadhulumiwa kuandika `prev_size` hadi `0x4e0`.
* Kumbuka jinsi ukubwa wa vipande vilivyopangwa awali 1, 2, 5 na 3 pamoja na vichwa vya vipande hivyo 4 vinavyolingana na `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Kisha, kipande 4 kinafunguliwa, kikizalisha kipande kinachotumia vipande vyote hadi mwanzo:
* ```python
[ 0x4e0 Kipande 1-2-5-3 (huru) ] [ 0xf0 Kipande 4 (kilichoharibiwa) ] [ 0x400 Kipande cha ulinzi ]
```
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Kipande cha ulinzi ]
```
* Kisha, `0x200` bytes zinapangwa zikijaza kipande cha awali 1
* Na nyingine 0x200 bytes zinapangwa na kipande2 kinaharibiwa na kwa hivyo hakuna kuvuja na hii haifanyi kazi? Labda hii haipaswi kufanywa
* Kisha, inapangilia kipande kingine chenye 0x58 "a"s (ikiandika kipande2 na kufikia kipande5) na kubadilisha `fd` ya kipande cha haraka cha kipande5 ikielekeza kwenye `__malloc_hook`
* Kisha, kipande cha 0x68 kinapangwa ili kipande cha haraka cha uwongo katika `__malloc_hook` kiwe kipande cha haraka kinachofuata
* Hatimaye, kipande kipya cha haraka cha 0x68 kinapangwa na `__malloc_hook` kinandikwa tena na anwani ya `one_gadget`

{% hint style="success" %}
Jifunze & fanya mazoezi ya AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & fanya mazoezi ya GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **fuata** sisi kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki hila za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
{% endhint %}
