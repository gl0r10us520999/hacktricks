# Off by one overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Sadece 1B overflow erişimine sahip olmak, bir saldırganın bir sonraki chunk'ın `size` alanını değiştirmesine olanak tanır. Bu, hangi chunk'ların gerçekten serbest bırakıldığını manipüle etmeyi sağlar ve potansiyel olarak başka bir geçerli chunk içeren bir chunk oluşturabilir. Sömürü, [double free](double-free.md) veya üst üste binen chunk'lar ile benzerdir.

İki tür off by one güvenlik açığı vardır:

* Keyfi byte: Bu tür, o byte'ı herhangi bir değerle üzerine yazmaya olanak tanır.
* Null byte (off-by-null): Bu tür, o byte'ı yalnızca 0x00 ile üzerine yazmaya olanak tanır.
* Bu güvenlik açığının yaygın bir örneği, `strlen` ve `strcpy` davranışının tutarsız olduğu aşağıdaki kodda görülebilir; bu, bir sonraki chunk'ın başında 0x00 byte'ı ayarlamaya olanak tanır.
* Bu, [House of Einherjar](house-of-einherjar.md) ile sömürülebilir.
* Tcache kullanılıyorsa, bu bir [double free](double-free.md) durumuna dönüştürülebilir.

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Diğer kontrollerin yanı sıra, artık bir parça serbest bırakıldığında, önceki boyut, meta verilerin parçasında yapılandırılan boyut ile karşılaştırılmaktadır, bu da bu saldırıyı 2.28 sürümünden itibaren oldukça karmaşık hale getirmektedir.

### Kod örneği:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Bu saldırı artık Tcaches kullanımı nedeniyle çalışmamaktadır.
* Ayrıca, daha büyük parçaları kullanarak bunu kötüye kullanmaya çalışırsanız (bu durumda tcaches dahil değildir), `malloc(): invalid next size (unsorted)` hatasını alırsınız.

### Hedef

* Bir parçanın başka bir parçanın içinde yer almasını sağlamak, böylece o ikinci parçaya yazma erişimi, içeridekini üzerine yazmaya izin verir.

### Gereksinimler

* Boyut meta verisi bilgisini değiştirmek için off by one overflow.

### Genel off-by-one saldırısı

* Üç parça `A`, `B` ve `C` (örneğin boyut 0x20) ayırın ve üst parçayla birleştirmeyi önlemek için başka bir parça ayırın.
* `C` parçasını serbest bırakın (0x20 Tcache serbest listesine eklenmiştir).
* `A` parçasını `B` üzerinde taşmak için kullanın. Off-by-one'ı kötüye kullanarak `B`'nin `size` alanını 0x21'den 0x41'e değiştirin.
* Artık `B`, serbest parça `C`'yi içermektedir.
* `B`'yi serbest bırakın ve 0x40 boyutunda bir parça ayırın (buraya tekrar yerleştirilecektir).
* Hala serbest olan `C`'nin `fd` işaretçisini değiştirebiliriz (Tcache zehirlenmesi).

### Off-by-null saldırısı

* 3 bellek parçası (a, b, c) ardışık olarak ayrılır. Ardından ortadaki parça serbest bırakılır. İlk parça bir off by one overflow açığı içerir ve saldırgan bunu 0x00 ile kötüye kullanır (önceki byte 0x10 olsaydı, ortadaki parça gerçekte olduğundan 0x10 daha küçük olduğunu gösterirdi).
* Ardından, ortada serbest bırakılan parçaya (b) 2 tane daha küçük parça ayrılır, ancak `b + b->size` asla c parçasını güncellemez çünkü işaret edilen adres olması gerekenin altındadır.
* Ardından, b1 ve c serbest bırakılır. `c - c->prev_size` hala b'ye (şimdi b1) işaret ettiğinden, her ikisi de tek bir parçada birleştirilir. Ancak, b2 hala b1 ve c arasında içtedir.
* Son olarak, bu bellek alanını geri almak için yeni bir malloc gerçekleştirilir ve bu alan aslında b2'yi içerecektir, bu da yeni malloc'un sahibinin b2'nin içeriğini kontrol etmesine izin verir.

Bu resim saldırıyı mükemmel bir şekilde açıklamaktadır:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Diğer Örnekler & Referanslar

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* `strlen`'in bir sonraki parçanın `size` alanını dikkate alması nedeniyle off-by-one.
* Tcache kullanılıyor, bu nedenle genel off-by-one saldırıları, Tcache zehirlenmesi ile keyfi yazma ilkesini elde etmek için çalışır.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Off by one'ı kötüye kullanarak heap'ten bir adres sızdırmak mümkündür çünkü bir dizeyi aşan 0x00 byte'ı, bir sonraki alan tarafından üzerine yazılmaktadır.
* Keyfi yazma, işaretçiyi başka bir yere işaret edecek şekilde sahte işaretçilerle sahte bir yapı oluşturmak için off by one yazma açığını kötüye kullanarak elde edilir. Ardından, bu yapının işaretçisini takip ederek keyfi yazma elde etmek mümkündür.
* libc adresi sızdırılır çünkü heap mmap kullanılarak genişletildiğinde, mmap tarafından tahsis edilen bellek libc'den sabit bir ofset ile ayrılmıştır.
* Son olarak, keyfi yazma, `__free\_hook` adresine bir gadget ile yazmak için kötüye kullanılır.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Kullanıcı girişi satırlarını okuyan `getline` fonksiyonunda bir NULL off by one açığı vardır. Bu fonksiyon, içeriğin "anahtarını" okumak için kullanılır ve içeriği değil.
* Yazımda 5 başlangıç parçası oluşturulur:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* üst parça ile birleştirmeyi önlemek için chunk defense (0x400)
* Ardından chunk 1, 5 ve 3 serbest bırakılır, böylece:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Ardından chunk3 (0x1f8) kötüye kullanılarak null off-by-one, `prev_size`'i `0x4e0` olarak yazmaktadır.
* Başlangıçta tahsis edilen chunk1, 2, 5 ve 3'ün boyutlarının yanı sıra bu parçaların başlıklarının toplamı `0x4e0`'a eşittir:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Ardından, chunk 4 serbest bırakılır ve başlangıca kadar tüm parçaları tüketen bir parça oluşturur:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Ardından, `0x200` byte ayrılır ve orijinal chunk 1 doldurulur.
* Ve başka bir 0x200 byte ayrılır ve chunk2 yok edilir ve bu nedenle hiçbir sızdırma yoktur ve bu çalışmaz mı? Belki bu yapılmamalı.
* Ardından, 0x58 "a" ile başka bir parça ayrılır (chunk2'yi üzerine yazar ve chunk5'e ulaşır) ve chunk5'in hızlı bin parçasının `fd`'sini `__malloc_hook`'a işaret edecek şekilde değiştirir.
* Ardından, 0x68 boyutunda bir parça ayrılır, böylece `__malloc_hook`'taki sahte hızlı bin parçası bir sonraki hızlı bin parçasıdır.
* Son olarak, 0x68 boyutunda yeni bir hızlı bin parçası ayrılır ve `__malloc_hook` bir `one_gadget` adresi ile üzerine yazılır.

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **HackTricks'e ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR göndererek hacking ipuçlarını paylaşın.**

</details>
{% endhint %}
