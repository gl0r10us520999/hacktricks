# Desbordamiento por uno

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* 춰Consulta los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci칩n b치sica

Tener acceso a un desbordamiento por uno de 1 byte permite a un atacante modificar el campo `size` del siguiente chunk. Esto permite manipular qu칠 chunks se liberan realmente, potencialmente generando un chunk que contiene otro chunk leg칤timo. La explotaci칩n es similar a la de [doble liberaci칩n](double-free.md) o a la de solapamiento de chunks.

Existen 2 tipos de vulnerabilidades de desbordamiento por uno:

* Byte arbitrario: Este tipo permite sobrescribir ese byte con cualquier valor.
* Byte nulo (off-by-null): Este tipo permite sobrescribir ese byte solo con 0x00.
* Un ejemplo com칰n de esta vulnerabilidad se puede ver en el siguiente c칩digo donde el comportamiento de `strlen` y `strcpy` es inconsistente, lo que permite establecer un byte 0x00 al principio del siguiente chunk.
* Esto se puede explotar con el [House of Einherjar](house-of-einherjar.md).
* Si se utiliza Tcache, esto se puede aprovechar para una situaci칩n de [doble liberaci칩n](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre otras comprobaciones, ahora cada vez que se libera un fragmento, se compara el tama침o anterior con el tama침o configurado en los metadatos del fragmento, lo que hace que este ataque sea bastante complejo a partir de la versi칩n 2.28.

### Ejemplo de c칩digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque ya no funciona debido al uso de Tcaches.
* Adem치s, si intentas abusar de 칠l usando fragmentos m치s grandes (para que no intervengan las tcaches), obtendr치s el error: `malloc(): invalid next size (unsorted)`

### Objetivo

* Hacer que un fragmento est칠 contenido dentro de otro fragmento para que el acceso de escritura sobre ese segundo fragmento permita sobrescribir el contenido del fragmento contenido

### Requisitos

* Desbordamiento de un byte para modificar la informaci칩n de metadatos de tama침o

### Ataque general de desbordamiento de un byte

* Asigna tres fragmentos `A`, `B` y `C` (digamos de tama침o 0x20), y otro para evitar la consolidaci칩n con el fragmento superior.
* Libera `C` (insertado en la lista de fragmentos libres de Tcache de 0x20).
* Usa el fragmento `A` para desbordar en `B`. Abusa del desbordamiento de un byte para modificar el campo `size` de `B` de 0x21 a 0x41.
* Ahora tenemos que `B` contiene el fragmento libre `C`
* Libera `B` y asigna un fragmento de 0x40 (se colocar치 aqu칤 nuevamente)
* Podemos modificar el puntero `fd` de `C`, que todav칤a est치 libre (envenenamiento de Tcache)

### Ataque de desbordamiento de nulo

* Se reservan 3 fragmentos de memoria (a, b, c) uno tras otro. Luego se libera el del medio. El primero contiene una vulnerabilidad de desbordamiento de un byte y el atacante la abusa con un 0x00 (si el byte anterior fuera 0x10, har칤a que el fragmento del medio indicara que es 0x10 m치s peque침o de lo que realmente es).
* Luego, se asignan 2 fragmentos m치s peque침os en el fragmento liberado del medio (b), sin embargo, como `b + b->size` nunca actualiza el fragmento c porque la direcci칩n apuntada es m치s peque침a de lo que deber칤a.
* Luego, se liberan b1 y c. Como `c - c->prev_size` todav칤a apunta a b (ahora b1), ambos se consolidan en un solo fragmento. Sin embargo, b2 todav칤a est치 dentro entre b1 y c.
* Finalmente, se realiza un nuevo malloc reclamando esta 치rea de memoria que en realidad va a contener b2, lo que permite al propietario del nuevo malloc controlar el contenido de b2.

Esta imagen explica perfectamente el ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Otros Ejemplos y Referencias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Desbordamiento de un byte debido a que `strlen` considera el campo `size` del siguiente fragmento.
* Se est치 utilizando Tcache, por lo que los ataques generales de desbordamiento de un byte funcionan para obtener un primitivo de escritura arbitraria con envenenamiento de Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es posible abusar de un desbordamiento de un byte para filtrar una direcci칩n de la pila porque el byte 0x00 del final de una cadena est치 siendo sobrescrito por el siguiente campo.
* Se obtiene una escritura arbitraria abusando del desbordamiento de un byte para hacer que el puntero apunte a otro lugar donde se construir치 una estructura falsa con punteros falsos. Luego, es posible seguir el puntero de esta estructura para obtener una escritura arbitraria.
* La direcci칩n de libc se filtra porque si la pila se extiende usando mmap, la memoria asignada por mmap tiene un desplazamiento fijo desde libc.
* Finalmente, se abusa de la escritura arbitraria para escribir en la direcci칩n de \_\_free\_hook con un gadget 칰nico.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Hay una vulnerabilidad de desbordamiento de un byte nulo en la funci칩n `getline` que lee l칤neas de entrada de usuario. Esta funci칩n se utiliza para leer la "clave" del contenido y no el contenido.
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de Github.

</details>
{% endhint %}
