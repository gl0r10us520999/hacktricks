# Dom Siły

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępnij sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Podstawowe Informacje

### Kod

* Ta technika została załatana ([**tutaj**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) i powoduje ten błąd: `malloc(): corrupted top size`
* Możesz wypróbować [**kod stąd**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html), jeśli chcesz go przetestować.

### Cel

* Celem tego ataku jest możliwość alokacji fragmentu pamięci w określonym adresie.

### Wymagania

* Przepełnienie, które pozwala nadpisać rozmiar nagłówka top chunk (np. -1).
* Możliwość kontrolowania rozmiaru alokacji sterty

### Atak

Jeśli atakujący chce zaalokować fragment pamięci pod adresem P, aby nadpisać wartość tutaj. Zaczyna od nadpisania rozmiaru top chunk `-1` (może to być z przepełnieniem). Zapewnia to, że malloc nie będzie używał mmap do żadnej alokacji, ponieważ Top chunk zawsze będzie miał wystarczająco dużo miejsca.

Następnie oblicz odległość między adresem top chunk a docelową przestrzenią do alokacji. Jest to konieczne, ponieważ malloc o takim rozmiarze zostanie wykonany, aby przenieść top chunk na tę pozycję. Tak można łatwo obliczyć różnicę/rozmiar:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Dlatego przydzielenie rozmiaru `target - old_top - 4*sizeof(long)` (4 longi, ponieważ metadane top chunk i nowego chunka są przydzielane) spowoduje przeniesienie top chunka pod adres, który chcemy nadpisać. Następnie wykonujemy kolejne malloc, aby uzyskać chunka pod docelowym adresem.

### Referencje i Inne Przykłady

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* Celem tego scenariusza jest ret2win, gdzie musimy zmodyfikować adres funkcji, która zostanie wywołana przez funkcję ret2win.
* Binarny plik ma przepełnienie, które można wykorzystać do zmodyfikowania rozmiaru top chunka, który jest zmieniony na -1 lub p64(0xffffffffffffffff).
* Następnie obliczany jest adres miejsca, gdzie istnieje wskaźnik do nadpisania, a różnica między bieżącą pozycją top chunka a tam jest alokowana za pomocą `malloc`.
* W końcu alokowany jest nowy chunk, który będzie zawierał ten pożądany cel, wewnątrz którego zostanie nadpisany funkcją ret2win.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* W `Wprowadź swoje imię:` istnieje początkowa podatność, która pozwala na wyciek adresu z heapa.
* Następnie w funkcjonalności `Org:` i `Host:` można wypełnić 64B wskaźnika `s`, gdy zostanie zapytane o **nazwę org**, która na stosie jest następnie śledzona przez adres v2, a następnie przez wskazaną **nazwę hosta**. Ponieważ strcpy będzie kopiować zawartość s do chunka o rozmiarze 64B, możliwe jest **nadpisanie rozmiaru top chunka** danymi wprowadzonymi w **nazwie hosta**.
* Teraz, gdy możliwe jest dowolne pisanie, GOT `atoi` został nadpisany adresem printf. Następnie możliwe było wyciekanie adresu `IO_2_1_stderr` _z_ `%24$p`. Dzięki temu wyciekowi libc możliwe było ponowne nadpisanie GOT `atoi` adresem `system` i wywołanie go, przekazując jako parametr `/bin/sh`.
* Alternatywna metoda [zapropnowana w tym innym rozwiązaniu](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), polega na nadpisaniu `free` z `puts`, a następnie dodaniu adresu `atoi@got` do wskaźnika, który zostanie później zwolniony, aby został wycieknięty, a z tym wyciekiem ponowne nadpisanie `atoi@got` z `system` i wywołanie go z `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Istnieje UAF, który pozwala na ponowne użycie zwolnionego chunka bez wyczyszczenia wskaźnika. Ponieważ istnieją pewne metody odczytu, możliwe jest wyciekanie adresu libc, zapisując wskaźnik do funkcji free w GOT i następnie wywołując funkcję odczytu.
* Następnie, użyto House of force (wykorzystując UAF) do nadpisania rozmiaru pozostałej przestrzeni na -1, zaalokowania wystarczająco dużego chunka, aby dotrzeć do free hook, a następnie zaalokowania innego chunka, który będzie zawierał free hook. Następnie, w hooku zapisano adres `system`, w chunku `"/bin/sh"` i ostatecznie zwolniono chunk z tym zawartością ciągu znaków.
