# House of Force

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Podstawowe informacje

### Kod

* Ta technika została załatana ([**tutaj**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) i generuje ten błąd: `malloc(): corrupted top size`
* Możesz spróbować [**kodu stąd**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html), aby go przetestować, jeśli chcesz.

### Cel

* Celem tego ataku jest możliwość przydzielenia kawałka pamięci pod określonym adresem.

### Wymagania

* Przepełnienie, które pozwala na nadpisanie rozmiaru nagłówka górnego kawałka (np. -1).
* Możliwość kontrolowania rozmiaru przydzielania pamięci na stercie.

### Atak

Jeśli atakujący chce przydzielić kawałek pamięci pod adresem P, aby nadpisać wartość tutaj. Zaczyna od nadpisania rozmiaru górnego kawałka wartością `-1` (może za pomocą przepełnienia). To zapewnia, że malloc nie będzie używał mmap do żadnego przydziału, ponieważ górny kawałek zawsze będzie miał wystarczająco dużo miejsca.

Następnie oblicza odległość między adresem górnego kawałka a docelową przestrzenią do przydzielenia. Dzieje się tak, ponieważ malloc o tym rozmiarze zostanie wykonany w celu przeniesienia górnego kawałka na tę pozycję. W ten sposób różnica/rozmiar może być łatwo obliczona:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Zatem, przydzielenie rozmiaru `target - old_top - 4*sizeof(long)` (4 longi są potrzebne z powodu metadanych górnego kawałka i nowego kawałka podczas alokacji) przeniesie górny kawałek do adresu, który chcemy nadpisać.\
Następnie, wykonaj kolejne malloc, aby uzyskać kawałek pod docelowym adresem.

### Odniesienia i inne przykłady

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* Celem tego scenariusza jest ret2win, w którym musimy zmodyfikować adres funkcji, która ma być wywołana przez adres funkcji ret2win
* Program binarny ma przepełnienie, które można wykorzystać do modyfikacji rozmiaru górnego kawałka, który jest zmieniany na -1 lub p64(0xffffffffffffffff)
* Następnie oblicza się adres miejsca, w którym znajduje się wskaźnik do nadpisania, a różnica od bieżącej pozycji górnego kawałka do tego miejsca jest alokowana za pomocą `malloc`
* Na koniec alokowany jest nowy kawałek, który będzie zawierał ten pożądany cel wewnątrz, który jest nadpisywany przez funkcję ret2win
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* W `Input your name:` znajduje się początkowa luka, która pozwala na wyciek adresu z heap
* Następnie w funkcjonalności `Org:` i `Host:` możliwe jest wypełnienie 64B wskaźnika `s`, gdy zapytano o **nazwa organizacji**, która w stosie jest następnie śledzona przez adres v2, który jest następnie śledzony przez wskazaną **nazwę hosta**. Ponieważ następnie, strcpy będzie kopiować zawartość s do kawałka o rozmiarze 64B, możliwe jest **nadpisanie rozmiaru górnego kawałka** danymi umieszczonymi w **nazwie hosta**.
* Teraz, gdy możliwe jest dowolne zapisanie, GOT `atoi` został nadpisany adresem printf. Następnie możliwe było wyciekanie adresu `IO_2_1_stderr` _z_ `%24$p`. A z tym wyciekiem libc możliwe było ponowne nadpisanie GOT `atoi` adresem do `system` i wywołanie go, przekazując jako parametr `/bin/sh`
* Alternatywna metoda [proponowana w tym innym opisie](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud) polega na nadpisaniu `free` z `puts`, a następnie dodaniu adresu `atoi@got`, w wskaźniku, który później zostanie zwolniony, aby został wycieknięty, a z tym wyciekiem ponownie nadpisać `atoi@got` z `system` i wywołać go z `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Istnieje UAF, który pozwala na ponowne użycie kawałka, który został zwolniony bez wyczyszczenia wskaźnika. Ponieważ istnieją pewne metody odczytu, możliwe jest wyciekanie adresu libc, zapisując wskaźnik do funkcji free w GOT tutaj, a następnie wywołując funkcję odczytu.
* Następnie, House of force został użyty (wykorzystując UAF) do nadpisania rozmiaru pozostałej przestrzeni na -1, alokowania kawałka wystarczająco dużego, aby dotrzeć do hooka free, a następnie alokowania kolejnego kawałka, który będzie zawierał hook free. Następnie, zapisz w hooku adres `system`, zapisz w kawałku `"/bin/sh"` i na koniec zwolnij kawałek z tą zawartością ciągu.

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
