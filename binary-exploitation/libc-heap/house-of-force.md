# Maison de la Force



{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informations de base

### Code

* Cette technique a √©t√© corrig√©e ([**ici**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) et produit cette erreur : `malloc(): corrupted top size`
* Vous pouvez essayer le [**code d'ici**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) pour le tester si vous le souhaitez.

### Objectif

* L'objectif de cette attaque est de pouvoir allouer un morceau dans une adresse sp√©cifique.

### Exigences

* Un d√©bordement qui permet de remplacer la taille de l'en-t√™te du morceau sup√©rieur (par exemple, -1).
* Pouvoir contr√¥ler la taille de l'allocation du tas

### Attaque

Si un attaquant souhaite allouer un morceau √† l'adresse P pour remplacer une valeur ici. Il commence par remplacer la taille du morceau sup√©rieur par `-1` (peut-√™tre avec un d√©bordement). Cela garantit que malloc n'utilisera pas mmap pour toute allocation car le morceau sup√©rieur aura toujours suffisamment d'espace.

Ensuite, calculez la distance entre l'adresse du morceau sup√©rieur et l'espace cible √† allouer. Cela est n√©cessaire car un malloc de cette taille sera effectu√© pour d√©placer le morceau sup√©rieur √† cette position. C'est ainsi que la diff√©rence/taille peut √™tre facilement calcul√©e:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Par cons√©quent, allouer une taille de `cible - old_top - 4*sizeof(long)` (les 4 longs sont dus aux m√©tadonn√©es du chunk sup√©rieur et du nouveau chunk lors de l'allocation) d√©placera le chunk sup√©rieur √† l'adresse que nous voulons √©craser. Ensuite, effectuez un autre malloc pour obtenir un chunk √† l'adresse cible.

### R√©f√©rences et Autres Exemples

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* Le but de ce sc√©nario est un ret2win o√π nous devons modifier l'adresse d'une fonction qui va √™tre appel√©e par l'adresse de la fonction ret2win
* Le binaire a un d√©bordement qui peut √™tre exploit√© pour modifier la taille du chunk sup√©rieur, qui est modifi√© en -1 ou p64(0xffffffffffffffff)
* Ensuite, l'adresse de l'endroit o√π se trouve le pointeur √† √©craser est calcul√©e, et la diff√©rence entre la position actuelle du chunk sup√©rieur et cet endroit est allou√©e avec `malloc`
* Enfin, un nouveau chunk est allou√© qui contiendra cette cible d√©sir√©e √† l'int√©rieur et qui sera √©cras√©e par la fonction ret2win
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* Dans `Input your name:`, il y a une vuln√©rabilit√© initiale qui permet de divulguer une adresse de la heap
* Ensuite, dans les fonctionnalit√©s `Org:` et `Host:`, il est possible de remplir les 64B du pointeur `s` lorsqu'on demande le **nom de l'org**, qui dans la pile est suivi de l'adresse de v2, qui est ensuite suivi du **nom d'h√¥te** indiqu√©. Comme ensuite, strcpy va copier le contenu de s dans un chunk de taille 64B, il est possible de **√©craser la taille du chunk sup√©rieur** avec les donn√©es mises √† l'int√©rieur du **nom d'h√¥te**.
* Maintenant qu'une √©criture arbitraire est possible, le GOT de `atoi` a √©t√© √©cras√© avec l'adresse de printf. il est alors possible de divulguer l'adresse de `IO_2_1_stderr` _avec_ `%24$p`. Et avec cette fuite de libc, il a √©t√© possible de r√©√©crire le GOT de `atoi` avec l'adresse de `system` et de l'appeler en passant en param√®tre `/bin/sh`
* Une m√©thode alternative [propos√©e dans cet autre writeup](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), consiste √† √©craser `free` avec `puts`, puis √† ajouter l'adresse de `atoi@got`, dans le pointeur qui sera plus tard lib√©r√© pour qu'il soit divulgu√© et avec cette fuite r√©√©crire √† nouveau `atoi@got` avec `system` et l'appeler avec `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Il y a une UAF permettant de r√©utiliser un chunk qui a √©t√© lib√©r√© sans effacer le pointeur. Comme il y a quelques m√©thodes de lecture, il est possible de divulguer une adresse de libc en √©crivant un pointeur vers la fonction free dans le GOT ici, puis en appelant la fonction de lecture.
* Ensuite, House of force a √©t√© utilis√© (en abusant de l'UAF) pour √©craser la taille de l'espace restant avec un -1, allouer un chunk suffisamment grand pour arriver au crochet free, puis allouer un autre chunk qui contiendra le crochet free. Ensuite, √©crivez dans le crochet l'adresse de `system`, √©crivez dans un chunk `"/bin/sh"` et enfin lib√©rez le chunk avec ce contenu de cha√Æne.
