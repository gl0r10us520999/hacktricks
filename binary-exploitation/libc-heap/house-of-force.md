# 힘의 집

{% hint style="success" %}
AWS 해킹 배우고 실습하기:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우고 실습하기: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 **디스코드 그룹**에 **가입**하세요(https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
{% endhint %}

## 기본 정보

### 코드

* 이 기법은 ([**여기**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c))에서 패치되었으며 다음 오류를 생성합니다: `malloc(): corrupted top size`
* 테스트하려면 [**여기의 코드**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)를 사용할 수 있습니다.

### 목표

* 이 공격의 목표는 특정 주소에 청크를 할당할 수 있는 것입니다.

### 요구 사항

* 힙 할당의 크기를 제어할 수 있는 오버플로우가 필요합니다.
* 힙 할당의 크기를 제어할 수 있어야 합니다.

### 공격

공격자가 특정 주소 P에 청크를 할당하여 여기에 값을 덮어쓰려면 다음과 같이 시작합니다. 먼저 top 청크 크기를 `-1`로 덮어씁니다(오버플로우를 사용할 수도 있음). 이렇게 하면 malloc이 Top 청크를 항상 충분한 공간이 있는 상태로 mmap를 사용하지 않게 됩니다.

그런 다음 top 청크의 주소와 할당할 대상 공간 사이의 거리를 계산합니다. 이는 해당 크기로 malloc이 수행되어 top 청크가 해당 위치로 이동하도록 하기 위함입니다. 이 차이/크기는 쉽게 계산할 수 있습니다:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
따라서 `target - old_top - 4*sizeof(long)` 크기를 할당하면 (4개의 long은 상단 청크의 메타데이터와 새로 할당된 청크의 메타데이터 때문입니다) 상단 청크를 덮어쓰고자 하는 주소로 이동시킬 수 있습니다.\
그런 다음, 대상 주소에서 청크를 얻기 위해 다른 malloc을 수행하십시오.

### 참고 자료 및 다른 예시

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* 이 시나리오의 목표는 ret2win으로, 호출될 함수의 주소를 ret2win 함수의 주소로 수정해야 합니다.
* 이진 파일에는 상단 청크 크기를 수정할 수 있는 오버플로우가 있으며, 이를 -1 또는 p64(0xffffffffffffffff)로 수정합니다.
* 그런 다음 덮어쓸 포인터가 존재하는 위치로 주소를 계산하고, 현재 상단 청크 위치부터 해당 위치까지의 차이가 `malloc`으로 할당됩니다.
* 마지막으로 원하는 대상을 포함하는 새로운 청크가 할당되며, 이 대상이 ret2win 함수에 의해 덮어쓰입니다.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* `Input your name:`에는 힙에서 주소를 누출할 수 있는 초기 취약점이 있습니다.
* 그런 다음 `Org:` 및 `Host:` 기능에서 **org name**을 요청할 때 `s` 포인터의 64B를 채울 수 있으며, 이는 스택에서 v2의 주소 뒤에 따르는데, 그 다음에는 지정된 **host name**이 따릅니다. 그 후 strcpy가 s의 내용을 64B 크기의 청크로 복사하게 되므로 **host name**에 입력된 데이터로 **상단 청크의 크기를 덮어쓸 수 있습니다**.
* 이제 임의 쓰기가 가능하므로, `atoi`의 GOT를 printf의 주소로 덮어씁니다. 그런 다음 `%24$p`로 `IO_2_1_stderr`의 주소를 누출할 수 있습니다. 이 libc 누출로 `atoi`의 GOT를 다시 `system` 주소로 덮어쓰고 `/bin/sh`를 매개변수로 전달하여 호출할 수 있습니다.
* [이 다른 writeup에서 제안된 대체 방법](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud)은 `free`를 `puts`로 덮어쓰고, 나중에 해제될 포인터에 `atoi@got`의 주소를 추가하여 누출하고 이 누출로 다시 `atoi@got`를 `system`으로 덮어쓰고 `/bin/sh`로 호출할 수 있습니다.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* 포인터를 지우지 않고 해제된 청크를 재사용할 수 있는 UAF가 있습니다. 일부 읽기 방법이 있기 때문에 GOT에 free 함수의 포인터를 쓰고 나중에 read 함수를 호출하여 libc 주소를 누출할 수 있습니다.
* 그런 다음, UAF를 악용하여 House of force를 사용하여 왼쪽 공간의 크기를 -1로 덮어쓰고, free 후크에 도달할 수 있는 충분히 큰 청크를 할당한 다음, free 후크를 포함하는 다른 청크를 할당합니다. 그런 다음 후크에 `system`의 주소를 쓰고, 청크에 `"/bin/sh"`를 쓰고, 그 문자열 내용을 포함하는 청크를 해제합니다.
