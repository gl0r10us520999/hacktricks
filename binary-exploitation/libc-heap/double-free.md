# Double Free

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Si vous lib√©rez un bloc de m√©moire plus d'une fois, cela peut perturber les donn√©es de l'allocateur et ouvrir la porte √† des attaques. Voici comment cela se produit : lorsque vous lib√©rez un bloc de m√©moire, il retourne dans une liste de morceaux libres (par exemple, le "fast bin"). Si vous lib√©rez le m√™me bloc deux fois de suite, l'allocateur d√©tecte cela et renvoie une erreur. Mais si vous **lib√©rez un autre morceau entre-temps, la v√©rification de double lib√©ration est contourn√©e**, provoquant une corruption.

Maintenant, lorsque vous demandez de la nouvelle m√©moire (en utilisant `malloc`), l'allocateur peut vous donner un **bloc qui a √©t√© lib√©r√© deux fois**. Cela peut conduire √† deux pointeurs diff√©rents pointant vers le m√™me emplacement m√©moire. Si un attaquant contr√¥le l'un de ces pointeurs, il peut modifier le contenu de cette m√©moire, ce qui peut causer des probl√®mes de s√©curit√© ou m√™me leur permettre d'ex√©cuter du code.

Example:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i2);

return 0;
}
```
Dans cet exemple, apr√®s avoir rempli le tcache avec plusieurs chunks lib√©r√©s (7), le code **lib√®re le chunk `h`, puis le chunk `i`, et ensuite `h` √† nouveau, provoquant un double free** (√©galement connu sous le nom de Fast Bin dup). Cela ouvre la possibilit√© de recevoir des adresses m√©moire qui se chevauchent lors de la r√©allocation, ce qui signifie que deux ou plusieurs pointeurs peuvent pointer vers la m√™me localisation m√©moire. Manipuler des donn√©es via un pointeur peut alors affecter l'autre, cr√©ant un risque de s√©curit√© critique et un potentiel d'exploitation.

En l'ex√©cutant, notez comment **`i1` et `i2` ont obtenu la m√™me adresse** :

<pre><code>Allocations initiales :
a : 0xaaab0f0c22a0
b : 0xaaab0f0c22c0
c : 0xaaab0f0c22e0
d : 0xaaab0f0c2300
e : 0xaaab0f0c2320
f : 0xaaab0f0c2340
g : 0xaaab0f0c2360
h : 0xaaab0f0c2380
i : 0xaaab0f0c23a0
Apr√®s r√©allocations :
a1 : 0xaaab0f0c2360
b1 : 0xaaab0f0c2340
c1 : 0xaaab0f0c2320
d1 : 0xaaab0f0c2300
e1 : 0xaaab0f0c22e0
f1 : 0xaaab0f0c22c0
g1 : 0xaaab0f0c22a0
h1 : 0xaaab0f0c2380
<strong>i1 : 0xaaab0f0c23a0
</strong><strong>i2 : 0xaaab0f0c23a0
</strong></code></pre>

## Exemples

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Nous ne pouvons allouer que des chunks de taille Fast-Bin sauf pour la taille `0x70`, ce qui emp√™che l'√©crasement habituel de `__malloc_hook`.
* Au lieu de cela, nous utilisons des adresses PIE qui commencent par `0x56` comme cible pour Fast Bin dup (1/2 chance).
* Un endroit o√π les adresses PIE sont stock√©es est dans `main_arena`, qui se trouve √† l'int√©rieur de Glibc et pr√®s de `__malloc_hook`.
* Nous ciblons un offset sp√©cifique de `main_arena` pour allouer un chunk l√† et continuer √† allouer des chunks jusqu'√† atteindre `__malloc_hook` pour obtenir une ex√©cution de code.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* En utilisant des bins Tcache et un d√©bordement de null-byte, nous pouvons atteindre une situation de double-free :
* Nous allouons trois chunks de taille `0x110` (`A`, `B`, `C`)
* Nous lib√©rons `B`
* Nous lib√©rons `A` et allouons √† nouveau pour utiliser le d√©bordement de null-byte
* Maintenant, le champ de taille de `B` est `0x100`, au lieu de `0x111`, donc nous pouvons le lib√©rer √† nouveau
* Nous avons un Tcache-bin de taille `0x110` et un de taille `0x100` qui pointent vers la m√™me adresse. Donc nous avons un double free.
* Nous exploitons le double free en utilisant [Tcache poisoning](tcache-bin-attack.md)

## R√©f√©rences

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
