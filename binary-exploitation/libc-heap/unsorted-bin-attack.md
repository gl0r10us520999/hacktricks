# Ataque ao Unsorted Bin

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

Para mais informa√ß√µes sobre o que √© um unsorted bin, consulte esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

As listas n√£o ordenadas s√£o capazes de escrever o endere√ßo para `unsorted_chunks (av)` no endere√ßo `bk` do chunk. Portanto, se um atacante puder **modificar o endere√ßo do ponteiro `bk`** em um chunk dentro do unsorted bin, ele poderia ser capaz de **escrever esse endere√ßo em um endere√ßo arbitr√°rio** que poderia ser √∫til para vazar endere√ßos do Glibc ou contornar algumas defesas.

Portanto, basicamente, esse ataque permite **definir um n√∫mero grande em um endere√ßo arbitr√°rio**. Esse n√∫mero grande √© um endere√ßo, que poderia ser um endere√ßo de heap ou um endere√ßo do Glibc. Um alvo t√≠pico √© o **`global_max_fast`** para permitir a cria√ß√£o de bins r√°pidos com tamanhos maiores (e passar de um ataque unsorted bin para um ataque fast bin).

{% hint style="success" %}
Analisando o exemplo fornecido em [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e usando 0x4000 e 0x5000 em vez de 0x400 e 0x500 como tamanhos de chunk (para evitar Tcache), √© poss√≠vel ver que **atualmente** o erro **`malloc(): unsorted double linked list corrupted`** √© acionado.

Portanto, esse ataque unsorted bin agora (entre outras verifica√ß√µes) tamb√©m requer ser capaz de corrigir a lista duplamente encadeada para que isso seja contornado `victim->bk->fd == victim` ou n√£o `victim->fd == av (arena)`, o que significa que o endere√ßo onde queremos escrever deve ter o endere√ßo do chunk falso em sua posi√ß√£o `fd` e que o `fd` do chunk falso est√° apontando para a arena.
{% endhint %}

{% hint style="danger" %}
Observe que esse ataque corrompe o unsorted bin (portanto, tamb√©m o small e large). Portanto, agora s√≥ podemos **usar aloca√ß√µes do fast bin** (um programa mais complexo pode fazer outras aloca√ß√µes e travar), e para acionar isso devemos **alocar o mesmo tamanho ou o programa travar√°**.

Observe que sobrescrever **`global_max_fast`** pode ajudar nesse caso, confiando que o fast bin ser√° capaz de lidar com todas as outras aloca√ß√µes at√© que o exploit seja conclu√≠do.
{% endhint %}

O c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) explica muito bem, embora se voc√™ modificar as aloca√ß√µes para alocar mem√≥ria grande o suficiente para n√£o terminar em um Tcache, voc√™ ver√° que o erro mencionado anteriormente aparece, impedindo essa t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Ataque de Vazamento de Informa√ß√µes do Unsorted Bin

Este √© na verdade um conceito muito b√°sico. Os chunks no unsorted bin ter√£o ponteiros. O primeiro chunk no unsorted bin ter√° na verdade os links **`fd`** e **`bk`** **apontando para uma parte da arena principal (Glibc)**.\
Portanto, se voc√™ pode **colocar um chunk dentro de um unsorted bin e l√™-lo** (uso ap√≥s libera√ß√£o) ou **aloc√°-lo novamente sem sobrescrever pelo menos 1 dos ponteiros** para ent√£o **l√™-lo**, voc√™ pode ter um **vazamento de informa√ß√µes do Glibc**.

Um [**ataque semelhante usado neste artigo**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), foi abusar de uma estrutura de 4 chunks (A, B, C e D - D √© apenas para evitar a consolida√ß√£o com o top chunk) para que uma sobrecarga de byte nulo em B fosse usada para fazer C indicar que B estava inutilizado. Al√©m disso, em B, os dados `prev_size` foram modificados para que o tamanho, em vez de ser o tamanho de B, fosse A+B.\
Ent√£o C foi desalocado e consolidado com A+B (mas B ainda estava em uso). Um novo chunk de tamanho A foi alocado e ent√£o os endere√ßos vazados do libc foram escritos em B de onde foram vazados.

## Refer√™ncias e Outros Exemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* O objetivo √© sobrescrever uma vari√°vel global com um valor maior que 4869 para ser poss√≠vel obter a flag e o PIE n√£o estar habilitado.
* √â poss√≠vel gerar chunks de tamanhos arbitr√°rios e h√° um estouro de heap com o tamanho desejado.
* O ataque come√ßa criando 3 chunks: chunk0 para abusar do estouro, chunk1 para ser estourado e chunk2 para que o top chunk n√£o consolide os anteriores.
* Em seguida, o chunk1 √© liberado e o chunk0 √© estourado para que o ponteiro `bk` do chunk1 aponte para: `bk = magic - 0x10`
* Em seguida, o chunk3 √© alocado com o mesmo tamanho que o chunk1, o que acionar√° o ataque unsorted bin e modificar√° o valor da vari√°vel global, tornando poss√≠vel obter a flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* A fun√ß√£o de mesclagem √© vulner√°vel porque se ambos os √≠ndices passados forem iguais, ela realocar√° nele e ent√£o o liberar√°, mas retornando um ponteiro para aquela regi√£o liberada que pode ser usada.
* Portanto, **2 chunks s√£o criados**: **chunk0** que ser√° mesclado consigo mesmo e chunk1 para evitar a consolida√ß√£o com o top chunk. Em seguida, a **fun√ß√£o de mesclagem √© chamada com o chunk0** duas vezes, o que causar√° um uso ap√≥s a libera√ß√£o.
* Em seguida, a fun√ß√£o **`view`** √© chamada com o √≠ndice 2 (que √© o √≠ndice do chunk de uso ap√≥s libera√ß√£o), que ir√° **vazar um endere√ßo do libc**.
* Como o bin√°rio tem prote√ß√µes para alocar apenas tamanhos maiores que **`global_max_fast`** para que nenhum fastbin seja usado, um ataque unsorted bin ser√° usado para sobrescrever a vari√°vel global `global_max_fast`.
* Em seguida, √© poss√≠vel chamar a fun√ß√£o edit com o √≠ndice 2 (o ponteiro de uso ap√≥s libera√ß√£o) e sobrescrever o ponteiro `bk` para apontar para `p64(global_max_fast-0x10)`. Em seguida, criando um novo chunk usar√° o endere√ßo de libera√ß√£o comprometido anteriormente (0x20) e **acionar√° o ataque unsorted bin** sobrescrevendo o `global_max_fast` com um valor muito grande, permitindo agora criar chunks em fast bins.
* Agora um **ataque fast bin** √© realizado:
* Primeiramente, √© descoberto que √© poss√≠vel trabalhar com **chunks r√°pidos de tamanho 200** na localiza√ß√£o de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se conseguirmos obter um fast chunk de tamanho 0x200 nessa localiza√ß√£o, ser√° poss√≠vel sobrescrever um ponteiro de fun√ß√£o que ser√° executado
* Para isso, um novo chunk de tamanho `0xfc` √© criado e a fun√ß√£o mesclada √© chamada com esse ponteiro duas vezes, dessa forma obtemos um ponteiro para um chunk liberado de tamanho `0xfc*2 = 0x1f8` no fast bin.
* Em seguida, a fun√ß√£o edit √© chamada nesse chunk para modificar o endere√ßo **`fd`** desse fast bin para apontar para a fun√ß√£o **`__free_hook`** anterior.
* Depois, um chunk com tamanho `0x1f8` √© criado para recuperar do fast bin o chunk in√∫til anterior, ent√£o outro chunk de tamanho `0x1f8` √© criado para obter um chunk do fast bin no **`__free_hook`** que √© sobrescrito com o endere√ßo da fun√ß√£o **`system`**.
* E finalmente um chunk contendo a string `/bin/sh\x00` √© liberado chamando a fun√ß√£o delete, acionando a fun√ß√£o **`__free_hook`** que aponta para system com `/bin/sh\x00` como par√¢metro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Outro exemplo de abuso de um overflow de 1B para consolidar chunks no unsorted bin e obter um vazamento de informa√ß√µes da libc e depois realizar um ataque fast bin para sobrescrever o malloc hook com um endere√ßo de one gadget
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* S√≥ podemos alocar chunks de tamanho maior que `0x100`.
* Sobrescrever `global_max_fast` usando um ataque Unsorted Bin (funciona 1/16 vezes devido ao ASLR, porque precisamos modificar 12 bits, mas devemos modificar 16 bits).
* Ataque Fast Bin para modificar um array global de chunks. Isso fornece um primitivo de leitura/escrita arbitr√°rio, que permite modificar a GOT e definir algumas fun√ß√µes para apontar para `system`.

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoie o HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
