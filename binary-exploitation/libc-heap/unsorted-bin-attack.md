# Unsorted Bin Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

For more information about what is an unsorted bin check this page:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Las listas no ordenadas pueden escribir la direcci√≥n en `unsorted_chunks (av)` en la direcci√≥n `bk` del chunk. Por lo tanto, si un atacante puede **modificar la direcci√≥n del puntero `bk`** en un chunk dentro del bin no ordenado, podr√≠a **escribir esa direcci√≥n en una direcci√≥n arbitraria** que podr√≠a ser √∫til para filtrar direcciones de Glibc o eludir alguna defensa.

As√≠ que, b√°sicamente, este ataque permite **establecer un n√∫mero grande en una direcci√≥n arbitraria**. Este n√∫mero grande es una direcci√≥n, que podr√≠a ser una direcci√≥n de heap o una direcci√≥n de Glibc. Un objetivo t√≠pico es **`global_max_fast`** para permitir crear bins de fast bin con tama√±os m√°s grandes (y pasar de un ataque de bin no ordenado a un ataque de fast bin).

{% hint style="success" %}
Echando un vistazo al ejemplo proporcionado en [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) y usando 0x4000 y 0x5000 en lugar de 0x400 y 0x500 como tama√±os de chunk (para evitar Tcache) es posible ver que **hoy en d√≠a** el error **`malloc(): unsorted double linked list corrupted`** se activa.

Por lo tanto, este ataque de bin no ordenado ahora (entre otras verificaciones) tambi√©n requiere poder arreglar la lista doblemente enlazada para que se eluda `victim->bk->fd == victim` o no `victim->fd == av (arena)`, lo que significa que la direcci√≥n donde queremos escribir debe tener la direcci√≥n del chunk falso en su posici√≥n `fd` y que el `fd` del chunk falso apunta a la arena.
{% endhint %}

{% hint style="danger" %}
Ten en cuenta que este ataque corrompe el bin no ordenado (por lo tanto, tambi√©n peque√±o y grande). As√≠ que solo podemos **usar asignaciones del fast bin ahora** (un programa m√°s complejo podr√≠a hacer otras asignaciones y fallar), y para activar esto debemos **asignar el mismo tama√±o o el programa fallar√°.**

Ten en cuenta que sobrescribir **`global_max_fast`** podr√≠a ayudar en este caso confiando en que el fast bin podr√° encargarse de todas las otras asignaciones hasta que se complete el exploit.
{% endhint %}

El c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo explica muy bien, aunque si modificas los mallocs para asignar memoria lo suficientemente grande para no terminar en un Tcache puedes ver que el error mencionado anteriormente aparece impidiendo esta t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Este es en realidad un concepto muy b√°sico. Los chunks en el bin no ordenado van a tener punteros. El primer chunk en el bin no ordenado tendr√° en realidad los enlaces **`fd`** y **`bk`** **apuntando a una parte de la arena principal (Glibc)**.\
Por lo tanto, si puedes **poner un chunk dentro de un bin no ordenado y leerlo** (uso despu√©s de liberar) o **asignarlo de nuevo sin sobrescribir al menos 1 de los punteros** para luego **leerlo**, puedes tener una **fuga de informaci√≥n de Glibc**.

Un [**ataque similar utilizado en este informe**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), fue abusar de una estructura de 4 chunks (A, B, C y D - D es solo para evitar la consolidaci√≥n con el chunk superior) as√≠ que se utiliz√≥ un desbordamiento de byte nulo en B para hacer que C indicara que B no estaba en uso. Adem√°s, en B se modificaron los datos de `prev_size` para que el tama√±o en lugar de ser el tama√±o de B fuera A+B.\
Luego se liber√≥ C y se consolid√≥ con A+B (pero B todav√≠a estaba en uso). Se asign√≥ un nuevo chunk de tama√±o A y luego se escribieron las direcciones de libc filtradas en B desde donde fueron filtradas.

## References & Other examples

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* El objetivo es sobrescribir una variable global con un valor mayor que 4869 para que sea posible obtener la bandera y PIE no est√° habilitado.
* Es posible generar chunks de tama√±os arbitrarios y hay un desbordamiento de heap con el tama√±o deseado.
* El ataque comienza creando 3 chunks: chunk0 para abusar del desbordamiento, chunk1 para ser desbordado y chunk2 para que el chunk superior no consolide los anteriores.
* Luego, chunk1 se libera y chunk0 se desborda para que el puntero `bk` de chunk1 apunte a: `bk = magic - 0x10`
* Luego, chunk3 se asigna con el mismo tama√±o que chunk1, lo que activar√° el ataque de bin no ordenado y modificar√° el valor de la variable global, haciendo posible obtener la bandera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funci√≥n de fusi√≥n es vulnerable porque si ambos √≠ndices pasados son el mismo, se reasignar√° sobre √©l y luego se liberar√°, pero devolviendo un puntero a esa regi√≥n liberada que puede ser utilizada.
* Por lo tanto, **se crean 2 chunks**: **chunk0** que se fusionar√° consigo mismo y chunk1 para evitar la consolidaci√≥n con el chunk superior. Luego, se **llama a la funci√≥n de fusi√≥n con chunk0** dos veces, lo que causar√° un uso despu√©s de liberar.
* Luego, se llama a la funci√≥n **`view`** con el √≠ndice 2 (que es el √≠ndice del chunk de uso despu√©s de liberar), lo que **filtrar√° una direcci√≥n de libc**.
* Como el binario tiene protecciones para solo malloc tama√±os mayores que **`global_max_fast`**, por lo que no se usa fastbin, se va a utilizar un ataque de bin no ordenado para sobrescribir la variable global `global_max_fast`.
* Luego, es posible llamar a la funci√≥n de edici√≥n con el √≠ndice 2 (el puntero de uso despu√©s de liberar) y sobrescribir el puntero `bk` para que apunte a `p64(global_max_fast-0x10)`. Luego, crear un nuevo chunk utilizar√° la direcci√≥n liberada previamente comprometida (0x20) que **activar√° el ataque de bin no ordenado** sobrescribiendo el `global_max_fast` con un valor muy grande, permitiendo ahora crear chunks en fast bins.
* Ahora se realiza un **ataque de fast bin**:
* Primero se descubre que es posible trabajar con fast **chunks de tama√±o 200** en la ubicaci√≥n de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Si logramos obtener un chunk r√°pido de tama√±o 0x200 en esta ubicaci√≥n, ser√° posible sobrescribir un puntero de funci√≥n que se ejecutar√°.
* Para esto, se crea un nuevo chunk de tama√±o `0xfc` y se llama a la funci√≥n de fusi√≥n con ese puntero dos veces, de esta manera obtenemos un puntero a un chunk liberado de tama√±o `0xfc*2 = 0x1f8` en el fast bin.
* Luego, se llama a la funci√≥n de edici√≥n en este chunk para modificar la direcci√≥n **`fd`** de este fast bin para que apunte a la funci√≥n **`__free_hook`** anterior.
* Luego, se crea un chunk de tama√±o `0x1f8` para recuperar del fast bin el chunk in√∫til anterior, por lo que se crea otro chunk de tama√±o `0x1f8` para obtener un chunk de fast bin en el **`__free_hook`** que se sobrescribe con la direcci√≥n de la funci√≥n **`system`**.
* Y finalmente, se libera un chunk que contiene la cadena `/bin/sh\x00` llamando a la funci√≥n de eliminaci√≥n, activando la funci√≥n **`__free_hook`** que apunta a system con `/bin/sh\x00` como par√°metro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Otro ejemplo de abusar de un desbordamiento de 1B para consolidar chunks en el bin no ordenado y obtener una fuga de informaci√≥n de libc y luego realizar un ataque de fast bin para sobrescribir el gancho de malloc con una direcci√≥n de un gadget.
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Solo podemos asignar chunks de tama√±o mayor que `0x100`.
* Sobrescribir `global_max_fast` usando un ataque de bin no ordenado (funciona 1/16 veces debido a ASLR, porque necesitamos modificar 12 bits, pero debemos modificar 16 bits).
* Ataque de Fast Bin para modificar un arreglo global de chunks. Esto proporciona una primitiva de lectura/escritura arbitraria, que permite modificar el GOT y hacer que algunas funciones apunten a `system`.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
