# Ataque de Bin N√£o Ordenado

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

Para mais informa√ß√µes sobre o que √© um bin n√£o ordenado, confira esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Listas n√£o ordenadas s√£o capazes de escrever o endere√ßo para `unsorted_chunks (av)` no endere√ßo `bk` do chunk. Portanto, se um atacante puder **modificar o endere√ßo do ponteiro `bk`** em um chunk dentro do bin n√£o ordenado, ele poder√° **escrever esse endere√ßo em um endere√ßo arbitr√°rio**, o que pode ser √∫til para vazar endere√ßos Glibc ou contornar alguma defesa.

Assim, basicamente, esse ataque permite **definir um grande n√∫mero em um endere√ßo arbitr√°rio**. Esse grande n√∫mero √© um endere√ßo, que pode ser um endere√ßo de heap ou um endere√ßo Glibc. Um alvo t√≠pico √© **`global_max_fast`** para permitir a cria√ß√£o de bins de fast bin com tamanhos maiores (e passar de um ataque de bin n√£o ordenado para um ataque de fast bin).

{% hint style="success" %}
Dando uma olhada no exemplo fornecido em [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e usando 0x4000 e 0x5000 em vez de 0x400 e 0x500 como tamanhos de chunk (para evitar Tcache), √© poss√≠vel ver que **hoje em dia** o erro **`malloc(): unsorted double linked list corrupted`** √© acionado.

Portanto, esse ataque de bin n√£o ordenado agora (entre outras verifica√ß√µes) tamb√©m requer ser capaz de corrigir a lista duplamente encadeada, de modo que isso seja contornado `victim->bk->fd == victim` ou n√£o `victim->fd == av (arena)`, o que significa que o endere√ßo onde queremos escrever deve ter o endere√ßo do chunk falso em sua posi√ß√£o `fd` e que o `fd` do chunk falso est√° apontando para a arena.
{% endhint %}

{% hint style="danger" %}
Note que este ataque corrompe o bin n√£o ordenado (portanto, pequeno e grande tamb√©m). Portanto, s√≥ podemos **usar aloca√ß√µes do fast bin agora** (um programa mais complexo pode fazer outras aloca√ß√µes e travar), e para acionar isso devemos **alocar o mesmo tamanho ou o programa travar√°.**

Note que sobrescrever **`global_max_fast`** pode ajudar neste caso, confiando que o fast bin ser√° capaz de cuidar de todas as outras aloca√ß√µes at√© que a explora√ß√£o seja conclu√≠da.
{% endhint %}

O c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) explica isso muito bem, embora se voc√™ modificar os mallocs para alocar mem√≥ria grande o suficiente para n√£o acabar em um Tcache, voc√™ pode ver que o erro mencionado anteriormente aparece, impedindo essa t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Ataque de Vazamento de Informa√ß√£o de Bin N√£o Ordenado

Este √©, na verdade, um conceito muito b√°sico. Os chunks no bin n√£o ordenado ter√£o ponteiros. O primeiro chunk no bin n√£o ordenado ter√°, na verdade, os links **`fd`** e **`bk`** **apontando para uma parte da arena principal (Glibc)**.\
Portanto, se voc√™ puder **colocar um chunk dentro de um bin n√£o ordenado e l√™-lo** (uso ap√≥s libera√ß√£o) ou **aloc√°-lo novamente sem sobrescrever pelo menos 1 dos ponteiros** para ent√£o **l√™-lo**, voc√™ pode ter um **vazamento de informa√ß√£o Glibc**.

Um [**ataque semelhante usado neste relat√≥rio**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html) foi abusar de uma estrutura de 4 chunks (A, B, C e D - D √© apenas para evitar a consolida√ß√£o com o chunk superior), ent√£o um estouro de byte nulo em B foi usado para fazer C indicar que B estava n√£o utilizado. Al√©m disso, em B, os dados `prev_size` foram modificados para que o tamanho, em vez de ser o tamanho de B, fosse A+B.\
Ent√£o C foi desalocado e consolidado com A+B (mas B ainda estava em uso). Um novo chunk de tamanho A foi alocado e ent√£o os endere√ßos da libc vazados foram escritos em B, de onde foram vazados.

## Refer√™ncias e Outros Exemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* O objetivo √© sobrescrever uma vari√°vel global com um valor maior que 4869 para que seja poss√≠vel obter a flag e o PIE n√£o est√° habilitado.
* √â poss√≠vel gerar chunks de tamanhos arbitr√°rios e h√° um estouro de heap com o tamanho desejado.
* O ataque come√ßa criando 3 chunks: chunk0 para abusar do estouro, chunk1 para ser estourado e chunk2 para que o chunk superior n√£o consolide os anteriores.
* Ent√£o, chunk1 √© liberado e chunk0 √© estourado para que o ponteiro `bk` de chunk1 aponte para: `bk = magic - 0x10`
* Ent√£o, chunk3 √© alocado com o mesmo tamanho que chunk1, o que acionar√° o ataque de bin n√£o ordenado e modificar√° o valor da vari√°vel global, tornando poss√≠vel obter a flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* A fun√ß√£o de mesclagem √© vulner√°vel porque se ambos os √≠ndices passados forem o mesmo, ela ir√° realocar nele e depois liber√°-lo, mas retornando um ponteiro para essa regi√£o liberada que pode ser usada.
* Portanto, **2 chunks s√£o criados**: **chunk0** que ser√° mesclado consigo mesmo e chunk1 para evitar a consolida√ß√£o com o chunk superior. Ent√£o, a **fun√ß√£o de mesclagem √© chamada com chunk0** duas vezes, o que causar√° um uso ap√≥s libera√ß√£o.
* Ent√£o, a **fun√ß√£o `view`** √© chamada com o √≠ndice 2 (que √© o √≠ndice do chunk de uso ap√≥s libera√ß√£o), o que **vazar√° um endere√ßo da libc**.
* Como o bin√°rio tem prote√ß√µes para alocar apenas tamanhos maiores que **`global_max_fast`**, nenhum fastbin √© usado, um ataque de bin n√£o ordenado ser√° usado para sobrescrever a vari√°vel global `global_max_fast`.
* Ent√£o, √© poss√≠vel chamar a fun√ß√£o de edi√ß√£o com o √≠ndice 2 (o ponteiro de uso ap√≥s libera√ß√£o) e sobrescrever o ponteiro `bk` para apontar para `p64(global_max_fast-0x10)`. Ent√£o, criando um novo chunk, o endere√ßo livre anteriormente comprometido (0x20) **acionar√° o ataque de bin n√£o ordenado**, sobrescrevendo o `global_max_fast` com um valor muito grande, permitindo agora criar chunks em fast bins.
* Agora um **ataque de fast bin** √© realizado:
* Primeiro de tudo, descobre-se que √© poss√≠vel trabalhar com fast **chunks de tamanho 200** na localiza√ß√£o de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se conseguirmos obter um fast chunk de tamanho 0x200 nesta localiza√ß√£o, ser√° poss√≠vel sobrescrever um ponteiro de fun√ß√£o que ser√° executado.
* Para isso, um novo chunk de tamanho `0xfc` √© criado e a fun√ß√£o de mesclagem √© chamada com esse ponteiro duas vezes, assim obtemos um ponteiro para um chunk liberado de tamanho `0xfc*2 = 0x1f8` no fast bin.
* Ent√£o, a fun√ß√£o de edi√ß√£o √© chamada neste chunk para modificar o endere√ßo **`fd`** deste fast bin para apontar para a fun√ß√£o anterior **`__free_hook`**.
* Ent√£o, um chunk com tamanho `0x1f8` √© criado para recuperar do fast bin o chunk in√∫til anterior, assim outro chunk de tamanho `0x1f8` √© criado para obter um chunk de fast bin na **`__free_hook`** que √© sobrescrito com o endere√ßo da fun√ß√£o **`system`**.
* E finalmente, um chunk contendo a string `/bin/sh\x00` √© liberado chamando a fun√ß√£o de deletar, acionando a fun√ß√£o **`__free_hook`** que aponta para system com `/bin/sh\x00` como par√¢metro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Outro exemplo de abuso de um estouro de 1B para consolidar chunks no bin n√£o ordenado e obter um vazamento de informa√ß√£o da libc e depois realizar um ataque de fast bin para sobrescrever o malloc hook com um endere√ßo de um gadget.
* [**F√°brica de Rob√¥s. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* S√≥ podemos alocar chunks de tamanho maior que `0x100`.
* Sobrescrever `global_max_fast` usando um ataque de Bin N√£o Ordenado (funciona 1/16 vezes devido ao ASLR, porque precisamos modificar 12 bits, mas devemos modificar 16 bits).
* Ataque de Fast Bin para modificar um array global de chunks. Isso fornece uma primitiva de leitura/escrita arbitr√°ria, que permite modificar o GOT e definir algumas fun√ß√µes para apontar para `system`.

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
