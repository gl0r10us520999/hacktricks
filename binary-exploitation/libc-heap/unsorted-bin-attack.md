# Unsorted Bin Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

For more information about what is an unsorted bin check this page:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Orodha zisizo na mpangilio zinaweza kuandika anwani kwa `unsorted_chunks (av)` katika anwani ya `bk` ya kipande. Hivyo, ikiwa mshambuliaji anaweza **kubadilisha anwani ya kiashiria cha `bk`** katika kipande ndani ya bin isiyo na mpangilio, anaweza **kuandika anwani hiyo katika anwani yoyote** ambayo inaweza kusaidia kuvuja anwani za Glibc au kupita baadhi ya ulinzi.

Hivyo, kimsingi, shambulio hili linaruhusu **kweka nambari kubwa katika anwani yoyote**. Nambari hii kubwa ni anwani, ambayo inaweza kuwa anwani ya heap au anwani ya Glibc. Lengo la kawaida ni **`global_max_fast`** ili kuruhusu kuunda bins za haraka zenye ukubwa mkubwa (na kupita kutoka shambulio la bin isiyo na mpangilio hadi shambulio la bin haraka).

{% hint style="success" %}
Taking a look to the example provided in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) and using 0x4000 and 0x5000 instead of 0x400 and 0x500 as chunk sizes (to avoid Tcache) it's possible to see that **nowadays** the error **`malloc(): unsorted double linked list corrupted`** is triggered.

Hivyo, shambulio hili la bin isiyo na mpangilio sasa (pamoja na ukaguzi mwingine) pia linahitaji kuwa na uwezo wa kurekebisha orodha ya viungo viwili ili hii ipitishwe `victim->bk->fd == victim` au si `victim->fd == av (arena)`, ambayo inamaanisha kwamba anwani ambapo tunataka kuandika lazima iwe na anwani ya kipande bandia katika nafasi yake ya `fd` na kwamba kipande bandia `fd` kinaelekeza kwenye arena.
{% endhint %}

{% hint style="danger" %}
Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **allocate the same size or the program will crash.**

Note that overwriting **`global_max_fast`** might help in this case trusting that the fast bin will be able to take care of all the other allocations until the exploit is completed.
{% endhint %}

The code from [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) explains it very well, although if you modify the mallocs to allocate memory big enough so don't end in a Tcache you can see that the previously mentioned error appears preventing this technique: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Hiki ni dhana ya msingi sana. Vipande katika bin isiyo na mpangilio vitakuwa na viashiria. Kipande cha kwanza katika bin isiyo na mpangilio kitakuwa na **`fd`** na viungo vya **`bk`** **vinavyoelekeza sehemu ya arena kuu (Glibc)**.\
Hivyo, ikiwa unaweza **kweka kipande ndani ya bin isiyo na mpangilio na kukisoma** (tumia baada ya bure) au **kukipatia tena bila kuandika angalau 1 ya viashiria** ili kisha **kusoma** hiyo, unaweza kuwa na **kuvuja kwa Glibc**.

Shambulio linalofanana [**lililotumika katika andiko hili**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), lilikuwa kutumia muundo wa vipande 4 (A, B, C na D - D ni tu kuzuia kuunganishwa na kipande cha juu) hivyo overflow ya byte ya null katika B ilitumika kufanya C kuonyesha kwamba B haijatumika. Pia, katika B data ya `prev_size` ilibadilishwa hivyo ukubwa badala ya kuwa ukubwa wa B ilikuwa A+B.\
Kisha C ilifutwa, na kuunganishwa na A+B (lakini B bado ilikuwa inatumika). Kipande kipya cha ukubwa A kilipatikana na kisha anwani za libc zilivuja zikaandikwa ndani ya B kutoka ambapo zilivuja.

## References & Other examples

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Lengo ni kuandika thamani ya kimataifa iliyo na thamani kubwa kuliko 4869 ili iwezekane kupata bendera na PIE haijawashwa.
* Inawezekana kuzalisha vipande vya ukubwa wowote na kuna overflow ya heap yenye ukubwa unaotakiwa.
* Shambulio linaanza kwa kuunda vipande 3: kipande0 ili kutumia overflow, kipande1 ili kujaa na kipande2 ili kipande cha juu kisijumuishwe na vipande vya awali.
* Kisha, kipande1 kinafutwa na kipande0 kinajaa hadi kiashiria cha `bk` cha kipande1 kinaelekeza: `bk = magic - 0x10`
* Kisha, kipande3 kinapatikana kwa ukubwa sawa na kipande1, ambacho kitachochea shambulio la bin isiyo na mpangilio na kubadilisha thamani ya kiashiria cha kimataifa, na kufanya iwezekane kupata bendera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Kazi ya kuunganishwa ina udhaifu kwa sababu ikiwa viashiria vyote viwili vilivyopitishwa ni sawa itafanya realloc juu yake na kisha ifute lakini ikirudisha kiashiria kwa eneo hilo lililofutwa ambalo linaweza kutumika.
* Hivyo, **vipande 2 vinaundwa**: **kipande0** ambacho kitaundwa na mwenyewe na kipande1 ili kuzuia kuunganishwa na kipande cha juu. Kisha, **kazi ya kuunganishwa inaitwa na kipande0** mara mbili ambayo itasababisha matumizi baada ya bure.
* Kisha, kazi ya **`view`** inaitwa na index 2 (ambayo ni index ya kipande kilichotumika baada ya bure), ambayo it **kuvuja anwani ya libc**.
* Kwa kuwa binary ina kinga za kutumia tu ukubwa wa malloc mkubwa kuliko **`global_max_fast`** hivyo hakuna fastbin inatumika, shambulio la bin isiyo na mpangilio litatumika kuandika kiashiria cha kimataifa `global_max_fast`.
* Kisha, inawezekana kuita kazi ya kuhariri na index 2 (kiashiria cha matumizi baada ya bure) na kuandika kiashiria cha `bk` ili kiweze kuelekeza kwenye `p64(global_max_fast-0x10)`. Kisha, kuunda kipande kipya kutatumia anwani ya bure iliyovunjika (0x20) it **kuchochea shambulio la bin isiyo na mpangilio** kuandika `global_max_fast` ambayo ni thamani kubwa sana, ikiruhusu sasa kuunda vipande katika fast bins.
* Sasa shambulio la **fast bin** linafanywa:
* Kwanza kabisa inagundulika kwamba inawezekana kufanya kazi na fast **vipande vya ukubwa 200** katika eneo la **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Ikiwa tutafanikiwa kupata kipande cha haraka cha ukubwa 0x200 katika eneo hili, itakuwa inawezekana kuandika kiashiria cha kazi ambacho kitatekelezwa
* Kwa hili, kipande kipya cha ukubwa `0xfc` kinaundwa na kazi ya kuunganishwa inaitwa na kiashiria hicho mara mbili, kwa njia hii tunapata kiashiria kwa kipande kilichofutwa cha ukubwa `0xfc*2 = 0x1f8` katika fast bin.
* Kisha, kazi ya kuhariri inaitwa katika kipande hiki kubadilisha anwani ya **`fd`** ya fast bin hii ili kuelekeza kwenye kazi ya awali ya **`__free_hook`**.
* Kisha, kipande chenye ukubwa `0x1f8` kinaundwa ili kupata kutoka fast bin kipande kisichokuwa na matumizi cha awali ili kipande kingine cha ukubwa `0x1f8` kiundwe ili kupata kipande cha fast bin katika **`__free_hook`** ambacho kimeandikwa na anwani ya kazi ya **`system`**.
* Na hatimaye kipande kinachoshikilia mfuatano wa `/bin/sh\x00` kinafutwa kwa kuita kazi ya kufuta, kuchochea kazi ya **`__free_hook`** ambayo inaelekeza kwenye system na `/bin/sh\x00` kama parameter.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Mfano mwingine wa kutumia overflow ya 1B kuunganishwa kwa vipande katika bin isiyo na mpangilio na kupata kuvuja kwa libc na kisha kufanya shambulio la fast bin kuandika hook ya malloc na anwani ya gadget moja
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Tunaweza tu kuunda vipande vya ukubwa mkubwa kuliko `0x100`.
* Andika `global_max_fast` kwa kutumia shambulio la Unsorted Bin (inashughulika 1/16 kwa sababu ya ASLR, kwa sababu tunahitaji kubadilisha bits 12, lakini tunapaswa kubadilisha bits 16).
* Shambulio la Fast Bin kubadilisha array ya kimataifa ya vipande. Hii inatoa primitive ya kusoma/kandika isiyo na mipaka, ambayo inaruhusu kubadilisha GOT na kuweka kazi fulani kuelekeza kwenye `system`.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
