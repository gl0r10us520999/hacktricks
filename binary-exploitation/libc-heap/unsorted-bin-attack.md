# Unsorted Bin Attack

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Grundinformationen

F√ºr weitere Informationen dar√ºber, was ein unsortierter Bin ist, siehe diese Seite:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Unsortierte Listen k√∂nnen die Adresse von `unsorted_chunks (av)` in der `bk`-Adresse des Chunks schreiben. Daher, wenn ein Angreifer **die Adresse des `bk`-Zeigers** in einem Chunk innerhalb des unsortierten Bins **modifizieren** kann, k√∂nnte er in der Lage sein, **diese Adresse an einer beliebigen Adresse zu schreiben**, was hilfreich sein k√∂nnte, um Glibc-Adressen zu leaken oder einige Abwehrma√ünahmen zu umgehen.

Im Grunde erm√∂glicht dieser Angriff, **eine gro√üe Zahl an einer beliebigen Adresse zu setzen**. Diese gro√üe Zahl ist eine Adresse, die eine Heap-Adresse oder eine Glibc-Adresse sein k√∂nnte. Ein typisches Ziel ist **`global_max_fast`**, um die Erstellung von Fast-Bin-Bins mit gr√∂√üeren Gr√∂√üen zu erm√∂glichen (und von einem unsortierten Bin-Angriff zu einem Fast-Bin-Angriff √ºberzugehen).

{% hint style="success" %}
Ein Blick auf das Beispiel, das in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) bereitgestellt wird, und die Verwendung von 0x4000 und 0x5000 anstelle von 0x400 und 0x500 als Chunk-Gr√∂√üen (um Tcache zu vermeiden), zeigt, dass **heutzutage** der Fehler **`malloc(): unsorted double linked list corrupted`** ausgel√∂st wird.

Daher erfordert dieser unsortierte Bin-Angriff jetzt (neben anderen √úberpr√ºfungen) auch die F√§higkeit, die doppelt verkettete Liste zu reparieren, sodass dies `victim->bk->fd == victim` oder nicht `victim->fd == av (arena)` umgangen wird, was bedeutet, dass die Adresse, an die wir schreiben m√∂chten, die Adresse des gef√§lschten Chunks in seiner `fd`-Position haben muss und dass der gef√§lschte Chunk `fd` auf die Arena zeigt.
{% endhint %}

{% hint style="danger" %}
Beachte, dass dieser Angriff den unsortierten Bin (und damit auch kleine und gro√üe) besch√§digt. Daher k√∂nnen wir jetzt nur **Allokationen aus dem Fast Bin verwenden** (ein komplexeres Programm k√∂nnte andere Allokationen durchf√ºhren und abst√ºrzen), und um dies auszul√∂sen, m√ºssen wir **die gleiche Gr√∂√üe allokieren, oder das Programm wird abst√ºrzen.**

Beachte, dass das √úberschreiben von **`global_max_fast`** in diesem Fall helfen k√∂nnte, in der Annahme, dass der Fast Bin in der Lage sein wird, sich um alle anderen Allokationen zu k√ºmmern, bis der Exploit abgeschlossen ist.
{% endhint %}

Der Code von [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) erkl√§rt es sehr gut, obwohl du, wenn du die Mallocs √§nderst, um gen√ºgend Speicher zu allokieren, sodass du nicht in einem Tcache landest, sehen kannst, dass der zuvor erw√§hnte Fehler erscheint, der diese Technik verhindert: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Angriff

Dies ist tats√§chlich ein sehr grundlegendes Konzept. Die Chunks im unsortierten Bin werden Zeiger haben. Der erste Chunk im unsortierten Bin wird tats√§chlich die **`fd`**- und **`bk`**-Links **auf einen Teil der Hauptarena (Glibc)** zeigen.\
Daher, wenn du **einen Chunk in einen unsortierten Bin legen und ihn lesen** (use after free) oder **ihn erneut allokieren kannst, ohne mindestens 1 der Zeiger zu √ºberschreiben**, um ihn dann **zu lesen**, kannst du einen **Glibc-Infoleak** erhalten.

Ein √§hnlicher [**Angriff, der in diesem Bericht verwendet wurde**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), bestand darin, eine Struktur mit 4 Chunks (A, B, C und D - D dient nur dazu, die Konsolidierung mit dem Top-Chunk zu verhindern) auszunutzen, sodass ein Null-Byte-Overflow in B verwendet wurde, um C anzuzeigen, dass B ungenutzt war. Au√üerdem wurde in B die `prev_size`-Daten ge√§ndert, sodass die Gr√∂√üe anstelle der Gr√∂√üe von B A+B war.\
Dann wurde C freigegeben und mit A+B konsolidiert (aber B war weiterhin in Gebrauch). Ein neuer Chunk der Gr√∂√üe A wurde allokiert und dann wurden die geleakten Adressen der libc in B geschrieben, von wo sie geleakt wurden.

## Referenzen & Weitere Beispiele

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Das Ziel ist es, eine globale Variable mit einem Wert gr√∂√üer als 4869 zu √ºberschreiben, sodass es m√∂glich ist, die Flagge zu erhalten und PIE nicht aktiviert ist.
* Es ist m√∂glich, Chunks beliebiger Gr√∂√üen zu generieren, und es gibt einen Heap-Overflow mit der gew√ºnschten Gr√∂√üe.
* Der Angriff beginnt mit der Erstellung von 3 Chunks: chunk0, um den Overflow auszunutzen, chunk1, um √ºberflutet zu werden, und chunk2, damit der Top-Chunk die vorherigen nicht konsolidiert.
* Dann wird chunk1 freigegeben und chunk0 wird √ºberflutet, sodass der `bk`-Zeiger von chunk1 auf zeigt: `bk = magic - 0x10`
* Dann wird chunk3 mit der gleichen Gr√∂√üe wie chunk1 allokiert, was den unsortierten Bin-Angriff ausl√∂st und den Wert der globalen Variable √§ndert, wodurch es m√∂glich wird, die Flagge zu erhalten.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die Merge-Funktion ist anf√§llig, weil, wenn beide √ºbergebenen Indizes gleich sind, sie darauf realloc und dann freigeben wird, aber einen Zeiger auf diesen freigegebenen Bereich zur√ºckgibt, der verwendet werden kann.
* Daher werden **2 Chunks erstellt**: **chunk0**, das mit sich selbst zusammengef√ºhrt wird, und chunk1, um die Konsolidierung mit dem Top-Chunk zu verhindern. Dann wird die **Merge-Funktion mit chunk0** zweimal aufgerufen, was zu einem Use-After-Free f√ºhrt.
* Dann wird die **`view`**-Funktion mit Index 2 (der Index des Use-After-Free-Chunks) aufgerufen, was einen **libc-Adresse leak** ausl√∂sen wird.
* Da die Bin√§rdatei Schutzma√ünahmen hat, um nur Malloc-Gr√∂√üen gr√∂√üer als **`global_max_fast`** zuzulassen, wird ein unsortierter Bin-Angriff verwendet, um die globale Variable `global_max_fast` zu √ºberschreiben.
* Dann ist es m√∂glich, die Edit-Funktion mit Index 2 (dem Use-After-Free-Zeiger) aufzurufen und den `bk`-Zeiger so zu √ºberschreiben, dass er auf `p64(global_max_fast-0x10)` zeigt. Dann wird ein neuer Chunk erstellt, der die zuvor kompromittierte freigegebene Adresse (0x20) verwendet, was den **unsortierten Bin-Angriff** ausl√∂st, der `global_max_fast` √ºberschreibt, was einen sehr gro√üen Wert hat, sodass jetzt Chunks in Fast-Bins erstellt werden k√∂nnen.
* Jetzt wird ein **Fast Bin-Angriff** durchgef√ºhrt:
* Zun√§chst wird entdeckt, dass es m√∂glich ist, mit schnellen **Chunks der Gr√∂√üe 200** im **`__free_hook`**-Bereich zu arbeiten:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Wenn es uns gelingt, einen schnellen Chunk der Gr√∂√üe 0x200 an dieser Stelle zu erhalten, wird es m√∂glich sein, einen Funktionszeiger zu √ºberschreiben, der ausgef√ºhrt wird.
* Dazu wird ein neuer Chunk der Gr√∂√üe `0xfc` erstellt und die Merge-Funktion wird mit diesem Zeiger zweimal aufgerufen, sodass wir einen Zeiger auf einen freigegebenen Chunk der Gr√∂√üe `0xfc*2 = 0x1f8` im Fast Bin erhalten.
* Dann wird die Edit-Funktion in diesem Chunk aufgerufen, um die **`fd`**-Adresse dieses Fast Bins so zu √§ndern, dass sie auf die vorherige **`__free_hook`**-Funktion zeigt.
* Dann wird ein Chunk der Gr√∂√üe `0x1f8` erstellt, um den vorherigen nutzlosen Chunk aus dem Fast Bin abzurufen, sodass ein weiterer Chunk der Gr√∂√üe `0x1f8` erstellt wird, um einen Fast Bin-Chunk im **`__free_hook`** zu erhalten, der mit der Adresse der **`system`**-Funktion √ºberschrieben wird.
* Und schlie√ülich wird ein Chunk, der den String `/bin/sh\x00` enth√§lt, freigegeben, indem die Delete-Funktion aufgerufen wird, was die **`__free_hook`**-Funktion ausl√∂st, die auf system mit `/bin/sh\x00` als Parameter zeigt.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Ein weiteres Beispiel f√ºr den Missbrauch eines 1B-Overflows, um Chunks im unsortierten Bin zu konsolidieren und einen libc-Infoleak zu erhalten und dann einen Fast Bin-Angriff durchzuf√ºhren, um den Malloc-Hook mit einer One-Gadget-Adresse zu √ºberschreiben.
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Wir k√∂nnen nur Chunks mit einer Gr√∂√üe gr√∂√üer als `0x100` allokieren.
* √úberschreibe `global_max_fast` mit einem Unsorted Bin-Angriff (funktioniert 1/16 Mal aufgrund von ASLR, da wir 12 Bits √§ndern m√ºssen, aber 16 Bits √§ndern m√ºssen).
* Fast Bin-Angriff, um ein globales Array von Chunks zu √§ndern. Dies gibt eine beliebige Lese-/Schreibprimitive, die es erm√∂glicht, die GOT zu √§ndern und einige Funktionen auf `system` zu zeigen.

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
