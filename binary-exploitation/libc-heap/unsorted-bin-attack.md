# Shambulio la Benki Isiyopangwa

{% hint style="success" %}
Jifunze & zoezi la Kuvamia AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks ya Mtaalam wa Timu Nyekundu ya AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & zoezi la Kuvamia GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks ya Mtaalam wa Timu Nyekundu ya GCP (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za kuvamia kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Taarifa Msingi

Kwa habari zaidi kuhusu ni nini benki isiyopangwa angalia ukurasa huu:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Orodha zisizopangwa zinaweza kuandika anwani kwa `unsorted_chunks (av)` kwenye anwani ya `bk` ya kipande. Kwa hivyo, ikiwa mshambuliaji anaweza **kurekebisha anwani ya kielekezi cha `bk`** katika kipande ndani ya benki isiyopangwa, anaweza kuwa na uwezo wa **kuandika anwani hiyo katika anwani ya aina yoyote** ambayo inaweza kusaidia kuvuja anwani za Glibc au kuepuka ulinzi fulani.

Kwa hivyo, kimsingi, shambulio hili linaruhusu **kuweka nambari kubwa kwenye anwani ya aina yoyote**. Nambari kubwa hii ni anwani, ambayo inaweza kuwa anwani ya rundo au anwani ya Glibc. Lengo la kawaida ni **`global_max_fast`** kuruhusu kuunda benki za haraka zenye saizi kubwa (na kupita kutoka shambulio la benki isiyopangwa hadi shambulio la benki ya haraka).

{% hint style="success" %}
Kwa kuangalia mfano uliotolewa katika [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) na kutumia 0x4000 na 0x5000 badala ya 0x400 na 0x500 kama saizi za kipande (kuepuka Tcache) inawezekana kuona kwamba **siku hizi** kosa **`malloc(): unsorted double linked list corrupted`** linasababishwa.

Kwa hivyo, shambulio la benki isiyopangwa sasa (miongoni mwa ukaguzi mwingine) pia inahitaji kuweza kurekebisha orodha iliyodoubli ili hii ipuuzwe `victim->bk->fd == victim` au sio `victim->fd == av (arena)`, ambayo inamaanisha kwamba anwani ambapo tunataka kuandika lazima iwe na anwani ya kipande bandia katika nafasi yake ya `fd` na kwamba kipande bandia `fd` inaelekeza kwenye uwanja.
{% endhint %}

{% hint style="danger" %}
Tafadhali elewa kwamba shambulio hili linaharibu benki isiyopangwa (hivyo ndogo na kubwa pia). Kwa hivyo tunaweza **tumia vipande kutoka kwa benki ya haraka sasa** (programu yenye utata zaidi inaweza kufanya alokesheni zingine na kugonga), na kuzindua hii lazima **aloke kwa saizi ile ile au programu itaanguka.**

Tafadhali elewa kwamba kubadilisha **`global_max_fast`** kunaweza kusaidia katika kesi hii kwa kuamini kwamba benki ya haraka itaweza kushughulikia alokesheni zingine zote hadi shambulio linakamilika.
{% endhint %}

Msimbo kutoka [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) unaelezea vizuri, ingawa ikiwa utabadilisha mallocs kuweka kumbukumbu kubwa ya kutosha ili isimalize kwenye Tcache unaweza kuona kosa lililotajwa hapo awali linalozuia mbinu hii: **`malloc(): unsorted double linked list corrupted`**

## Shambulio la Unsorted Bin Infoleak

Hii ni dhana ya msingi sana. Vipande katika benki isiyopangwa vitakuwa na kielekezi. Kipande cha kwanza katika benki isiyopangwa kimsingi kitakuwa na viungo vya **`fd`** na **`bk`** **vinavyoelekeza sehemu ya uwanja mkuu (Glibc)**.\
Kwa hivyo, ikiwa unaweza **kuweka kipande ndani ya benki isiyopangwa na kusoma** (tumia baada ya kuachilia) au **kualokesheni tena bila kubadilisha angalau 1 ya viungo** kisha **kusoma** hiyo, unaweza kuwa na **uvujaji wa habari za Glibc**.

[**Shambulio linalotumiwa katika andiko hili**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), lilikuwa kutumia muundo wa vipande 4 (A, B, C na D - D ni kuzuia konsolidisheni na kipande cha juu) hivyo kuzidi kwa herufi sifuri katika B kulitumika kufanya C ionyeshe kuwa B haikutumiwa. Pia, katika B data ya `prev_size` ilibadilishwa ili saizi badala ya kuwa saizi ya B iwe A+B.\
Kisha C iliondolewa, na konsolidishwa na A+B (lakini B ilikuwa bado inatumika). Kipande kipya cha saizi ya A kilialokeshwa na kisha anwani zilizovuja za libc ziliandikwa kwenye B kutoka ambapo zilivuja.

## Marejeo & Mifano Mingine

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Lengo ni kubadilisha kigezo la jumla na thamani kubwa kuliko 4869 ili iwezekane kupata bendera na PIE haipo.
* Inawezekana kuzalisha vipande vya saizi za aina yoyote na kuna kuzidi kwa rundo lenye saizi inayotakiwa.
* Shambulio linaanza kwa kuunda vipande 3: kipande0 kutumia kuzidi, kipande1 kuwa na kuzidi na kipande2 ili kuzuia konsolidisheni na vipande vilivyotangulia.
* Kisha, kipande1 kinaachiliwa na kipande0 kina kuzidi kwa kielekezi cha `bk` cha kipande1 kinaelekeza: `bk = magic - 0x10`
* Kisha, kipande3 kinalokeshwa na saizi sawa na kipande1, ambacho kitazindua shambulio la benki isiyopangwa na kurekebisha thamani ya kigezo la jumla, kuruhusu kupata bendera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Kazi ya kufunga ina mapungufu kwa sababu ikiwa viashiria vyote viwili vilivyopitishwa ni sawa itarealloc juu yake na kisha kuifuta lakini kurudisha kielekezi kwa eneo hilo lililofutwa ambalo linaweza kutumika.
* Kwa hivyo, **vipande 2 vinavyoundwa**: **kipande0** ambacho kitakusanywa na yenyewe na kipande1 kuzuia konsolidisheni na kipande cha juu. Kisha, **kazi ya kufunga inaitwa na kipande0** mara mbili ambayo itasababisha matumizi baada ya kuachilia.
* Kisha, **kazi ya `view`** inaitwa na index 2 (ambayo ni index ya kipande baada ya kutumia baada ya kuachilia), ambayo ita **vujisha anwani ya libc**.
* Kwa kuwa binary ina ulinzi wa tu malloc saizi kubwa kuliko **`global_max_fast`** hivyo hakuna fastbin inayotumiwa, shambulio la benki isiyopangwa litatumika kurekebisha kigezo cha jumla `global_max_fast`.
* Kisha, inawezekana kuita kazi ya hariri na index 2 (kielekezi baada ya kutumia baada ya kuachilia) na kurekebisha kielekezi cha `bk` ili kielekeze kwa `p64(global_max_fast-0x10)`. Kisha, kuunda kipande kipya kutatumia kielekezi kilichofutwa hapo awali (0x20) kutazindua shambulio la benki isiyopangwa kurekebisha `global_max_fast` na thamani kubwa sana, kuruhusu sasa kuunda vipande katika benki za haraka.
* Sasa shambulio la **benki ya haraka** linatekelezwa:
* Kwanza kabisa inagundulika kwamba inawezekana kufanya kazi na **vipande vya haraka vya saizi 200** kwenye eneo la **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Ikiwa tutafanikiwa kupata kipande cha haraka cha ukubwa wa 0x200 katika eneo hili, itakuwa inawezekana kubadilisha pointer ya kazi ambayo itatekelezwa
* Kwa hili, kipande kipya cha ukubwa wa `0xfc` huzalishwa na kazi iliyohaririwa huitwa mara mbili na pointer hiyo, njia hii tunapata pointer kwa kipande kilichofutwa cha ukubwa wa `0xfc*2 = 0x1f8` katika fast bin.
* Kisha, kazi ya hariri inaitwa katika kipande hiki kurekebisha anwani ya **`fd`** ya fast bin hii ielekeze kwa kazi ya awali ya **`__free_hook`**.
* Kisha, kipande cha ukubwa wa `0x1f8` huzalishwa ili kupata kutoka kwa fast bin kipande cha hapo awali kisichotumika hivyo kipande kingine cha ukubwa wa `0x1f8` huzalishwa ili kupata kipande cha fast bin katika **`__free_hook`** ambayo inabadilishwa na anwani ya kazi ya **`system`**.
* Na hatimaye kipande kinachohifadhi string `/bin/sh\x00` hurudishwa kwa kuita kazi ya kufuta, kuzindua kazi ya **`__free_hook`** ambayo inaelekeza kwa mfumo na `/bin/sh\x00` kama parameta.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Mfano mwingine wa kutumia kipindi cha 1B kufanya kipande cha unsorted bin na kupata libc infoleak na kisha kufanya shambulio la fast bin kubadilisha kitanzi cha malloc na anwani ya one gadget
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Tunaweza tu kuweka vipande vya ukubwa zaidi ya `0x100`.
* Badilisha `global_max_fast` kwa kutumia shambulio la Unsorted Bin (inafanya kazi 1/16 ya wakati kutokana na ASLR, kwa sababu tunahitaji kurekebisha bits 12, lakini lazima tubadilishe bits 16).
* Shambulio la Fast Bin kubadilisha safu ya kimataifa ya vipande. Hii hutoa msingi wa kusoma/ku
