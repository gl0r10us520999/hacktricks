# Attaque de la Bin Non Tri√©e

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Informations de Base

Pour plus d'informations sur ce qu'est une bin non tri√©e, consultez cette page :

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Les listes non tri√©es peuvent √©crire l'adresse dans `unsorted_chunks (av)` dans l'adresse `bk` du chunk. Par cons√©quent, si un attaquant peut **modifier l'adresse du pointeur `bk`** dans un chunk √† l'int√©rieur de la bin non tri√©e, il pourrait √™tre capable de **√©crire cette adresse √† une adresse arbitraire** ce qui pourrait √™tre utile pour divulguer des adresses Glibc ou contourner certaines d√©fenses.

Donc, fondamentalement, cette attaque permet de **d√©finir un grand nombre √† une adresse arbitraire**. Ce grand nombre est une adresse, qui pourrait √™tre une adresse de tas ou une adresse Glibc. Une cible typique est **`global_max_fast`** pour permettre de cr√©er des bins rapides avec des tailles plus grandes (et passer d'une attaque de bin non tri√©e √† une attaque de bin rapide).

{% hint style="success" %}
En regardant l'exemple fourni dans [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) et en utilisant 0x4000 et 0x5000 au lieu de 0x400 et 0x500 comme tailles de chunk (pour √©viter Tcache), il est possible de voir que **de nos jours** l'erreur **`malloc(): liste doublement cha√Æn√©e non tri√©e corrompue`** est d√©clench√©e.

Par cons√©quent, cette attaque de bin non tri√©e n√©cessite maintenant (entre autres v√©rifications) √©galement d'√™tre capable de r√©parer la liste doublement cha√Æn√©e afin que cela soit contourn√© `victim->bk->fd == victim` ou non `victim->fd == av (arena)`, ce qui signifie que l'adresse o√π nous voulons √©crire doit avoir l'adresse du faux chunk dans sa position `fd` et que le faux chunk `fd` pointe vers l'ar√®ne.
{% endhint %}

{% hint style="danger" %}
Notez que cette attaque corrompt la bin non tri√©e (d'o√π les petites et grandes aussi). Donc, nous ne pouvons **utiliser que des allocations √† partir de la bin rapide maintenant** (un programme plus complexe pourrait faire d'autres allocations et planter), et pour d√©clencher cela, nous devons **allouer la m√™me taille ou le programme plantera.**

Notez que l'√©crasement de **`global_max_fast`** pourrait aider dans ce cas en faisant confiance au fait que la bin rapide sera capable de s'occuper de toutes les autres allocations jusqu'√† ce que l'exploitation soit termin√©e.
{% endhint %}

Le code de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) l'explique tr√®s bien, bien que si vous modifiez les mallocs pour allouer une m√©moire suffisamment grande pour ne pas se retrouver dans un Tcache, vous pouvez voir que l'erreur mentionn√©e pr√©c√©demment appara√Æt emp√™chant cette technique : **`malloc(): liste doublement cha√Æn√©e non tri√©e corrompue`**

## Attaque de Divulgation d'Informations de Bin Non Tri√©e

C'est en fait un concept tr√®s basique. Les chunks dans la bin non tri√©e vont avoir des pointeurs. Le premier chunk dans la bin non tri√©e aura en fait les liens **`fd`** et **`bk`** **pointant vers une partie de l'ar√®ne principale (Glibc)**.\
Par cons√©quent, si vous pouvez **mettre un chunk √† l'int√©rieur d'une bin non tri√©e et le lire** (utiliser apr√®s lib√©ration) ou **le r√©allouer sans √©craser au moins 1 des pointeurs** pour ensuite **le lire**, vous pouvez avoir une **divulgation d'informations Glibc**.

Une [**attaque similaire utilis√©e dans ce rapport**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html) a √©t√© d'abuser d'une structure de 4 chunks (A, B, C et D - D est seulement pour emp√™cher la consolidation avec le chunk sup√©rieur) donc un d√©bordement de byte nul dans B a √©t√© utilis√© pour faire en sorte que C indique que B √©tait inutilis√©. De plus, dans B, les donn√©es `prev_size` ont √©t√© modifi√©es pour que la taille au lieu d'√™tre la taille de B soit A+B.\
Ensuite, C a √©t√© d√©sallou√© et consolid√© avec A+B (mais B √©tait toujours utilis√©). Un nouveau chunk de taille A a √©t√© allou√© et ensuite les adresses libc divulgu√©es ont √©t√© √©crites dans B d'o√π elles ont √©t√© divulgu√©es.

## R√©f√©rences et Autres Exemples

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* L'objectif est d'√©craser une variable globale avec une valeur sup√©rieure √† 4869 afin qu'il soit possible d'obtenir le drapeau et que PIE ne soit pas activ√©.
* Il est possible de g√©n√©rer des chunks de tailles arbitraires et il y a un d√©bordement de tas avec la taille souhait√©e.
* L'attaque commence par cr√©er 3 chunks : chunk0 pour abuser du d√©bordement, chunk1 pour √™tre d√©bord√© et chunk2 pour que le chunk sup√©rieur ne consolide pas les pr√©c√©dents.
* Ensuite, chunk1 est lib√©r√© et chunk0 est d√©bord√© pour que le pointeur `bk` de chunk1 pointe vers : `bk = magic - 0x10`
* Ensuite, chunk3 est allou√© avec la m√™me taille que chunk1, ce qui d√©clenchera l'attaque de bin non tri√©e et modifiera la valeur de la variable globale, rendant possible d'obtenir le drapeau.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La fonction de fusion est vuln√©rable car si les deux index pass√©s sont le m√™me, elle le r√©allouera et ensuite le lib√©rera mais renverra un pointeur vers cette r√©gion lib√©r√©e qui peut √™tre utilis√©e.
* Par cons√©quent, **2 chunks sont cr√©√©s** : **chunk0** qui sera fusionn√© avec lui-m√™me et chunk1 pour emp√™cher la consolidation avec le chunk sup√©rieur. Ensuite, la **fonction de fusion est appel√©e avec chunk0** deux fois, ce qui provoquera une utilisation apr√®s lib√©ration.
* Ensuite, la **fonction `view`** est appel√©e avec l'index 2 (qui est l'index du chunk utilis√© apr√®s lib√©ration), ce qui **divulguera une adresse libc**.
* Comme le binaire a des protections pour n'allouer que des tailles sup√©rieures √† **`global_max_fast`**, donc aucune bin rapide n'est utilis√©e, une attaque de bin non tri√©e sera utilis√©e pour √©craser la variable globale `global_max_fast`.
* Ensuite, il est possible d'appeler la fonction d'√©dition avec l'index 2 (le pointeur utilis√© apr√®s lib√©ration) et d'√©craser le pointeur `bk` pour pointer vers `p64(global_max_fast-0x10)`. Ensuite, la cr√©ation d'un nouveau chunk utilisera l'adresse libre compromise pr√©c√©demment (0x20) qui **d√©clenchera l'attaque de bin non tri√©e** √©crasant le `global_max_fast` qui a une tr√®s grande valeur, permettant maintenant de cr√©er des chunks dans des bins rapides.
* Maintenant, une **attaque de bin rapide** est effectu√©e :
* Tout d'abord, il est d√©couvert qu'il est possible de travailler avec des **chunks de taille 200** dans l'emplacement **`__free_hook`** :
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Si nous parvenons √† obtenir un chunk rapide de taille 0x200 √† cet emplacement, il sera possible d'√©craser un pointeur de fonction qui sera ex√©cut√©.
* Pour cela, un nouveau chunk de taille `0xfc` est cr√©√© et la fonction fusionn√©e est appel√©e avec ce pointeur deux fois, de cette fa√ßon nous obtenons un pointeur vers un chunk lib√©r√© de taille `0xfc*2 = 0x1f8` dans la bin rapide.
* Ensuite, la fonction d'√©dition est appel√©e dans ce chunk pour modifier l'adresse **`fd`** de cette bin rapide pour pointer vers la fonction **`__free_hook`** pr√©c√©dente.
* Ensuite, un chunk de taille `0x1f8` est cr√©√© pour r√©cup√©rer de la bin rapide le chunk inutile pr√©c√©dent afin qu'un autre chunk de taille `0x1f8` soit cr√©√© pour obtenir un chunk de bin rapide dans le **`__free_hook`** qui est √©cras√© avec l'adresse de la fonction **`system`**.
* Et enfin, un chunk contenant la cha√Æne `/bin/sh\x00` est lib√©r√© en appelant la fonction de suppression, d√©clenchant la fonction **`__free_hook`** qui pointe vers system avec `/bin/sh\x00` comme param√®tre.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Un autre exemple d'abus d'un d√©bordement de 1B pour consolider des chunks dans la bin non tri√©e et obtenir une divulgation d'informations libc, puis effectuer une attaque de bin rapide pour √©craser le crochet malloc avec une adresse de gadget unique.
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Nous ne pouvons allouer que des chunks de taille sup√©rieure √† `0x100`.
* √âcraser `global_max_fast` en utilisant une attaque de bin non tri√©e (fonctionne 1/16 fois en raison de l'ASLR, car nous devons modifier 12 bits, mais nous devons modifier 16 bits).
* Attaque de bin rapide pour modifier un tableau global de chunks. Cela donne une primitive de lecture/√©criture arbitraire, ce qui permet de modifier le GOT et de d√©finir certaines fonctions pour pointer vers `system`.

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
