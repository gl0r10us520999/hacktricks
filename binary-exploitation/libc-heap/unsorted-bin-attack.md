# Attaque de la liste non tri√©e

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supportez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Informations de base

Pour plus d'informations sur ce qu'est une liste non tri√©e, consultez cette page :

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Les listes non tri√©es peuvent √©crire l'adresse de `unsorted_chunks (av)` dans l'adresse `bk` du chunk. Par cons√©quent, si un attaquant peut **modifier l'adresse du pointeur `bk`** dans un chunk √† l'int√©rieur de la liste non tri√©e, il pourrait √™tre en mesure d'**√©crire cette adresse dans une adresse arbitraire** ce qui pourrait √™tre utile pour divulguer des adresses Glibc ou contourner certaines d√©fenses.

Donc, fondamentalement, cette attaque permet de **d√©finir un grand nombre √† une adresse arbitraire**. Ce grand nombre est une adresse, qui pourrait √™tre une adresse de tas ou une adresse Glibc. Une cible typique est **`global_max_fast`** pour permettre de cr√©er des bacs rapides avec des tailles plus grandes (et passer d'une attaque de liste non tri√©e √† une attaque de bac rapide).

{% hint style="success" %}
En examinant l'exemple fourni dans [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) et en utilisant 0x4000 et 0x5000 au lieu de 0x400 et 0x500 comme tailles de chunk (pour √©viter le Tcache), il est possible de voir que de nos jours l'erreur **`malloc(): unsorted double linked list corrupted`** est d√©clench√©e.

Par cons√©quent, cette attaque de liste non tri√©e (parmi d'autres v√©rifications) n√©cessite √©galement de pouvoir corriger la liste doublement cha√Æn√©e pour contourner cela `victim->bk->fd == victim` ou non `victim->fd == av (ar√®ne)`, ce qui signifie que l'adresse o√π nous voulons √©crire doit avoir l'adresse du faux chunk dans sa position `fd` et que le faux chunk `fd` pointe vers l'ar√®ne.
{% endhint %}

{% hint style="danger" %}
Notez que cette attaque corrompt la liste non tri√©e (donc aussi petite et grande). Nous ne pouvons donc **utiliser que des allocations du bac rapide maintenant** (un programme plus complexe pourrait effectuer d'autres allocations et planter), et pour d√©clencher cela, nous devons **allouer la m√™me taille ou le programme plantera.**

Notez que le fait de remplacer **`global_max_fast`** pourrait aider dans ce cas en supposant que le bac rapide pourra g√©rer toutes les autres allocations jusqu'√† ce que l'exploit soit termin√©.
{% endhint %}

Le code de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) l'explique tr√®s bien, bien que si vous modifiez les mallocs pour allouer suffisamment de m√©moire pour ne pas aboutir √† un Tcache, vous verrez que l'erreur mentionn√©e pr√©c√©demment appara√Æt, emp√™chant ainsi cette technique : **`malloc(): unsorted double linked list corrupted`**

## Attaque d'Infoleak de la liste non tri√©e

Il s'agit en fait d'un concept tr√®s basique. Les chunks dans la liste non tri√©e vont avoir des pointeurs. Le premier chunk dans la liste non tri√©e aura en fait les liens **`fd`** et **`bk`** **pointant vers une partie de l'ar√®ne principale (Glibc)**.\
Par cons√©quent, si vous pouvez **mettre un chunk √† l'int√©rieur d'une liste non tri√©e et le lire** (utilisation apr√®s lib√©ration) ou **l'allouer √† nouveau sans √©craser au moins 1 des pointeurs** pour ensuite le **lire**, vous pouvez obtenir une **fuite d'informations Glibc**.

Une [**attaque similaire utilis√©e dans ce writeup**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), consistait √† abuser d'une structure de 4 chunks (A, B, C et D - D sert uniquement √† emp√™cher la consolidation avec le chunk sup√©rieur) de sorte qu'un d√©bordement de null byte dans B √©tait utilis√© pour indiquer que B √©tait inutilis√©. De plus, dans B, les donn√©es `prev_size` ont √©t√© modifi√©es pour que la taille, au lieu d'√™tre la taille de B, soit A+B.\
Ensuite, C a √©t√© d√©sallou√© et consolid√© avec A+B (mais B √©tait toujours utilis√©). Un nouveau chunk de taille A a √©t√© allou√© et les adresses de la libc divulgu√©es ont √©t√© √©crites dans B √† partir desquelles elles ont √©t√© divulgu√©es.

## R√©f√©rences et autres exemples

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* L'objectif est de remplacer une variable globale par une valeur sup√©rieure √† 4869 pour obtenir le drapeau et le PIE n'est pas activ√©.
* Il est possible de g√©n√©rer des chunks de tailles arbitraires et il y a un d√©bordement de tas avec la taille souhait√©e.
* L'attaque commence en cr√©ant 3 chunks : chunk0 pour exploiter le d√©bordement, chunk1 pour √™tre d√©bord√© et chunk2 pour que le chunk sup√©rieur ne consolide pas les pr√©c√©dents.
* Ensuite, chunk1 est lib√©r√© et chunk0 est d√©bord√© pour que le pointeur `bk` de chunk1 pointe vers : `bk = magic - 0x10`
* Ensuite, chunk3 est allou√© avec la m√™me taille que chunk1, ce qui d√©clenchera l'attaque de la liste non tri√©e et modifiera la valeur de la variable globale, permettant ainsi d'obtenir le drapeau.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La fonction de fusion est vuln√©rable car si les deux index pass√©s sont les m√™mes, elle va realloc dessus puis le lib√©rer mais renvoyer un pointeur vers cette r√©gion lib√©r√©e qui peut √™tre utilis√©.
* Par cons√©quent, **2 chunks sont cr√©√©s** : **chunk0** qui sera fusionn√© avec lui-m√™me et chunk1 pour emp√™cher la consolidation avec le chunk sup√©rieur. Ensuite, la **fonction de fusion est appel√©e avec chunk0** deux fois ce qui provoquera une utilisation apr√®s lib√©ration.
* Ensuite, la fonction **`view`** est appel√©e avec l'index 2 (qui est l'index du chunk utilis√© apr√®s lib√©ration), ce qui va **divulguer une adresse de la libc**.
* Comme le binaire a des protections pour allouer uniquement des tailles plus grandes que **`global_max_fast`** donc aucun fastbin n'est utilis√©, une attaque de liste non tri√©e va √™tre utilis√©e pour √©craser la variable globale `global_max_fast`.
* Ensuite, il est possible d'appeler la fonction edit avec l'index 2 (le pointeur utilis√© apr√®s lib√©ration) et d'√©craser le pointeur `bk` pour pointer vers `p64(global_max_fast-0x10)`. Ensuite, en cr√©ant un nouveau chunk, l'adresse de lib√©ration compromise pr√©c√©demment (0x20) va **d√©clencher l'attaque de la liste non tri√©e** en √©crasant le `global_max_fast` avec une valeur tr√®s grande, permettant maintenant de cr√©er des chunks dans les bacs rapides.
* Maintenant, une **attaque de bac rapide** est effectu√©e :
* Tout d'abord, il est d√©couvert qu'il est possible de travailler avec des **chunks rapides de taille 200** √† l'emplacement de **`__free_hook`** :
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Si nous parvenons √† obtenir un chunk rapide de taille 0x200 √† cet emplacement, il sera possible de remplacer un pointeur de fonction qui sera ex√©cut√©
* Pour cela, un nouveau chunk de taille `0xfc` est cr√©√© et la fonction fusionn√©e est appel√©e avec ce pointeur deux fois, de cette mani√®re nous obtenons un pointeur vers un chunk lib√©r√© de taille `0xfc*2 = 0x1f8` dans le fast bin.
* Ensuite, la fonction edit est appel√©e dans ce chunk pour modifier l'adresse **`fd`** de ce fast bin pour pointer vers la fonction **`__free_hook`** pr√©c√©dente.
* Ensuite, un chunk de taille `0x1f8` est cr√©√© pour r√©cup√©rer du fast bin le chunk inutile pr√©c√©dent, puis un autre chunk de taille `0x1f8` est cr√©√© pour obtenir un chunk fast bin dans le **`__free_hook`** qui est √©cras√© avec l'adresse de la fonction **`system`**.
* Enfin, un chunk contenant la cha√Æne `/bin/sh\x00` est lib√©r√© en appelant la fonction delete, d√©clenchant la fonction **`__free_hook`** qui pointe vers system avec `/bin/sh\x00` comme param√®tre.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Un autre exemple d'abus d'un d√©bordement de 1B pour consolider des chunks dans le unsorted bin et obtenir une fuite d'informations libc puis effectuer une attaque fast bin pour √©craser le crochet malloc avec une adresse de one gadget
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Nous ne pouvons allouer que des chunks de taille sup√©rieure √† `0x100`.
* √âcraser `global_max_fast` en utilisant une attaque Unsorted Bin (fonctionne 1/16 fois en raison de l'ASLR, car nous devons modifier 12 bits, mais nous devons modifier 16 bits).
* Attaque Fast Bin pour modifier un tableau global de chunks. Cela donne un primitive de lecture/√©criture arbitraire, qui permet de modifier la GOT et de d√©finir certaines fonctions pour pointer vers `system`.

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
