# Ataque al Bin No Ordenado

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* ¬°Consulta los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>
{% endhint %}

## Informaci√≥n B√°sica

Para obtener m√°s informaci√≥n sobre qu√© es un bin no ordenado, consulta esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Las listas no ordenadas pueden escribir la direcci√≥n en `unsorted_chunks (av)` en la direcci√≥n `bk` del fragmento. Por lo tanto, si un atacante puede **modificar la direcci√≥n del puntero `bk`** en un fragmento dentro del bin no ordenado, podr√≠a ser capaz de **escribir esa direcci√≥n en una direcci√≥n arbitraria** que podr√≠a ser √∫til para filtrar direcciones de Glibc o evitar alguna defensa.

Por lo tanto, b√°sicamente, este ataque permite **establecer un n√∫mero grande en una direcci√≥n arbitraria**. Este n√∫mero grande es una direcci√≥n, que podr√≠a ser una direcci√≥n de heap o una direcci√≥n de Glibc. Un objetivo t√≠pico es **`global_max_fast`** para permitir crear bins de fast bin con tama√±os m√°s grandes (y pasar de un ataque de bin no ordenado a un ataque de fast bin).

{% hint style="success" %}
Al observar el ejemplo proporcionado en [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) y usando 0x4000 y 0x5000 en lugar de 0x400 y 0x500 como tama√±os de fragmento (para evitar Tcache), es posible ver que **en la actualidad** se desencadena el error **`malloc(): unsorted double linked list corrupted`**.

Por lo tanto, este ataque de bin no ordenado ahora (entre otras comprobaciones) tambi√©n requiere poder arreglar la lista doble enlazada para que se salte esto `victim->bk->fd == victim` o no `victim->fd == av (arena)`, lo que significa que la direcci√≥n donde queremos escribir debe tener la direcci√≥n del fragmento falso en su posici√≥n `fd` y que el `fd` del fragmento falso apunta a la arena.
{% endhint %}

{% hint style="danger" %}
Ten en cuenta que este ataque corrompe el bin no ordenado (por lo tanto, tambi√©n el peque√±o y el grande). Por lo tanto, ahora solo podemos **utilizar asignaciones del fast bin** (un programa m√°s complejo podr√≠a hacer otras asignaciones y fallar), y para desencadenar esto debemos **asignar el mismo tama√±o o el programa fallar√°**.

Ten en cuenta que sobrescribir **`global_max_fast`** podr√≠a ayudar en este caso confiando en que el fast bin podr√° encargarse de todas las dem√°s asignaciones hasta que se complete el exploit.
{% endhint %}

El c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo explica muy bien, aunque si modificas las asignaciones de memoria para asignar memoria lo suficientemente grande para que no termine en un Tcache, puedes ver que aparece el error mencionado anteriormente que evita esta t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Ataque de Fuga de Informaci√≥n del Bin No Ordenado

Este es en realidad un concepto muy b√°sico. Los fragmentos en el bin no ordenado van a tener punteros. El primer fragmento en el bin no ordenado realmente tendr√° los enlaces **`fd`** y **`bk`** **apuntando a una parte de la arena principal (Glibc)**.\
Por lo tanto, si puedes **colocar un fragmento dentro de un bin no ordenado y leerlo** (uso despu√©s de liberar) o **asignarlo nuevamente sin sobrescribir al menos 1 de los punteros** para luego **leerlo**, puedes obtener una **fuga de informaci√≥n de Glibc**.

Un [**ataque similar utilizado en este informe**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), consisti√≥ en abusar de una estructura de 4 fragmentos (A, B, C y D - D es solo para evitar la consolidaci√≥n con el fragmento superior) por lo que se utiliz√≥ un desbordamiento de byte nulo en B para hacer que C indicara que B no se estaba utilizando. Adem√°s, en B se modific√≥ los datos de `prev_size` para que el tama√±o en lugar de ser el tama√±o de B fuera A+B.\
Luego se desasign√≥ C y se consolid√≥ con A+B (pero B a√∫n estaba en uso). Se asign√≥ un nuevo fragmento de tama√±o A y luego se escribieron las direcciones filtradas de Glibc en B desde donde se filtraron.

## Referencias y Otros ejemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* El objetivo es sobrescribir una variable global con un valor mayor que 4869 para poder obtener la bandera y PIE no est√° habilitado.
* Es posible generar fragmentos de tama√±os arbitrarios y hay un desbordamiento de heap con el tama√±o deseado.
* El ataque comienza creando 3 fragmentos: fragmento0 para abusar del desbordamiento, fragmento1 para ser desbordado y fragmento2 para que el fragmento superior no consolide los anteriores.
* Luego, se libera el fragmento1 y se desborda el fragmento0 para que el puntero `bk` del fragmento1 apunte a: `bk = magic - 0x10`
* Luego, se asigna el fragmento3 con el mismo tama√±o que el fragmento1, lo que desencadenar√° el ataque al bin no ordenado y modificar√° el valor de la variable global, lo que hace posible obtener la bandera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funci√≥n de fusi√≥n es vulnerable porque si ambos √≠ndices pasados son iguales, se realocar√° en √©l y luego se liberar√°, pero devolviendo un puntero a esa regi√≥n liberada que se puede utilizar.
* Por lo tanto, se crean **2 fragmentos**: **fragmento0** que se fusionar√° consigo mismo y fragmento1 para evitar la consolidaci√≥n con el fragmento superior. Luego, se llama a la **funci√≥n de fusi√≥n con el fragmento0** dos veces, lo que causar√° un uso despu√©s de liberar.
* Luego, se llama a la funci√≥n **`view`** con el √≠ndice 2 (que es el √≠ndice del fragmento de uso despu√©s de liberar), lo que **filtrar√° una direcci√≥n de Glibc**.
* Como el binario tiene protecciones para asignar solo tama√±os mayores que **`global_max_fast`** para que no se use fastbin, se utilizar√° un ataque al bin no ordenado para sobrescribir la variable global `global_max_fast`.
* Luego, es posible llamar a la funci√≥n de edici√≥n con el √≠ndice 2 (el puntero de uso despu√©s de liberar) y sobrescribir el puntero `bk` para que apunte a `p64(global_max_fast-0x10)`. Luego, al crear un nuevo fragmento, se usar√° la direcci√≥n de liberaci√≥n comprometida anteriormente (0x20) y se **desencadenar√° el ataque al bin no ordenado** sobrescribiendo el `global_max_fast` con un valor muy grande, lo que ahora permite crear fragmentos en los bins r√°pidos.
* Ahora se realiza un **ataque al fast bin**:
* En primer lugar, se descubre que es posible trabajar con **fragmentos r√°pidos de tama√±o 200** en la ubicaci√≥n de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Si logramos obtener un fragmento r√°pido de tama√±o 0x200 en esta ubicaci√≥n, ser√° posible sobrescribir un puntero de funci√≥n que se ejecutar√°.
* Para esto, se crea un nuevo fragmento de tama√±o `0xfc` y se llama a la funci√≥n fusionada con ese puntero dos veces, de esta manera obtenemos un puntero a un fragmento liberado de tama√±o `0xfc*2 = 0x1f8` en el fast bin.
* Luego, se llama a la funci√≥n edit en este fragmento para modificar la direcci√≥n **`fd`** de este fast bin para que apunte a la funci√≥n **`__free_hook`** anterior.
* Luego, se crea un fragmento con tama√±o `0x1f8` para recuperar del fast bin el fragmento in√∫til anterior, por lo que se crea otro fragmento de tama√±o `0x1f8` para obtener un fragmento de fast bin en el **`__free_hook`** que se sobrescribe con la direcci√≥n de la funci√≥n **`system`**.
* Y finalmente se libera un fragmento que contiene la cadena `/bin/sh\x00` llamando a la funci√≥n delete, desencadenando la funci√≥n **`__free_hook`** que apunta a system con `/bin/sh\x00` como par√°metro.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Otro ejemplo de abuso de un desbordamiento de 1B para consolidar fragmentos en el unsorted bin y obtener una fuga de informaci√≥n de libc y luego realizar un ataque de fast bin para sobrescribir el gancho de asignaci√≥n con una direcci√≥n de un solo gadget
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Solo podemos asignar fragmentos de tama√±o mayor que `0x100`.
* Sobrescribir `global_max_fast` usando un ataque Unsorted Bin (funciona 1/16 veces debido a ASLR, porque necesitamos modificar 12 bits, pero debemos modificar 16 bits).
* Ataque de Fast Bin para modificar una matriz global de fragmentos. Esto proporciona un primitivo de lectura/escritura arbitrario, lo que permite modificar la GOT y hacer que alguna funci√≥n apunte a `system`.

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* ¬°Consulta los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
