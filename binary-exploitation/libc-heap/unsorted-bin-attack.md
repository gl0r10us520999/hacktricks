# Ongeordende Bin Aanval

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

Vir meer inligting oor wat 'n ongeordende bin is, kyk na hierdie bladsy:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Ongeordende lyste kan die adres na `unsorted_chunks (av)` in die `bk` adres van die chunk skryf. Daarom, as 'n aanvaller die **adres van die `bk` pointer** in 'n chunk binne die ongeordende bin kan **wysig**, kan hy in staat wees om **daardie adres in 'n arbitr√™re adres te skryf** wat nuttig kan wees om 'n Glibc adresse te lek of om sekere verdediging te omseil.

So, basies, laat hierdie aanval toe om **'n groot getal op 'n arbitr√™re adres in te stel**. Hierdie groot getal is 'n adres, wat 'n heap adres of 'n Glibc adres kan wees. 'n Tipiese teiken is **`global_max_fast`** om vinnige binne met groter groottes te skep (en om van 'n ongeordende bin aanval na 'n vinnige bin aanval oor te gaan).

{% hint style="success" %}
Kyk na die voorbeeld wat gegee is in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) en gebruik 0x4000 en 0x5000 in plaas van 0x400 en 0x500 as chunk groottes (om Tcache te vermy) is dit moontlik om te sien dat **vandag** die fout **`malloc(): unsorted double linked list corrupted`** geaktiveer word.

Daarom, hierdie ongeordende bin aanval vereis nou (benewens ander kontroles) ook om in staat te wees om die dubbele verknoping te herstel sodat dit `victim->bk->fd == victim` of nie `victim->fd == av (arena)` omseil nie, wat beteken dat die adres waar ons wil skryf die adres van die valse chunk in sy `fd` posisie moet h√™ en dat die valse chunk `fd` na die arena wys.
{% endhint %}

{% hint style="danger" %}
Let daarop dat hierdie aanval die ongeordende bin korrupteer (dus klein en groot ook). So ons kan slegs **toewysings van die vinnige bin nou gebruik** ( 'n meer komplekse program mag ander toewysings doen en crash), en om dit te aktiveer moet ons **die dieselfde grootte toewys of die program sal crash.**

Let daarop dat om **`global_max_fast`** te oorskry dalk in hierdie geval kan help, vertrou dat die vinnige bin in staat sal wees om al die ander toewysings te hanteer totdat die uitbuiting voltooi is.
{% endhint %}

Die kode van [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) verduidelik dit baie goed, alhoewel as jy die mallocs wysig om geheue groot genoeg toe te ken sodat dit nie in 'n Tcache eindig nie, kan jy sien dat die voorheen genoemde fout voorkom wat hierdie tegniek voorkom: **`malloc(): unsorted double linked list corrupted`**

## Ongeordende Bin Inligtingslek Aanval

Dit is eintlik 'n baie basiese konsep. Die chunks in die ongeordende bin gaan pointers h√™. Die eerste chunk in die ongeordende bin sal eintlik die **`fd`** en die **`bk`** skakels h√™ **wat na 'n deel van die hoof arena (Glibc)** wys.\
Daarom, as jy **'n chunk in 'n ongeordende bin kan plaas en dit kan lees** (gebruik na vry) of **dit weer kan toewys sonder om ten minste 1 van die pointers te oorskry** om dan **dit te lees**, kan jy 'n **Glibc inligtingslek** h√™.

'n Soortgelyke [**aanval wat in hierdie skrywe gebruik is**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), was om 'n 4 chunks struktuur (A, B, C en D - D is slegs om konsolidasie met die boonste chunk te voorkom) te misbruik, sodat 'n null byte oorgang in B gebruik is om C aan te dui dat B nie gebruik is nie. Ook, in B is die `prev_size` data gewysig sodat die grootte in plaas van die grootte van B A+B was.\
Toe is C vrygestel, en met A+B gekonsolideer (maar B was steeds in gebruik). 'n Nuwe chunk van grootte A is toegeken en toe is die libc gelekte adresse in B geskryf waarvandaan hulle gelek is.

## Verwysings & Ander Voorbeelde

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Die doel is om 'n globale veranderlike met 'n waarde groter as 4869 te oorskry sodat dit moontlik is om die vlag te kry en PIE is nie geaktiveer nie.
* Dit is moontlik om chunks van arbitr√™re groottes te genereer en daar is 'n heap oorgang met die gewenste grootte.
* Die aanval begin deur 3 chunks te skep: chunk0 om die oorgang te misbruik, chunk1 om oorgestort te word en chunk2 sodat die boonste chunk nie die vorige een konsolideer nie.
* Toe word chunk1 vrygestel en chunk0 word oorgestort sodat die `bk` pointer van chunk1 wys na: `bk = magic - 0x10`
* Toe word chunk3 toegeken met dieselfde grootte as chunk1, wat die ongeordende bin aanval sal aktiveer en die waarde van die globale veranderlike sal wysig, wat dit moontlik maak om die vlag te kry.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die samensmeltingsfunksie is kwesbaar omdat as beide indekse wat oorgedra word dieselfde is, dit op dit sal heraansluit en dit dan vry sal stel, maar 'n pointer na daardie vrygestelde streek sal teruggee wat gebruik kan word.
* Daarom, **2 chunks word geskep**: **chunk0** wat met homself saamgevoeg sal word en chunk1 om te voorkom dat dit met die boonste chunk konsolideer. Toe, die **samensmeltingsfunksie word twee keer met chunk0** aangeroep wat 'n gebruik na vry sal veroorsaak.
* Toe, die **`view`** funksie word met indeks 2 (wat die indeks van die gebruik na vry chunk is) aangeroep, wat 'n **libc adres sal lek**.
* Aangesien die bin√™re beskermings het om slegs groottes groter as **`global_max_fast`** toe te ken, sodat geen fastbin gebruik word nie, sal 'n ongeordende bin aanval gebruik word om die globale veranderlike `global_max_fast` te oorskry.
* Toe is dit moontlik om die redigeer funksie met indeks 2 (die gebruik na vry pointer) aan te roep en die `bk` pointer te oorskry om na `p64(global_max_fast-0x10)` te wys. Toe, die skep van 'n nuwe chunk sal die voorheen gecompromitteerde vry adres (0x20) gebruik wat die **ongeordende bin aanval** sal aktiveer wat die `global_max_fast` oorskry wat 'n baie groot waarde is, wat dit nou moontlik maak om chunks in vinnige bins te skep.
* Nou word 'n **vinnige bin aanval** uitgevoer:
* Eerstens word ontdek dat dit moontlik is om met vinnige **chunks van grootte 200** in die **`__free_hook`** ligging te werk:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* As ons daarin slaag om 'n vinnige chunk van grootte 0x200 in hierdie ligging te kry, sal dit moontlik wees om 'n funksie pointer te oorskry wat uitgevoer sal word.
* Hiervoor word 'n nuwe chunk van grootte `0xfc` geskep en die samensmeltingsfunksie word twee keer met daardie pointer aangeroep, sodat ons 'n pointer na 'n vrygestelde chunk van grootte `0xfc*2 = 0x1f8` in die vinnige bin verkry.
* Toe, die redigeer funksie word in hierdie chunk aangeroep om die **`fd`** adres van hierdie vinnige bin te wys na die vorige **`__free_hook`** funksie.
* Toe, 'n chunk van grootte `0x1f8` word geskep om die vorige nuttelose chunk uit die vinnige bin te verkry sodat 'n ander chunk van grootte `0x1f8` geskep word om 'n vinnige bin chunk in die **`__free_hook`** te kry wat oorgeskryf word met die adres van die **`system`** funksie.
* En uiteindelik word 'n chunk wat die string `/bin/sh\x00` bevat, vrygestel deur die verwyder funksie aan te roep, wat die **`__free_hook`** funksie aktiveer wat na system met `/bin/sh\x00` as parameter wys.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Nog 'n voorbeeld van die misbruik van 'n 1B oorgang om chunks in die ongeordende bin te konsolideer en 'n libc inligtingslek te verkry en dan 'n vinnige bin aanval uit te voer om die malloc hook met 'n een gadget adres te oorskry.
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Ons kan slegs chunks van grootte groter as `0x100` toewys.
* Oorskry `global_max_fast` deur 'n Ongeordende Bin aanval (werk 1/16 keer as gevolg van ASLR, omdat ons 12 bits moet wysig, maar ons moet 16 bits wysig).
* Vinnige Bin aanval om 'n globale array van chunks te wysig. Dit bied 'n arbitr√™re lees/schrijf primitief, wat toelaat om die GOT te wysig en sommige funksies na `system` te laat wys. 

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
