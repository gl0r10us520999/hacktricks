# Sıralanmamış Bin Saldırısı

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek katkıda bulunun.

</details>
{% endhint %}

## Temel Bilgiler

Sıralanmamış bir liste, bir parçanın `bk` adresindeki `sıralanmamış_parçalar (av)` adresini yazabilmektedir. Bu nedenle, bir saldırgan bir parçanın içindeki `bk` işaretçisinin adresini değiştirebilirse, bu adresi **herhangi bir adrese yazabilir** ve bu da Glibc adreslerini sızdırmaya veya bazı savunmaları atlamaya yardımcı olabilir.

Bu saldırı temelde **bir büyük sayıyı bir keyfi adrese ayarlamayı** sağlar. Bu büyük sayı bir adres olabilir, bu adres bir heap adresi veya bir Glibc adresi olabilir. Tipik bir hedef, **`global_max_fast`**'ın daha büyük boyutlarda hızlı parça parçaları oluşturmasına izin vermek (ve sıralanmamış bir bin saldırısından hızlı bir bin saldırısına geçmek).

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) adresinde sağlanan örneğe bakıldığında ve 0x400 ve 0x500 yerine 0x4000 ve 0x5000 kullanıldığında (Tcache'i önlemek için) **günümüzde** hata **`malloc(): sıralanmamış çift bağlantılı liste bozulmuş`** tetiklenmektedir.

Bu nedenle, bu sıralanmamış bin saldırısı artık (diğer kontroller arasında) çift bağlantılı listeyi düzeltme yeteneğine de sahip olmalıdır, böylece bu, `victim->bk->fd == victim` veya `victim->fd == av (arena)` olmamalıdır, bu da yazmak istediğimiz adresin `fd` konumunda sahte parçanın adresini ve sahte parçanın `fd`'sinin arenaya işaret etmesi gerektiği anlamına gelir.
{% endhint %}

{% hint style="danger" %}
Bu saldırı sıralanmamış bin'i (dolayısıyla küçük ve büyük olanı da) bozar. Bu nedenle şimdi sadece **hızlı binlerden tahsisleri kullanabiliriz** (daha karmaşık bir program başka tahsisler yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsis yapmalıyız veya program çökecektir.**

**`global_max_fast`**'ın üzerine yazma, hızlı binin tüm diğer tahsislerle ilgilenebileceğine güvenmek bu durumda yardımcı olabilir ve saldırı tamamlandığında bayrağı almayı mümkün kılar.
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) tarafından sağlanan kod bunu çok iyi açıklar, ancak malloc'ları Tcache'e sona ermemesi için yeterince büyük bellek ayırmak için değiştirirseniz, önce bahsedilen hata ortaya çıkar ve bu tekniği engeller: **`malloc(): sıralanmamış çift bağlantılı liste bozulmuş`**

## Sıralanmamış Bin Bilgi Sızdırma Saldırısı

Bu aslında çok temel bir kavramdır. Sıralanmamış bindeki parçaların işaretçilere sahip olacağı. Sıralanmamış bindeki ilk parça aslında **`fd`** ve **`bk`** bağlantılarını **ana arenanın bir kısmına (Glibc)** işaret edecektir.\
Bu nedenle, bir parçayı sıralanmamış bir bine yerleştirebilir ve onu okuyabilirsiniz (kullanımdan sonra serbest bırakın) veya **en azından işaretçilerden birini üzerine yazmadan tekrar tahsis edebilir ve ardından** okuyabilirsiniz, bir **Glibc bilgi sızıntısı** elde edebilirsiniz.

Bu yazıda kullanılan benzer bir [**saldırı**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), 4 parçalı bir yapıyı (A, B, C ve D - D yalnızca üst parçayla birleşmeyi önlemek için) kötüye kullanmaktı, böylece B'de bir null bayt taşması kullanılarak C'nin B'nin kullanılmadığını belirtmesi sağlandı. Ayrıca, B'de `prev_size` verisi değiştirildi, böylece boyut B'nin boyutu olmak yerine A+B oldu.\
Ardından C serbest bırakıldı ve A+B ile birleştirildi (ancak B hala kullanımda idi). A boyutunda yeni bir parça tahsis edildi ve ardından sızdırılan libc adresleri B'ye yazıldı ve oradan sızdırıldı.

## Referanslar ve Diğer Örnekler

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Global bir değişkenin değeri 4869'dan büyük bir değerle üzerine yazılması hedeflenir, bu sayede bayrağı almak mümkün olur ve PIE etkin değildir.
* Keyfi boyutlarda parçalar oluşturulabilir ve istenen boyutta bir heap taşması vardır.
* Saldırı, 3 parça oluşturarak başlar: taşmayı kötüye kullanmak için chunk0, taşmayla karşılaşacak chunk1 ve önceki parçaların birleşmesini önlemek için chunk2.
* Ardından, chunk1 serbest bırakılır ve chunk0 taşar, böylece chunk1'in `bk` işaretçisi şuna işaret eder: `bk = magic - 0x10`
* Ardından, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da sıralanmamış bin saldırısını tetikler ve global değişkenin değerini değiştirir, bayrağı almayı mümkün kılar.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Birleştirme işlevi, geçilen her iki dizin de aynı olduğunda onu yeniden boyutlandıracağı ve ardından serbest bırakacağı ancak kullanılan bir bölgeye işaret eden bir işaretçi döndüreceği için savunmasızdır.
* Bu nedenle, **2 parça oluşturulur**: **chunk0** kendisiyle birleştirilecek ve üst parçayla birleşmesini önlemek için chunk1. Ardından, **birleştirme işlevi chunk0 ile iki kez çağrılır**, bu da kullanımdan sonra serbest bırakma hatasına neden olur.
* Ardından, **`view`** işlevi kullanımdan sonra serbest bırakılan parçanın dizini olan 2 ile çağrılır, bu da bir libc adresi sızdırır.
* Binary, sadece **`global_max_fast`**'ten büyük boyutlarda malloc yapmasına izin veren korumalara sahip olduğundan hiçbir fastbin kullanılmaz, bu nedenle sıralanmamış bin saldırısı, global değişken `global_max_fast`'ın üzerine yazmak için kullanılacaktır.
* Ardından, kullanımdan sonra serbest bırakılan adresi (0x20) etkileyen `bk` işaretçisini `p64(global_max_fast-0x10)`'a işaret edecek şekilde indeks 2 (kullanımdan sonra serbest bırakılan işaretçi) ile edit işlevi çağrılabilir ve ardından yeni bir parça oluşturulduğunda **sıralanmamış bin saldırısı tetiklenir**, `global_max_fast`'ı çok büyük bir değerle üzerine yazarak artık hızlı parçalar oluşturulabilir.
* Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
* İlk olarak, **`__free_hook`** konumunda **200 boyutunda hızlı parçalarla çalışılabileceği keşfedilir**:
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Bu konumda 0x200 boyutunda hızlı bir parça elde edebilirsek, yürütülecek bir işlev işaretçisini üzerine yazmak mümkün olacaktır
* Bunun için, boyutu `0xfc` olan yeni bir parça oluşturulur ve birleştirilmiş işlev bu işaretçiyle iki kez çağrılır, bu şekilde hızlı bir parçada boyutu `0xfc*2 = 0x1f8` olan bir serbest bırakılmış parçanın işaretçisine ulaşılır.
* Ardından, bu parçada **`fd`** adresini önceki **`__free_hook`** işlevine işaret etmek için düzenleme işlevi çağrılır.
* Daha sonra, hızlı parçadan önceki gereksiz parçayı almak için boyutu `0x1f8` olan bir parça oluşturulur, böylece **`__free_hook`** içinde **`system`** işlevine işaret eden bir hızlı parça parçası alınır.
* Ve son olarak, `/bin/sh\x00` dizesini içeren bir parça serbest bırakılarak silme işlevi çağrılır, **`__free_hook`** işlevini tetikleyerek `/bin/sh\x00` parametresiyle işaret eden sistem işlevine işaret eder.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Unsorted binde parçaları birleştirmek ve bir libc bilgi sızıntısı elde etmek ve ardından malloc kancasını bir tek araç adresiyle üzerine yazmak için hızlı parça saldırısını kullanma başka bir örneği
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Yalnızca `0x100`'den büyük boyutta parçalar tahsis edebiliriz.
* Unsorted Bin saldırısı kullanarak `global_max_fast` üzerine yazma (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 biti değiştirmemiz gerekiyor, ancak 16 biti değiştirmemiz gerekiyor).
* Global bir parça dizisini değiştirmek için Hızlı Parça saldırısı. Bu, GOT'yi değiştirmeye ve bazı işlevleri `system`'e işaret etmeye olanak tanıyan bir keyfi okuma/yazma ilkesi sağlar.
