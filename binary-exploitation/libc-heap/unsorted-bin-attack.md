# アンソートビン攻撃

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを送信してハッキングトリックを共有してください。**

</details>
{% endhint %}

## 基本情報

アンソートビンとは何かについての詳細は、このページを確認してください：

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

アンソートリストは、チャンクの`bk`アドレスに`unsorted_chunks (av)`のアドレスを書き込むことができます。したがって、攻撃者がアンソートビン内のチャンクの`bk`ポインタのアドレスを**変更できる**場合、彼は**そのアドレスを任意のアドレスに書き込む**ことができ、これはGlibcアドレスを漏洩させたり、いくつかの防御を回避するのに役立ちます。

基本的に、この攻撃は**任意のアドレスに大きな数を設定する**ことを可能にします。この大きな数はアドレスであり、ヒープアドレスまたはGlibcアドレスである可能性があります。典型的なターゲットは**`global_max_fast`**であり、これによりより大きなサイズのファストビンを作成できるようになります（アンソートビン攻撃からファストビン攻撃に移行することができます）。

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle)で提供されている例を見て、チャンクサイズとして0x400と0x500の代わりに0x4000と0x5000を使用すると（Tcacheを避けるため）、**現在**エラー**`malloc(): unsorted double linked list corrupted`**がトリガーされることがわかります。

したがって、このアンソートビン攻撃は、現在（他のチェックの中で）ダブルリンクリストを修正できる必要があり、`victim->bk->fd == victim`または`victim->fd == av (arena)`を回避する必要があります。これは、書き込みたいアドレスがその`fd`位置にフェイクチャンクのアドレスを持ち、フェイクチャンクの`fd`がアリーナを指している必要があることを意味します。
{% endhint %}

{% hint style="danger" %}
この攻撃はアンソートビンを破損させることに注意してください（したがって小さなビンと大きなビンも）。したがって、**現在はファストビンからの割り当てのみを使用できます**（より複雑なプログラムは他の割り当てを行い、クラッシュする可能性があります）、これをトリガーするには、**同じサイズを割り当てる必要があります。さもなければプログラムはクラッシュします。**

`global_max_fast`を上書きすることは、この場合に役立つかもしれません。ファストビンが他のすべての割り当てを処理できると信頼して、エクスプロイトが完了するまで。
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html)のコードは非常によく説明していますが、mallocを変更してTcacheに終わらないように十分な大きさのメモリを割り当てると、前述のエラーが表示され、この技術を防ぐことができます：**`malloc(): unsorted double linked list corrupted`**

## アンソートビン情報漏洩攻撃

これは実際には非常に基本的な概念です。アンソートビン内のチャンクはポインタを持つことになります。アンソートビンの最初のチャンクは、実際には**`fd`**と**`bk`**リンクが**メインアリーナ（Glibc）の一部を指しています**。\
したがって、チャンクをアンソートビンに**入れて読み取る**（use after free）か、**ポインタの少なくとも1つを上書きせずに再度割り当ててから**それを**読み取る**ことができれば、**Glibc情報漏洩**を得ることができます。

この[**書き込みで使用された攻撃**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)は、4つのチャンク構造（A、B、C、D - Dはトップチャンクとの統合を防ぐためだけに存在）を悪用するもので、Bでのヌルバイトオーバーフローを使用してCがBが未使用であることを示すようにしました。また、Bでは`prev_size`データが変更され、サイズがBのサイズではなくA+Bになりました。\
その後、Cが解放され、A+Bと統合されました（ただしBはまだ使用中でした）。サイズAの新しいチャンクが割り当てられ、その後、漏洩したlibcアドレスがBに書き込まれました。

## 参考文献と他の例

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* 目標は、4869より大きな値でグローバル変数を上書きすることです。これにより、フラグを取得でき、PIEは有効になっていません。
* 任意のサイズのチャンクを生成することができ、希望するサイズのヒープオーバーフローがあります。
* 攻撃は3つのチャンクを作成することから始まります：チャンク0はオーバーフローを悪用し、チャンク1はオーバーフローされ、チャンク2はトップチャンクが前のものと統合しないようにします。
* 次に、チャンク1が解放され、チャンク0がチャンク1の`bk`ポインタを指すようにオーバーフローします：`bk = magic - 0x10`
* 次に、チャンク1と同じサイズのチャンク3が割り当てられ、これによりアンソートビン攻撃がトリガーされ、グローバル変数の値が変更され、フラグを取得できるようになります。
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* マージ関数は脆弱であり、渡された両方のインデックスが同じであれば、それを再割り当てし、その後解放しますが、解放された領域へのポインタを返します。
* したがって、**2つのチャンクが作成されます**：**チャンク0**は自分自身とマージされ、チャンク1はトップチャンクとの統合を防ぎます。次に、**チャンク0でマージ関数が2回呼び出され**、これによりuse after freeが発生します。
* 次に、**`view`**関数がインデックス2（use after freeチャンクのインデックス）で呼び出され、**libcアドレスが漏洩します**。
* バイナリには**`global_max_fast`**より大きなサイズのみをmallocする保護があるため、ファストビンは使用されず、アンソートビン攻撃が使用されてグローバル変数`global_max_fast`を上書きします。
* 次に、インデックス2（use after freeポインタ）で編集関数を呼び出し、`bk`ポインタを`p64(global_max_fast-0x10)`を指すように上書きします。次に、新しいチャンクを作成すると、以前に妥協された解放アドレス（0x20）が使用され、**アンソートビン攻撃がトリガーされ**、`global_max_fast`が非常に大きな値で上書きされ、ファストビンでチャンクを作成できるようになります。
* ここで**ファストビン攻撃**が実行されます：
* まず、**`__free_hook`**の場所でサイズ200のファストチャンクを操作できることがわかります：
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* この場所でサイズ0x200のファストチャンクを取得できれば、実行される関数ポインタを上書きすることが可能になります。
* そのために、サイズ`0xfc`の新しいチャンクを作成し、そのポインタでマージ関数を2回呼び出すことで、ファストビン内のサイズ`0xfc*2 = 0x1f8`の解放されたチャンクへのポインタを取得します。
* 次に、このチャンクの編集関数を呼び出して、このファストビンの**`fd`**アドレスを前の**`__free_hook`**関数を指すように変更します。
* 次に、サイズ`0x1f8`のチャンクを作成して、ファストビンから以前の無駄なチャンクを取得し、さらにサイズ`0x1f8`のチャンクを作成して**`__free_hook`**内のファストビンチャンクを取得し、これを**`system`**関数のアドレスで上書きします。
* 最後に、文字列`/bin/sh\x00`を含むチャンクを解放し、削除関数を呼び出して**`__free_hook`**関数をトリガーし、`/bin/sh\x00`をパラメータとしてsystemを指します。
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* アンソートビン内のチャンクを統合するために1Bオーバーフローを悪用し、libc情報漏洩を取得し、その後mallocフックを1つのガジェットアドレスで上書きするためのファストビン攻撃の別の例。
* [**ロボット工場。BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* サイズ`0x100`より大きなチャンクのみを割り当てることができます。
* アンソートビン攻撃を使用して`global_max_fast`を上書きします（ASLRのために1/16回機能します。12ビットを変更する必要がありますが、16ビットを変更する必要があります）。
* グローバルチャンク配列を変更するためのファストビン攻撃。これにより、任意の読み取り/書き込みプリミティブが得られ、GOTを変更していくつかの関数を`system`を指すように設定できます。

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを送信してハッキングトリックを共有してください。**

</details>
{% endhint %}
