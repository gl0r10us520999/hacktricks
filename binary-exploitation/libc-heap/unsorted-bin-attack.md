# Ongeorden Bin√™re Aanval

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## Basiese Inligting

Vir meer inligting oor wat 'n ongeordende bin√™re is, kyk na hierdie bladsy:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Ongeordende lysies kan die adres na `ongesorteerde brokke (av)` in die `bk`-adres van die brokkie skryf. Daarom, as 'n aanvaller die adres van die `bk`-aanwyser in 'n brokkie binne die ongeordende bin kan **verander**, kan hy in staat wees om **daardie adres in 'n willekeurige adres te skryf** wat nuttig kan wees om 'n Glibc-adres te lek of om sekere verdediging te omseil.

Dus, hierdie aanval maak dit basies moontlik om **'n groot getal by 'n willekeurige adres in te stel**. Hierdie groot getal is 'n adres, wat 'n heap-adres of 'n Glibc-adres kan wees. 'n Tipiese teiken is **`global_max_fast`** om dit moontlik te maak om vinnige binne met groter groottes te skep (en oorgaan van 'n ongeordende bin-aanval na 'n vinnige bin-aanval).

{% hint style="success" %}
Deur na die voorbeeld te kyk wat verskaf is in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) en 0x4000 en 0x5000 in plaas van 0x400 en 0x500 as brokkie groottes te gebruik (om Tcache te vermy), is dit moontlik om te sien dat **teenwoordig** die fout **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrupteer`** geaktiveer word.

Daarom vereis hierdie ongeordende bin-aanval nou (onder andere kontroles) ook dat die dubbel gekoppelde lys reggestel moet word sodat dit omseil word `victim->bk->fd == victim` of nie `victim->fd == av (arena)`, wat beteken dat die adres waar ons wil skryf die adres van die vals brokkie in sy `fd`-posisie moet h√™ en dat die vals brokkie `fd` na die arena wys.
{% endhint %}

{% hint style="danger" %}
Let daarop dat hierdie aanval die ongeordende bin (dus klein en groot ook) korruptheid. Dus kan ons nou slegs **toewysings van die vinnige bin gebruik** ( 'n meer komplekse program kan ander toewysings doen en vasloop), en om dit te aktiveer moet ons **dieselfde grootte toewys anders sal die program vasloop.**

Let daarop dat die oorskrywing van **`global_max_fast`** in hierdie geval kan help om te vertrou dat die vinnige bin in staat sal wees om al die ander toewysings te hanteer totdat die uitbuiting voltooi is.
{% endhint %}

Die kode van [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) verduidelik dit baie goed, alhoewel as jy die mallocs wysig om geheue groot genoeg toe te ken sodat dit nie in 'n Tcache eindig nie, kan jy sien dat die voorheen genoemde fout voorkom wat hierdie tegniek voorkom: **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrupteer`**

## Ongeordende Bin Inligtingslek Aanval

Dit is eintlik 'n baie basiese konsep. Die brokkies in die ongeordende bin gaan aanwysers h√™. Die eerste brokkie in die ongeordende bin sal eintlik die **`fd`** en die **`bk`** skakels h√™ wat **na 'n deel van die hoof-arena (Glibc)** wys.\
Daarom, as jy **'n brokkie binne 'n ongeordende bin kan plaas en dit lees** (gebruik na vry) of **dit weer kan toeken sonder om ten minste 1 van die aanwysers te oorskryf** om dit dan **te lees**, kan jy 'n **Glibc-inligtingslek** h√™.

'n Soortgelyke [**aanval wat in hierdie skryfstuk gebruik is**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), was om 'n 4-brokkie struktuur (A, B, C en D - D is slegs om konsolidasie met die boonste brokkie te voorkom) te misbruik sodat 'n nulbyte-oorvloei in B gebruik is om C aan te dui dat B ongebruik was. Ook is in B die `prev_size`-data gewysig sodat die grootte in plaas daarvan om die grootte van B was A+B.\
Toe is C vrygestel en gekonsolideer met A+B (maar B was nog in gebruik). 'n Nuwe brokkie van grootte A is toegeken en toe is die gelekte Glibc-adresse in B geskryf vanwaar hulle gelekte is.

## Verwysings & Ander voorbeelde

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Die doel is om 'n globale veranderlike met 'n waarde groter as 4869 te oorskryf sodat dit moontlik is om die vlag te kry en PIE is nie geaktiveer nie.
* Dit is moontlik om brokkies van willekeurige groottes te genereer en daar is 'n geheue-oorvloei met die gewenste grootte.
* Die aanval begin deur 3 brokkies te skep: brokkie0 om die oorvloei te misbruik, brokkie1 om oorvloei te h√™ en brokkie2 sodat die boonste brokkie nie konsolideer met die voriges nie.
* Dan word brokkie1 vrygestel en brokkie0 word oorvloei sodat die `bk`-aanwyser van brokkie1 wys na: `bk = magic - 0x10`
* Dan word brokkie3 toegewys met dieselfde grootte as brokkie1, wat die ongeordende bin-aanval sal aktiveer en die waarde van die globale veranderlike sal wysig, wat dit moontlik maak om die vlag te kry.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die saamvoegfunksie is kwesbaar omdat as beide indekse wat oorgedra word dieselfde is, sal dit daarop herallokeer en dit dan vrymaak, maar 'n aanwyser na daardie vrygemaakte gebied teruggee wat gebruik kan word.
* Daarom word **2 brokkies geskep**: **brokkie0** wat met homself saamgevoeg sal word en brokkie1 om konsolidering met die boonste brokkie te voorkom. Dan word die **saamvoegfunksie met brokkie0** twee keer geroep wat 'n gebruik na vry sal veroorsaak.
* Dan word die **`view`-funksie geroep met indeks 2** (wat die indeks van die gebruik na vry brokkie is), wat 'n **libc-adres sal lek**.
* Aangesien die bin√™re beskermings het om slegs groottes groter as **`global_max_fast`** toe te ken sodat geen vinnige bin gebruik word nie, gaan 'n ongeordende bin-aanval gebruik word om die globale veranderlike `global_max_fast` te oorskryf.
* Dan is dit moontlik om die wysigingsfunksie met indeks 2 (die gebruik na vry aanwyser) te roep en die `bk`-aanwyser te oorskryf om te wys na `p64(global_max_fast-0x10)`. Dan, deur 'n nuwe brokkie te skep, sal die voorheen gekompromitteerde vry adres (0x20) gebruik word om die ongeordende bin-aanval te **aktiveer** deur die `global_max_fast` te oorskryf met 'n baie groot waarde, wat dit nou moontlik maak om brokkies in vinnige binne te skep.
* Nou word 'n **vinnige bin-aanval** uitgevoer:
* Eerstens word ontdek dat dit moontlik is om te werk met vinnige **brokkies van grootte 200** op die **`__free_hook`-plek:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* As ons daarin kan slaag om 'n vinnige stuk van grootte 0x200 op hierdie plek te kry, sal dit moontlik wees om 'n funksie-aanwyser te oorskryf wat uitgevoer sal word
* Hiervoor word 'n nuwe stuk van grootte `0xfc` geskep en die saamgevoegde funksie word twee keer geroep met daardie aanwyser, op hierdie manier verkry ons 'n aanwyser na 'n vrygemaakte stuk van grootte `0xfc*2 = 0x1f8` in die vinnige bin.
* Dan word die wysigingsfunksie in hierdie stuk geroep om die **`fd`**-adres van hierdie vinnige bin te wysig om te wys na die vorige **`__free_hook`**-funksie.
* Dan word 'n stuk met grootte `0x1f8` geskep om uit die vinnige bin die vorige nuttelose stuk te herwin sodat 'n ander stuk met grootte `0x1f8` geskep kan word om 'n vinnige bin-stuk in die **`__free_hook`** te kry wat oorskryf is met die adres van die **`system`**-funksie.
* En uiteindelik word 'n stuk wat die string `/bin/sh\x00` bevat, vrygelaat deur die verwyderingsfunksie te roep, wat die **`__free_hook`**-funksie aktiveer wat na system wys met `/bin/sh\x00` as parameter.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* 'n Ander voorbeeld van die misbruik van 'n 1B-oorvloei om stukke in die ongesorteerde bin te konsolideer en 'n libc-infolek te kry en dan 'n vinnige bin-aanval uit te voer om die malloc-aanwyser met 'n een-gadget-adres te oorskryf
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Ons kan slegs stukke van grootte groter as `0x100` toewys.
* Oorskryf `global_max_fast` deur 'n Ongesorteerde Bin-aanval te gebruik (werk 1/16 keer as gevolg van ASLR, omdat ons 12 bietjies moet wysig, maar ons moet 16 bietjies wysig).
* Vinnige Bin-aanval om die globale reeks stukke te wysig. Dit gee 'n arbit√™re lees-/skryf-primitief, wat dit moontlik maak om die GOT te wysig en sommige funksies te laat wys na `system`.

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}
