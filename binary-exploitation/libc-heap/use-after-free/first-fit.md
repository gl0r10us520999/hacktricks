# First Fit

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **First Fit**

Wakati unapoachia kumbukumbu katika programu ukitumia glibc, "bins" tofauti zinatumika kusimamia vipande vya kumbukumbu. Hapa kuna maelezo rahisi ya hali mbili za kawaida: bins zisizo na mpangilio na fastbins.

### Bins Zisizo na Mpangilio

Wakati unapoachia kipande cha kumbukumbu ambacho si kipande cha haraka, kinakwenda kwenye bin isiyo na mpangilio. Bin hii inafanya kazi kama orodha ambapo vipande vipya vilivyoachiliwa vinaongezwa mbele (mwenye "kichwa"). Wakati unapoomba kipande kipya cha kumbukumbu, mtoaji anatazama bin isiyo na mpangilio kutoka nyuma (mwenye "mkia") ili kupata kipande ambacho ni kikubwa vya kutosha. Ikiwa kipande kutoka kwenye bin isiyo na mpangilio ni kikubwa kuliko unavyohitaji, kinagawanywa, ambapo sehemu ya mbele inarudishwa na sehemu iliyobaki inabaki kwenye bin.

Mfano:

* Unapotoa 300 bytes (`a`), kisha 250 bytes (`b`), unapoachia `a` na kuomba tena 250 bytes (`c`).
* Wakati unapoachia `a`, inakwenda kwenye bin isiyo na mpangilio.
* Ikiwa kisha unapoomba 250 bytes tena, mtoaji anapata `a` kwenye mkia na kuigawanya, akirudisha sehemu inayofaa ombi lako na kuweka iliyobaki kwenye bin.
* `c` itakuwa ikielekeza kwenye `a` ya awali na kujazwa na `a's`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins hutumiwa kwa vipande vidogo vya kumbukumbu. Tofauti na unsorted bins, fastbins huongeza vipande vipya kwenye kichwa, na kuunda tabia ya last-in-first-out (LIFO). Ikiwa unahitaji kipande kidogo cha kumbukumbu, mtoa huduma atavuta kutoka kichwa cha fastbin.

Mfano:

* Unapoweka vipande vinne vya byte 20 kila kimoja (`a`, `b`, `c`, `d`).
* Unapofungua kwa mpangilio wowote, vipande vilivyofunguliwa vinaongezwa kwenye kichwa cha fastbin.
* Ikiwa kisha unahitaji kipande cha byte 20, mtoa huduma atarudisha kipande kilichofunguliwa hivi karibuni kutoka kichwa cha fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Other References & Examples

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Tumia baada ya kuachia: Tengeneza kitu cha mtumiaji, kiache, tengeneza kitu kinachopata kipande kilichoachwa na kuruhusu kuandika ndani yake, **kufuta nafasi ya mtumiaji->password** kutoka kwa ile ya awali. Tumia tena mtumiaji ili **kupita ukaguzi wa nenosiri**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Programu inaruhusu kuunda noti. Noti itakuwa na taarifa za noti katika malloc(8) (ikiwa na kiashiria kwa kazi inayoweza kuitwa) na kiashiria kwa malloc nyingine (\<size>) yenye maudhui ya noti.
* Shambulio litakuwa kuunda noti 2 (note0 na note1) zikiwa na maudhui makubwa ya malloc kuliko saizi ya taarifa za noti na kisha kuziachia ili ziingie kwenye fast bin (au tcache).
* Kisha, tengeneza noti nyingine (note2) yenye saizi ya maudhui 8. Maudhui yatakuwa katika note1 kwani kipande kitarejelewa, ambapo tunaweza kubadilisha kiashiria cha kazi ili kiashirie kazi ya ushindi na kisha Tumia-Baada-ya-Kuachia noti1 ili kuita kiashiria kipya cha kazi.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Inawezekana kugawa kumbukumbu, kuandika thamani inayotakiwa, kuachia, kuigawa tena na kwa kuwa data ya awali bado ipo, itatendewa kulingana na muundo mpya unaotarajiwa katika kipande, na kufanya iwezekane kuweka thamani ili kupata bendera.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Katika kesi hii inahitajika kuandika 4 ndani ya kipande maalum ambacho ndicho cha kwanza kinachogawiwa (hata baada ya kuachia kwa nguvu yote). Kila kipande kipya kinachogawiwa kina nambari yake katika orodha ya kiashiria. Kisha, gawiwa vipande 4 (+ ile iliyogawiwa awali), ya mwisho itakuwa na 4 ndani yake, ziache na kulazimisha kugawiwa tena kwa cha kwanza, ambacho kitatumia kipande cha mwisho kilichoachwa ambacho ndicho chenye 4 ndani yake.
