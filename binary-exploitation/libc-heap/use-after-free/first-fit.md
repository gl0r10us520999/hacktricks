# First Fit

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **First Fit**

Kiedy zwalniasz pami w programie u偶ywajc glibc, r贸偶ne "kosze" s u偶ywane do zarzdzania kawakami pamici. Oto uproszczone wyjanienie dw贸ch powszechnych scenariuszy: koszy niesortowanych i fastbins.

### Kosze Niesortowane

Kiedy zwalniasz kawaek pamici, kt贸ry nie jest szybkim kawakiem, trafia on do kosza niesortowanego. Ten kosz dziaa jak lista, gdzie nowe zwolnione kawaki s dodawane na pocztku (do "gowy"). Kiedy 偶dasz nowego kawaka pamici, alokator przeszukuje kosz niesortowany od tyu (do "ogona"), aby znale藕 kawaek wystarczajco du偶y. Jeli kawaek z kosza niesortowanego jest wikszy ni偶 potrzebujesz, zostaje podzielony, a przednia cz jest zwracana, a pozostaa cz pozostaje w koszu.

Przykad:

* Alokujesz 300 bajt贸w (`a`), nastpnie 250 bajt贸w (`b`), zwalniasz `a` i ponownie 偶dasz 250 bajt贸w (`c`).
* Kiedy zwalniasz `a`, trafia on do kosza niesortowanego.
* Jeli nastpnie ponownie za偶dzasz 250 bajt贸w, alokator znajduje `a` na ogonie i dzieli go, zwracajc cz, kt贸ra pasuje do twojego 偶dania, a reszt pozostawiajc w koszu.
* `c` bdzie wskazywa na poprzednie `a` i bdzie wypenione danymi z `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins s u偶ywane do maych kawak贸w pamici. W przeciwiestwie do nieposortowanych bin贸w, fastbins dodaj nowe kawaki na pocztek, tworzc zachowanie last-in-first-out (LIFO). Jeli poprosisz o may kawaek pamici, alokator pobierze z gowy fastbina.

Example:

* Alokujesz cztery kawaki po 20 bajt贸w ka偶dy (`a`, `b`, `c`, `d`).
* Kiedy je zwolnisz w dowolnej kolejnoci, zwolnione kawaki s dodawane do gowy fastbina.
* Jeli nastpnie poprosisz o kawaek 20-bajtowy, alokator zwr贸ci najnowszy zwolniony kawaek z gowy fastbina.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Inne odniesienia i przykady

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. U偶ycie po zwolnieniu: Wygeneruj obiekt u偶ytkownika, zwolnij go, wygeneruj obiekt, kt贸ry uzyskuje zwolniony kawaek i pozw贸l na zapis do niego, **nadpisujc pozycj user->password** z poprzedniego. Ponownie u偶yj u偶ytkownika, aby **obej sprawdzanie hasa**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program pozwala na tworzenie notatek. Notatka bdzie miaa informacje o notatce w malloc(8) (z wska藕nikiem do funkcji, kt贸ra mogaby by wywoana) oraz wska藕nik do innego malloc(\<size>) z treci notatki.
* Atak polegaby na stworzeniu 2 notatek (note0 i note1) z wiksz zawartoci malloc ni偶 rozmiar informacji o notatce, a nastpnie ich zwolnieniu, aby trafiy do szybkiego koszyka (lub tcache).
* Nastpnie stw贸rz inn notatk (note2) o rozmiarze treci 8. Tre bdzie znajdowa si w note1, poniewa偶 kawaek bdzie ponownie u偶yty, gdzie moglibymy zmodyfikowa wska藕nik funkcji, aby wskazywa na funkcj wygranej, a nastpnie u偶y Use-After-Free notatki note1, aby wywoa nowy wska藕nik funkcji.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Mo偶liwe jest przydzielenie pamici, zapisanie po偶danej wartoci, zwolnienie jej, ponowne przydzielenie i poniewa偶 poprzednie dane wci偶 tam s, bd traktowane zgodnie z now oczekiwan struktur w kawaku, co umo偶liwia ustawienie wartoci, aby uzyska flag.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* W tym przypadku konieczne jest zapisanie 4 wewntrz konkretnego kawaka, kt贸ry jest pierwszym przydzielonym (nawet po wymuszeniu zwolnienia wszystkich). W ka偶dym nowym przydzielonym kawaku jego numer w indeksie tablicy jest przechowywany. Nastpnie przydziel 4 kawaki (+ pocztkowo przydzielony), ostatni bdzie mia 4 wewntrz, zwolnij je i wymu ponowne przydzielenie pierwszego, kt贸re u偶yje ostatniego zwolnionego kawaka, kt贸ry ma 4 wewntrz.
