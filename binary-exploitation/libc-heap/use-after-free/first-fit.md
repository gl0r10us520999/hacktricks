# First Fit

{% hint style="success" %}
AWSハッキングの学習と練習:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して**ハッキングトリックを共有**してください。

</details>
{% endhint %}

## **First Fit**

glibcを使用してプログラム内のメモリを解放すると、異なる"bins"がメモリチャンクを管理するために使用されます。ここでは、一般的な2つのシナリオ、つまりunsorted binsとfastbinsの簡略化された説明を示します。

### Unsorted Bins

高速チャンクでないメモリチャンクを解放すると、それはunsorted binに移動します。このbinは、新しく解放されたチャンクが前方（"head"）に追加されるリストのように機能します。新しいメモリチャンクを要求すると、アロケータはunsorted binを後方（"tail"）から見て、要求されたサイズに十分なチャンクを見つけます。unsorted binからのチャンクが必要なサイズよりも大きい場合、そのチャンクは分割され、前半部分が返され、残りの部分がbinに残ります。

例:

* 300バイト(`a`)を割り当て、次に250バイト(`b`)を割り当て、`a`を解放してから再度250バイト(`c`)を要求します。
* `a`を解放すると、unsorted binに移動します。
* その後250バイトを再度要求すると、アロケータは`a`を末尾で見つけて分割し、要求に合う部分を返し、残りをbinに保持します。
* `c`は以前の`a`を指し示し、`a`の内容で埋められます。
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbinsは小さなメモリチャンクに使用されます。unsorted binsとは異なり、fastbinsは新しいチャンクを先頭に追加し、最後に追加されたものが最初に取り出される（LIFO）動作を作成します。もしメモリの小さなチャンクをリクエストすると、アロケータはfastbinの先頭から取り出します。

例：

- 20バイトずつ4つのチャンク（`a`、`b`、`c`、`d`）を割り当てます。
- 任意の順序でそれらを解放すると、解放されたチャンクはfastbinの先頭に追加されます。
- その後20バイトのチャンクをリクエストすると、アロケータはfastbinの先頭から最も最近解放されたチャンクを返します。
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## その他の参考文献と例

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64。Use after free: ユーザーオブジェクトを生成し、解放し、解放されたチャンクを取得し、その位置に書き込むことで、**前のユーザー->パスワード**を上書きします。ユーザーを再利用して、**パスワードチェックをバイパス**します。
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* プログラムではノートを作成できます。ノートには、malloc(8)でノート情報（呼び出される可能性のある関数へのポインタ）が含まれ、ノートの内容がmalloc(\<size>)へのポインタで含まれます。
* 攻撃方法は、ノート情報サイズよりも大きなmallocコンテンツを持つ2つのノート（note0とnote1）を作成し、それらを解放して高速ビン（またはtcache）に入れることです。
* 次に、コンテンツサイズが8の別のノート（note2）を作成します。コンテンツはノート1になり、チャンクが再利用されるため、関数ポインタをwin関数を指すように変更し、note1をUse-After-Freeして新しい関数ポインタを呼び出します。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* 一部のメモリを割り当て、必要な値を書き込み、解放し、再割り当てすることが可能で、以前のデータがまだ残っているため、新しい期待される構造体に従って処理され、値を設定するかフラグを取得することが可能です。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* この場合、最初に割り当てられた特定のチャンクに4を書き込む必要があります（それらをすべて強制的に解放した後でも）。 新しく割り当てられた各チャンクには、配列インデックスの番号が格納されます。 次に、4つのチャンク（最初に割り当てられたものを含む）を割り当て、最後のチャンクにはその中に4が含まれています。それらを解放し、最初のチャンクを再割り当てし、最後に解放された最初のチャンクを使用します。それは4が含まれているチャンクです。
