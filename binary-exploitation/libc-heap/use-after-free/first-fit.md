# First Fit

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **First Fit**

Cuando liberas memoria en un programa usando glibc, se utilizan diferentes "bins" para gestionar los bloques de memoria. Aqu칤 hay una explicaci칩n simplificada de dos escenarios comunes: bins no ordenados y fastbins.

### Bins No Ordenados

Cuando liberas un bloque de memoria que no es un bloque r치pido, va al bin no ordenado. Este bin act칰a como una lista donde los nuevos bloques liberados se a침aden al frente (la "cabeza"). Cuando solicitas un nuevo bloque de memoria, el asignador mira el bin no ordenado desde la parte trasera (la "cola") para encontrar un bloque que sea lo suficientemente grande. Si un bloque del bin no ordenado es m치s grande de lo que necesitas, se divide, devolviendo la parte delantera y manteniendo la parte restante en el bin.

Ejemplo:

* Asignas 300 bytes (`a`), luego 250 bytes (`b`), liberas `a` y solicitas nuevamente 250 bytes (`c`).
* Cuando liberas `a`, va al bin no ordenado.
* Si luego solicitas 250 bytes nuevamente, el asignador encuentra `a` en la cola y lo divide, devolviendo la parte que se ajusta a tu solicitud y manteniendo el resto en el bin.
* `c` apuntar치 al anterior `a` y estar치 lleno con los `a's`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se utilizan para peque침os fragmentos de memoria. A diferencia de los bins no ordenados, los fastbins a침aden nuevos fragmentos a la cabeza, creando un comportamiento de 칰ltimo en entrar, primero en salir (LIFO). Si solicitas un peque침o fragmento de memoria, el asignador tomar치 de la cabeza del fastbin.

Ejemplo:

* Asignas cuatro fragmentos de 20 bytes cada uno (`a`, `b`, `c`, `d`).
* Cuando los liberas en cualquier orden, los fragmentos liberados se a침aden a la cabeza del fastbin.
* Si luego solicitas un fragmento de 20 bytes, el asignador devolver치 el fragmento liberado m치s recientemente de la cabeza del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Otras Referencias y Ejemplos

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Generar un objeto de usuario, liberarlo, generar un objeto que obtenga el fragmento liberado y permitir escribir en 칠l, **sobrescribiendo la posici칩n de user->password** del anterior. Reutilizar el usuario para **eludir la verificaci칩n de contrase침a**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* El programa permite crear notas. Una nota tendr치 la informaci칩n de la nota en un malloc(8) (con un puntero a una funci칩n que podr칤a ser llamada) y un puntero a otro malloc(\<size>) con el contenido de la nota.
* El ataque consistir칤a en crear 2 notas (note0 y note1) con contenidos de malloc m치s grandes que el tama침o de la informaci칩n de la nota y luego liberarlas para que entren en el fast bin (o tcache).
* Luego, crear otra nota (note2) con un tama침o de contenido de 8. El contenido estar치 en note1 ya que el fragmento se reutilizar치, donde podr칤amos modificar el puntero de funci칩n para apuntar a la funci칩n win y luego Use-After-Free la note1 para llamar al nuevo puntero de funci칩n.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Es posible asignar algo de memoria, escribir el valor deseado, liberarlo, reallocarlo y como los datos anteriores a칰n est치n all칤, se tratar치n de acuerdo con la nueva estructura esperada en el fragmento, lo que hace posible establecer el valor para obtener la bandera.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* En este caso, es necesario escribir 4 dentro de un fragmento espec칤fico que es el primero que se asigna (incluso despu칠s de forzar la liberaci칩n de todos ellos). En cada nuevo fragmento asignado, su n칰mero en el 칤ndice del array se almacena. Luego, asignar 4 fragmentos (+ el inicialmente asignado), el 칰ltimo tendr치 4 dentro de 칠l, liberarlos y forzar la reasignaci칩n del primero, que utilizar치 el 칰ltimo fragmento liberado que es el que tiene 4 dentro de 칠l.
