# First Fit

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **First Fit**

Quando si libera memoria in un programma utilizzando glibc, vengono utilizzati diversi "bins" per gestire i chunk di memoria. Ecco una spiegazione semplificata di due scenari comuni: unsorted bins e fastbins.

### Unsorted Bins

Quando si libera un chunk di memoria che non √® un fast chunk, va nell'unsorted bin. Questo bin funziona come una lista in cui i nuovi chunk liberati vengono aggiunti all'inizio (la "testa"). Quando si richiede un nuovo chunk di memoria, l'allocatore guarda l'unsorted bin dalla parte posteriore (la "coda") per trovare un chunk abbastanza grande. Se un chunk dell'unsorted bin √® pi√π grande di quanto necessario, viene diviso, con la parte anteriore restituita e la parte rimanente che rimane nel bin.

Esempio:

* Si allocano 300 byte (`a`), poi 250 byte (`b`), si libera `a` e si richiedono di nuovo 250 byte (`c`).
* Quando si libera `a`, va nell'unsorted bin.
* Se poi si richiedono di nuovo 250 byte, l'allocatore trova `a` alla coda e lo divide, restituendo la parte che soddisfa la richiesta e mantenendo il resto nel bin.
* `c` punter√† al precedente `a` e sar√† riempito con gli `a's`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

I fastbins sono utilizzati per piccoli chunk di memoria. A differenza degli unsorted bins, i fastbins aggiungono nuovi chunk all'inizio, creando un comportamento last-in-first-out (LIFO). Se richiedi un piccolo chunk di memoria, l'allocatore prelever√† dalla testa del fastbin.

Esempio:

* Allocchi quattro chunk di 20 byte ciascuno (`a`, `b`, `c`, `d`).
* Quando li liberi in qualsiasi ordine, i chunk liberati vengono aggiunti alla testa del fastbin.
* Se poi richiedi un chunk di 20 byte, l'allocatore restituir√† il chunk liberato pi√π di recente dalla testa del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Altre Riferimenti & Esempi

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Genera un oggetto utente, liberalo, genera un oggetto che ottiene il chunk liberato e consenti di scriverci, **sovrascrivendo la posizione di user->password** del precedente. Riutilizza l'utente per **bypassare il controllo della password**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Il programma consente di creare note. Una nota avr√† le informazioni della nota in un malloc(8) (con un puntatore a una funzione che potrebbe essere chiamata) e un puntatore a un altro malloc(\<size>) con i contenuti della nota.
* L'attacco consisterebbe nel creare 2 note (note0 e note1) con contenuti malloc pi√π grandi della dimensione delle informazioni della nota e poi liberarle in modo che finiscano nel fast bin (o tcache).
* Poi, crea un'altra nota (note2) con una dimensione del contenuto di 8. Il contenuto andr√† in note1 poich√© il chunk verr√† riutilizzato, dove potremmo modificare il puntatore della funzione per puntare alla funzione win e poi Use-After-Free la note1 per chiamare il nuovo puntatore della funzione.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* √à possibile allocare della memoria, scrivere il valore desiderato, liberarlo, riallocarlo e poich√© i dati precedenti sono ancora l√¨, verr√† trattato secondo la nuova struttura prevista nel chunk rendendo possibile impostare il valore per ottenere il flag.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* In questo caso √® necessario scrivere 4 all'interno di un chunk specifico che √® il primo ad essere allocato (anche dopo aver forzato la liberazione di tutti). In ogni nuovo chunk allocato, il suo numero nell'indice dell'array √® memorizzato. Poi, allocare 4 chunk (+ quello inizialmente allocato), l'ultimo avr√† 4 al suo interno, liberali e forzare la riallocazione del primo, che utilizzer√† l'ultimo chunk liberato che √® quello con 4 al suo interno.
