# First Fit

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## **First Fit**

Wenn du Speicher in einem Programm mit glibc freigibst, werden verschiedene "Bins" verwendet, um die Speicherbl√∂cke zu verwalten. Hier ist eine vereinfachte Erkl√§rung von zwei h√§ufigen Szenarien: unsortierte Bins und Fastbins.

### Unsortierte Bins

Wenn du einen Speicherblock freigibst, der kein schneller Block ist, gelangt er in den unsortierten Bin. Dieser Bin fungiert wie eine Liste, in die neue freigegebene Bl√∂cke an den Anfang (den "Kopf") hinzugef√ºgt werden. Wenn du einen neuen Speicherblock anforderst, schaut der Zuweiser von hinten (dem "Schwanz") in den unsortierten Bin, um einen Block zu finden, der gro√ü genug ist. Wenn ein Block aus dem unsortierten Bin gr√∂√üer ist als das, was du ben√∂tigst, wird er aufgeteilt, wobei der vordere Teil zur√ºckgegeben wird und der verbleibende Teil im Bin bleibt.

Beispiel:

* Du allocierst 300 Bytes (`a`), dann 250 Bytes (`b`), gibst `a` frei und forderst erneut 250 Bytes (`c`) an.
* Wenn du `a` freigibst, gelangt es in den unsortierten Bin.
* Wenn du dann erneut 250 Bytes anforderst, findet der Zuweiser `a` am Schwanz und teilt es auf, wobei der Teil zur√ºckgegeben wird, der deiner Anfrage entspricht, und der Rest im Bin bleibt.
* `c` wird auf das vorherige `a` zeigen und mit den `a's` gef√ºllt sein.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins werden f√ºr kleine Speicherst√ºcke verwendet. Im Gegensatz zu unsortierten Bins f√ºgen Fastbins neue St√ºcke am Kopf hinzu, was ein Last-in-First-out (LIFO) Verhalten erzeugt. Wenn Sie ein kleines Speicherst√ºck anfordern, zieht der Allocator vom Kopf des Fastbins.

Beispiel:

* Sie allocieren vier St√ºcke von jeweils 20 Bytes (`a`, `b`, `c`, `d`).
* Wenn Sie sie in beliebiger Reihenfolge freigeben, werden die freigegebenen St√ºcke am Kopf des Fastbins hinzugef√ºgt.
* Wenn Sie dann ein 20-Byte-St√ºck anfordern, gibt der Allocator das zuletzt freigegebene St√ºck vom Kopf des Fastbins zur√ºck.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Weitere Referenzen & Beispiele

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Erzeuge ein Benutzerobjekt, gib es frei, erzeuge ein Objekt, das den freigegebenen Chunk erh√§lt und schreibe darauf, **√ºberschreibe die Position von user->password** vom vorherigen. Wiederverwende den Benutzer, um **die Passwort√ºberpr√ºfung zu umgehen**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Das Programm erlaubt das Erstellen von Notizen. Eine Notiz hat die Notizinformationen in einem malloc(8) (mit einem Zeiger auf eine Funktion, die aufgerufen werden k√∂nnte) und einen Zeiger auf ein anderes malloc(\<size>) mit dem Inhalt der Notiz.
* Der Angriff besteht darin, 2 Notizen (note0 und note1) mit gr√∂√üeren malloc-Inhalten als der Notizinformationsgr√∂√üe zu erstellen und sie dann freizugeben, damit sie in den Fast Bin (oder tcache) gelangen.
* Erstelle dann eine weitere Notiz (note2) mit einer Inhaltsgr√∂√üe von 8. Der Inhalt wird in note1 sein, da der Chunk wiederverwendet wird, wo wir den Funktionszeiger √§ndern k√∂nnten, um auf die Gewinnfunktion zu zeigen und dann Use-After-Free die note1, um den neuen Funktionszeiger aufzurufen.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Es ist m√∂glich, etwas Speicher zu alloc, den gew√ºnschten Wert zu schreiben, ihn freizugeben, ihn erneut zu alloc und da die vorherigen Daten noch vorhanden sind, wird er gem√§√ü der neuen erwarteten Struktur im Chunk behandelt, was es erm√∂glicht, den Wert zu setzen, um das Flag zu erhalten.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* In diesem Fall ist es notwendig, 4 in einen bestimmten Chunk zu schreiben, der der erste ist, der allociert wird (auch nachdem alle zwangsweise freigegeben wurden). Bei jedem neu allocierten Chunk wird seine Nummer im Array-Index gespeichert. Dann, allociere 4 Chunks (+ den urspr√ºnglich allocierten), der letzte wird 4 enthalten, gib sie frei und erzwinge die Reallokation des ersten, der den letzten freigegebenen Chunk verwenden wird, der den 4 enth√§lt.
