# First Fit

{% hint style="success" %}
Aprenda e pratique Hacking AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Treinamento HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Treinamento HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## **First Fit**

Quando voc√™ libera mem√≥ria em um programa usando glibc, diferentes "bins" s√£o usados para gerenciar os peda√ßos de mem√≥ria. Aqui est√° uma explica√ß√£o simplificada de dois cen√°rios comuns: bins n√£o ordenados e fastbins.

### Bins N√£o Ordenados

Quando voc√™ libera um peda√ßo de mem√≥ria que n√£o √© um peda√ßo r√°pido, ele vai para o bin n√£o ordenado. Este bin age como uma lista onde novos peda√ßos liberados s√£o adicionados √† frente (a "cabe√ßa"). Quando voc√™ solicita um novo peda√ßo de mem√≥ria, o alocador olha para o bin n√£o ordenado de tr√°s para frente (a "cauda") para encontrar um peda√ßo grande o suficiente. Se um peda√ßo do bin n√£o ordenado for maior do que o necess√°rio, ele √© dividido, com a parte da frente sendo retornada e a parte restante permanecendo no bin.

Exemplo:

* Voc√™ aloca 300 bytes (`a`), ent√£o 250 bytes (`b`), libera `a` e solicita novamente 250 bytes (`c`).
* Quando voc√™ libera `a`, ele vai para o bin n√£o ordenado.
* Se voc√™ ent√£o solicitar 250 bytes novamente, o alocador encontra `a` na cauda e o divide, retornando a parte que se encaixa na sua solicita√ß√£o e mantendo o restante no bin.
* `c` estar√° apontando para o `a` anterior e preenchido com os dados do `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins s√£o usados para pequenos peda√ßos de mem√≥ria. Ao contr√°rio dos bins n√£o ordenados, os fastbins adicionam novos peda√ßos √† cabe√ßa, criando um comportamento de √∫ltimo a entrar, primeiro a sair (LIFO). Se voc√™ solicitar um pequeno peda√ßo de mem√≥ria, o alocador ir√° retirar da cabe√ßa do fastbin.

Exemplo:

* Voc√™ aloca quatro peda√ßos de 20 bytes cada (`a`, `b`, `c`, `d`).
* Quando voc√™ os libera em qualquer ordem, os peda√ßos liberados s√£o adicionados √† cabe√ßa do fastbin.
* Se voc√™ ent√£o solicitar um peda√ßo de 20 bytes, o alocador ir√° retornar o peda√ßo mais recentemente liberado da cabe√ßa do fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Outras Refer√™ncias e Exemplos

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Gere um objeto de usu√°rio, libere-o, gere um objeto que recebe o chunk liberado e permite escrever nele, **sobrescrevendo a posi√ß√£o de user->password** do anterior. Reutilize o usu√°rio para **burlar a verifica√ß√£o de senha**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* O programa permite criar notas. Uma nota ter√° as informa√ß√µes da nota em um malloc(8) (com um ponteiro para uma fun√ß√£o que pode ser chamada) e um ponteiro para outro malloc(\<size>) com o conte√∫do da nota.
* O ataque seria criar 2 notas (nota0 e nota1) com conte√∫dos de malloc maiores do que o tamanho das informa√ß√µes da nota e, em seguida, liber√°-las para que entrem no fast bin (ou tcache).
* Em seguida, crie outra nota (nota2) com tamanho de conte√∫do 8. O conte√∫do estar√° na nota1, pois o chunk ser√° reutilizado, onde poder√≠amos modificar o ponteiro da fun√ß√£o para apontar para a fun√ß√£o win e ent√£o Use-After-Free na nota1 para chamar o novo ponteiro da fun√ß√£o.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* √â poss√≠vel alocar alguma mem√≥ria, escrever o valor desejado, liber√°-lo, realoc√°-lo e como os dados anteriores ainda est√£o l√°, eles ser√£o tratados de acordo com a nova estrutura esperada no chunk, tornando poss√≠vel definir o valor ou obter a flag.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Neste caso, √© necess√°rio escrever 4 dentro de um chunk espec√≠fico que √© o primeiro a ser alocado (mesmo ap√≥s for√ßar a libera√ß√£o de todos eles). Em cada novo chunk alocado, seu n√∫mero no √≠ndice do array √© armazenado. Em seguida, aloque 4 chunks (+ o inicialmente alocado), o √∫ltimo ter√° 4 dentro dele, libere-os e force a realoca√ß√£o do primeiro, que usar√° o √∫ltimo chunk liberado, que √© o que cont√©m 4 dentro dele.
