# Prva Fit

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## **Prva Fit**

Kada oslobodite memoriju u programu koristeći glibc, različite "bins" se koriste za upravljanje memorijskim blokovima. Evo pojednostavljena objašnjenja dva uobičajena scenarija: unsorted bins i fastbins.

### Unsorted Bins

Kada oslobodite memorijski blok koji nije brzi blok, on ide u unsorted bin. Ovaj bin deluje kao lista gde se novi oslobođeni blokovi dodaju na početak („head“). Kada zatražite novi blok memorije, alokator gleda unsorted bin sa zadnje strane („tail“) da pronađe blok dovoljno velik. Ako je blok iz unsorted bina veći od onoga što vam je potrebno, on se deli, pri čemu se prednji deo vraća, a preostali deo ostaje u binu.

Primer:

* Alokujete 300 bajtova (`a`), zatim 250 bajtova (`b`), oslobodite `a` i ponovo zatražite 250 bajtova (`c`).
* Kada oslobodite `a`, ide u unsorted bin.
* Ako zatim ponovo zatražite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraćajući deo koji odgovara vašem zahtevu i zadržavajući ostatak u binu.
* `c` će pokazivati na prethodni `a` i biti popunjen sa `a`-ima.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male memorijske blokove. Za razliku od nesortiranih kanti, fastbins dodaju nove blokove na početak, stvarajući ponašanje poslednji unutra - prvi napolje (LIFO). Ako zatražite mali blok memorije, alokator će uzeti blok sa početka fastbina.

Primer:

* Alokujete četiri bloka od po 20 bajtova svaki (`a`, `b`, `c`, `d`).
* Kada ih oslobodite u bilo kom redosledu, oslobođeni blokovi se dodaju na početak fastbina.
* Ako zatim zatražite blok od 20 bajtova, alokator će vratiti najskorije oslobođeni blok sa početka fastbina.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Ostale reference i primeri

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Korišćenje nakon oslobađanja: Generisanje korisničkog objekta, oslobađanje istog, generisanje objekta koji dobija oslobođeni blok i omogućava pisanje u njega, **prepisivanje pozicije korisnikovog->šifra** iz prethodnog. Ponovno korišćenje korisnika da **zaobiđe proveru šifre**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program omogućava kreiranje beleški. Beleška će imati informacije o belešci u malloc(8) (sa pokazivačem na funkciju koja može biti pozvana) i pokazivač na drugi malloc(\<size>) sa sadržajem beleške.
* Napad bi bio da se kreiraju 2 beleške (beleška0 i beleška1) sa većim malloc sadržajem od veličine informacija o belešci, a zatim ih oslobode kako bi bile smeštene u brzi bin (ili tcache).
* Zatim, kreirajte još jednu belešku (beleška2) sa veličinom sadržaja 8. Sadržaj će biti u belešci1 jer će se blok ponovo koristiti, gde bismo mogli izmeniti pokazivač funkcije da pokazuje na funkciju za pobedu, a zatim koristiti Nakon-Oslobađanja belešku1 da pozove novi pokazivač funkcije.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Moguće je alocirati nešto memorije, upisati željenu vrednost, osloboditi je, ponovo alocirati i pošto su prethodni podaci i dalje tu, biće tretirani prema novoj očekivanoj strukturi u bloku što omogućava postavljanje vrednosti ili dobijanje zastave.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* U ovom slučaju je potrebno upisati 4 unutar specifičnog bloka koji je prvi alociran (čak i nakon prinudnog oslobađanja svih njih). Na svakom novom alociranom bloku čuva se njegov broj u nizu indeksa. Zatim, alocirajte 4 bloka (+ prvobitno alociran), poslednji će imati unutar sebe 4, oslobodite ih i prinudno ponovo alocirajte prvi, koji će koristiti poslednji oslobođeni blok koji ima unutar sebe 4.
