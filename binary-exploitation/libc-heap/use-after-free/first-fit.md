# İlk Uygun

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter**'da **bizi takip edin** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## **İlk Uygun**

Bir programda glibc kullanarak bellek serbest bıraktığınızda, bellek parçalarını yönetmek için farklı "kutular" kullanılır. İşte iki yaygın senaryonun basitleştirilmiş bir açıklaması: sıralanmamış kutular ve hızlı kutular.

### Sıralanmamış Kutular

Hızlı bir parça olmayan bir bellek parçasını serbest bıraktığınızda, bu sıralanmamış kutuya gider. Bu kutu, yeni serbest bırakılan parçaların ön tarafa (baş) eklendiği bir liste gibi davranır. Yeni bir bellek parçası talep ettiğinizde, ayırıcı sıralanmamış kutuya arka taraftan (kuyruk) bakarak yeterince büyük bir parça bulur. Eğer sıralanmamış kutudan bir parça, ihtiyacınız olandan büyükse, bu parça bölünür; ön kısmı geri döner ve kalan kısım kutuda kalır.

Örnek:

* 300 bayt (`a`) ayırırsınız, ardından 250 bayt (`b`), `a`'yı serbest bırakır ve tekrar 250 bayt (`c`) talep edersiniz.
* `a`'yı serbest bıraktığınızda, bu sıralanmamış kutuya gider.
* Eğer tekrar 250 bayt talep ederseniz, ayırıcı `a`'yı kuyrukta bulur ve onu böler, talebinize uyan kısmı geri döner ve geri kalanını kutuda tutar.
* `c`, önceki `a`'ya işaret edecek ve `a`'larla doldurulacaktır.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, küçük bellek parçaları için kullanılır. Sıralanmamış kutuların aksine, fastbins yeni parçaları başa ekler ve bu da son giren ilk çıkar (LIFO) davranışı oluşturur. Küçük bir bellek parçası talep ettiğinizde, allocator fastbin'in başından alır.

Örnek:

* Dört adet 20 baytlık parça (`a`, `b`, `c`, `d`) ayırırsınız.
* Bunları herhangi bir sırayla serbest bıraktığınızda, serbest bırakılan parçalar fastbin'in başına eklenir.
* Daha sonra 20 baytlık bir parça talep ederseniz, allocator fastbin'in başından en son serbest bırakılan parçayı döndürecektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Diğer Referanslar & Örnekler

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Kullanımdan sonra serbest bırakma: Bir kullanıcı nesnesi oluşturun, serbest bırakın, serbest bırakılan parçayı alan bir nesne oluşturun ve buna yazma izni verin, **önceki kullanıcı->şifre konumunu üzerine yazarak**. Kullanıcıyı yeniden kullanarak **şifre kontrolünü atlayın**.
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program notlar oluşturulmasına izin verir. Bir not, bir malloc(8) içinde not bilgilerini (çağrılabilecek bir işlevin işaretçisi ile) ve notun içeriği ile başka bir malloc(\<boyut>) için bir işaretçi içerecektir.
* Saldırı, not bilgisi boyutundan daha büyük malloc içeriklerine sahip 2 not (not0 ve not1) oluşturmak ve ardından bunları serbest bırakmak olacaktır, böylece hızlı kutuya (veya tcache) gireceklerdir.
* Ardından, içerik boyutu 8 olan başka bir not (not2) oluşturun. İçerik, parça yeniden kullanılacağı için not1'de olacak, burada işlev işaretçisini kazanan işlevine işaret edecek şekilde değiştirebiliriz ve ardından Kullanımdan Sonra Serbest Bırakma ile not1'i yeni işlev işaretçisini çağırmak için kullanabiliriz.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Bazı bellek ayırmak, istenen değeri yazmak, serbest bırakmak, yeniden ayırmak ve önceki veriler hala orada olduğu için, parçadaki yeni beklenen yapı ile işlenmesi mümkün olacaktır, bu da değeri ayarlayıp bayrağı almayı mümkün kılar.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Bu durumda, belirli bir parçanın içine 4 yazmak gereklidir, bu da ilk tahsis edilen parçadır (hepsini zorla serbest bıraktıktan sonra bile). Her yeni tahsis edilen parçanın dizideki numarası saklanır. Ardından, 4 parça (+ başlangıçta tahsis edilen) ayırın, sonuncusu içinde 4 olacak, bunları serbest bırakın ve ilk parçanın yeniden tahsis edilmesini zorlayın, bu da içinde 4 olan son serbest bırakılan parçayı kullanacaktır.
