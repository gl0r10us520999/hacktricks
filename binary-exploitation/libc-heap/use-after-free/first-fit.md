# First Fit

{% hint style="success" %}
AWS 해킹을 배우고 실습하세요:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹을 배우고 실습하세요: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
{% endhint %}

## **First Fit**

프로그램에서 glibc를 사용하여 메모리를 해제할 때, 다른 "bins"가 메모리 청크를 관리하는 데 사용됩니다. 여기에는 정렬되지 않은 bins와 fastbins의 두 가지 일반적인 시나리오에 대한 간소화된 설명이 있습니다.

### 정렬되지 않은 Bins

빠른 청크가 아닌 메모리 청크를 해제하면 정렬되지 않은 bin에 들어갑니다. 이 bin은 새로 해제된 청크가 앞쪽(머리)에 추가되는 리스트처럼 작동합니다. 새로운 메모리 청크를 요청하면 할당기는 뒤쪽(꼬리)의 정렬되지 않은 bin을 확인하여 충분히 큰 청크를 찾습니다. 정렬되지 않은 bin에서 청크가 요청한 것보다 크면 분할되어 앞부분이 반환되고 나머지 부분은 bin에 유지됩니다.

예시:

* 300바이트(`a`)를 할당하고, 250바이트(`b`)를 할당한 다음 `a`를 해제하고 다시 250바이트(`c`)를 요청합니다.
* `a`를 해제하면 정렬되지 않은 bin에 들어갑니다.
* 그런 다음 250바이트를 다시 요청하면 할당기는 꼬리에서 `a`를 찾아 분할하여 요청에 맞는 부분을 반환하고 나머지를 bin에 유지합니다.
* `c`는 이전 `a`를 가리키고 `a`로 채워집니다.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins는 작은 메모리 청크에 사용됩니다. Unsorted bins와 달리, fastbins는 새로운 청크를 헤드에 추가하여 후입선출(LIFO) 동작을 만듭니다. 만약 작은 청크의 메모리를 요청하면, 할당기는 fastbin의 헤드에서 가져올 것입니다.

예시:

* 20바이트씩 네 개의 청크(`a`, `b`, `c`, `d`)를 할당합니다.
* 어떤 순서로 해제하더라도, 해제된 청크는 fastbin의 헤드에 추가됩니다.
* 그 후 20바이트 청크를 요청하면, 할당기는 fastbin의 헤드에서 가장 최근에 해제된 청크를 반환할 것입니다.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## 기타 참고 자료 및 예시

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: 사용자 객체를 생성한 후 해제하고, 해제된 청크를 가져오는 객체를 생성하여 해당 위치에 쓰기를 허용함으로써 이전 것에서 **user->password의 위치를 덮어씀**. 사용자를 재사용하여 **비밀번호 확인을 우회함**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* 프로그램은 노트를 생성할 수 있게 함. 노트는 malloc(8)에 노트 정보(호출될 수 있는 함수를 가리키는 포인터)와 다른 malloc(\<size>)에 노트 내용의 포인터를 가짐.
* 공격은 노트 정보 크기보다 큰 malloc 내용을 가진 2개의 노트 (note0 및 note1)를 생성한 다음, 이들을 해제하여 빠른 bin (또는 tcache)에 들어가게 함.
* 그런 다음, 내용 크기가 8인 다른 노트 (note2)를 생성함. 내용은 재사용될 청크인 note1에 있게 되며, 여기서 함수 포인터를 win 함수를 가리키도록 수정한 다음, note1을 Use-After-Free하여 새 함수 포인터를 호출함.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* 일부 메모리를 할당하고 원하는 값을 쓴 다음 해제하고 다시 할당함. 이전 데이터가 여전히 남아 있으므로, 새로운 예상된 구조에 따라 처리되어 값을 설정하거나 플래그를 얻을 수 있음.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* 이 경우 특정 청크 내에 4를 써야 하며, 이는 처음 할당된 청크 중 첫 번째 것임 (모두 강제 해제한 후에도). 각 새로 할당된 청크에는 배열 인덱스 번호가 저장됨. 그런 다음, 4개의 청크를 할당함 (+ 초기 할당된 것), 마지막 청크에는 내부에 4가 들어 있음, 이들을 해제하고 처음 것을 다시 할당하도록 강제하면, 4가 들어 있는 마지막 청크를 사용하게 됨.
