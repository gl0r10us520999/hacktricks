# Ä°lk Uygun

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks EÄŸitim AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks EÄŸitim GCP KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter**'da **bizi takip edin** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

## **Ä°lk Uygun**

Bir programda glibc kullanarak bellek serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bellek parÃ§alarÄ±nÄ± yÃ¶netmek iÃ§in farklÄ± "kutular" kullanÄ±lÄ±r. Ä°ÅŸte iki yaygÄ±n senaryonun basitleÅŸtirilmiÅŸ bir aÃ§Ä±klamasÄ±: sÄ±ralanmamÄ±ÅŸ kutular ve hÄ±zlÄ± kutular.

### SÄ±ralanmamÄ±ÅŸ Kutular

HÄ±zlÄ± bir parÃ§a olmayan bir bellek parÃ§asÄ±nÄ± serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bu sÄ±ralanmamÄ±ÅŸ kutuya gider. Bu kutu, yeni serbest bÄ±rakÄ±lan parÃ§alarÄ±n Ã¶n tarafa (baÅŸ) eklendiÄŸi bir liste gibi davranÄ±r. Yeni bir bellek parÃ§asÄ± talep ettiÄŸinizde, ayÄ±rÄ±cÄ± sÄ±ralanmamÄ±ÅŸ kutuya arka taraftan (kuyruk) bakarak yeterince bÃ¼yÃ¼k bir parÃ§a bulur. EÄŸer sÄ±ralanmamÄ±ÅŸ kutudan bir parÃ§a, ihtiyacÄ±nÄ±z olandan bÃ¼yÃ¼kse, bu parÃ§a bÃ¶lÃ¼nÃ¼r; Ã¶n kÄ±smÄ± geri dÃ¶ner ve kalan kÄ±sÄ±m kutuda kalÄ±r.

Ã–rnek:

* 300 bayt (`a`) ayÄ±rÄ±rsÄ±nÄ±z, ardÄ±ndan 250 bayt (`b`), `a`'yÄ± serbest bÄ±rakÄ±r ve tekrar 250 bayt (`c`) talep edersiniz.
* `a`'yÄ± serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bu sÄ±ralanmamÄ±ÅŸ kutuya gider.
* EÄŸer tekrar 250 bayt talep ederseniz, ayÄ±rÄ±cÄ± `a`'yÄ± kuyrukta bulur ve onu bÃ¶ler, talebinize uyan kÄ±smÄ± geri dÃ¶ner ve geri kalanÄ±nÄ± kutuda tutar.
* `c`, Ã¶nceki `a`'ya iÅŸaret edecek ve `a`'larla doldurulacaktÄ±r.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, kÃ¼Ã§Ã¼k bellek parÃ§alarÄ± iÃ§in kullanÄ±lÄ±r. SÄ±ralanmamÄ±ÅŸ kutularÄ±n aksine, fastbins yeni parÃ§alarÄ± baÅŸa ekler ve bu da son giren ilk Ã§Ä±kar (LIFO) davranÄ±ÅŸÄ± oluÅŸturur. KÃ¼Ã§Ã¼k bir bellek parÃ§asÄ± talep ettiÄŸinizde, allocator fastbin'in baÅŸÄ±ndan alÄ±r.

Ã–rnek:

* DÃ¶rt adet 20 baytlÄ±k parÃ§a (`a`, `b`, `c`, `d`) ayÄ±rÄ±rsÄ±nÄ±z.
* BunlarÄ± herhangi bir sÄ±rayla serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, serbest bÄ±rakÄ±lan parÃ§alar fastbin'in baÅŸÄ±na eklenir.
* Daha sonra 20 baytlÄ±k bir parÃ§a talep ederseniz, allocator fastbin'in baÅŸÄ±ndan en son serbest bÄ±rakÄ±lan parÃ§ayÄ± dÃ¶ndÃ¼recektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## DiÄŸer Referanslar & Ã–rnekler

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. KullanÄ±mdan sonra serbest bÄ±rakma: Bir kullanÄ±cÄ± nesnesi oluÅŸturun, serbest bÄ±rakÄ±n, serbest bÄ±rakÄ±lan parÃ§ayÄ± alan bir nesne oluÅŸturun ve buna yazma izni verin, **Ã¶nceki kullanÄ±cÄ±->ÅŸifre konumunu Ã¼zerine yazarak**. KullanÄ±cÄ±yÄ± yeniden kullanarak **ÅŸifre kontrolÃ¼nÃ¼ atlayÄ±n**.
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program notlar oluÅŸturulmasÄ±na izin verir. Bir not, bir malloc(8) iÃ§inde not bilgilerini (Ã§aÄŸrÄ±labilecek bir iÅŸlevin iÅŸaretÃ§isi ile) ve notun iÃ§eriÄŸi ile baÅŸka bir malloc(\<boyut>) iÃ§in bir iÅŸaretÃ§i iÃ§erecektir.
* SaldÄ±rÄ±, not bilgisi boyutundan daha bÃ¼yÃ¼k malloc iÃ§eriklerine sahip 2 not (not0 ve not1) oluÅŸturmak ve ardÄ±ndan bunlarÄ± serbest bÄ±rakmak olacaktÄ±r, bÃ¶ylece hÄ±zlÄ± kutuya (veya tcache) gireceklerdir.
* ArdÄ±ndan, iÃ§erik boyutu 8 olan baÅŸka bir not (not2) oluÅŸturun. Ä°Ã§erik, parÃ§a yeniden kullanÄ±lacaÄŸÄ± iÃ§in not1'de olacak, burada iÅŸlev iÅŸaretÃ§isini kazanan iÅŸlevine iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirebiliriz ve ardÄ±ndan KullanÄ±mdan Sonra Serbest BÄ±rakma ile not1'i yeni iÅŸlev iÅŸaretÃ§isini Ã§aÄŸÄ±rmak iÃ§in kullanabiliriz.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* BazÄ± bellek ayÄ±rmak, istenen deÄŸeri yazmak, serbest bÄ±rakmak, yeniden ayÄ±rmak ve Ã¶nceki veriler hala orada olduÄŸu iÃ§in, parÃ§adaki yeni beklenen yapÄ± ile iÅŸlenmesi mÃ¼mkÃ¼n olacaktÄ±r, bu da deÄŸeri ayarlayÄ±p bayraÄŸÄ± almayÄ± mÃ¼mkÃ¼n kÄ±lar.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Bu durumda, belirli bir parÃ§anÄ±n iÃ§ine 4 yazmak gereklidir, bu da ilk tahsis edilen parÃ§adÄ±r (hepsini zorla serbest bÄ±raktÄ±ktan sonra bile). Her yeni tahsis edilen parÃ§anÄ±n dizideki numarasÄ± saklanÄ±r. ArdÄ±ndan, 4 parÃ§a (+ baÅŸlangÄ±Ã§ta tahsis edilen) ayÄ±rÄ±n, sonuncusu iÃ§inde 4 olacak, bunlarÄ± serbest bÄ±rakÄ±n ve ilk parÃ§anÄ±n yeniden tahsis edilmesini zorlayÄ±n, bu da iÃ§inde 4 olan son serbest bÄ±rakÄ±lan parÃ§ayÄ± kullanacaktÄ±r.
