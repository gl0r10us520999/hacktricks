# First Fit

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **First Fit**

Lorsque vous lib√©rez de la m√©moire dans un programme utilisant glibc, diff√©rents "bins" sont utilis√©s pour g√©rer les morceaux de m√©moire. Voici une explication simplifi√©e de deux sc√©narios courants : les bins non tri√©s et les fastbins.

### Bins Non Tri√©s

Lorsque vous lib√©rez un morceau de m√©moire qui n'est pas un morceau rapide, il va dans le bin non tri√©. Ce bin agit comme une liste o√π les nouveaux morceaux lib√©r√©s sont ajout√©s √† l'avant (la "t√™te"). Lorsque vous demandez un nouveau morceau de m√©moire, l'allocateur examine le bin non tri√© par l'arri√®re (la "queue") pour trouver un morceau suffisamment grand. Si un morceau du bin non tri√© est plus grand que ce dont vous avez besoin, il est divis√©, la partie avant √©tant retourn√©e et la partie restante restant dans le bin.

Exemple :

* Vous allouez 300 octets (`a`), puis 250 octets (`b`), vous lib√©rez `a` et demandez √† nouveau 250 octets (`c`).
* Lorsque vous lib√©rez `a`, il va dans le bin non tri√©.
* Si vous demandez ensuite √† nouveau 250 octets, l'allocateur trouve `a` √† la queue et le divise, retournant la partie qui correspond √† votre demande et gardant le reste dans le bin.
* `c` pointera vers l'ancien `a` et sera rempli avec les `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Les fastbins sont utilis√©s pour de petits morceaux de m√©moire. Contrairement aux unsorted bins, les fastbins ajoutent de nouveaux morceaux √† la t√™te, cr√©ant un comportement de dernier entr√©, premier sorti (LIFO). Si vous demandez un petit morceau de m√©moire, l'allocateur prendra √† partir de la t√™te du fastbin.

Exemple :

* Vous allouez quatre morceaux de 20 octets chacun (`a`, `b`, `c`, `d`).
* Lorsque vous les lib√©rez dans n'importe quel ordre, les morceaux lib√©r√©s sont ajout√©s √† la t√™te du fastbin.
* Si vous demandez ensuite un morceau de 20 octets, l'allocateur renverra le morceau le plus r√©cemment lib√©r√© de la t√™te du fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Autres R√©f√©rences & Exemples

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Utilisation apr√®s lib√©ration : G√©n√©rer un objet utilisateur, le lib√©rer, g√©n√©rer un objet qui obtient le morceau lib√©r√© et permettre d'√©crire dessus, **√©crasant la position de user->password** de l'ancien. R√©utiliser l'utilisateur pour **contourner la v√©rification du mot de passe**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Le programme permet de cr√©er des notes. Une note aura les informations de la note dans un malloc(8) (avec un pointeur vers une fonction qui pourrait √™tre appel√©e) et un pointeur vers un autre malloc(\<size>) avec le contenu de la note.
* L'attaque consisterait √† cr√©er 2 notes (note0 et note1) avec des contenus malloc plus grands que la taille des informations de la note, puis √† les lib√©rer pour qu'elles entrent dans le fast bin (ou tcache).
* Ensuite, cr√©er une autre note (note2) avec une taille de contenu de 8. Le contenu va √™tre dans note1 car le morceau va √™tre r√©utilis√©, o√π nous pourrions modifier le pointeur de fonction pour pointer vers la fonction win et ensuite utiliser apr√®s lib√©ration note1 pour appeler le nouveau pointeur de fonction.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Il est possible d'allouer de la m√©moire, d'√©crire la valeur souhait√©e, de la lib√©rer, de la r√©allouer et comme les donn√©es pr√©c√©dentes sont toujours l√†, elles seront trait√©es selon la nouvelle structure attendue dans le morceau, rendant possible de d√©finir la valeur pour obtenir le drapeau.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Dans ce cas, il est n√©cessaire d'√©crire 4 √† l'int√©rieur d'un morceau sp√©cifique qui est le premier allou√© (m√™me apr√®s avoir forc√© la lib√©ration de tous). Pour chaque nouveau morceau allou√©, son num√©ro dans l'index du tableau est stock√©. Ensuite, allouer 4 morceaux (+ le morceau initialement allou√©), le dernier aura 4 √† l'int√©rieur, les lib√©rer et forcer la r√©allocation du premier, qui utilisera le dernier morceau lib√©r√©, qui est celui avec 4 √† l'int√©rieur.
