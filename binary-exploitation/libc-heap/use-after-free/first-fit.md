# İlk Uygun

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## **İlk Uygun**

Bir programda glibc kullanarak belleği serbest bıraktığınızda, bellek parçalarını yönetmek için farklı "kutular" kullanılır. İki yaygın senaryonun basitleştirilmiş bir açıklaması şunlardır: sıralanmamış kutular ve hızlı kutular.

### Sıralanmamış Kutular

Hızlı bir parça olmayan bir bellek parçasını serbest bıraktığınızda, bu parça sıralanmamış kutuya gider. Bu kutu, yeni serbest bırakılan parçaların önüne (başa) eklenen bir liste gibi davranır. Yeni bir bellek parçası istediğinizde, tahsisatçı, istediğinizden yeterince büyük bir parça bulmak için sıralanmamış kutuya arkadan (kuyruk) bakar. Eğer sıralanmamış kutudan bir parça istediğinizden büyükse, bölünür; ön kısmı geri döndürülür ve geri kalan kısım kutuda kalır.

Örnek:

* 300 bayt (`a`) tahsis edersiniz, ardından 250 bayt (`b`) tahsis edersiniz, `a`yı serbest bırakırsınız ve tekrar 250 bayt (`c`) istersiniz.
* `a`yı serbest bıraktığınızda, sıralanmamış kutuya gider.
* Sonra 250 bayt daha isterseniz, tahsisatçı `a`yı kuyrukta bulur ve bölerek, isteğinize uygun olan kısmı geri döndürür ve geri kalanı kutuda tutar.
* `c`, önceki `a`ya işaret edecek ve `a`'ların içeriğiyle dolacaktır.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, küçük bellek parçaları için kullanılır. Sıralanmamış kovaların aksine, fastbins yeni parçaları başa ekler ve son giren-ilk çıkan (LIFO) davranışı oluşturur. Eğer küçük bir bellek parçası isterseniz, ayırıcı fastbin'in başından alacaktır.

Örnek:

* 20 baytlık dört parça ayırırsınız (`a`, `b`, `c`, `d`).
* Onları herhangi bir sırayla serbest bıraktığınızda, serbest bırakılan parçalar fastbin'in başına eklenir.
* Sonra 20 baytlık bir parça isterseniz, ayırıcı en son serbest bırakılan parçayı fastbin'in başından döndürecektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Diğer Referanslar ve Örnekler

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Bir kullanıcı nesnesi oluştur, serbest bırak, serbest bırakılan parçayı alan bir nesne oluştur ve ona yazma izni ver, **öncekinin konumunu kullanıcı->şifre ile değiştir**. Kullanıcıyı **şifre kontrolünü atlamak** için yeniden kullan.
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program notlar oluşturmaya izin verir. Bir not, not bilgisini içeren malloc(8) (çağrılabilen bir işlevin işaretçisi ile) ve notun içeriğini içeren başka bir malloc(\<boyut>) işaretçisine sahip olacak.
* Saldırı, not bilgi boyutundan daha büyük malloc içeriğine sahip 2 not (not0 ve not1) oluşturmak ve ardından bunları serbest bırakarak hızlı bin (veya tcache) içine almaktır.
* Sonra, içerik boyutu 8 olan başka bir not (not2) oluşturun. İçerik, parçanın yeniden kullanılacağı not1'de olacak, işlev işaretçisini win işlevine yönlendirebilir ve ardından not1'i Use-After-Free yaparak yeni işlev işaretçisini çağırabiliriz.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Bazı bellek ayırmak, istenen değeri yazmak, serbest bırakmak, yeniden boyutlandırmak mümkündür ve önceki veriler hala orada olduğundan, parçadaki yeni beklenen yapıya göre işlenecektir, böylece değeri ayarlamak veya bayrağı almak mümkün olacaktır.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* Bu durumda, belirli bir parçanın içine 4 yazmak gereklidir, bu ilk ayrılan parçadır (hepsini zorla serbest bıraktıktan sonra bile). Her yeni ayrılan parçada, dizin içindeki numarası saklanır. Sonra, 4 parça (+ başlangıçta ayrılan) tahsis edin, sonuncusu içinde 4 olacak, onları serbest bırakın ve ilk parçanın yeniden tahsisini zorlayın, bu da içinde 4 olan son parçayı kullanacaktır.
