# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Un heap overflow √® simile a un [**stack overflow**](../stack-overflow/) ma nell'heap. Fondamentalmente significa che √® stato riservato dello spazio nell'heap per memorizzare alcuni dati e **i dati memorizzati erano pi√π grandi dello spazio riservato.**

Negli stack overflow sappiamo che alcuni registri come il puntatore di istruzione o il frame dello stack verranno ripristinati dallo stack e potrebbe essere possibile abusarne. Nel caso degli heap overflow, **non ci sono informazioni sensibili memorizzate per impostazione predefinita** nel chunk dell'heap che pu√≤ essere sovrascritto. Tuttavia, potrebbero esserci informazioni sensibili o puntatori, quindi la **criticit√†** di questa vulnerabilit√† **dipende** da **quali dati potrebbero essere sovrascritti** e da come un attaccante potrebbe abusarne.

{% hint style="success" %}
Per trovare gli offset di overflow puoi usare gli stessi schemi che in [**stack overflows**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

Negli stack overflow l'organizzazione e i dati che saranno presenti nello stack al momento in cui la vulnerabilit√† pu√≤ essere attivata sono abbastanza affidabili. Questo perch√© lo stack √® lineare, sempre in aumento in memoria collidente, in **posti specifici dell'esecuzione del programma la memoria dello stack di solito memorizza dati simili** e ha una struttura specifica con alcuni puntatori alla fine della parte dello stack utilizzata da ciascuna funzione.

Tuttavia, nel caso di un heap overflow, la memoria utilizzata non √® lineare ma **i chunk allocati sono di solito in posizioni separate della memoria** (non uno accanto all'altro) a causa di **bins e zone** che separano le allocazioni per dimensione e perch√© **la memoria precedentemente liberata viene utilizzata** prima di allocare nuovi chunk. √à **complicato sapere quale oggetto andr√† a collidere con quello vulnerabile** a un heap overflow. Quindi, quando viene trovato un heap overflow, √® necessario trovare un **modo affidabile per fare in modo che l'oggetto desiderato sia il prossimo in memoria** rispetto a quello che pu√≤ essere sovrascritto.

Una delle tecniche utilizzate per questo √® **Heap Grooming** che viene utilizzata ad esempio [**in questo post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Nel post viene spiegato come quando nel kernel iOS una zona esaurisce la memoria per memorizzare chunk di memoria, la espande di una pagina del kernel, e questa pagina viene suddivisa in chunk delle dimensioni previste che verrebbero utilizzate in ordine (fino alla versione 9.2 di iOS, poi questi chunk vengono utilizzati in modo randomizzato per rendere pi√π difficile l'exploitation di questi attacchi).

Pertanto, nel post precedente in cui si verifica un heap overflow, per forzare l'oggetto sovrascritto a collidere con un ordine vittima, diversi **`kallocs` vengono forzati da diversi thread per cercare di garantire che tutti i chunk liberi siano riempiti e che venga creata una nuova pagina**.

Per forzare questo riempimento con oggetti di una dimensione specifica, l'**allocazione out-of-line associata a un mach port iOS** √® un candidato ideale. Modificando la dimensione del messaggio, √® possibile specificare esattamente la dimensione dell'allocazione `kalloc` e quando il corrispondente mach port viene distrutto, l'allocazione corrispondente verr√† immediatamente rilasciata a `kfree`.

Quindi, alcuni di questi segnaposto possono essere **liberati**. La **lista libera `kalloc.4096` rilascia elementi in ordine last-in-first-out**, il che significa fondamentalmente che se alcuni segnaposto vengono liberati e l'exploit cerca di allocare diversi oggetti vittima mentre cerca di allocare l'oggetto vulnerabile all'overflow, √® probabile che questo oggetto sar√† seguito da un oggetto vittima.

### Example libc

[**In questa pagina**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) √® possibile trovare un'emulazione di base di Heap overflow che mostra come sovrascrivere il bit prev in uso del chunk successivo e la posizione della dimensione prev √® possibile **consolidare un chunk utilizzato** (facendolo pensare che sia inutilizzato) e **poi allocarlo di nuovo** potendo sovrascrivere dati che vengono utilizzati in un puntatore diverso.

Un altro esempio da [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) mostra un esempio molto basilare di un CTF in cui un **heap overflow** pu√≤ essere abusato per chiamare la funzione vincitrice per **ottenere la flag**.

Nell'esempio [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) √® possibile vedere come abusando di un buffer overflow √® possibile **sovrascrivere in un chunk vicino un indirizzo** dove **dati arbitrari dell'utente** verranno scritti.

### Example ARM64

Nella pagina [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) puoi trovare un esempio di heap overflow dove un comando che verr√† eseguito √® memorizzato nel chunk successivo al chunk sovrascritto. Quindi, √® possibile modificare il comando eseguito sovrascrivendolo con un exploit semplice come:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Altri esempi

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Utilizziamo una vulnerabilit√† di Overflow di Interi per ottenere un Heap Overflow.
* Corrompiamo i puntatori a una funzione all'interno di un `struct` del chunk sovrascritto per impostare una funzione come `system` e ottenere l'esecuzione di codice.

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}
