# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Przepenienie sterty (heap overflow) jest jak [**przepenienie stosu**](../stack-overflow/), ale w stercie. Zasadniczo oznacza to, 偶e pewna przestrze zostaa zarezerwowana w stercie do przechowywania danych, a **przechowywane dane byy wiksze ni偶 zarezerwowana przestrze.**

W przypadku przepenie stosu wiemy, 偶e niekt贸re rejestry, takie jak wska藕nik instrukcji lub ramka stosu, bd przywracane ze stosu i mo偶e by mo偶liwe ich nadu偶ycie. W przypadku przepenie sterty, **nie ma 偶adnych wra偶liwych informacji przechowywanych domylnie** w kawaku sterty, kt贸ry mo偶e by przepeniony. Jednak mog to by wra偶liwe informacje lub wska藕niki, wic **krytyczno** tej podatnoci **zale偶y** od **tego, jakie dane mog by nadpisane** i jak napastnik m贸gby to wykorzysta.

{% hint style="success" %}
Aby znale藕 przesunicia przepenienia, mo偶esz u偶y tych samych wzorc贸w, co w [**przepenieniach stosu**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

W przypadku przepenie stosu ukad i dane, kt贸re bd obecne na stosie w momencie, gdy podatno mo偶e zosta wyzwolona, s do wiarygodne. Dzieje si tak, poniewa偶 stos jest liniowy, zawsze ronie w kolidujcej pamici, w **konkretnych miejscach dziaania programu pami stosu zazwyczaj przechowuje podobny rodzaj danych** i ma pewn specyficzn struktur z pewnymi wska藕nikami na kocu czci stosu u偶ywanej przez ka偶d funkcj.

Jednak w przypadku przepenienia sterty u偶ywana pami nie jest liniowa, ale **przydzielone kawaki s zazwyczaj w oddzielnych pozycjach pamici** (nie jeden obok drugiego) z powodu **koszyk贸w i stref** oddzielajcych przydziay wedug rozmiaru oraz dlatego, 偶e **wczeniej zwolniona pami jest u偶ywana** przed przydzieleniem nowych kawak贸w. **Trudno jest wiedzie, kt贸ry obiekt bdzie kolidowa z tym, kt贸ry jest podatny** na przepenienie sterty. Dlatego, gdy znajdzie si przepenienie sterty, konieczne jest znalezienie **wiarygodnego sposobu, aby po偶dany obiekt by nastpny w pamici** od tego, kt贸ry mo偶e by przepeniony.

Jedn z technik u偶ywanych do tego jest **Heap Grooming**, kt贸ra jest u偶ywana na przykad [**w tym pocie**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). W pocie wyjaniono, jak w jdrze iOS, gdy strefa koczy si pamici do przechowywania kawak贸w pamici, rozszerza j o stron jdra, a ta strona jest dzielona na kawaki oczekiwanych rozmiar贸w, kt贸re bd u偶ywane w kolejnoci (do wersji iOS 9.2, potem te kawaki s u偶ywane w spos贸b losowy, aby utrudni wykorzystanie tych atak贸w).

Dlatego w poprzednim pocie, w kt贸rym wystpuje przepenienie sterty, aby wymusi kolizj przepenionego obiektu z obiektem ofiary, kilka **`kalloc` jest wymuszanych przez kilka wtk贸w, aby spr贸bowa zapewni, 偶e wszystkie wolne kawaki s wypenione i 偶e tworzona jest nowa strona**.

Aby wymusi to wypenienie obiektami o okrelonym rozmiarze, **alokacja poza lini zwizana z portem mach iOS** jest idealnym kandydatem. Poprzez skonstruowanie rozmiaru wiadomoci, mo偶liwe jest dokadne okrelenie rozmiaru alokacji `kalloc`, a gdy odpowiedni port mach zostanie zniszczony, odpowiednia alokacja zostanie natychmiast zwolniona z powrotem do `kfree`.

Nastpnie niekt贸re z tych miejsc rezerwowych mog by **zwolnione**. **Lista wolnych `kalloc.4096` zwalnia elementy w kolejnoci ostatni wchodzi, pierwszy wychodzi**, co zasadniczo oznacza, 偶e jeli niekt贸re miejsca rezerwowe s zwolnione, a exploit pr贸buje alokowa kilka obiekt贸w ofiar, podczas gdy pr贸buje alokowa obiekt podatny na przepenienie, prawdopodobne jest, 偶e ten obiekt bdzie nastpowa po obiekcie ofiary.

### Example libc

[**Na tej stronie**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) mo偶na znale藕 podstawow emulacj przepenienia sterty, kt贸ra pokazuje, jak nadpisanie bitu prev in use nastpnego kawaka i pozycji prev size pozwala na **konsolidacj u偶ywanego kawaka** (sprawiajc, 偶e myli, 偶e jest nieu偶ywany) i **nastpnie ponowne przydzielenie go**, bdc w stanie nadpisa dane, kt贸re s u偶ywane w innym wska藕niku.

Inny przykad z [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje bardzo podstawowy przykad CTF, w kt贸rym **przepenienie sterty** mo偶e by wykorzystane do wywoania funkcji zwycizcy, aby **zdoby flag**.

W przykadzie [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) mo偶na zobaczy, jak nadu偶ycie przepenienia bufora pozwala na **nadpisanie w pobliskim kawaku adresu**, gdzie **dane u偶ytkownika** bd zapisywane.

### Example ARM64

Na stronie [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) mo偶na znale藕 przykad przepenienia sterty, w kt贸rym polecenie, kt贸re ma by wykonane, jest przechowywane w nastpnym kawaku z przepenionego kawaka. Tak wic, mo偶liwe jest modyfikowanie wykonywanego polecenia poprzez nadpisanie go prostym exploitem, takim jak:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Inne przykady

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* U偶ywamy podatnoci na przepenienie cakowite, aby uzyska przepenienie sterty.
* Korumpujemy wska藕niki do funkcji wewntrz `struct` przepenionego kawaka, aby ustawi funkcj tak jak `system` i uzyska wykonanie kodu.

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si sztuczkami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}
