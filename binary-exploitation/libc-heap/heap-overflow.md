# Heap Overflow

{% hint style="success" %}
Impara e pratica l'Hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informazioni di Base

Un heap overflow √® simile a un [**stack overflow**](../stack-overflow/) ma nell'heap. Fondamentalmente significa che √® stato riservato dello spazio nell'heap per memorizzare alcuni dati e che **i dati memorizzati erano pi√π grandi dello spazio riservato**.

Nei stack overflows sappiamo che alcuni registri come il puntatore di istruzione o il frame dello stack verranno ripristinati dallo stack e potrebbe essere possibile abusarne. Nel caso degli heap overflows, **non vi √® alcuna informazione sensibile memorizzata per impostazione predefinita** nel chunk dell'heap che pu√≤ essere sovraffollato. Tuttavia, potrebbero esserci informazioni sensibili o puntatori, quindi la **criticit√†** di questa vulnerabilit√† **dipende** da **quali dati potrebbero essere sovrascritti** e da come un attaccante potrebbe abusarne.

{% hint style="success" %}
Per trovare gli offset degli overflow √® possibile utilizzare gli stessi schemi dei [**stack overflows**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

Nei stack overflows, l'organizzazione e i dati che saranno presenti nello stack nel momento in cui la vulnerabilit√† pu√≤ essere attivata sono piuttosto affidabili. Ci√≤ √® dovuto al fatto che lo stack √® lineare, aumenta sempre in memoria in collisione, in **specifici punti dell'esecuzione del programma la memoria dello stack di solito memorizza tipi di dati simili** e ha una struttura specifica con alcuni puntatori alla fine della parte dello stack utilizzata da ciascuna funzione.

Tuttavia, nel caso di un heap overflow, la memoria utilizzata non √® lineare ma **i chunk allocati sono di solito in posizioni separate della memoria** (non uno accanto all'altro) a causa di **bin e zone** che separano le allocazioni per dimensione e perch√© **la memoria precedentemente liberata viene utilizzata** prima di allocare nuovi chunk. √à **complicato sapere quale oggetto andr√† in collisione con quello vulnerabile** a un heap overflow. Quindi, quando viene trovato un heap overflow, √® necessario trovare un **modo affidabile per far s√¨ che l'oggetto desiderato sia il successivo in memoria** rispetto a quello che pu√≤ essere sovraffollato.

Una delle tecniche utilizzate per questo √® il **Heap Grooming** che viene utilizzato ad esempio [**in questo post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Nel post viene spiegato come nel kernel iOS quando una zona esaurisce la memoria per memorizzare chunk di memoria, la espande di una pagina del kernel, e questa pagina viene divisa in chunk delle dimensioni previste che verranno utilizzati in ordine (fino alla versione iOS 9.2, poi questi chunk vengono utilizzati in modo randomizzato per rendere pi√π difficile lo sfruttamento di questi attacchi).

Pertanto, nel post precedente in cui si verifica un heap overflow, per forzare l'oggetto sovraccaricato a collidere con un ordine vittima, diversi **`kallocs` sono forzati da diversi thread per cercare di garantire che tutti i chunk liberi siano riempiti e che venga creato una nuova pagina**.

Per forzare questo riempimento con oggetti di una dimensione specifica, l'**allocazione fuori linea associata a una porta mach iOS** √® un candidato ideale. Creando la dimensione del messaggio, √® possibile specificare esattamente la dimensione dell'allocazione `kalloc` e quando la porta mach corrispondente viene distrutta, l'allocazione corrispondente verr√† immediatamente rilasciata a `kfree`.

Quindi, alcuni di questi segnaposto possono essere **liberati**. La lista di liberazione **`kalloc.4096` rilascia gli elementi in ordine di ultimo entrato, primo uscito**, il che significa fondamentalmente che se alcuni segnaposto vengono liberati e l'exploit prova a allocare diversi oggetti vittime mentre cerca di allocare l'oggetto vulnerabile all'overflow, √® probabile che questo oggetto sar√† seguito da un oggetto vittima.

### Esempio libc

[**In questa pagina**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) √® possibile trovare un'emulazione di base di un Heap overflow che mostra come sovrascrivendo il bit prev in uso del chunk successivo e la posizione della dimensione prev sia possibile **consolidare un chunk utilizzato** (facendogli credere che non sia in uso) e **poi allocarlo nuovamente** potendo sovrascrivere dati che vengono utilizzati in un diverso puntatore.

Un altro esempio da [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) mostra un esempio molto basilare di un CTF in cui un **heap overflow** pu√≤ essere abusato per chiamare la funzione vincitrice e **ottenere la flag**.

Nel [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) esempio √® possibile vedere come abusando di un buffer overflow sia possibile **sovrascrivere in un chunk vicino un indirizzo** dove verr√† scritto **un dato arbitrario dall'utente**.

### Esempio ARM64

Nella pagina [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) √® possibile trovare un esempio di heap overflow in cui un comando che verr√† eseguito √® memorizzato nel chunk successivo a quello sovraccaricato. Quindi, √® possibile modificare il comando eseguito sovrascribendolo con un exploit semplice come:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Altri esempi

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Utilizziamo una vulnerabilit√† di Integer Overflow per ottenere un Heap Overflow.
* Corrompiamo i puntatori a una funzione all'interno di una `struct` del blocco sovraccaricato per impostare una funzione come `system` ed ottenere l'esecuzione del codice.

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
{% endhint %}
