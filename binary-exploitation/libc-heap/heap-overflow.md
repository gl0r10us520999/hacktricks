# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Um heap overflow √© como um [**stack overflow**](../stack-overflow/) mas no heap. Basicamente, isso significa que algum espa√ßo foi reservado no heap para armazenar alguns dados e **os dados armazenados eram maiores do que o espa√ßo reservado.**

Em stack overflows, sabemos que alguns registradores, como o ponteiro de instru√ß√£o ou o quadro de pilha, ser√£o restaurados da pilha e pode ser poss√≠vel abusar disso. No caso de heap overflows, **n√£o h√° nenhuma informa√ß√£o sens√≠vel armazenada por padr√£o** no chunk do heap que pode ser transbordado. No entanto, pode haver informa√ß√µes sens√≠veis ou ponteiros, ent√£o a **criticidade** dessa vulnerabilidade **depende** de **quais dados podem ser sobrescritos** e como um atacante poderia abusar disso.

{% hint style="success" %}
Para encontrar offsets de overflow, voc√™ pode usar os mesmos padr√µes que em [**stack overflows**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

Em stack overflows, a disposi√ß√£o e os dados que estar√£o presentes na pilha no momento em que a vulnerabilidade pode ser acionada s√£o bastante confi√°veis. Isso ocorre porque a pilha √© linear, sempre aumentando em mem√≥ria colidida, em **lugares espec√≠ficos da execu√ß√£o do programa, a mem√≥ria da pilha geralmente armazena um tipo semelhante de dados** e tem uma estrutura espec√≠fica com alguns ponteiros no final da parte da pilha usada por cada fun√ß√£o.

No entanto, no caso de um heap overflow, a mem√≥ria usada n√£o √© linear, mas **chunks alocados geralmente est√£o em posi√ß√µes separadas da mem√≥ria** (n√£o um ao lado do outro) devido a **bins e zonas** que separam aloca√ß√µes por tamanho e porque **mem√≥ria previamente liberada √© usada** antes de alocar novos chunks. √â **complicado saber qual objeto estar√° colidindo com o vulner√°vel** a um heap overflow. Portanto, quando um heap overflow √© encontrado, √© necess√°rio encontrar uma **maneira confi√°vel de fazer o objeto desejado estar pr√≥ximo na mem√≥ria** do que pode ser transbordado.

Uma das t√©cnicas usadas para isso √© **Heap Grooming**, que √© usada, por exemplo, [**neste post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). No post, √© explicado como, quando no kernel do iOS, quando uma zona fica sem mem√≥ria para armazenar chunks de mem√≥ria, ela a expande por uma p√°gina do kernel, e essa p√°gina √© dividida em chunks dos tamanhos esperados que seriam usados em ordem (at√© a vers√£o 9.2 do iOS, depois esses chunks s√£o usados de maneira aleat√≥ria para dificultar a explora√ß√£o desses ataques).

Portanto, no post anterior onde um heap overflow est√° acontecendo, para for√ßar o objeto transbordado a colidir com uma ordem de v√≠tima, v√°rios **`kallocs` s√£o for√ßados por v√°rias threads para tentar garantir que todos os chunks livres sejam preenchidos e que uma nova p√°gina seja criada**.

Para for√ßar esse preenchimento com objetos de um tamanho espec√≠fico, a **aloca√ß√£o fora da linha associada a um mach port do iOS** √© um candidato ideal. Ao elaborar o tamanho da mensagem, √© poss√≠vel especificar exatamente o tamanho da aloca√ß√£o `kalloc` e, quando o mach port correspondente √© destru√≠do, a aloca√ß√£o correspondente ser√° imediatamente liberada de volta para `kfree`.

Ent√£o, alguns desses espa√ßos reservados podem ser **liberados**. A **lista livre `kalloc.4096` libera elementos em uma ordem de √∫ltimo a primeiro** (last-in-first-out), o que basicamente significa que se alguns espa√ßos reservados forem liberados e a explora√ß√£o tentar alocar v√°rios objetos de v√≠tima enquanto tenta alocar o objeto vulner√°vel ao overflow, √© prov√°vel que esse objeto seja seguido por um objeto de v√≠tima.

### Example libc

[**Nesta p√°gina**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) √© poss√≠vel encontrar uma emula√ß√£o b√°sica de Heap overflow que mostra como sobrescrever o bit prev in use do pr√≥ximo chunk e a posi√ß√£o do tamanho prev √© poss√≠vel **consolidar um chunk usado** (fazendo-o pensar que est√° n√£o utilizado) e **ent√£o aloc√°-lo novamente**, sendo capaz de sobrescrever dados que est√£o sendo usados em um ponteiro diferente tamb√©m.

Outro exemplo do [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) mostra um exemplo muito b√°sico de um CTF onde um **heap overflow** pode ser abusado para chamar a fun√ß√£o vencedora para **obter a bandeira**.

No exemplo do [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) √© poss√≠vel ver como abusar de um buffer overflow √© poss√≠vel **sobrescrever em um chunk pr√≥ximo um endere√ßo** onde **dados arbitr√°rios do usu√°rio** ser√£o escritos.

### Example ARM64

Na p√°gina [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) voc√™ pode encontrar um exemplo de heap overflow onde um comando que ser√° executado √© armazenado no seguinte chunk do chunk transbordado. Assim, √© poss√≠vel modificar o comando executado sobrescrevendo-o com uma explora√ß√£o f√°cil, como:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Outros exemplos

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Usamos uma vulnerabilidade de Integer Overflow para obter um Heap Overflow.
* Corrompemos ponteiros para uma fun√ß√£o dentro de um `struct` do chunk transbordado para definir uma fun√ß√£o como `system` e obter execu√ß√£o de c√≥digo.

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
