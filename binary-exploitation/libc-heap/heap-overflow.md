# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Μια υπερχείλιση σωρού είναι όπως μια [**υπερχείλιση στοίβας**](../stack-overflow/) αλλά στον σωρό. Βασικά σημαίνει ότι κάποιος χώρος είχε κρατηθεί στον σωρό για να αποθηκεύσει κάποια δεδομένα και **τα αποθηκευμένα δεδομένα ήταν μεγαλύτερα από τον κρατημένο χώρο.**

Στις υπερχείλισεις στοίβας γνωρίζουμε ότι μερικοί καταχωρητές όπως ο δείκτης εντολών ή το πλαίσιο στοίβας θα αποκατασταθούν από τη στοίβα και θα μπορούσε να είναι δυνατό να γίνει κατάχρηση αυτού. Στην περίπτωση των υπερχείλισεων σωρού, **δεν υπάρχει καμία ευαίσθητη πληροφορία αποθηκευμένη από προεπιλογή** στο κομμάτι του σωρού που μπορεί να υπερχυθεί. Ωστόσο, θα μπορούσε να είναι ευαίσθητη πληροφορία ή δείκτες, οπότε η **κριτική σημασία** αυτής της ευπάθειας **εξαρτάται** από **ποια δεδομένα θα μπορούσαν να αντικατασταθούν** και πώς ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί αυτό.

{% hint style="success" %}
Για να βρείτε τις υπερχείλισεις, μπορείτε να χρησιμοποιήσετε τα ίδια μοτίβα όπως στις [**υπερχείλισεις στοίβας**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

Στις υπερχείλισεις στοίβας η διάταξη και τα δεδομένα που θα είναι παρόντα στη στοίβα τη στιγμή που μπορεί να ενεργοποιηθεί η ευπάθεια είναι αρκετά αξιόπιστα. Αυτό συμβαίνει επειδή η στοίβα είναι γραμμική, πάντα αυξανόμενη σε συγκρουόμενη μνήμη, σε **συγκεκριμένες θέσεις της εκτέλεσης του προγράμματος η μνήμη στοίβας συνήθως αποθηκεύει παρόμοιο είδος δεδομένων** και έχει κάποια συγκεκριμένη δομή με κάποιους δείκτες στο τέλος του μέρους της στοίβας που χρησιμοποιείται από κάθε συνάρτηση.

Ωστόσο, στην περίπτωση μιας υπερχείλισης σωρού, η χρησιμοποιούμενη μνήμη δεν είναι γραμμική αλλά **οι κατανεμημένοι θρόισκοι είναι συνήθως σε ξεχωριστές θέσεις μνήμης** (όχι ο ένας δίπλα στον άλλο) λόγω των **δοχείων και ζωνών** που διαχωρίζουν τις κατανομές κατά μέγεθος και επειδή **η προηγούμενη ελεύθερη μνήμη χρησιμοποιείται** πριν από την κατανομή νέων θρόισκων. Είναι **περίπλοκο να γνωρίζουμε το αντικείμενο που θα συγκρούεται με αυτό που είναι ευάλωτο** σε μια υπερχείλιση σωρού. Έτσι, όταν βρεθεί μια υπερχείλιση σωρού, είναι απαραίτητο να βρεθεί ένας **αξιόπιστος τρόπος για να γίνει το επιθυμητό αντικείμενο το επόμενο στη μνήμη** από αυτό που μπορεί να υπερχυθεί.

Μία από τις τεχνικές που χρησιμοποιούνται για αυτό είναι το **Heap Grooming** το οποίο χρησιμοποιείται για παράδειγμα [**σε αυτήν την ανάρτηση**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Στην ανάρτηση εξηγείται πώς όταν στον πυρήνα iOS όταν μια ζώνη εξαντλείται από μνήμη για να αποθηκεύσει θρόισκους μνήμης, την επεκτείνει κατά μια σελίδα πυρήνα, και αυτή η σελίδα χωρίζεται σε θρόισκους των αναμενόμενων μεγεθών που θα χρησιμοποιηθούν με σειρά (μέχρι την έκδοση iOS 9.2, τότε αυτοί οι θρόισκοι χρησιμοποιούνται με τυχαίο τρόπο για να δυσκολέψουν την εκμετάλλευση αυτών των επιθέσεων).

Επομένως, στην προηγούμενη ανάρτηση όπου συμβαίνει μια υπερχείλιση σωρού, προκειμένου να αναγκαστεί το υπερχυθέν αντικείμενο να συγκρούεται με μια θυματική σειρά, αρκετές **`kallocs` αναγκάζονται από αρκετές νήματα για να προσπαθήσουν να διασφαλίσουν ότι όλοι οι ελεύθεροι θρόισκοι είναι γεμάτοι και ότι δημιουργείται μια νέα σελίδα**.

Για να αναγκαστεί αυτή η γέμιση με αντικείμενα συγκεκριμένου μεγέθους, η **εκτός γραμμής κατανομή που σχετίζεται με μια θύρα mach iOS** είναι ένας ιδανικός υποψήφιος. Δημιουργώντας το μέγεθος του μηνύματος, είναι δυνατό να καθοριστεί ακριβώς το μέγεθος της κατανομής `kalloc` και όταν η αντίστοιχη θύρα mach καταστραφεί, η αντίστοιχη κατανομή θα απελευθερωθεί αμέσως πίσω στο `kfree`.

Στη συνέχεια, μερικοί από αυτούς τους χώρους μπορεί να είναι **ελεύθεροι**. Η **λίστα ελεύθερων `kalloc.4096` απελευθερώνει στοιχεία με σειρά τελευταίου εισερχόμενου πρώτου εξερχόμενου**, που σημαίνει βασικά ότι αν μερικοί χώροι είναι ελεύθεροι και η εκμετάλλευση προσπαθεί να κατανεμήσει αρκετά θυματικά αντικείμενα ενώ προσπαθεί να κατανεμήσει το αντικείμενο που είναι ευάλωτο σε υπερχείλιση, είναι πιθανό ότι αυτό το αντικείμενο θα ακολουθηθεί από ένα θυματικό αντικείμενο.

### Example libc

[**Σε αυτή τη σελίδα**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) είναι δυνατό να βρείτε μια βασική προσομοίωση υπερχείλισης σωρού που δείχνει πώς η αντικατάσταση του προηγούμενου bit χρήσης του επόμενου θρόισκου και η θέση του προηγούμενου μεγέθους είναι δυνατό να **συγκεντρώσουν έναν χρησιμοποιούμενο θρόισκο** (κάνοντάς τον να νομίζει ότι είναι αχρησιμοποίητος) και **στη συνέχεια να τον κατανεμήσουν ξανά** έχοντας τη δυνατότητα να αντικαταστήσουν δεδομένα που χρησιμοποιούνται σε διαφορετικό δείκτη επίσης.

Ένα άλλο παράδειγμα από [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) δείχνει ένα πολύ βασικό παράδειγμα ενός CTF όπου μια **υπερχείλιση σωρού** μπορεί να εκμεταλλευτεί για να καλέσει τη συνάρτηση νικητή για να **πάρετε τη σημαία**.

Στο παράδειγμα [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) είναι δυνατό να δείτε πώς εκμεταλλευόμενοι μια υπερχείλιση buffer είναι δυνατό να **αντικαταστήσετε σε έναν κοντινό θρόισκο μια διεύθυνση** όπου **τυχαία δεδομένα από τον χρήστη** θα γραφούν.

### Example ARM64

Στη σελίδα [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) μπορείτε να βρείτε ένα παράδειγμα υπερχείλισης σωρού όπου μια εντολή που πρόκειται να εκτελεστεί αποθηκεύεται στο επόμενο θρόισκο από τον υπερχυθέντα θρόισκο. Έτσι, είναι δυνατό να τροποποιήσετε την εκτελούμενη εντολή αντικαθιστώντας την με μια εύκολη εκμετάλλευση όπως:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Άλλα παραδείγματα

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Χρησιμοποιούμε μια ευπάθεια Integer Overflow για να αποκτήσουμε Heap Overflow.
* Διαφθείρουμε δείκτες σε μια συνάρτηση μέσα σε μια `struct` του υπερχειλισμένου κομματιού για να ορίσουμε μια συνάρτηση όπως το `system` και να αποκτήσουμε εκτέλεση κώδικα.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
