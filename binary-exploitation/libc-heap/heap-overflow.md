# Heap Overflow

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **bizi** **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

## Temel Bilgiler

Heap overflow, [**stack overflow**](../stack-overflow/) gibi ama heap'te gerÃ§ekleÅŸir. Temelde, heap'te bazÄ± verileri saklamak iÃ§in yer ayrÄ±ldÄ±ÄŸÄ±nÄ± ve **saklanan verinin ayrÄ±lan alandan daha bÃ¼yÃ¼k olduÄŸunu** ifade eder.

Stack overflow'larda, talimat iÅŸaretÃ§isi veya stack Ã§erÃ§evesi gibi bazÄ± kayÄ±tlarÄ±n stack'ten geri yÃ¼kleneceÄŸini biliyoruz ve bunu kÃ¶tÃ¼ye kullanmak mÃ¼mkÃ¼n olabilir. Heap overflow'larda ise, **varsayÄ±lan olarak heap parÃ§asÄ±nda saklanan herhangi bir hassas bilgi yoktur**. Ancak, hassas bilgiler veya iÅŸaretÃ§iler olabilir, bu nedenle bu aÃ§Ä±ÄŸÄ±n **kritikliÄŸi** **hangi verilerin Ã¼zerine yazÄ±labileceÄŸine** ve bir saldÄ±rganÄ±n bunu nasÄ±l kÃ¶tÃ¼ye kullanabileceÄŸine **baÄŸlÄ±dÄ±r**.

{% hint style="success" %}
Overflow offsetlerini bulmak iÃ§in [**stack overflow'larda**](../stack-overflow/#finding-stack-overflows-offsets) kullanÄ±lan aynÄ± desenleri kullanabilirsiniz.
{% endhint %}

### Stack Overflow'lar vs Heap Overflow'lar

Stack overflow'larda, aÃ§Ä±ÄŸÄ±n tetiklenebileceÄŸi anda stack'te bulunacak dÃ¼zen ve veriler oldukÃ§a gÃ¼venilirdir. Bunun nedeni, stack'in lineer olmasÄ±, her zaman Ã§arpÄ±ÅŸan bellek iÃ§inde artmasÄ±, **programÄ±n Ã§alÄ±ÅŸmasÄ± sÄ±rasÄ±nda stack belleÄŸinin genellikle benzer tÃ¼rde verileri saklamasÄ±** ve her fonksiyon tarafÄ±ndan kullanÄ±lan stack bÃ¶lÃ¼mÃ¼nÃ¼n sonunda bazÄ± iÅŸaretÃ§ilerle belirli bir yapÄ±ya sahip olmasÄ±dÄ±r.

Ancak, heap overflow durumunda, kullanÄ±lan bellek lineer deÄŸildir, **ayrÄ±lan parÃ§alar genellikle bellek iÃ§inde ayrÄ± konumlarda** (birbirinin yanÄ±nda deÄŸil) bulunur Ã§Ã¼nkÃ¼ **boyutlarÄ±na gÃ¶re ayrÄ±lan alanlar ve bÃ¶lgeler** vardÄ±r ve **Ã¶nceki serbest bellek kullanÄ±lÄ±r** yeni parÃ§alar ayÄ±rmadan Ã¶nce. **Heap overflow'a maruz kalan nesne ile Ã§arpÄ±ÅŸacak nesneyi bilmek karmaÅŸÄ±ktÄ±r**. Bu nedenle, bir heap overflow bulunduÄŸunda, **istenen nesnenin bellek iÃ§inde overflow edilebilecek nesnenin yanÄ±na gelmesini saÄŸlamak iÃ§in gÃ¼venilir bir yol bulmak** gerekir.

Bunun iÃ§in kullanÄ±lan tekniklerden biri **Heap Grooming**'dir, Ã¶rneÄŸin [**bu yazÄ±da**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) aÃ§Ä±klanmaktadÄ±r. YazÄ±da, iOS Ã§ekirdeÄŸinde bir bÃ¶lge bellek parÃ§alarÄ±nÄ± saklamak iÃ§in bellek tÃ¼kendiÄŸinde, bir Ã§ekirdek sayfasÄ± ile geniÅŸletildiÄŸi ve bu sayfanÄ±n beklenen boyutlarda parÃ§alara bÃ¶lÃ¼ndÃ¼ÄŸÃ¼ aÃ§Ä±klanmaktadÄ±r (iOS sÃ¼rÃ¼m 9.2'ye kadar, ardÄ±ndan bu parÃ§alar bu saldÄ±rÄ±larÄ±n istismarÄ±nÄ± zorlaÅŸtÄ±rmak iÃ§in rastgele bir ÅŸekilde kullanÄ±lÄ±r).

Bu nedenle, Ã¶nceki yazÄ±da bir heap overflow gerÃ§ekleÅŸtiÄŸinde, overflow edilen nesneyi bir kurban nesnesi ile Ã§arpÄ±ÅŸacak ÅŸekilde zorlamak iÃ§in, birkaÃ§ **`kalloc`'un birkaÃ§ iÅŸ parÃ§acÄ±ÄŸÄ± tarafÄ±ndan zorlanmasÄ± gerekir** ki tÃ¼m serbest parÃ§alarÄ±n doldurulmasÄ± ve yeni bir sayfanÄ±n oluÅŸturulmasÄ± saÄŸlansÄ±n.

Belirli bir boyuttaki nesnelerle bu doldurmayÄ± zorlamak iÃ§in, **iOS mach portu ile iliÅŸkili dÄ±ÅŸarÄ±dan ayrÄ±lan bellek** ideal bir adaydÄ±r. MesajÄ±n boyutunu ayarlayarak, `kalloc` ayrÄ±mÄ±nÄ±n boyutunu tam olarak belirlemek mÃ¼mkÃ¼ndÃ¼r ve ilgili mach portu yok edildiÄŸinde, ilgili ayrÄ±m hemen `kfree`'ye geri verilecektir.

Sonra, bu yer tutuculardan bazÄ±larÄ± **serbest bÄ±rakÄ±labilir**. **`kalloc.4096` serbest listesi, son giren ilk Ã§Ä±kar sÄ±rasÄ±na gÃ¶re elemanlarÄ± serbest bÄ±rakÄ±r**, bu da temelde bazÄ± yer tutucular serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve istismar, overflow'a maruz kalan nesneyi ayarlamaya Ã§alÄ±ÅŸÄ±rken birkaÃ§ kurban nesnesi ayarlamaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda, bu nesnenin bir kurban nesnesi ile takip edilme olasÄ±lÄ±ÄŸÄ±nÄ±n yÃ¼ksek olduÄŸu anlamÄ±na gelir.

### Ã–rnek libc

[**Bu sayfada**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) bir heap overflow emÃ¼lasyonu bulmak mÃ¼mkÃ¼ndÃ¼r; bu emÃ¼lasyon, bir sonraki parÃ§anÄ±n prev in use bitini ve prev boyutunun konumunu Ã¼zerine yazarak **kullanÄ±lan bir parÃ§ayÄ± birleÅŸtirmenin** (kullanÄ±lmamÄ±ÅŸ gibi dÃ¼ÅŸÃ¼nmesini saÄŸlayarak) ve **sonra tekrar ayÄ±rmanÄ±n** nasÄ±l mÃ¼mkÃ¼n olduÄŸunu gÃ¶sterir; bÃ¶ylece farklÄ± bir iÅŸaretÃ§ide kullanÄ±lan verileri de Ã¼zerine yazma imkanÄ± saÄŸlar.

[**Protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) Ã¶rneÄŸi, bir **heap overflow**'un istismar edilebileceÄŸi Ã§ok temel bir CTF Ã¶rneÄŸini gÃ¶stermektedir; burada **bayraÄŸÄ± almak iÃ§in** kazanan fonksiyonu Ã§aÄŸÄ±rmak mÃ¼mkÃ¼ndÃ¼r.

[**Protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) Ã¶rneÄŸinde, bir buffer overflow istismar edilerek **yakÄ±n bir parÃ§aya bir adresin Ã¼zerine yazÄ±labileceÄŸi** gÃ¶sterilmektedir; burada **kullanÄ±cÄ±dan rastgele verilerin** yazÄ±lacaÄŸÄ± bir adres bulunmaktadÄ±r.

### Ã–rnek ARM64

[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) sayfasÄ±nda, yÃ¼rÃ¼tÃ¼lecek bir komutun overflow edilen parÃ§anÄ±n sonraki parÃ§asÄ±nda saklandÄ±ÄŸÄ± bir heap overflow Ã¶rneÄŸi bulabilirsiniz. BÃ¶ylece, yÃ¼rÃ¼tÃ¼len komutu, kolay bir istismar ile Ã¼zerine yazarak deÄŸiÅŸtirmek mÃ¼mkÃ¼ndÃ¼r:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### DiÄŸer Ã¶rnekler

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Bir Heap Overflow elde etmek iÃ§in bir Integer Overflow zafiyetini kullanÄ±yoruz.
* Bir `struct` iÃ§indeki bir iÅŸlevin iÅŸaretÃ§ilerini bozarak `system` gibi bir iÅŸlev ayarlayÄ±p kod yÃ¼rÃ¼tme elde ediyoruz.

{% hint style="success" %}
AWS Hacking Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
