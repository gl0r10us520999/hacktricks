# Heap Taşması

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

## Temel Bilgiler

Bir heap taşması, heap'te bir [**yığın taşması**](../stack-overflow/) gibi. Temelde, heap'te belirli bir veriyi depolamak için bir alan ayrılmış ve **depolanan veri ayrılan alandan daha büyük olmuş.**

Yığın taşmalarında, yığından bazı kayıtların (örneğin yönlendirme işaretçisi veya yığın çerçevesi) geri yükleneceğini ve bunun istismar edilebileceğini biliyoruz. Heap taşmalarında ise, taşınabilecek **varsayılan olarak hassas bilgi depolanan** bir heap parçası yok. Bununla birlikte, hassas bilgi veya işaretçiler olabilir, bu nedenle bu zafiyetin **kritikliği**, bu zafiyetin **hangi verilerin üzerine yazılabileceğine** ve bir saldırganın bunu nasıl istismar edebileceğine bağlıdır.

{% hint style="success" %}
Taşma ofsetlerini bulmak için [**yığın taşmalarında**](../stack-overflow/#finding-stack-overflows-offsets) olduğu gibi aynı desenleri kullanabilirsiniz.
{% endhint %}

### Yığın Taşmaları vs. Heap Taşmaları

Yığın taşmalarında, zafiyet tetiklendiğinde yığında bulunacak düzen ve veri oldukça güvenilirdir. Bu, yığının lineer olduğu, hafızanın çakışarak arttığı, programın belirli yerlerinde yığın belleğinin genellikle benzer türde verileri depoladığı ve her işlev tarafından kullanılan yığın kısmının sonunda bazı işaretçilerle belirli bir yapıya sahip olduğu için geçerlidir.

Ancak, bir heap taşması durumunda, kullanılan bellek lineer değil, **ayrılmış konumlarda genellikle ayrılmış parçalar** (yan yana değil) çünkü boyuta göre ayrımları ayıran **kutular ve bölgeler** ve **önceki serbest bırakılan bellek kullanılır**. Bir heap taşmasıyla çakışacak nesnenin hangisi olduğunu bilmek **karmaşıktır**. Bu nedenle, bir heap taşması bulunduğunda, istenen nesnenin bellekteki bir sonraki olmasını sağlamak için **güvenilir bir yol bulunması gerekir**.

Bunun için kullanılan tekniklerden biri **Heap Grooming**'dir ve örneğin [**bu yazıda**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) kullanılmaktadır. Yazıda, iOS çekirdeğinde bir bölge belleği, bellek parçalarını depolamak için bellekten tükendiğinde, bir çekirdek sayfası ile genişletilir ve bu sayfa beklenen boyuttaki parçalara bölünür (iOS sürüm 9.2'ye kadar, ardından bu parçaların bu saldırıların zorlaştırılması için rastgele bir şekilde kullanıldığı belirtilir).

Bu nedenle, bir heap taşması gerçekleştiğinde, taşan nesnenin çakışacak şekilde zorlanması için birkaç **`kalloc`'un** birkaç iş parçası tarafından zorlanması gerekmektedir ve tüm boş parçaların doldurulduğundan ve yeni bir sayfa oluşturulduğundan emin olunmalıdır.

Belirli bir boyuttaki nesnelerle bu doldurmayı zorlamak için, **iOS mach port ile ilişkilendirilmiş dış hattan tahsis** ideal bir adaydır. Mesajın boyutunu şekillendirerek, `kalloc` tahsisinin boyutunu tam olarak belirlemek mümkündür ve karşılık gelen mach portu yok edildiğinde, karşılık gelen tahsis hemen `kfree`'ye geri bırakılacaktır.

Ardından, bazı bu yer tutucular **serbest bırakılabilir**. **`kalloc.4096` serbest listesi elemanları son giren ilk çıkan düzeninde serbest bırakır**, bu da temelde bazı yer tutucuların serbest bırakıldığı ve saldırının taşma olabilecek nesneyi tahsis etmeye çalışırken birkaç kurban nesne tahsis etmeye çalıştığı durumda, bu nesnenin bir kurban nesne tarafından takip edileceği olasılığının yüksek olduğu anlamına gelir.

### Örnek libc

[**Bu sayfada**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) bir temel Heap taşması emülasyonu bulunabilir. Bir sonraki parçanın kullanılan önceki bitini ve önceki boyutun konumunu değiştirerek, **kullanılan bir parçayı birleştirmek** (kullanılmadığına inandırarak) ve ardından tekrar tahsis ederek farklı bir işaretçide kullanılan verileri üzerine yazmak mümkündür.

[**Protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) örneğinde, bir **heap taşmasının** bayrağı **almak için** kazan fonksiyonunu çağırmak için **kullanılabilecek** bir CTF'nin çok temel bir örneği gösterilmektedir.

[**Protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) örneğinde, bir tampon taşmasının **kullanıcıdan alınan keyfi verinin yazılacağı yakın bir parçada bir adresi üzerine yazmak** mümkün olduğu görülebilir.

### Örnek ARM64

[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) sayfasında, yığın taşması örneği bulunabilir, burada taşan parçadan sonraki parçada saklanacak bir komut bulunmaktadır. Bu nedenle, basit bir saldırı ile komutu değiştirerek yürütülecek komutu değiştirmek mümkündür.
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Diğer örnekler

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Bir Tamsayı Taşma zafiyetini kullanarak Bir Heap Taşması elde ediyoruz.
* Taşan parçanın içindeki bir `struct`'ın işaretçilerini bozarak bir işlevi, örneğin `system` işlevini ayarlıyoruz ve kod yürütme elde ediyoruz.

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* Hacking püf noktalarını paylaşarak PR'lar göndererek **HackTricks** ve **HackTricks Cloud** github depolarına katkıda bulunun.

</details>
{% endhint %}
