# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Heap overflow je kao [**stack overflow**](../stack-overflow/) ali u heap-u. U suštini, to znači da je neki prostor rezervisan u heap-u za skladištenje podataka i **skladišteni podaci su bili veći od rezervisanog prostora.**

U stack overflow-ima znamo da će neki registri kao što su pokazivač instrukcija ili stack frame biti vraćeni iz stack-a i to bi moglo biti moguće zloupotrebiti. U slučaju heap overflow-a, **nema osetljivih informacija koje se po default-u čuvaju** u heap chunk-u koji može biti preplavljen. Međutim, to mogu biti osetljive informacije ili pokazivači, tako da **kritičnost** ove ranjivosti **zavisi** od **koji podaci mogu biti prepisani** i kako bi napadač mogao to zloupotrebiti.

{% hint style="success" %}
Da biste pronašli offset-e prelivanja, možete koristiti iste obrasce kao u [**stack overflow-ima**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

U stack overflow-ima raspored i podaci koji će biti prisutni u stack-u u trenutku kada se ranjivost može aktivirati su prilično pouzdani. To je zato što je stack linearan, uvek se povećava u koliziji memorije, na **specifičnim mestima izvršavanja programa stack memorija obično čuva slične vrste podataka** i ima neku specifičnu strukturu sa nekim pokazivačima na kraju dela stack-a koji koristi svaka funkcija.

Međutim, u slučaju heap overflow-a, korišćena memorija nije linearna, već su **alokacije obično u odvojenim pozicijama memorije** (ne jedna pored druge) zbog **bins i zona** koje razdvajaju alokacije po veličini i zato što se **prethodno oslobođena memorija koristi** pre nego što se alociraju novi chunk-ovi. **Teško je znati objekat koji će kolidirati sa onim koji je ranjiv** na heap overflow. Dakle, kada se pronađe heap overflow, potrebno je pronaći **pouzdan način da se željeni objekat postavi pored u memoriji** onog koji može biti preplavljen.

Jedna od tehnika koja se koristi za ovo je **Heap Grooming** koja se koristi na primer [**u ovom postu**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). U postu se objašnjava kako kada u iOS kernel-u zona ostane bez memorije za skladištenje chunk-ova memorije, ona se širi za kernel stranicu, a ova stranica se deli na chunk-ove očekivanih veličina koji će se koristiti redom (do iOS verzije 9.2, zatim se ovi chunk-ovi koriste na randomizovan način kako bi se otežala eksploatacija ovih napada).

Stoga, u prethodnom postu gde se dešava heap overflow, kako bi se primorao preplavljeni objekat da kolidira sa objektom žrtve, nekoliko **`kallocs` se primorava od strane nekoliko niti kako bi se pokušalo osigurati da su svi slobodni chunk-ovi popunjeni i da je stvorena nova stranica**.

Da bi se primoralo ovo popunjavanje objektima specifične veličine, **out-of-line alokacija povezana sa iOS mach port-om** je idealan kandidat. Prilagođavanjem veličine poruke, moguće je tačno odrediti veličinu `kalloc` alokacije i kada se odgovarajući mach port uništi, odgovarajuća alokacija će odmah biti vraćena `kfree`.

Zatim, neki od ovih mesta mogu biti **oslobođeni**. **`kalloc.4096` slobodna lista oslobađa elemente u redosledu poslednji ulaz, prvi izlaz**, što u suštini znači da ako su neka mesta oslobođena i eksploatacija pokušava da alocira nekoliko objekata žrtava dok pokušava da alocira objekat ranjiv na prelivanje, verovatno je da će ovaj objekat biti praćen objektom žrtve.

### Example libc

[**Na ovoj stranici**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) moguće je pronaći osnovnu emulaciju Heap overflow-a koja pokazuje kako prepisivanje prev in use bita sledećeg chunk-a i pozicije prev veličine omogućava **konzolidaciju korišćenog chunk-a** (praveći ga da misli da je neiskorišćen) i **zatim ga ponovo alocirati** tako da može prepisati podatke koji se koriste u drugom pokazivaču.

Još jedan primer iz [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje vrlo osnovan primer CTF-a gde se **heap overflow** može zloupotrebiti da pozove funkciju pobednika da **dobije zastavicu**.

U [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) primeru moguće je videti kako zloupotreba prelivanja bafera može **prepisati u bliskom chunk-u adresu** gde će **arbitrarni podaci od korisnika** biti napisani.

### Example ARM64

Na stranici [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) možete pronaći primer heap overflow-a gde je komanda koja će biti izvršena smeštena u sledeći chunk od preplavljenog chunk-a. Tako, moguće je modifikovati izvršenu komandu prepisivanjem sa lakom eksploatacijom kao:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ostali primeri

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Koristimo ranjivost Integer Overflow da dobijemo Heap Overflow.
* Korumpiramo pokazivače na funkciju unutar `struct`-a prekomernog dela da postavimo funkciju kao što je `system` i dobijemo izvršenje koda.

{% hint style="success" %}
Učite i vežbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Učite i vežbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
