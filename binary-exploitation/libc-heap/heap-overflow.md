# Heap Oorvloei

{% hint style="success" %}
Leer & oefen AWS Hack: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## Basiese Inligting

'n Heap oorvloei is soos 'n [**stapel oorvloei**](../stack-overflow/) maar in die heap. Dit beteken basies dat 'n spasie in die heap gereserveer was om data te stoor en **die gestoorde data was groter as die gereserveerde spasie.**

In stapel oorvloeie weet ons dat sekere registers soos die instruksie-aanwyser of die stapelraam van die stapel herstel gaan word en dit moontlik is om dit te misbruik. In die geval van heap oorvloeie, is daar **nie enige sensitiewe inligting wat standaard in die heapstuk gestoor word nie** wat oorvloei kan word. Dit kan egter sensitiewe inligting of aanwysers wees, dus die **kritikaliteit** van hierdie kwesbaarheid **hang af** van **watter data oorskryf kan word** en hoe 'n aanvaller dit kan misbruik.

{% hint style="success" %}
Om oorvloei-offsette te vind, kan jy dieselfde patrone gebruik as in [**stapel oorvloeie**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stapel Oorvloeie vs Heap Oorvloeie

In stapel oorvloeie is die rangskikking en data wat teenwoordig gaan wees in die stapel op die oomblik wanneer die kwesbaarheid geaktiveer kan word, redelik betroubaar. Dit is omdat die stapel line√™r is, altyd toeneem in botsende geheue, in **spesifieke plekke van die program hardloop die stapelgeheue gewoonlik soortgelyke data** en dit het 'n spesifieke struktuur met 'n paar aanwysers aan die einde van die stapelgedeelte wat deur elke funksie gebruik word.

Tog, in die geval van 'n heap oorvloei, is die gebruikte geheue nie line√™r nie maar **toegewysde stukke is gewoonlik in afsonderlike posisies van geheue** (nie een langs die ander nie) as gevolg van **bins en sones** wat toewysings volgens grootte skei en omdat **vorige vrygemaakte geheue gebruik word** voordat nuwe stukke toegewys word. Dit is **ingewikkeld om die voorwerp te ken wat met die een wat vatbaar is vir 'n heap oorvloei gaan bots**. Dus, wanneer 'n heap oorvloei gevind word, moet 'n **betroubare manier gevind word om die gewenste voorwerp volgende in geheue te maak** van die een wat oorvloei kan word.

Een van die tegnieke wat hiervoor gebruik word, is **Heap Grooming** wat byvoorbeeld gebruik word [**in hierdie pos**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). In die pos word verduidelik hoe wanneer in die iOS-kernel 'n sone uit geheue raak om stukke geheue te stoor, dit uitgebrei word met 'n kernbladsy, en hierdie bladsy word verdeel in stukke van die verwagte groottes wat in orde gebruik sou word (tot iOS-weergawe 9.2, dan word hierdie stukke op 'n willekeurige manier gebruik om die uitbuiting van hierdie aanvalle te bemoeilik).

Daarom, in die vorige pos waar 'n heap oorvloei plaasvind, moet 'n paar **`kallocs` afgedwing word deur verskeie drade om te probeer verseker dat al die vry stukke gevul is en dat 'n nuwe bladsy geskep word**.

Om hierdie vulling met voorwerpe van 'n spesifieke grootte af te dwing, is die **buite lyntoewysing wat met 'n iOS mach-poort geassosieer word** 'n ideale kandidaat. Deur die grootte van die boodskap te skep, is dit moontlik om presies die grootte van `kalloc` toewysing te spesifiseer en wanneer die ooreenstemmende mach-poort vernietig word, sal die ooreenstemmende toewysing dadelik terug na `kfree` vrygestel word.

Dan kan sommige van hierdie plekhouers **vrygestel** word. Die **`kalloc.4096` vrylys vrygestel elemente in 'n laaste-in-eerste-uit-orde**, wat basies beteken dat as sommige plekhouers vrygestel word en die aanval probeer om verskeie slagoffersvoorwerpe toe te ken terwyl die voorwerp wat vatbaar is vir oorvloei toegewys word, is dit waarskynlik dat hierdie voorwerp deur 'n slagoffersvoorwerp gevolg sal word.

### Voorbeeld libc

[**Op hierdie bladsy**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) is dit moontlik om 'n basiese Heap oorvloei-emulasie te vind wat wys hoe om die vorig in gebruik bit van die volgende stuk en die posisie van die vorige grootte te oorskryf, dit is moontlik om 'n gebruikte stuk te **konsolideer** (deur dit te laat dink dit is ongebruik) en **dit dan weer toe te ken** en sodoende data te oorskryf wat in 'n ander aanwyser ook gebruik word.

'n Ander voorbeeld van [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) wys 'n baie basiese voorbeeld van 'n CTF waar 'n **heap oorvloei** misbruik kan word om die wennerfunksie te roep om die vlag te **kry**.

In die [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) voorbeeld is dit moontlik om te sien hoe 'n buffer oorvloei misbruik kan word om **in 'n naby stuk 'n adres oor te skryf** waar **willekeurige data van die gebruiker** geskryf gaan word.

### Voorbeeld ARM64

Op die bladsy [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) kan jy 'n voorbeeld van 'n heap oorvloei vind waar 'n bevel wat uitgevoer gaan word in die volgende stuk vanaf die oorvloeiende stuk gestoor word. Dus, dit is moontlik om die uitgevoerde bevel te wysig deur dit met 'n maklike uitbuiting soos oorskrywing te oorskryf.
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ander voorbeelde

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Ons gebruik 'n Integer Overflow kwesbaarheid om 'n Heap Overflow te kry.
* Ons beskadig aanwysers na 'n funksie binne 'n `struct` van die oorvloeiende blok om 'n funksie soos `system` in te stel en kode-uitvoering te kry.

{% hint style="success" %}
Leer & oefen AWS Hack: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}
