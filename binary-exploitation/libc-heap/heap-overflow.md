# Υπερχείλιση Σωρού

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Εκπαίδευση HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα χάκερ υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Βασικές Πληροφορίες

Η υπερχείλιση σωρού είναι σαν ένα [**χειρισμός υπερχείλισης στοίβας**](../stack-overflow/) αλλά στο σωρό. Βασικά σημαίνει ότι κάποιος χώρος είχε διατεθεί στο σωρό για να αποθηκεύσει κάποια δεδομένα και **τα αποθηκευμένα δεδομένα ήταν μεγαλύτερα από τον διατεθείσα χώρο.**

Στις υπερχειλίσεις στοίβας γνωρίζουμε ότι κάποιοι καταχωρητές όπως ο δείκτης εντολών ή το πλαίσιο στοίβας θα αποκατασταθούν από τη στοίβα και θα μπορούσε να είναι δυνατό να καταχραστεί αυτό. Στην περίπτωση των υπερχειλίσεων σωρού, **δεν υπάρχει καμία ευαίσθητη πληροφορία που αποθηκεύεται από προεπιλογή** στο κομμάτι του σωρού που μπορεί να υπερχειλιστεί. Ωστόσο, θα μπορούσε να είναι ευαίσθητες πληροφορίες ή δείκτες, οπότε η **κρισιμότητα** αυτής της ευπάθειας **εξαρτάται** από το **ποια δεδομένα μπορούν να αντικατασταθούν** και πώς μπορεί ένας επιτιθέμενος να καταχραστεί αυτό.

{% hint style="success" %}
Για να βρείτε τις μετατοπίσεις υπερχειλίσεων μπορείτε να χρησιμοποιήσετε τα ίδια πρότυπα όπως στις [**υπερχειλίσεις στοίβας**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Υπερχειλίσεις Στοίβας έναντι Υπερχειλίσεων Σωρού

Στις υπερχειλίσεις στοίβας η διάταξη και τα δεδομένα που θα υπάρχουν στη στοίβα τη στιγμή που μπορεί να ενεργοποιηθεί η ευπάθεια είναι αρκετά αξιόπιστα. Αυτό οφείλεται στο γεγονός ότι η στοίβα είναι γραμμική, αυξάνεται πάντα σε συγκρούουσα μνήμη, σε **συγκεκριμένα σημεία της εκτέλεσης του προγράμματος η μνήμη στοίβας αποθηκεύει συνήθως παρόμοιου είδους δεδομένα** και έχει κάποια συγκεκριμένη δομή με ορισμένους δείκτες στο τέλος του τμήματος στοίβας που χρησιμοποιείται από κάθε συνάρτηση.

Ωστόσο, στην περίπτωση μιας υπερχείλισης σωρού, η χρησιμοποιούμενη μνήμη δεν είναι γραμμική αλλά **οι εκχωρημένες χούνκς είναι συνήθως σε ξεχωρισμένες θέσεις μνήμης** (όχι μία δίπλα στην άλλη) λόγω των **κάδων και ζωνών** που χωρίζουν τις εκχωρήσεις ανά μέγεθος και επειδή **η προηγούμενη ελευθέρωση μνήμης χρησιμοποιείται** πριν από την εκχώρηση νέων χούνκς. Είναι **δύσκολο να γνωρίζουμε το αντικείμενο που θα συγκρουστεί με το ευάλωτο αντικείμενο** σε μια υπερχείλιση σωρού. Έτσι, όταν βρεθεί μια υπερχείλιση σωρού, είναι απαραίτητο να βρεθεί ένας **αξιόπιστος τρόπος για να το επιθυμητό αντικείμενο να είναι το επόμενο στη μνήμη** από αυτό που μπορεί να υπερχειλιστεί.

Ένας από τους τεχνικές που χρησιμοποιούνται γι' αυτό είναι η **Διαμόρφωση Σωρού** που χρησιμοποιείται για παράδειγμα [**σε αυτή την ανάρτηση**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Στην ανάρτηση εξηγείται πώς όταν στο πυρήνα iOS ένας κάδος εξαντλεί τη μνήμη για να αποθηκεύσει χούνκς μνήμης, το διευρύνει με μια σελίδα πυρήνα, και αυτή η σελίδα διαιρείται σε χούνκς των αναμενόμενων μεγεθών που θα χρησιμοποιηθούν με τη σειρά (μέχρι την έκδοση iOS 9.2, τότε αυτά τα κομμάτια χρησιμοποιούνται με τυχαίο τρόπο για να δυσκολέψει η εκμετάλλευση αυτών των επιθέσεων).

Συνεπώς, στην προηγούμενη ανάρτηση όπου συμβαίνει μια υπερχείλιση σωρού, για να αναγκαστεί το υπερχειλισμένο αντικείμενο να συγκρουστεί με ένα αντικείμενο θύμα, αρκετά **`kallocs` είναι αναγκασμένα από αρκετά νήματα για να εξασφαλίσουν ότι όλα τα ελεύθερα κομμάτια είναι γεμάτα και ότι δημιουργείται μια νέα σελίδα**.

Για να αναγκαστεί αυτή η γέμιση με αντικείμενα συγκεκριμένου μεγέθους, η **εκτός-γραμμής εκχώρηση που συσχετίζεται με ένα iOS mach port** είναι ένας ιδανικός υποψήφιος. Με τον σχεδιασμό του μεγέθους του μηνύματος, είναι δυνατό να καθοριστεί ακριβώς το μέγεθος της εκχώρησης `kalloc` και όταν το αντίστοιχο mach port καταστραφεί, η αντίστοιχη εκχώρηση θα απελευθερωθεί αμέσως πίσω στο `kfree`.

Στη συνέχεια, μερικά από αυτά τα σημεία αντικείμενων μπορούν να **απελευθερωθούν**. Η λίστα ελεύθερωσης **`kalloc.4096` απελευθερώνει στοιχεία με τη σειρά τελευταίο-πρώτο, που βασικά σημαίνει ότι αν κάποια σημεία απελευθερωθούν και η εκμετάλλευση προσπαθήσει να εκχωρήσει αρκετά αντικείμενα θύματα ενώ προσπαθεί να εκχωρήσει το ευάλωτο αντικείμενο υπερχείλισης, είναι πιθανό ότι αυτό το αντικείμενο θα ακολουθηθεί από ένα αντικείμενο θύμα.

### Παράδειγμα libc

[**Σε αυτή τη σελίδα**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) είναι δυνατό να βρεθεί μια βασική προσομοίωση υπερχείλισης σωρού που δείχνει πώς με τον υπεργραφέα του
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Άλλα παραδείγματα

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Χρησιμοποιούμε μια ευπάθεια Υπερχείλισης Ακεραίων για να πάρουμε μια Υπερχείλιση Σωρού.
* Χαλάμε δείκτες προς μια συνάρτηση μέσα σε ένα `struct` του κομματιού που έχει υπερχειλιστεί για να ορίσουμε μια συνάρτηση όπως το `system` και να πάρουμε εκτέλεση κώδικα.
