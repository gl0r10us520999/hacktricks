# Kujaa kwa Heap

{% hint style="success" %}
Jifunze na zoezi la AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze na zoezi la GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa michango**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Taarifa Msingi

Kujaa kwa heap ni kama [**kujaa kwa steki**](../stack-overflow/) lakini kwenye heap. Kimsingi inamaanisha kuwa nafasi fulani ilireserviwa kwenye heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyoreserviwa.**

Kwenye kujaa kwa steki tunajua kwamba baadhi ya rejista kama kipima maelekezo au fremu ya steki itarejeshwa kutoka kwenye steki na inaweza kuwa inawezekana kuitumia vibaya hii. Kwenye kujaa kwa heap, **hakuna taarifa nyeti iliyohifadhiwa kwa chaguo-msingi** kwenye kipande cha heap kinachoweza kujaa. Hata hivyo, inaweza kuwa taarifa nyeti au pointa, hivyo **umuhimu** wa udhaifu huu **unategemea** ni **data gani inaweza kubadilishwa** na jinsi mshambuliaji anaweza kutumia hii.

{% hint style="success" %}
Ili kupata violezo vya kujaa unaweza kutumia violezo sawa na kwenye [**kujaa kwa steki**](../stack-overflow/#kupata-violezo-vya-kujaa-kwa-steki).
{% endhint %}

### Kujaa kwa Steki vs Kujaa kwa Heap

Kwenye kujaa kwa steki, upangaji na data ambayo itakuwepo kwenye steki wakati udhaifu unaweza kuzinduliwa ni wa kuaminika kwa kiasi kikubwa. Hii ni kwa sababu steki ni mwendelezo, daima inaongezeka kwenye kumbukumbu inayogongana, kwenye **maeneo maalum ya kukimbia kwa programu kumbukumbu ya steki kawaida inahifadhi aina sawa ya data** na ina muundo maalum na pointa fulani mwishoni mwa sehemu ya steki inayotumiwa na kila kazi.

Hata hivyo, kwenye kujaa kwa heap, kumbukumbu inayotumiwa sio mwendelezo lakini **vipande vilivyotengwa kawaida viko kwenye nafasi tofauti za kumbukumbu** (sio moja karibu na nyingine) kwa sababu ya **makorongo na maeneo** yanayotenganisha alokesheni kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa awali inatumika** kabla ya kutenga vipande vipya. Ni **ngumu kujua kitu ambacho kitagongana na kile kilichovunjika** kwa kujaa kwa heap. Kwa hivyo, unapopata kujaa kwa heap, ni muhimu kupata njia **ya kuaminika ya kufanya kitu kilichotaka kiwe kifuatacho kwenye kumbukumbu** kutoka kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Kupamba kwa Heap** ambayo hutumiwa kwa mfano [**kwenye chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Kwenye chapisho inaelezea jinsi wakati wa kernel wa iOS unapokosa kumbukumbu ya kuhifadhi vipande vya kumbukumbu, inapanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika vipande vya ukubwa uliotarajiwa ambavyo vitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha vipande hivi vinatumika kwa njia iliyochanganywa ili kufanya ugumu wa kutekeleza mashambulizi haya).

Kwa hivyo, kwenye chapisho lililopita ambapo kujaa kwa heap linatokea, ili kulazimisha kitu kilichovunjika kugongana na mpangilio wa mwathiriwa, **`kallocs` kadhaa zinalazimishwa na nyuzi kadhaa kujaribu kuhakikisha kuwa vipande vyote vilivyotolewa vimejazwa na ukurasa mpya unatengenezwa**.

Ili kulazimisha kujazwa huku na vitu vya ukubwa maalum, **mgawanyo wa nje unaohusishwa na mlango wa iOS mach** ni mgombea bora. Kwa kutengeneza ukubwa wa ujumbe, inawezekana kubainisha kwa usahihi ukubwa wa alokesheni ya `kalloc` na wakati mlango wa mach unaohusika unaharibiwa, alokesheni inayohusiana itaachiliwa mara moja kurudi kwa `kfree`.

Kisha, baadhi ya hizi nafasi zinaweza **kuachiliwa**. **Orodha ya kufunguliwa ya `kalloc.4096` inaachilia vipengele kwa mpangilio wa mwisho kuingia kwanza**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya nafasi zimeachiliwa na shambulizi linajaribu kutoa vitu vingi waathiriwa wakati ikijaribu kutenga kitu kilichovunjika, ni uwezekano kwamba kitu hiki kitafuatwa na kitu waathiriwa.

### Mfano wa libc

[**Kwenye ukurasa huu**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) inawezekana kupata uigizaji wa kujaa kwa heap wa msingi unaonyesha jinsi ya kubadilisha biti ya awali inayotumiwa ya kipande kinachofuata na nafasi ya ukubwa wa awali inawezekana **kuunganisha kipande kilichotumiwa** (kwa kufanya ionekane kama haijatumika) na **kisha kutenga tena** ikiwa inawezekana kubadilisha data inayotumiwa kwenye pointa tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) unaonyesha mfano wa msingi sana wa CTF ambapo **kujaa kwa heap** inaweza kutumiwa kuita kazi ya mshindi kupata **bendera**.

Kwenye [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) mfano inawezekana kuona jinsi ya kutumia kujaa kwa buffer inawezekana **kubadilisha kwenye kipande karibu anwani** ambapo **data ya kupindukia kutoka kwa mtumiaji** itaandikwa.

### Mfano wa ARM64

Kwenye ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa kujaa kwa heap ambapo amri itakayotekelezwa imehifadhiwa kwenye kipande kinachofuata kutoka kwa kipande kilichojaa. Kwa hivyo, inawezekana kubadilisha amri itakayotekelezwa kwa kuiandika upya kwa shambulizi rahisi kama vile:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano mingine

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Tunatumia udhaifu wa Kuzidisha Nambari ya Integer kupata Kujaa kwa Heap.
* Tunaharibu pointa kwa kazi ndani ya `struct` ya kipande kilichojaa ili kuweka kazi kama vile `system` na kupata utekelezaji wa nambari.

{% hint style="success" %}
Jifunze & zoezi la AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & zoezi la GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa michango**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
