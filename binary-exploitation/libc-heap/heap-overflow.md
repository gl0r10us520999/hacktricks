# Heap Overflow

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **bizi** **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* Hacking ipuçlarını paylaşmak için [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## Temel Bilgiler

Heap overflow, [**stack overflow**](../stack-overflow/) gibi ama heap'te gerçekleşir. Temelde, heap'te bazı verileri saklamak için yer ayrıldığını ve **saklanan verinin ayrılan alandan daha büyük olduğunu** ifade eder.

Stack overflow'larda, talimat işaretçisi veya stack çerçevesi gibi bazı kayıtların stack'ten geri yükleneceğini biliyoruz ve bunu kötüye kullanmak mümkün olabilir. Heap overflow'larda ise, **varsayılan olarak heap parçasında saklanan herhangi bir hassas bilgi yoktur**. Ancak, hassas bilgiler veya işaretçiler olabilir, bu nedenle bu açığın **kritikliği** **hangi verilerin üzerine yazılabileceğine** ve bir saldırganın bunu nasıl kötüye kullanabileceğine **bağlıdır**.

{% hint style="success" %}
Overflow offsetlerini bulmak için [**stack overflow'larda**](../stack-overflow/#finding-stack-overflows-offsets) kullanılan aynı desenleri kullanabilirsiniz.
{% endhint %}

### Stack Overflow'lar vs Heap Overflow'lar

Stack overflow'larda, açığın tetiklenebileceği anda stack'te bulunacak düzen ve veriler oldukça güvenilirdir. Bunun nedeni, stack'in lineer olması, her zaman çarpışan bellek içinde artması, **programın çalışması sırasında stack belleğinin genellikle benzer türde verileri saklaması** ve her fonksiyon tarafından kullanılan stack bölümünün sonunda bazı işaretçilerle belirli bir yapıya sahip olmasıdır.

Ancak, heap overflow durumunda, kullanılan bellek lineer değildir, **ayrılan parçalar genellikle bellek içinde ayrı konumlarda** (birbirinin yanında değil) bulunur çünkü **boyutlarına göre ayrılan alanlar ve bölgeler** vardır ve **önceki serbest bellek kullanılır** yeni parçalar ayırmadan önce. **Heap overflow'a maruz kalan nesne ile çarpışacak nesneyi bilmek karmaşıktır**. Bu nedenle, bir heap overflow bulunduğunda, **istenen nesnenin bellek içinde overflow edilebilecek nesnenin yanına gelmesini sağlamak için güvenilir bir yol bulmak** gerekir.

Bunun için kullanılan tekniklerden biri **Heap Grooming**'dir, örneğin [**bu yazıda**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) açıklanmaktadır. Yazıda, iOS çekirdeğinde bir bölge bellek parçalarını saklamak için bellek tükendiğinde, bir çekirdek sayfası ile genişletildiği ve bu sayfanın beklenen boyutlarda parçalara bölündüğü açıklanmaktadır (iOS sürüm 9.2'ye kadar, ardından bu parçalar bu saldırıların istismarını zorlaştırmak için rastgele bir şekilde kullanılır).

Bu nedenle, önceki yazıda bir heap overflow gerçekleştiğinde, overflow edilen nesneyi bir kurban nesnesi ile çarpışacak şekilde zorlamak için, birkaç **`kalloc`'un birkaç iş parçacığı tarafından zorlanması gerekir** ki tüm serbest parçaların doldurulması ve yeni bir sayfanın oluşturulması sağlansın.

Belirli bir boyuttaki nesnelerle bu doldurmayı zorlamak için, **iOS mach portu ile ilişkili dışarıdan ayrılan bellek** ideal bir adaydır. Mesajın boyutunu ayarlayarak, `kalloc` ayrımının boyutunu tam olarak belirlemek mümkündür ve ilgili mach portu yok edildiğinde, ilgili ayrım hemen `kfree`'ye geri verilecektir.

Sonra, bu yer tutuculardan bazıları **serbest bırakılabilir**. **`kalloc.4096` serbest listesi, son giren ilk çıkar sırasına göre elemanları serbest bırakır**, bu da temelde bazı yer tutucular serbest bırakıldığında ve istismar, overflow'a maruz kalan nesneyi ayarlamaya çalışırken birkaç kurban nesnesi ayarlamaya çalıştığında, bu nesnenin bir kurban nesnesi ile takip edilme olasılığının yüksek olduğu anlamına gelir.

### Örnek libc

[**Bu sayfada**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) bir heap overflow emülasyonu bulmak mümkündür; bu emülasyon, bir sonraki parçanın prev in use bitini ve prev boyutunun konumunu üzerine yazarak **kullanılan bir parçayı birleştirmenin** (kullanılmamış gibi düşünmesini sağlayarak) ve **sonra tekrar ayırmanın** nasıl mümkün olduğunu gösterir; böylece farklı bir işaretçide kullanılan verileri de üzerine yazma imkanı sağlar.

[**Protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) örneği, bir **heap overflow**'un istismar edilebileceği çok temel bir CTF örneğini göstermektedir; burada **bayrağı almak için** kazanan fonksiyonu çağırmak mümkündür.

[**Protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) örneğinde, bir buffer overflow istismar edilerek **yakın bir parçaya bir adresin üzerine yazılabileceği** gösterilmektedir; burada **kullanıcıdan rastgele verilerin** yazılacağı bir adres bulunmaktadır.

### Örnek ARM64

[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) sayfasında, yürütülecek bir komutun overflow edilen parçanın sonraki parçasında saklandığı bir heap overflow örneği bulabilirsiniz. Böylece, yürütülen komutu, kolay bir istismar ile üzerine yazarak değiştirmek mümkündür:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Diğer örnekler

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Bir Heap Overflow elde etmek için bir Integer Overflow zafiyetini kullanıyoruz.
* Bir `struct` içindeki bir işlevin işaretçilerini bozarak `system` gibi bir işlev ayarlayıp kod yürütme elde ediyoruz.

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
