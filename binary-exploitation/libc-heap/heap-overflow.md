# Prekoračenje hipa

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne informacije

Prekoračenje hipa je poput [**prekoračenja steka**](../stack-overflow/), ali u hipu. U osnovi to znači da je neki prostor rezervisan u hipu za čuvanje podataka i **čuvani podaci su bili veći od rezervisanog prostora.**

Kod prekoračenja steka znamo da će neki registri poput pokazivača instrukcija ili okvira steka biti obnovljeni sa steka i moguće je zloupotrebiti to. U slučaju prekoračenja hipa, **nema podataka osetljivih po podrazumevanim postavkama** u hipu koji može biti prekoračen. Međutim, mogu biti osetljivi podaci ili pokazivači, pa **kritičnost** ove ranjivosti **zavisi** o **kojim podacima mogu biti prepisani** i kako napadač može to zloupotrebiti.

{% hint style="success" %}
Da biste pronašli prekoračenja ofseta, možete koristiti iste obrasce kao kod [**prekoračenja steka**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Prekoračenje steka vs prekoračenje hipa

Kod prekoračenja steka, organizacija i podaci koji će biti prisutni na steku u trenutku kada se može aktivirati ranjivost su prilično pouzdani. To je zato što je stek linearan, uvek se povećava u koliziji memorije, na **specifičnim mestima izvršavanja programa stek memorija obično čuva slične vrste podataka** i ima određenu strukturu sa nekim pokazivačima na kraju dela steka koji koristi svaka funkcija.

Međutim, u slučaju prekoračenja hipa, korišćena memorija nije linearna već **dodeljeni blokovi obično su na odvojenim pozicijama memorije** (ne jedan pored drugog) zbog **kanti i zona** koje razdvajaju alokacije po veličini i zbog toga što se **prethodno oslobođena memorija koristi** pre nego što se dodele novi blokovi. **Komplikovano je znati koji objekat će se sudariti sa onim koji je ranjiv** na prekoračenje hipa. Dakle, kada se pronađe prekoračenje hipa, potrebno je pronaći **pouzdan način da se željeni objekat nađe odmah u memoriji** pored onog koji može biti prekoračen.

Jedna od tehnika korišćenih za to je **Gajenje hipa** koje se koristi na primer [**u ovom postu**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). U postu je objašnjeno kako kada u iOS kernelu jedna zona ostane bez memorije za čuvanje blokova memorije, proširuje se za jednu stranicu kernela, a ova stranica se deli na blokove očekivanih veličina koji će se koristiti redom (do verzije iOS 9.2, zatim se ovi blokovi koriste na nasumičan način kako bi se otežala eksploatacija ovih napada).

Stoga, u prethodnom postu gde se dešava prekoračenje hipa, kako bi se naterao prekoračeni objekat da se sudari sa žrtvom, nekoliko **`kallocs` se forsira pomoću nekoliko niti kako bi se osiguralo da su svi slobodni blokovi popunjeni i da je kreirana nova stranica**.

Da bi se prisililo ovo popunjavanje objektima određene veličine, **alokacija van linije povezana sa iOS mach portom** je idealan kandidat. Oblikovanjem veličine poruke, moguće je tačno odrediti veličinu alokacije `kalloc` i kada odgovarajući mach port bude uništen, odgovarajuća alokacija će odmah biti oslobođena natrag `kfree`.

Zatim, neki od ovih čuvara mogu biti **oslobođeni**. Lista oslobođenih **`kalloc.4096`** elemenata oslobađa elemente po principu poslednji unutra-prvi napolje, što u osnovi znači da ako su neki čuvari oslobođeni i eksploit pokuša da alocira nekoliko žrtvenih objekata dok pokušava da alocira objekat ranjiv na prekoračenje, verovatno je da će ovaj objekat biti praćen žrtvenim objektom.

### Primer libc-a

[**Na ovoj stranici**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) moguće je pronaći osnovnu emulaciju prekoračenja hipa koja pokazuje kako prekoračenjem prethodnog bita u upotrebi sledećeg bloka i pozicije prethodne veličine moguće je **konsolidovati korišćeni blok** (praveći da misli da nije u upotrebi) i **zatim ga ponovo alocirati** kako bi se mogli prepisati podaci koji se koriste u drugom pokazivaču.

Još jedan primer iz [**protostar hipa 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje vrlo osnovan primer CTF-a gde se **prekoračenje hipa** može zloupotrebiti kako bi se pozvala funkcija pobednika i **dobio zastava**.

U [**protostar hipu 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) primeru moguće je videti kako zloupotrebom prekoračenja bafera moguće je **prepisati u blizak blok adresu** gde će **proizvoljni podaci od korisnika** biti upisani.

### Primer ARM64

Na stranici [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) možete pronaći primer prekoračenja hipa gde je komanda koja će biti izvršena smeštena u sledećem bloku od prekoračenog bloka. Dakle, moguće je izmeniti izvršenu komandu prepisivanjem je jednostavnim eksploatacijama kao što su:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ostali primeri

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Koristimo ranjivost prelivanja celobrojne vrednosti da bismo dobili prelivanje hipa.
* Korumpiramo pokazivače ka funkciji unutar `struct`-a prelivenog bloka da bismo postavili funkciju poput `system` i dobili izvršenje koda.

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
