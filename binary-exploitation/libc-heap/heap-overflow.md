# Heap Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Heap overflow je kao [**stack overflow**](../stack-overflow/) ali u heap-u. U su코tini, to zna캜i da je neki prostor rezervisan u heap-u za skladi코tenje podataka i **skladi코teni podaci su bili ve캖i od rezervisanog prostora.**

U stack overflow-ima znamo da 캖e neki registri kao 코to su pokaziva캜 instrukcija ili stack frame biti vra캖eni iz stack-a i to bi moglo biti mogu캖e zloupotrebiti. U slu캜aju heap overflow-a, **nema osetljivih informacija koje se po default-u 캜uvaju** u heap chunk-u koji mo쬰 biti preplavljen. Me캠utim, to mogu biti osetljive informacije ili pokaziva캜i, tako da **kriti캜nost** ove ranjivosti **zavisi** od **koji podaci mogu biti prepisani** i kako bi napada캜 mogao to zloupotrebiti.

{% hint style="success" %}
Da biste prona코li offset-e prelivanja, mo쬰te koristiti iste obrasce kao u [**stack overflow-ima**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

U stack overflow-ima raspored i podaci koji 캖e biti prisutni u stack-u u trenutku kada se ranjivost mo쬰 aktivirati su prili캜no pouzdani. To je zato 코to je stack linearan, uvek se pove캖ava u koliziji memorije, na **specifi캜nim mestima izvr코avanja programa stack memorija obi캜no 캜uva sli캜ne vrste podataka** i ima neku specifi캜nu strukturu sa nekim pokaziva캜ima na kraju dela stack-a koji koristi svaka funkcija.

Me캠utim, u slu캜aju heap overflow-a, kori코캖ena memorija nije linearna, ve캖 su **alokacije obi캜no u odvojenim pozicijama memorije** (ne jedna pored druge) zbog **bins i zona** koje razdvajaju alokacije po veli캜ini i zato 코to se **prethodno oslobo캠ena memorija koristi** pre nego 코to se alociraju novi chunk-ovi. **Te코ko je znati objekat koji 캖e kolidirati sa onim koji je ranjiv** na heap overflow. Dakle, kada se prona캠e heap overflow, potrebno je prona캖i **pouzdan na캜in da se 쬰ljeni objekat postavi pored u memoriji** onog koji mo쬰 biti preplavljen.

Jedna od tehnika koja se koristi za ovo je **Heap Grooming** koja se koristi na primer [**u ovom postu**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). U postu se obja코njava kako kada u iOS kernel-u zona ostane bez memorije za skladi코tenje chunk-ova memorije, ona se 코iri za kernel stranicu, a ova stranica se deli na chunk-ove o캜ekivanih veli캜ina koji 캖e se koristiti redom (do iOS verzije 9.2, zatim se ovi chunk-ovi koriste na randomizovan na캜in kako bi se ote쬬la eksploatacija ovih napada).

Stoga, u prethodnom postu gde se de코ava heap overflow, kako bi se primorao preplavljeni objekat da kolidira sa objektom rtve, nekoliko **`kallocs` se primorava od strane nekoliko niti kako bi se poku코alo osigurati da su svi slobodni chunk-ovi popunjeni i da je stvorena nova stranica**.

Da bi se primoralo ovo popunjavanje objektima specifi캜ne veli캜ine, **out-of-line alokacija povezana sa iOS mach port-om** je idealan kandidat. Prilago캠avanjem veli캜ine poruke, mogu캖e je ta캜no odrediti veli캜inu `kalloc` alokacije i kada se odgovaraju캖i mach port uni코ti, odgovaraju캖a alokacija 캖e odmah biti vra캖ena `kfree`.

Zatim, neki od ovih mesta mogu biti **oslobo캠eni**. **`kalloc.4096` slobodna lista osloba캠a elemente u redosledu poslednji ulaz, prvi izlaz**, 코to u su코tini zna캜i da ako su neka mesta oslobo캠ena i eksploatacija poku코ava da alocira nekoliko objekata rtava dok poku코ava da alocira objekat ranjiv na prelivanje, verovatno je da 캖e ovaj objekat biti pra캖en objektom rtve.

### Example libc

[**Na ovoj stranici**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) mogu캖e je prona캖i osnovnu emulaciju Heap overflow-a koja pokazuje kako prepisivanje prev in use bita slede캖eg chunk-a i pozicije prev veli캜ine omogu캖ava **konzolidaciju kori코캖enog chunk-a** (prave캖i ga da misli da je neiskori코캖en) i **zatim ga ponovo alocirati** tako da mo쬰 prepisati podatke koji se koriste u drugom pokaziva캜u.

Jo코 jedan primer iz [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje vrlo osnovan primer CTF-a gde se **heap overflow** mo쬰 zloupotrebiti da pozove funkciju pobednika da **dobije zastavicu**.

U [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) primeru mogu캖e je videti kako zloupotreba prelivanja bafera mo쬰 **prepisati u bliskom chunk-u adresu** gde 캖e **arbitrarni podaci od korisnika** biti napisani.

### Example ARM64

Na stranici [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) mo쬰te prona캖i primer heap overflow-a gde je komanda koja 캖e biti izvr코ena sme코tena u slede캖i chunk od preplavljenog chunk-a. Tako, mogu캖e je modifikovati izvr코enu komandu prepisivanjem sa lakom eksploatacijom kao:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ostali primeri

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Koristimo ranjivost Integer Overflow da dobijemo Heap Overflow.
* Korumpiramo pokaziva캜e na funkciju unutar `struct`-a prekomernog dela da postavimo funkciju kao 코to je `system` i dobijemo izvr코enje koda.

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
