# House of Orange

{% hint style="success" %}
AWSハッキングの学習と練習:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、ハッキングトリックを共有してください。

</details>
{% endhint %}

## 基本情報

### コード

* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)に例があります
* この[パッチ](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0)でこの悪用技術が修正されました（2.26より前で動作）
* より多くのコメントがついた同じ例は[こちら](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)にあります

### ゴール

* `malloc_printerr` 関数を悪用する

### 必要条件

* トップチャンクのサイズを上書きする
* Libcとヒープのリーク

### 背景

[**この例**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)のコメントから必要な背景情報があります：

古いバージョンのlibcでは、`malloc_printerr` 関数が呼び出されると、`_IO_list_all` に格納されている `_IO_FILE` 構造体のリストをイテレートし、その構造体内の命令ポインタを実際に実行していました。\
この攻撃では、`_IO_list_all` に書き込む**偽の `_IO_FILE` 構造体**を作成し、`malloc_printerr` を実行させます。\
その後、`_IO_FILE` 構造体のジャンプテーブルに格納されているアドレスを実行し、コード実行を行います。

### 攻撃

攻撃は、**アンソートされたビン**内の**トップチャンク**を取得することから始まります。これは、`malloc` を呼び出して、現在のトップチャンクのサイズよりも大きく、**`mmp_.mmap_threshold`**（デフォルトは128K）より小さいサイズで呼び出すことで達成されます。トップチャンクのサイズが変更されるときは、**トップチャンク + サイズ**がページアラインされており、かつトップチャンクの **prev\_inuse** ビットが常に設定されていることが重要です。

アンソートされたビン内にトップチャンクを取得するために、トップチャンクを作成するためにチャンクを割り当て、トップチャンクのサイズを変更します（割り当てられたチャンク内でオーバーフローが発生する）。その後、新しいトップチャンクのサイズよりも大きなチャンクを割り当てます。トップチャンクをアンソートされたビンに入れるために `free` は呼び出されません。

古いトップチャンクは今やアンソートされたビンにあります。それを読み取ることができる場合（オーバーフローを引き起こす脆弱性による可能性があります）、そこからlibcのアドレスをリークし、**\_IO\_list\_all** のアドレスを取得できます。

アンソートされたビン攻撃は、オーバーフローを悪用して `topChunk->bk->fwd = _IO_list_all - 0x10` と書き込むことで実行されます。新しいチャンクが割り当てられると、古いトップチャンクは分割され、アンソートされたビンへのポインタが **`_IO_list_all`** に書き込まれます。

次のステップは、古いトップチャンクのサイズを小さなビンに収まるように縮小することです。具体的には、サイズを **0x61** に設定します。これには2つの目的があります：

1. **Small Bin 4への挿入**：`malloc` がアンソートされたビンをスキャンしてこのチャンクを見つけると、サイズが小さいためにそれをSmall Bin 4に挿入しようとします。これにより、チャンクはSmall Bin 4リストの先頭に配置され、これは **`_IO_list_all`** のチャンクのFDポインタの場所です。アンソートされたビン攻撃を通じて **`_IO_list_all`** に近いアドレスを書き込んだためです。
2. **Mallocチェックのトリガー**：このチャンクサイズの操作により、`malloc` が内部チェックを実行します。偽のフォワードチャンクのサイズがゼロであるため、エラーが発生し、`malloc_printerr` が呼び出されます。

Small Binの操作により、チャンクのフォワードポインタを制御できます。 **\_IO\_list\_all** との重複を使用して、偽の **\_IO\_FILE** 構造体を作成します。この構造体は、libc内の内部チェックをパスする値に設定された `_IO_write_base` や `_IO_write_ptr` などの重要なフィールドを含むように注意深く作成されています。さらに、偽の構造体内にジャンプテーブルが作成され、命令ポインタが任意のコード（たとえば `system` 関数）が実行されるアドレスに設定されます。

技術の残りの部分を要約すると：

* **古いトップチャンクを縮小する**：古いトップチャンクのサイズを **0x61** に調整して小さなビンに収めます。
* **偽の `_IO_FILE` 構造体を設定する**：古いトップチャンクと重なるように偽の **\_IO\_FILE** 構造体を設定し、適切にフィールドを設定して実行フローを乗っ取ります。

次のステップは、アンソートされたビンに現在ある古いトップチャンクと重なる偽の **\_IO\_FILE** 構造体を作成することです。この構造体の最初のバイトは、実行されるコマンド（たとえば "/bin/sh"）へのポインタを慎重に作成されています。

偽の **\_IO\_FILE** 構造体内の重要なフィールド、例えば `_IO_write_base` や `_IO_write_ptr` などは、libc内の内部チェックをパスする値に設定されています。さらに、偽の構造体内にジャンプテーブルが作成され、命令ポインタが任意のコードが実行されるアドレスに設定されます。通常、これは `system` 関数のアドレスやシェルコマンドを実行できる他の関数のアドレスになります。

攻撃は、`malloc` の呼び出しが偽の **\_IO\_FILE** 構造体を介してコードの実行をトリガーするときに頂点に達します。これにより、任意のコードが実行され、通常はシェルが生成されるか、他の悪意のあるペイロードが実行されます。

**攻撃の要約:**

1. **トップチャンクを設定する**：チャンクを割り当ててトップチャンクのサイズを変更します。
2. **トップチャンクをアンソートされたビンに強制する**：より大きなチャンクを割り当てます。
3. **Libcアドレスをリークする**：アンソートされたビンから読み取るために脆弱性を使用します。
4. **アンソートされたビン攻撃を実行する**：オーバーフローを使用して **\_IO\_list\_all** に書き込みます。
5. **古いトップチャンクを縮小する**：サイズを小さなビンに収めるように調整します。
6. **偽の \_IO\_FILE 構造体を設定する**：制御フローを乗っ取るために偽のファイル構造体を作成します。
7. **コード実行をトリガーする**：攻撃を実行して任意のコードを実行します。

この手法は、`free` を直接呼び出すことなく、ヒープ管理メカニズム、libc情報のリーク、およびヒープオーバーフローを悪用してコード実行を達成します。偽の **\_IO\_FILE** 構造体を注意深く作成し、適切な位置に配置することで、通常のメモリ割り当て操作中に制御フローを乗っ取ることができます。これにより、任意のコードの実行が可能になり、通常はシェルや他の悪意のある活動が実行されます。
## 参考

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
AWSハッキングの学習と練習:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングの学習と練習: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* ハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>
{% endhint %}
