# Huis van Oranje

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

### Kode

* Vind 'n voorbeeld in [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* Die eksploitasiemetode is reggestel in hierdie [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) so dit werk nie meer nie (werk in vroe√´r as 2.26)
* Dieselfde voorbeeld **met meer kommentaar** in [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Doel

* Misbruik `malloc_printerr` funksie

### Vereistes

* Oorskry die top chunk grootte
* Libc en heap lek

### Agtergrond

Sommige nodige agtergrond uit die kommentaar van [**hierdie voorbeeld**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

Die ding is, in ouer weergawes van libc, wanneer die `malloc_printerr` funksie aangeroep is, sou dit **deur 'n lys van `_IO_FILE` strukture wat in `_IO_list_all` gestoor is, iterasie maak**, en werklik **'n** instruksie pointer in daardie struktuur **uitvoer**.\
Hierdie aanval sal 'n **valse `_IO_FILE` struktuur** forge wat ons sal skryf na **`_IO_list_all`**, en `malloc_printerr` laat loop.\
Dan sal dit **enige adres** uitvoer wat ons in die **`_IO_FILE`** strukture se sprongtafel gestoor het, en ons sal kode-uitvoering kry.

### Aanval

Die aanval begin deur te slaag om die **top chunk** binne die **onsortering bin** te kry. Dit word bereik deur `malloc` aan te roep met 'n grootte groter as die huidige top chunk grootte maar kleiner as **`mmp_.mmap_threshold`** (standaard is 128K), wat andersins `mmap` toewysing sou aktiveer. Wanneer die top chunk grootte gewysig word, is dit belangrik om te verseker dat die **top chunk + sy grootte** bladsy-gebalanseerd is en dat die **prev\_inuse** bit van die top chunk altyd ingestel is.

Om die top chunk binne die onsortering bin te kry, allokeer 'n chunk om die top chunk te skep, verander die top chunk grootte (met 'n oorgang in die toegewezen chunk) sodat **top chunk + grootte** bladsy-gebalanseerd is met die **prev\_inuse** bit ingestel. Allokeer dan 'n chunk groter as die nuwe top chunk grootte. Let daarop dat `free` nooit aangeroep word om die top chunk in die onsortering bin te kry.

Die ou top chunk is nou in die onsortering bin. Aannemend dat ons data binne dit kan lees (miskien as gevolg van 'n kwesbaarheid wat ook die oorgang veroorsaak het), is dit moontlik om libc adresse daaruit te lek en die adres van **\_IO\_list\_all** te kry.

'n Onsortering bin aanval word uitgevoer deur die oorgang te misbruik om `topChunk->bk->fwd = _IO_list_all - 0x10` te skryf. Wanneer 'n nuwe chunk toegeken word, sal die ou top chunk gesplit word, en 'n pointer na die onsortering bin sal in **`_IO_list_all`** geskryf word.

Die volgende stap behels die verkleining van die grootte van die ou top chunk om in 'n klein bin te pas, spesifiek om sy grootte op **0x61** in te stel. Dit dien twee doele:

1. **Invoeging in Klein Bin 4**: Wanneer `malloc` deur die onsortering bin skandeer en hierdie chunk sien, sal dit probeer om dit in klein bin 4 in te voeg weens sy klein grootte. Dit maak dat die chunk aan die kop van die klein bin 4 lys eindig, wat die ligging van die FD pointer van die chunk van **`_IO_list_all`** is, aangesien ons 'n naby adres in **`_IO_list_all`** geskryf het via die onsortering bin aanval.
2. **Aktivering van 'n Malloc Kontrole**: Hierdie chunk grootte manipulasie sal veroorsaak dat `malloc` interne kontroles uitvoer. Wanneer dit die grootte van die valse voorwaartse chunk kontroleer, wat nul sal wees, aktiveer dit 'n fout en roep `malloc_printerr` aan.

Die manipulasie van die klein bin sal jou toelaat om die voorwaartse pointer van die chunk te beheer. Die oorvleueling met **\_IO\_list\_all** word gebruik om 'n valse **\_IO\_FILE** struktuur te forge. Die struktuur is sorgvuldig saamgestel om sleutelvelde soos `_IO_write_base` en `_IO_write_ptr` in te sluit wat ingestel is op waardes wat interne kontroles in libc slaag. Boonop word 'n sprongtafel binne die valse struktuur geskep, waar 'n instruksie pointer op die adres ingestel word waar arbitr√™re kode (bv. die `system` funksie) uitgevoer kan word.

Om die oorblywende deel van die tegniek saam te vat:

* **Verklein die Ou Top Chunk**: Pas die grootte van die ou top chunk aan na **0x61** om dit in 'n klein bin te laat pas.
* **Stel die Valse `_IO_FILE` Struktuur op**: Oorvleuel die ou top chunk met die valse **\_IO\_FILE** struktuur en stel velde toepaslik in om die uitvoeringsvloei te kap.

Die volgende stap behels die forging van 'n valse **\_IO\_FILE** struktuur wat oorvleuel met die ou top chunk wat tans in die onsortering bin is. Die eerste bytes van hierdie struktuur word sorgvuldig saamgestel om 'n pointer na 'n opdrag (bv. "/bin/sh") in te sluit wat uitgevoer sal word.

Sleutelvelde in die valse **\_IO\_FILE** struktuur, soos `_IO_write_base` en `_IO_write_ptr`, word ingestel op waardes wat interne kontroles in libc slaag. Boonop word 'n sprongtafel binne die valse struktuur geskep, waar 'n instruksie pointer op die adres ingestel word waar arbitr√™re kode uitgevoer kan word. Gewoonlik sou dit die adres van die `system` funksie of 'n ander funksie wees wat shell opdragte kan uitvoer.

Die aanval kulmineer wanneer 'n oproep aan `malloc` die uitvoering van die kode deur die gemanipuleerde **\_IO\_FILE** struktuur aktiveer. Dit stel effektief arbitr√™re kode-uitvoering in staat, wat gewoonlik lei tot 'n shell wat geopen word of 'n ander kwaadwillige payload wat uitgevoer word.

**Samevatting van die Aanval:**

1. **Stel die top chunk op**: Allokeer 'n chunk en wysig die top chunk grootte.
2. **Dwing die top chunk in die onsortering bin**: Allokeer 'n groter chunk.
3. **Lek libc adresse**: Gebruik die kwesbaarheid om uit die onsortering bin te lees.
4. **Voer die onsortering bin aanval uit**: Skryf na **\_IO\_list\_all** met behulp van 'n oorgang.
5. **Verklein die ou top chunk**: Pas sy grootte aan om in 'n klein bin te pas.
6. **Stel 'n valse \_IO\_FILE struktuur op**: Forge 'n valse filestuktuur om die uitvoeringsvloei te kap.
7. **Aktiveer kode-uitvoering**: Allokeer 'n chunk om die aanval uit te voer en arbitr√™re kode te laat loop.

Hierdie benadering misbruik heap bestuur meganismes, libc inligting lek, en heap oorgange om kode-uitvoering te bereik sonder om direk `free` aan te roep. Deur die valse **\_IO\_FILE** struktuur sorgvuldig te saam te stel en dit op die regte plek te plaas, kan die aanval die uitvoeringsvloei kap tydens standaard geheue toewysingsoperasies. Dit stel die uitvoering van arbitr√™re kode in staat, wat moontlik lei tot 'n shell of ander kwaadwillige aktiwiteite.

## Verwysings

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
