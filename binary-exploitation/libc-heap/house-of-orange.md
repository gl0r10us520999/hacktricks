# House of Orange

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>
{% endhint %}

## Podstawowe informacje

### Kod

* Znajdź przykład w [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* Technika eksploatacji została naprawiona w tym [łatce](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0), więc to już nie działa (działa w wersjach wcześniejszych niż 2.26)
* Ten sam przykład **z większą ilością komentarzy** w [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Cel

* Wykorzystanie funkcji `malloc_printerr`

### Wymagania

* Nadpisanie rozmiaru górnego kawałka
* Wycieki libc i heap

### Tło

Nieco potrzebnego tła z komentarzy z [**tego przykładu**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

Rzecz w tym, że w starszych wersjach libc, gdy wywoływana była funkcja `malloc_printerr`, **iterowała przez listę struktur `_IO_FILE` przechowywanych w `_IO_list_all`**, a faktycznie **wykonywała** wskaźnik instrukcji w tej strukturze.\
Ten atak sfałszuje **fałszywą strukturę `_IO_FILE`**, którą zapiszemy do **`_IO_list_all`**, i spowoduje uruchomienie `malloc_printerr`.\
Następnie **wykona dowolny adres**, który mamy zapisany w tabeli skoków struktur **`_IO_FILE`**, a my uzyskamy wykonanie kodu.

### Atak

Atak zaczyna się od uzyskania **górnego kawałka** wewnątrz **nieposortowanego pojemnika**. Osiąga się to przez wywołanie `malloc` z rozmiarem większym niż aktualny rozmiar górnego kawałka, ale mniejszym niż **`mmp_.mmap_threshold`** (domyślnie 128K), co w przeciwnym razie spowodowałoby alokację `mmap`. Kiedy rozmiar górnego kawałka jest modyfikowany, ważne jest, aby upewnić się, że **górny kawałek + jego rozmiar** jest wyrównany do strony i że bit **prev\_inuse** górnego kawałka jest zawsze ustawiony.

Aby uzyskać górny kawałek wewnątrz nieposortowanego pojemnika, alokuj kawałek, aby utworzyć górny kawałek, zmień rozmiar górnego kawałka (z przepełnieniem w alokowanym kawałku), aby **górny kawałek + rozmiar** był wyrównany do strony z ustawionym bitem **prev\_inuse**. Następnie alokuj kawałek większy niż nowy rozmiar górnego kawałka. Zauważ, że `free` nigdy nie jest wywoływane, aby uzyskać górny kawałek do nieposortowanego pojemnika.

Stary górny kawałek jest teraz w nieposortowanym pojemniku. Zakładając, że możemy odczytać dane w nim (prawdopodobnie z powodu luki, która również spowodowała przepełnienie), możliwe jest wyciekanie adresów libc z niego i uzyskanie adresu **\_IO\_list\_all**.

Atak na nieposortowany pojemnik jest przeprowadzany przez wykorzystanie przepełnienia do zapisania `topChunk->bk->fwd = _IO_list_all - 0x10`. Gdy alokowany jest nowy kawałek, stary górny kawałek zostanie podzielony, a wskaźnik do nieposortowanego pojemnika zostanie zapisany w **`_IO_list_all`**.

Kolejny krok polega na zmniejszeniu rozmiaru starego górnego kawałka, aby zmieścił się w małym pojemniku, ustawiając jego rozmiar na **0x61**. Służy to dwóm celom:

1. **Wstawienie do Małego Pojemnika 4**: Gdy `malloc` przeszukuje nieposortowany pojemnik i widzi ten kawałek, spróbuje wstawić go do małego pojemnika 4 z powodu jego małego rozmiaru. To sprawia, że kawałek trafia na początek listy małego pojemnika 4, co jest lokalizacją wskaźnika FD kawałka **`_IO_list_all`**, ponieważ zapisaliśmy bliski adres w **`_IO_list_all`** za pomocą ataku na nieposortowany pojemnik.
2. **Wywołanie Sprawdzenia Malloc**: Manipulacja rozmiarem tego kawałka spowoduje, że `malloc` przeprowadzi wewnętrzne kontrole. Gdy sprawdzi rozmiar fałszywego kawałka do przodu, który będzie zerowy, wywoła błąd i wywoła `malloc_printerr`.

Manipulacja małym pojemnikiem pozwoli ci kontrolować wskaźnik do przodu kawałka. Nakładanie się na **\_IO\_list\_all** jest używane do sfałszowania fałszywej struktury **\_IO\_FILE**. Struktura jest starannie skonstruowana, aby zawierała kluczowe pola, takie jak `_IO_write_base` i `_IO_write_ptr`, ustawione na wartości, które przechodzą wewnętrzne kontrole w libc. Dodatkowo, w fałszywej strukturze tworzona jest tabela skoków, w której wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod (np. funkcja `system`).

Aby podsumować pozostałą część techniki:

* **Zmniejsz Stary Górny Kawałek**: Dostosuj rozmiar starego górnego kawałka do **0x61**, aby zmieścił się w małym pojemniku.
* **Ustaw Fałszywą Strukturę `_IO_FILE`**: Nakładaj stary górny kawałek na fałszywą strukturę **\_IO\_FILE** i odpowiednio ustawiaj pola, aby przejąć kontrolę nad przepływem wykonania.

Kolejny krok polega na sfałszowaniu fałszywej struktury **\_IO\_FILE**, która nakłada się na stary górny kawałek obecnie w nieposortowanym pojemniku. Pierwsze bajty tej struktury są starannie skonstruowane, aby zawierały wskaźnik do polecenia (np. "/bin/sh"), które zostanie wykonane.

Kluczowe pola w fałszywej strukturze **\_IO\_FILE**, takie jak `_IO_write_base` i `_IO_write_ptr`, są ustawione na wartości, które przechodzą wewnętrzne kontrole w libc. Dodatkowo, w fałszywej strukturze tworzona jest tabela skoków, w której wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod. Zazwyczaj byłby to adres funkcji `system` lub innej funkcji, która może wykonywać polecenia powłoki.

Atak kulminuje, gdy wywołanie `malloc` wyzwala wykonanie kodu przez manipulowaną strukturę **\_IO\_FILE**. To skutecznie pozwala na wykonanie dowolnego kodu, co zazwyczaj skutkuje uruchomieniem powłoki lub innym złośliwym ładunkiem.

**Podsumowanie Ataku:**

1. **Ustaw górny kawałek**: Alokuj kawałek i zmodyfikuj rozmiar górnego kawałka.
2. **Wymuś górny kawałek do nieposortowanego pojemnika**: Alokuj większy kawałek.
3. **Wycieki adresów libc**: Wykorzystaj lukę, aby odczytać z nieposortowanego pojemnika.
4. **Wykonaj atak na nieposortowany pojemnik**: Zapisz do **\_IO\_list\_all** za pomocą przepełnienia.
5. **Zmniejsz stary górny kawałek**: Dostosuj jego rozmiar, aby zmieścił się w małym pojemniku.
6. **Ustaw fałszywą strukturę \_IO\_FILE**: Sfałszuj fałszywą strukturę pliku, aby przejąć kontrolę nad przepływem.
7. **Wyzwól wykonanie kodu**: Alokuj kawałek, aby wykonać atak i uruchomić dowolny kod.

Podejście to wykorzystuje mechanizmy zarządzania pamięcią, wycieki informacji libc i przepełnienia stosu, aby osiągnąć wykonanie kodu bez bezpośredniego wywoływania `free`. Poprzez staranne skonstruowanie fałszywej struktury **\_IO\_FILE** i umieszczenie jej w odpowiedniej lokalizacji, atak może przejąć kontrolę nad przepływem wykonania podczas standardowych operacji alokacji pamięci. To umożliwia wykonanie dowolnego kodu, co potencjalnie skutkuje uruchomieniem powłoki lub innymi złośliwymi działaniami.

## Odniesienia

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>
{% endhint %}
