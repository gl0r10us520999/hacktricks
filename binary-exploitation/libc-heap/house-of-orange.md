# Maison d'Orange

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Informations de base

### Code

* Trouvez un exemple dans [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* La technique d'exploitation a √©t√© corrig√©e dans ce [correctif](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) donc cela ne fonctionne plus (fonctionne pour les versions ant√©rieures √† 2.26)
* M√™me exemple **avec plus de commentaires** dans [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Objectif

* Abuser de la fonction `malloc_printerr`

### Exigences

* √âcraser la taille du chunk sup√©rieur
* Fuites de libc et de heap

### Contexte

Certains √©l√©ments de contexte n√©cessaires provenant des commentaires de [**cet exemple**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

En fait, dans les anciennes versions de libc, lorsque la fonction `malloc_printerr` √©tait appel√©e, elle **it√©rait √† travers une liste de structures `_IO_FILE`** stock√©es dans `_IO_list_all`, et ex√©cutait en fait un pointeur d'instruction dans cette structure.\
Cette attaque va forger une **fausse structure `_IO_FILE`** que nous √©crirons dans **`_IO_list_all`**, et provoquer l'ex√©cution de `malloc_printerr`.\
Ensuite, il ex√©cutera l'adresse que nous avons stock√©e dans les pointeurs d'instruction de la structure **`_IO_FILE`**, et nous obtiendrons une ex√©cution de code

### Attaque

L'attaque commence par parvenir √† obtenir le **chunk sup√©rieur** √† l'int√©rieur du **bloc non tri√©**. Cela est r√©alis√© en appelant `malloc` avec une taille sup√©rieure √† la taille actuelle du chunk sup√©rieur mais plus petite que **`mmp_.mmap_threshold`** (par d√©faut 128K), ce qui d√©clencherait autrement une allocation `mmap`. Chaque fois que la taille du chunk sup√©rieur est modifi√©e, il est important de s'assurer que le **chunk sup√©rieur + sa taille** est align√© sur la page et que le bit **prev\_inuse** du chunk sup√©rieur est toujours d√©fini.

Pour obtenir le chunk sup√©rieur √† l'int√©rieur du bloc non tri√©, allouez un chunk pour cr√©er le chunk sup√©rieur, modifiez la taille du chunk sup√©rieur (avec un d√©bordement dans le chunk allou√©) de sorte que **le chunk sup√©rieur + la taille** soit align√© sur la page avec le bit **prev\_inuse** d√©fini. Ensuite, allouez un chunk plus grand que la nouvelle taille du chunk sup√©rieur. Notez que `free` n'est jamais appel√© pour placer le chunk sup√©rieur dans le bloc non tri√©.

L'ancien chunk sup√©rieur est maintenant dans le bloc non tri√©. En supposant que nous puissions lire des donn√©es √† l'int√©rieur (√©ventuellement en raison d'une vuln√©rabilit√© ayant √©galement provoqu√© le d√©bordement), il est possible de fuiter des adresses libc √† partir de celui-ci et d'obtenir l'adresse de **\_IO\_list\_all**.

Une attaque sur le bloc non tri√© est effectu√©e en abusant du d√©bordement pour √©crire `topChunk->bk->fwd = _IO_list_all - 0x10`. Lorsqu'un nouveau chunk est allou√©, l'ancien chunk sup√©rieur sera divis√©, et un pointeur vers le bloc non tri√© sera √©crit dans **`_IO_list_all`**.

L'√©tape suivante consiste √† r√©duire la taille de l'ancien chunk sup√©rieur pour qu'il rentre dans un petit bloc, en d√©finissant sp√©cifiquement sa taille √† **0x61**. Cela sert √† deux fins :

1. **Insertion dans le petit bloc 4** : Lorsque `malloc` parcourt le bloc non tri√© et voit ce chunk, il essaiera de l'ins√©rer dans le petit bloc 4 en raison de sa petite taille. Cela fait que le chunk se retrouve en t√™te de la liste du petit bloc 4, qui est l'emplacement du pointeur FD du chunk de **`_IO_list_all`** car nous avons √©crit une adresse proche dans **`_IO_list_all`** via l'attaque sur le bloc non tri√©.
2. **D√©clenchement d'une v√©rification de malloc** : Cette manipulation de la taille du chunk provoquera des v√©rifications internes de `malloc`. Lorsqu'il v√©rifie la taille du faux chunk suivant, qui sera nulle, cela d√©clenche une erreur et appelle `malloc_printerr`.

La manipulation du petit bloc vous permettra de contr√¥ler le pointeur avant du chunk. Le chevauchement avec **\_IO\_list\_all** est utilis√© pour forger une fausse structure **\_IO\_FILE**. La structure est soigneusement con√ßue pour inclure des champs cl√©s comme `_IO_write_base` et `_IO_write_ptr` d√©finis sur des valeurs qui passent les v√©rifications internes de libc. De plus, une table de saut est cr√©√©e √† l'int√©rieur de la fausse structure, o√π un pointeur d'instruction est d√©fini sur l'adresse o√π un code arbitraire (par exemple, la fonction `system`) peut √™tre ex√©cut√©.

Pour r√©sumer la partie restante de la technique :

* **R√©duire l'ancien chunk sup√©rieur** : Ajustez la taille de l'ancien chunk sup√©rieur √† **0x61** pour le faire rentrer dans un petit bloc.
* **Configurer la fausse structure `_IO_FILE`** : Faites chevaucher l'ancien chunk sup√©rieur avec la fausse structure **\_IO\_FILE** et d√©finissez les champs de mani√®re appropri√©e pour d√©tourner le flux d'ex√©cution.

L'√©tape suivante consiste √† forger une fausse structure **\_IO\_FILE** qui chevauche l'ancien chunk sup√©rieur actuellement dans le bloc non tri√©. Les premiers octets de cette structure sont soigneusement con√ßus pour inclure un pointeur vers une commande (par exemple, "/bin/sh") qui sera ex√©cut√©e.

Les champs cl√©s de la fausse structure **\_IO\_FILE**, tels que `_IO_write_base` et `_IO_write_ptr`, sont d√©finis sur des valeurs qui passent les v√©rifications internes de libc. De plus, une table de saut est cr√©√©e √† l'int√©rieur de la fausse structure, o√π un pointeur d'instruction est d√©fini sur l'adresse o√π un code arbitraire peut √™tre ex√©cut√©. Typiquement, il s'agirait de l'adresse de la fonction `system` ou d'une autre fonction pouvant ex√©cuter des commandes shell.

L'attaque culmine lorsque l'appel √† `malloc` d√©clenche l'ex√©cution du code √† travers la structure **\_IO\_FILE** manipul√©e. Cela permet efficacement l'ex√©cution de code arbitraire, aboutissant g√©n√©ralement √† un shell ou √† l'ex√©cution d'une autre charge malveillante.

**R√©sum√© de l'attaque :**

1. **Configurer le chunk sup√©rieur** : Allouer un chunk et modifier la taille du chunk sup√©rieur.
2. **Forcer le chunk sup√©rieur dans le bloc non tri√©** : Allouer un chunk plus grand.
3. **Fuites d'adresses libc** : Utiliser la vuln√©rabilit√© pour lire √† partir du bloc non tri√©.
4. **Effectuer l'attaque sur le bloc non tri√©** : √âcrire dans **\_IO\_list\_all** en utilisant un d√©bordement.
5. **R√©duire l'ancien chunk sup√©rieur** : Ajuster sa taille pour qu'il rentre dans un petit bloc.
6. **Configurer une fausse structure \_IO\_FILE** : Forger une fausse structure de fichier pour d√©tourner le flux de contr√¥le.
7. **D√©clencher l'ex√©cution de code** : Allouer un chunk pour ex√©cuter l'attaque et ex√©cuter du code arbitraire.

Cette approche exploite les m√©canismes de gestion de la m√©moire heap, les fuites d'informations libc et les d√©bordements de heap pour parvenir √† une ex√©cution de code sans appeler directement `free`. En concevant soigneusement la fausse structure **\_IO\_FILE** et en la pla√ßant au bon endroit, l'attaque peut d√©tourner le flux de contr√¥le lors des op√©rations standard d'allocation de m√©moire. Cela permet l'ex√©cution de code arbitraire, aboutissant potentiellement √† un shell ou √† d'autres activit√©s malveillantes.
## R√©f√©rences

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
