# House of Orange

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Informations de base

### Code

* Trouvez un exemple dans [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* La technique d'exploitation a √©t√© corrig√©e dans ce [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) donc cela ne fonctionne plus (fonctionne dans les versions ant√©rieures √† 2.26)
* M√™me exemple **avec plus de commentaires** dans [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Objectif

* Abuser de la fonction `malloc_printerr`

### Exigences

* √âcraser la taille du top chunk
* Fuites de libc et de heap

### Contexte

Quelques informations de base n√©cessaires provenant des commentaires de [**cet exemple**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

Le fait est que, dans les anciennes versions de libc, lorsque la fonction `malloc_printerr` √©tait appel√©e, elle **it√©rerait √† travers une liste de structures `_IO_FILE` stock√©es dans `_IO_list_all`**, et ex√©cuterait en fait un pointeur d'instruction dans cette structure.\
Cette attaque va forger une **fausse structure `_IO_FILE`** que nous allons √©crire dans **`_IO_list_all`**, et provoquer l'ex√©cution de `malloc_printerr`.\ 
Ensuite, elle **ex√©cutera n'importe quelle adresse** que nous avons stock√©e dans la table de saut des structures **`_IO_FILE`**, et nous obtiendrons une ex√©cution de code.

### Attaque

L'attaque commence par r√©ussir √† obtenir le **top chunk** √† l'int√©rieur du **unsorted bin**. Cela est r√©alis√© en appelant `malloc` avec une taille sup√©rieure √† la taille actuelle du top chunk mais inf√©rieure √† **`mmp_.mmap_threshold`** (la valeur par d√©faut est 128K), ce qui d√©clencherait autrement une allocation `mmap`. Chaque fois que la taille du top chunk est modifi√©e, il est important de s'assurer que le **top chunk + sa taille** est align√© sur une page et que le bit **prev\_inuse** du top chunk est toujours d√©fini.

Pour obtenir le top chunk √† l'int√©rieur du unsorted bin, allouez un chunk pour cr√©er le top chunk, changez la taille du top chunk (avec un d√©passement dans le chunk allou√©) afin que **top chunk + taille** soit align√© sur une page avec le bit **prev\_inuse** d√©fini. Ensuite, allouez un chunk plus grand que la nouvelle taille du top chunk. Notez que `free` n'est jamais appel√© pour obtenir le top chunk dans le unsorted bin.

L'ancien top chunk est maintenant dans le unsorted bin. En supposant que nous puissions lire des donn√©es √† l'int√©rieur (possiblement en raison d'une vuln√©rabilit√© qui a √©galement caus√© le d√©passement), il est possible de fuir des adresses libc √† partir de celui-ci et d'obtenir l'adresse de **\_IO\_list\_all**.

Une attaque de unsorted bin est effectu√©e en abusant du d√©passement pour √©crire `topChunk->bk->fwd = _IO_list_all - 0x10`. Lorsqu'un nouveau chunk est allou√©, l'ancien top chunk sera divis√©, et un pointeur vers le unsorted bin sera √©crit dans **`_IO_list_all`**.

L'√©tape suivante consiste √† r√©duire la taille de l'ancien top chunk pour qu'il s'adapte √† un petit bin, en d√©finissant sp√©cifiquement sa taille √† **0x61**. Cela sert deux objectifs :

1. **Insertion dans Small Bin 4** : Lorsque `malloc` parcourt le unsorted bin et voit ce chunk, il essaiera de l'ins√©rer dans le small bin 4 en raison de sa petite taille. Cela fait que le chunk se retrouve en t√™te de la liste du small bin 4, qui est l'emplacement du pointeur FD du chunk de **`_IO_list_all`** car nous avons √©crit une adresse proche dans **`_IO_list_all`** via l'attaque du unsorted bin.
2. **D√©clenchement d'un contr√¥le de Malloc** : Cette manipulation de la taille du chunk provoquera `malloc` √† effectuer des v√©rifications internes. Lorsqu'il v√©rifie la taille du faux chunk avant, qui sera z√©ro, cela d√©clenche une erreur et appelle `malloc_printerr`.

La manipulation du small bin vous permettra de contr√¥ler le pointeur avant du chunk. Le chevauchement avec **\_IO\_list\_all** est utilis√© pour forger une fausse structure **\_IO\_FILE**. La structure est soigneusement con√ßue pour inclure des champs cl√©s comme `_IO_write_base` et `_IO_write_ptr` d√©finis sur des valeurs qui passent les v√©rifications internes dans libc. De plus, une table de saut est cr√©√©e dans la fausse structure, o√π un pointeur d'instruction est d√©fini √† l'adresse o√π un code arbitraire (par exemple, la fonction `system`) peut √™tre ex√©cut√©.

Pour r√©sumer la partie restante de la technique :

* **R√©duire l'ancien top chunk** : Ajustez la taille de l'ancien top chunk √† **0x61** pour l'adapter √† un petit bin.
* **Configurer la fausse structure `_IO_FILE`** : Chevauchez l'ancien top chunk avec la fausse structure **\_IO\_FILE** et d√©finissez les champs de mani√®re appropri√©e pour d√©tourner le flux d'ex√©cution.

L'√©tape suivante consiste √† forger une fausse structure **\_IO\_FILE** qui chevauche l'ancien top chunk actuellement dans le unsorted bin. Les premiers octets de cette structure sont soigneusement con√ßus pour inclure un pointeur vers une commande (par exemple, "/bin/sh") qui sera ex√©cut√©e.

Les champs cl√©s dans la fausse structure **\_IO\_FILE**, tels que `_IO_write_base` et `_IO_write_ptr`, sont d√©finis sur des valeurs qui passent les v√©rifications internes dans libc. De plus, une table de saut est cr√©√©e dans la fausse structure, o√π un pointeur d'instruction est d√©fini √† l'adresse o√π un code arbitraire peut √™tre ex√©cut√©. En g√©n√©ral, cela serait l'adresse de la fonction `system` ou une autre fonction qui peut ex√©cuter des commandes shell.

L'attaque culmine lorsqu'un appel √† `malloc` d√©clenche l'ex√©cution du code via la structure **\_IO\_FILE** manipul√©e. Cela permet effectivement l'ex√©cution de code arbitraire, entra√Ænant g√©n√©ralement le lancement d'un shell ou l'ex√©cution d'une autre charge utile malveillante.

**R√©sum√© de l'attaque :**

1. **Configurer le top chunk** : Allouez un chunk et modifiez la taille du top chunk.
2. **Forcer le top chunk dans le unsorted bin** : Allouez un chunk plus grand.
3. **Fuir les adresses libc** : Utilisez la vuln√©rabilit√© pour lire √† partir du unsorted bin.
4. **Effectuer l'attaque du unsorted bin** : √âcrivez dans **\_IO\_list\_all** en utilisant un d√©passement.
5. **R√©duire l'ancien top chunk** : Ajustez sa taille pour l'adapter √† un petit bin.
6. **Configurer une fausse structure \_IO\_FILE** : Forgez une fausse structure de fichier pour d√©tourner le flux de contr√¥le.
7. **D√©clencher l'ex√©cution de code** : Allouez un chunk pour ex√©cuter l'attaque et ex√©cuter du code arbitraire.

Cette approche exploite les m√©canismes de gestion de heap, les fuites d'informations libc et les d√©passements de heap pour obtenir une ex√©cution de code sans appeler directement `free`. En fa√ßonnant soigneusement la fausse structure **\_IO\_FILE** et en la pla√ßant au bon endroit, l'attaque peut d√©tourner le flux de contr√¥le lors des op√©rations d'allocation de m√©moire standard. Cela permet l'ex√©cution de code arbitraire, entra√Ænant potentiellement un shell ou d'autres activit√©s malveillantes.

## R√©f√©rences

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
