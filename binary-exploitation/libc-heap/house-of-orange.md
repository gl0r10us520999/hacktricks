# Casa de Orange

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>
{% endhint %}

## Información Básica

### Código

* Encuentra un ejemplo en [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_orange.c)
* La técnica de explotación fue corregida en este [parche](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) por lo que ya no funciona (funciona en versiones anteriores a 2.26)
* Mismo ejemplo **con más comentarios** en [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

### Objetivo

* Abusar de la función `malloc_printerr`

### Requisitos

* Sobrescribir el tamaño del top chunk
* Fugas de información de Libc y heap

### Antecedentes

Algunos antecedentes necesarios de los comentarios de [**este ejemplo**](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)**:**

La cuestión es que, en versiones antiguas de libc, cuando se llamaba a la función `malloc_printerr`, **iteraba a través de una lista de estructuras `_IO_FILE` almacenadas en `_IO_list_all`**, y realmente **ejecutaba** un puntero de instrucción en esa estructura.\
Este ataque forjará una **estructura `_IO_FILE` falsa** que escribiremos en **`_IO_list_all`**, y provocará que se ejecute `malloc_printerr`.\
Luego **ejecutará cualquier dirección** que tengamos almacenada en la tabla de saltos de las estructuras **`_IO_FILE`**, y obtendremos ejecución de código

### Ataque

El ataque comienza logrando obtener el **top chunk** dentro del **unsorted bin**. Esto se logra llamando a `malloc` con un tamaño mayor al tamaño actual del top chunk pero menor que **`mmp_.mmap_threshold`** (por defecto es 128K), lo cual de lo contrario activaría la asignación de `mmap`. Siempre que se modifique el tamaño del top chunk, es importante asegurarse de que el **top chunk + su tamaño** esté alineado a página y que el bit **prev\_inuse** del top chunk esté siempre establecido.

Para obtener el top chunk dentro del unsorted bin, asigna un chunk para crear el top chunk, cambia el tamaño del top chunk (con un desbordamiento en el chunk asignado) de manera que **top chunk + tamaño** esté alineado a página con el bit **prev\_inuse** establecido. Luego asigna un chunk más grande que el nuevo tamaño del top chunk. Ten en cuenta que `free` nunca se llama para colocar el top chunk en el unsorted bin.

El antiguo top chunk está ahora en el unsorted bin. Suponiendo que podemos leer datos dentro de él (posiblemente debido a una vulnerabilidad que también causó el desbordamiento), es posible filtrar direcciones de Libc desde él y obtener la dirección de **\_IO\_list\_all**.

Se realiza un ataque al unsorted bin abusando del desbordamiento para escribir `topChunk->bk->fwd = _IO_list_all - 0x10`. Cuando se asigna un nuevo chunk, el antiguo top chunk se dividirá y se escribirá un puntero al unsorted bin en **`_IO_list_all`**.

El siguiente paso implica reducir el tamaño del antiguo top chunk para que quepa en un small bin, estableciendo específicamente su tamaño en **0x61**. Esto sirve para dos propósitos:

1. **Inserción en Small Bin 4**: Cuando `malloc` escanea el unsorted bin y ve este chunk, intentará insertarlo en el small bin 4 debido a su pequeño tamaño. Esto hace que el chunk termine en la cabeza de la lista del small bin 4 que es la ubicación del puntero FD del chunk de **`_IO_list_all`** ya que escribimos una dirección cercana en **`_IO_list_all`** mediante el ataque al unsorted bin.
2. **Desencadenar una Verificación de Malloc**: Esta manipulación del tamaño del chunk causará que `malloc` realice verificaciones internas. Cuando verifica el tamaño del chunk falso hacia adelante, que será cero, desencadena un error y llama a `malloc_printerr`.

La manipulación del small bin te permitirá controlar el puntero hacia adelante del chunk. La superposición con **\_IO\_list\_all** se utiliza para forjar una estructura falsa de **\_IO\_FILE**. La estructura se crea cuidadosamente para incluir campos clave como `_IO_write_base` y `_IO_write_ptr` establecidos en valores que pasan las verificaciones internas en libc. Además, se crea una tabla de saltos dentro de la estructura falsa, donde se establece un puntero de instrucción en la dirección donde se puede ejecutar código arbitrario (por ejemplo, la función `system`).

Para resumir la parte restante de la técnica:

* **Reducir el Antiguo Top Chunk**: Ajustar el tamaño del antiguo top chunk a **0x61** para que quepa en un small bin.
* **Configurar la Estructura Falsa de `_IO_FILE`**: Superponer el antiguo top chunk con la falsa estructura de **\_IO\_FILE** y establecer los campos de manera adecuada para secuestrar el flujo de ejecución.

El siguiente paso implica forjar una falsa estructura de **\_IO\_FILE** que se superpone con el antiguo top chunk actualmente en el unsorted bin. Los primeros bytes de esta estructura se crean cuidadosamente para incluir un puntero a un comando (por ejemplo, "/bin/sh") que se ejecutará.

Los campos clave en la falsa estructura de **\_IO\_FILE**, como `_IO_write_base` y `_IO_write_ptr`, se establecen en valores que pasan las verificaciones internas en libc. Además, se crea una tabla de saltos dentro de la estructura falsa, donde se establece un puntero de instrucción en la dirección donde se puede ejecutar código arbitrario. Típicamente, esta sería la dirección de la función `system` u otra función que pueda ejecutar comandos de shell.

El ataque culmina cuando una llamada a `malloc` desencadena la ejecución del código a través de la estructura manipulada de **\_IO\_FILE**. Esto permite la ejecución de código arbitrario, lo que generalmente resulta en el inicio de un shell u otra carga maliciosa.

**Resumen del Ataque:**

1. **Configurar el top chunk**: Asignar un chunk y modificar el tamaño del top chunk.
2. **Forzar el top chunk en el unsorted bin**: Asignar un chunk más grande.
3. **Filtrar direcciones de Libc**: Utilizar la vulnerabilidad para leer desde el unsorted bin.
4. **Realizar el ataque al unsorted bin**: Escribir en **\_IO\_list\_all** utilizando un desbordamiento.
5. **Reducir el antiguo top chunk**: Ajustar su tamaño para que quepa en un small bin.
6. **Configurar una estructura falsa de \_IO\_FILE**: Forjar una estructura de archivo falsa para secuestrar el flujo de control.
7. **Desencadenar la ejecución de código**: Asignar un chunk para ejecutar el ataque y ejecutar código arbitrario.

Este enfoque explota los mecanismos de gestión de heap, las fugas de información de libc y los desbordamientos de heap para lograr la ejecución de código sin llamar directamente a `free`. Al crear cuidadosamente la falsa estructura de **\_IO\_FILE** y colocarla en la ubicación correcta, el ataque puede secuestrar el flujo de control durante las operaciones estándar de asignación de memoria. Esto permite la ejecución de código arbitrario, lo que potencialmente resulta en un shell u otras actividades maliciosas.
## Referencias

* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_orange/)
* [https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html](https://guyinatuxedo.github.io/43-house\_of\_orange/house\_orange\_exp/index.html)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
