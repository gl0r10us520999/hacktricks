# House of Roman

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## 基本信息

这是一种非常有趣的技术，它允许通过假快块、未排序块攻击和相对覆盖来实现 RCE，而无需泄漏。然而，它已经被 [**修补**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c)。

### 代码

* 你可以在 [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c) 找到一个示例

### 目标

* 通过滥用相对指针实现 RCE

### 要求

* 编辑快块和未排序块指针
* 必须强行破解 12 位随机数（0.02% 的成功率）

## 攻击步骤

### 第 1 部分：快块块指向 \_\_malloc\_hook

创建几个块：

* `fastbin_victim` (0x60, offset 0): UAF 块，稍后编辑堆指针以指向 LibC 值。
* `chunk2` (0x80, offset 0x70): 用于良好的对齐
* `main_arena_use` (0x80, offset 0x100)
* `relative_offset_heap` (0x60, offset 0x190): 在 'main\_arena\_use' 块上的相对偏移

然后 `free(main_arena_use)`，这将把此块放入未排序列表，并在 `fd` 和 `bk` 指针中获取指向 `main_arena + 0x68` 的指针。

现在分配了一个新块 `fake_libc_chunk(0x60)`，因为它将包含指向 `main_arena + 0x68` 的指针在 `fd` 和 `bk` 中。

然后 `relative_offset_heap` 和 `fastbin_victim` 被释放。
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
* &#x20;`fastbin_victim` 有一个指向 `relative_offset_heap` 的 `fd`
* &#x20;`relative_offset_heap` 是从 `fake_libc_chunk` 的距离偏移量，其中包含指向 `main_arena + 0x68` 的指针
* 只需更改 `fastbin_victim.fd` 的最后一个字节，就可以使 `fastbin_victim` 指向 `main_arena + 0x68`

对于之前的操作，攻击者需要能够修改 `fastbin_victim` 的 fd 指针。

然后，`main_arena + 0x68` 并不是那么有趣，所以让我们修改它，使指针指向 **`__malloc_hook`**。

请注意，`__memalign_hook` 通常以 `0x7f` 开头，前面是零，因此可以将其伪装为 `0x70` 快速堆的一个值。由于地址的最后 4 位是 **随机** 的，因此有 `2^4=16` 种可能性使值最终指向我们感兴趣的地方。因此在这里执行 BF 攻击，使得块最终变成：**`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`。**

（有关其余字节的更多信息，请查看 [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)[ 示例](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c) 中的解释）。如果 BF 不起作用，程序就会崩溃（所以从头开始，直到它有效）。

然后，执行 2 次 malloc 以移除 2 个初始快速堆块，并分配第三个以获取一个在 **`__malloc_hook:`** 中的块。
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted\_bin 攻击

有关更多信息，您可以查看：

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

但基本上，它允许将 `main_arena + 0x68` 写入 `chunk->bk` 指定的任何位置。对于攻击，我们选择 `__malloc_hook`。然后，在覆盖它之后，我们将使用相对覆盖来指向 `one_gadget`。

为此，我们开始获取一个 chunk 并将其放入 **unsorted bin**：
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
使用 UAF 在这个块中将 `unsorted_bin_ptr->bk` 指向 `__malloc_hook` 的地址（我们之前已经暴力破解过这个）。

{% hint style="danger" %}
请注意，这个攻击会破坏未排序的 bin（因此小和大也会受到影响）。所以我们现在只能**使用来自快速 bin 的分配**（一个更复杂的程序可能会进行其他分配并崩溃），并且为了触发这一点，我们必须**分配相同的大小，否则程序将崩溃。**
{% endhint %}

因此，为了触发 `__malloc_hook` 中 `main_arena + 0x68` 的写入，我们在将 `__malloc_hook` 设置在 `unsorted_bin_ptr->bk` 后，只需执行：**`malloc(0x80)`**

### 第 3 步：将 \_\_malloc\_hook 设置为 system

在第一步中，我们控制了一个包含 `__malloc_hook` 的块（在变量 `malloc_hook_chunk` 中），在第二步中，我们成功地在这里写入了 `main_arena + 0x68`。

现在，我们利用 `malloc_hook_chunk` 中的部分覆盖，使用我们在那里写入的 libc 地址（`main_arena + 0x68`）来**指向一个 `one_gadget` 地址**。

在这里需要**暴力破解 12 位随机数**（更多信息请参见 [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)[ 示例](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)）。

最后，一旦正确的地址被覆盖，**调用 `malloc` 并触发 `one_gadget`**。

## 参考

* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_roman/)

{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **在 Twitter 上关注** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
