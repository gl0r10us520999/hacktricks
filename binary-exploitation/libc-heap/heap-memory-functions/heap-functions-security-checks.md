# V√©rifications de s√©curit√© des fonctions de tas

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## unlink

Pour plus d'informations, consultez :

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Voici un r√©sum√© des v√©rifications effectu√©es :

* V√©rifier si la taille indiqu√©e du chunk est la m√™me que `prev_size` indiqu√© dans le chunk suivant
* Message d'erreur : `taille corrompue par rapport √† prev_size`
* V√©rifier √©galement que `P->fd->bk == P` et `P->bk->fw == P`
* Message d'erreur : `liste doublement cha√Æn√©e corrompue`
* Si le chunk n'est pas petit, v√©rifier que `P->fd_nextsize->bk_nextsize == P` et `P->bk_nextsize->fd_nextsize == P`
* Message d'erreur : `liste doublement cha√Æn√©e corrompue (non petit)`

## \_int\_malloc

Pour plus d'informations, consultez :

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **V√©rifications pendant la recherche de fast bin :**
* Si le chunk n'est pas align√© :
* Message d'erreur : `malloc() : chunk fastbin non align√© d√©tect√© 2`
* Si le chunk suivant n'est pas align√© :
* Message d'erreur : `malloc() : chunk fastbin non align√© d√©tect√©`
* Si le chunk retourn√© a une taille incorrecte en raison de son index dans le fast bin :
* Message d'erreur : `malloc() : corruption de la m√©moire (rapide)`
* Si un chunk utilis√© pour remplir le tcache n'est pas align√© :
* Message d'erreur : `malloc() : chunk fastbin non align√© d√©tect√© 3`
* **V√©rifications pendant la recherche de small bin :**
* Si `victim->bk->fd != victim` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e smallbin corrompue`
* **V√©rifications pendant la consolidation** effectu√©es pour chaque chunk de fast bin :&#x20;
* Si le chunk n'est pas align√©, d√©clencher :
* Message d'erreur : `malloc_consolidate() : chunk fastbin non align√© d√©tect√©`
* Si le chunk a une taille diff√©rente de celle qu'il devrait en raison de l'index dans lequel il se trouve :
* Message d'erreur : `malloc_consolidate() : taille de chunk non valide`
* Si le chunk pr√©c√©dent n'est pas utilis√© et que le chunk pr√©c√©dent a une taille diff√©rente de celle indiqu√©e par prev_chunk :
* Message d'erreur : `taille corrompue par rapport √† prev_size dans fastbins`
* **V√©rifications pendant la recherche de unsorted bin** :
* Si la taille du chunk est √©trange (trop petite ou trop grande) :&#x20;
* Message d'erreur : `malloc() : taille non valide (non tri√©e)`
* Si la taille du chunk suivant est √©trange (trop petite ou trop grande) :
* Message d'erreur : `malloc() : taille suivante non valide (non tri√©e)`
* Si la taille pr√©c√©dente indiqu√©e par le chunk suivant diff√®re de la taille du chunk :
* Message d'erreur : `malloc() : taille next->prev_size non concordante (non tri√©e)`
* Si non `victim->bck->fd == victim` ou non `victim->fd == av (ar√®ne)` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e non tri√©e corrompue`
* Comme nous v√©rifions toujours le dernier, son fd devrait toujours pointer vers la structure de l'ar√®ne.
* Si le chunk suivant n'indique pas que le pr√©c√©dent est utilis√© :
* Message d'erreur : `malloc() : next->prev_inuse non valide (non tri√©e)`
* Si `fwd->bk_nextsize->fd_nextsize != fwd` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e largebin corrompue (nextsize)`
* Si `fwd->bk->fd != fwd` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e largebin corrompue (bk)`
* **V√©rifications pendant la recherche de large bin (par index) :**
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc() : chunks non tri√©s corrompus`
* **V√©rifications pendant la recherche de large bin (suivant plus grand) :**
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc() : chunks non tri√©s corrompus2`
* **V√©rifications pendant l'utilisation du Top chunk :**
* `chunksize(av->top) > av->system_mem` :
* Message d'erreur : `malloc() : taille de top corrompue`

## `tcache_get_n`

* **V√©rifications dans `tcache_get_n` :**
* Si le chunk n'est pas align√© :
* Message d'erreur : `malloc() : chunk tcache non align√© d√©tect√©`

## `tcache_thread_shutdown`

* **V√©rifications dans `tcache_thread_shutdown` :**
* Si le chunk n'est pas align√© :
* Message d'erreur : `tcache_thread_shutdown() : chunk tcache non align√© d√©tect√©`

## `__libc_realloc`

* **V√©rifications dans `__libc_realloc` :**
* Si l'ancien pointeur n'est pas align√© ou si la taille √©tait incorrecte :
* Message d'erreur : `realloc() : pointeur non valide`

## `_int_free`

Pour plus d'informations, consultez :

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **V√©rifications au d√©but de `_int_free` :**
* Le pointeur est align√© :
* Message d'erreur : `free() : pointeur non valide`
* Taille sup√©rieure √† `MINSIZE` et taille √©galement align√©e :
* Message d'erreur : `free() : taille non valide`
* **V√©rifications dans `_int_free` tcache :**
* S'il y a plus d'entr√©es que `mp_.tcache_count` :
* Message d'erreur : `free() : trop de chunks d√©tect√©s dans le tcache`
* Si l'entr√©e n'est pas align√©e :
* Message d'erreur : `free() : chunk non align√© d√©tect√© dans le tcache 2`
* Si le chunk lib√©r√© a d√©j√† √©t√© lib√©r√© et est pr√©sent comme chunk dans le tcache :
* Message d'erreur : `free() : double lib√©ration d√©tect√©e dans le tcache 2`
* **V√©rifications dans `_int_free` fast bin :**
* Si la taille du chunk est invalide (trop grande ou trop petite) d√©clencher :
* Message d'erreur : `free() : taille suivante non valide (rapide)`
* Si le chunk ajout√© √©tait d√©j√† en haut du fast bin :
* Message d'erreur : `double lib√©ration ou corruption (fasttop)`
* Si la taille du chunk en haut a une taille diff√©rente du chunk que nous ajoutons :
* Message d'erreur : `entr√©e fastbin non valide (libre)`
## **`_int_free_merge_chunk`**

* **V√©rifications dans `_int_free_merge_chunk`:**
* Si le chunk est le chunk sup√©rieur:
* Message d'erreur: `double free or corruption (top)`
* Si le chunk suivant est en dehors des limites de l'ar√®ne:
* Message d'erreur: `double free or corruption (out)`
* Si le chunk n'est pas marqu√© comme utilis√© (dans le prev\_inuse du chunk suivant):
* Message d'erreur: `double free or corruption (!prev)`
* Si le chunk suivant a une taille trop petite ou trop grande:
* Message d'erreur: `free(): invalid next size (normal)`
* Si le chunk pr√©c√©dent n'est pas utilis√©, il tentera de consolider. Mais, si la `prev_size` diff√®re de la taille indiqu√©e dans le chunk pr√©c√©dent:
* Message d'erreur: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **V√©rifications dans `_int_free_create_chunk`:**
* Ajout d'un chunk dans le bac non tri√©, v√©rifier si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Message d'erreur: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **V√©rifications dans `do_check_malloc_state`:**
* Si le chunk de bac rapide est mal align√©:
* Message d'erreur: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **V√©rifications dans `malloc_consolidate`:**
* Si le chunk de bac rapide est mal align√©:
* Message d'erreur: `malloc_consolidate(): unaligned fastbin chunk detected`
* Si la taille du chunk de bac rapide est incorrecte:
* Message d'erreur: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **V√©rifications dans `_int_realloc`:**
* La taille est trop grande ou trop petite:
* Message d'erreur: `realloc(): invalid old size`
* La taille du chunk suivant est trop grande ou trop petite:
* Message d'erreur: `realloc(): invalid next size`
