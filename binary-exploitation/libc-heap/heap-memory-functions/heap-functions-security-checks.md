# Sprawdzanie zabezpiecze켻 funkcji sterty

{% hint style="success" %}
Dowiedz si캧 i 캖wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz si캧 i 캖wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawd콬 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Do켹캔cz do** 游눫 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **콑led콬** nas na **Twitterze** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si캧 trikami hakerskimi, przesy켹aj캔c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
{% endhint %}

## unlink

Aby uzyska캖 wi캧cej informacji, sprawd콬:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

To podsumowanie przeprowadzonych kontroli:

* Sprawd콬, czy wskazany rozmiar fragmentu jest taki sam jak `prev_size` wskazany w nast캧pnym fragmencie
* Komunikat b켹캧du: `corrupted size vs. prev_size`
* Sprawd콬 r칩wnie콮, czy `P->fd->bk == P` i `P->bk->fw == P`
* Komunikat b켹캧du: `corrupted double-linked list`
* Je콑li fragment nie jest ma켹y, sprawd콬, czy `P->fd_nextsize->bk_nextsize == P` i `P->bk_nextsize->fd_nextsize == P`
* Komunikat b켹캧du: `corrupted double-linked list (not small)`

## \_int\_malloc

Aby uzyska캖 wi캧cej informacji, sprawd콬:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Kontrole podczas wyszukiwania w fast bin:**
* Je콑li fragment jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `malloc(): unaligned fastbin chunk detected 2`
* Je콑li nast캧pny fragment jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `malloc(): unaligned fastbin chunk detected`
* Je콑li zwr칩cony fragment ma niepoprawny rozmiar z powodu jego indeksu w fast bin:
* Komunikat b켹캧du: `malloc(): memory corruption (fast)`
* Je콑li kt칩rykolwiek fragment u콮yty do wype켹nienia tcache jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `malloc(): unaligned fastbin chunk detected 3`
* **Kontrole podczas wyszukiwania w small bin:**
* Je콑li `victim->bk->fd != victim`:
* Komunikat b켹캧du: `malloc(): smallbin double linked list corrupted`
* **Kontrole podczas konsolidacji** przeprowadzane dla ka콮dego fragmentu fast bin:&#x20;
* Je콑li fragment jest 콬le wyr칩wnany, wywo켹aj:
* Komunikat b켹캧du: `malloc_consolidate(): unaligned fastbin chunk detected`
* Je콑li fragment ma inny rozmiar ni콮 powinien z powodu indeksu, w kt칩rym si캧 znajduje:
* Komunikat b켹캧du: `malloc_consolidate(): invalid chunk size`
* Je콑li poprzedni fragment nie jest u콮ywany, a poprzedni fragment ma inny rozmiar ni콮 wskazany przez prev\_chunk:
* Komunikat b켹캧du: `corrupted size vs. prev_size in fastbins`
* **Kontrole podczas wyszukiwania w unsorted bin**:
* Je콑li rozmiar fragmentu jest dziwny (za ma켹y lub za du콮y):&#x20;
* Komunikat b켹캧du: `malloc(): invalid size (unsorted)`
* Je콑li rozmiar nast캧pnego fragmentu jest dziwny (za ma켹y lub za du콮y):
* Komunikat b켹캧du: `malloc(): invalid next size (unsorted)`
* Je콑li rozmiar poprzedni wskazany przez nast캧pny fragment r칩콮ni si캧 od rozmiaru fragmentu:
* Komunikat b켹캧du: `malloc(): mismatching next->prev_size (unsorted)`
* Je콑li nie `victim->bck->fd == victim` lub nie `victim->fd == av (arena)`:
* Komunikat b켹캧du: `malloc(): unsorted double linked list corrupted`
* Poniewa콮 zawsze sprawdzamy ostatni, jego fd powinien zawsze wskazywa캖 na struktur캧 areny.
* Je콑li nast캧pny fragment nie wskazuje, 콮e poprzedni jest u콮ywany:
* Komunikat b켹캧du: `malloc(): invalid next->prev_inuse (unsorted)`
* Je콑li `fwd->bk_nextsize->fd_nextsize != fwd`:
* Komunikat b켹캧du: `malloc(): largebin double linked list corrupted (nextsize)`
* Je콑li `fwd->bk->fd != fwd`:
* Komunikat b켹캧du: `malloc(): largebin double linked list corrupted (bk)`
* **Kontrole podczas wyszukiwania w large bin (wed켹ug indeksu):**
* `bck->fd-> bk != bck`:
* Komunikat b켹캧du: `malloc(): corrupted unsorted chunks`
* **Kontrole podczas wyszukiwania w large bin (nast캧pny wi캧kszy):**
* `bck->fd-> bk != bck`:
* Komunikat b켹캧du: `malloc(): corrupted unsorted chunks2`
* **Kontrole podczas u콮ycia Top chunk:**
* `chunksize(av->top) > av->system_mem`:
* Komunikat b켹캧du: `malloc(): corrupted top size`

## `tcache_get_n`

* **Kontrole w `tcache_get_n`:**
* Je콑li fragment jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Kontrole w `tcache_thread_shutdown`:**
* Je콑li fragment jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Kontrole w `__libc_realloc`:**
* Je콑li stary wska콬nik jest 콬le wyr칩wnany lub rozmiar by켹 niepoprawny:
* Komunikat b켹캧du: `realloc(): invalid pointer`

## `_int_free`

Aby uzyska캖 wi캧cej informacji, sprawd콬:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Kontrole na pocz캔tku `_int_free`:**
* Wska콬nik jest wyr칩wnany:
* Komunikat b켹캧du: `free(): invalid pointer`
* Rozmiar wi캧kszy ni콮 `MINSIZE` i r칩wnie콮 wyr칩wnany:
* Komunikat b켹캧du: `free(): invalid size`
* **Kontrole w `_int_free` tcache:**
* Je콑li jest wi캧cej wpis칩w ni콮 `mp_.tcache_count`:
* Komunikat b켹캧du: `free(): too many chunks detected in tcache`
* Je콑li wpis nie jest wyr칩wnany:
* Komunikat b켹캧du: `free(): unaligned chunk detected in tcache 2`
* Je콑li zwolniony fragment by켹 ju콮 zwolniony i jest obecny jako fragment w tcache:
* Komunikat b켹캧du: `free(): double free detected in tcache 2`
* **Kontrole w `_int_free` fast bin:**
* Je콑li rozmiar fragmentu jest nieprawid켹owy (za du콮y lub za ma켹y), wywo켹aj:
* Komunikat b켹캧du: `free(): invalid next size (fast)`
* Je콑li dodany fragment by켹 ju콮 na szczycie fast bin:
* Komunikat b켹캧du: `double free or corruption (fasttop)`
* Je콑li rozmiar fragmentu na szczycie ma inny rozmiar ni콮 dodawany fragment:
* Komunikat b켹캧du: `invalid fastbin entry (free)`
## **`_int_free_merge_chunk`**

* **Sprawdzenia w `_int_free_merge_chunk`:**
* Je콑li kawa켹ek jest kawa켹kiem g칩rnym:
* Komunikat b켹캧du: `double free or corruption (top)`
* Je콑li nast캧pny kawa켹ek znajduje si캧 poza granicami areny:
* Komunikat b켹캧du: `double free or corruption (out)`
* Je콑li kawa켹ek nie jest oznaczony jako u콮ywany (w prev\_inuse z nast캧pnego kawa켹ka):
* Komunikat b켹캧du: `double free or corruption (!prev)`
* Je콑li nast캧pny kawa켹ek ma zbyt ma켹y lub zbyt du콮y rozmiar:
* Komunikat b켹캧du: `free(): invalid next size (normal)`
* Je콑li poprzedni kawa켹ek nie jest u콮ywany, zostanie podj캧ta pr칩ba konsolidacji. Jednak je콑li `prev_size` r칩콮ni si캧 od rozmiaru wskazanego w poprzednim kawa켹ku:
* Komunikat b켹캧du: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Sprawdzenia w `_int_free_create_chunk`:**
* Dodaj캔c kawa켹ek do nieuporz캔dkowanego kube켹ka, sprawd콬, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Komunikat b켹캧du: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Sprawdzenia w `do_check_malloc_state`:**
* Je콑li kawa켹ek fast bin jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Sprawdzenia w `malloc_consolidate`:**
* Je콑li kawa켹ek fast bin jest 콬le wyr칩wnany:
* Komunikat b켹캧du: `malloc_consolidate(): unaligned fastbin chunk detected`
* Je콑li nieprawid켹owy rozmiar kawa켹ka fast bin:
* Komunikat b켹캧du: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Sprawdzenia w `_int_realloc`:**
* Rozmiar jest zbyt du콮y lub zbyt ma켹y:
* Komunikat b켹캧du: `realloc(): invalid old size`
* Rozmiar nast캧pnego kawa켹ka jest zbyt du콮y lub zbyt ma켹y:
* Komunikat b켹캧du: `realloc(): invalid next size`
