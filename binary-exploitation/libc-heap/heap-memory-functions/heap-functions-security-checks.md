# Controlli di Sicurezza delle Funzioni Heap

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}

## unlink

Per ulteriori informazioni controlla:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Questo √® un riepilogo dei controlli effettuati:

* Controlla se la dimensione indicata del chunk √® la stessa del `prev_size` indicato nel chunk successivo
* Messaggio di errore: `corrupted size vs. prev_size`
* Controlla anche che `P->fd->bk == P` e `P->bk->fw == P`
* Messaggio di errore: `corrupted double-linked list`
* Se il chunk non √® piccolo, controlla che `P->fd_nextsize->bk_nextsize == P` e `P->bk_nextsize->fd_nextsize == P`
* Messaggio di errore: `corrupted double-linked list (not small)`

## \_int\_malloc

Per ulteriori informazioni controlla:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Controlli durante la ricerca nel fast bin:**
* Se il chunk √® disallineato:
* Messaggio di errore: `malloc(): unaligned fastbin chunk detected 2`
* Se il chunk in avanti √® disallineato:
* Messaggio di errore: `malloc(): unaligned fastbin chunk detected`
* Se il chunk restituito ha una dimensione che non √® corretta a causa del suo indice nel fast bin:
* Messaggio di errore: `malloc(): memory corruption (fast)`
* Se qualsiasi chunk utilizzato per riempire il tcache √® disallineato:
* Messaggio di errore: `malloc(): unaligned fastbin chunk detected 3`
* **Controlli durante la ricerca nel small bin:**
* Se `victim->bk->fd != victim`:
* Messaggio di errore: `malloc(): smallbin double linked list corrupted`
* **Controlli durante la consolidazione** effettuati per ogni chunk del fast bin:&#x20;
* Se il chunk √® disallineato attiva:
* Messaggio di errore: `malloc_consolidate(): unaligned fastbin chunk detected`
* Se il chunk ha una dimensione diversa da quella che dovrebbe avere a causa dell'indice in cui si trova:
* Messaggio di errore: `malloc_consolidate(): invalid chunk size`
* Se il chunk precedente non √® in uso e il chunk precedente ha una dimensione diversa da quella indicata da prev\_chunk:
* Messaggio di errore: `corrupted size vs. prev_size in fastbins`
* **Controlli durante la ricerca nel bin non ordinato**:
* Se la dimensione del chunk √® strana (troppo piccola o troppo grande):&#x20;
* Messaggio di errore: `malloc(): invalid size (unsorted)`
* Se la dimensione del chunk successivo √® strana (troppo piccola o troppo grande):
* Messaggio di errore: `malloc(): invalid next size (unsorted)`
* Se la dimensione precedente indicata dal chunk successivo differisce dalla dimensione del chunk:
* Messaggio di errore: `malloc(): mismatching next->prev_size (unsorted)`
* Se non `victim->bck->fd == victim` o non `victim->fd == av (arena)`:
* Messaggio di errore: `malloc(): unsorted double linked list corrupted`
* Poich√© stiamo sempre controllando l'ultimo, il suo fd dovrebbe sempre puntare alla struttura arena.
* Se il chunk successivo non indica che il precedente √® in uso:
* Messaggio di errore: `malloc(): invalid next->prev_inuse (unsorted)`
* Se `fwd->bk_nextsize->fd_nextsize != fwd`:
* Messaggio di errore: `malloc(): largebin double linked list corrupted (nextsize)`
* Se `fwd->bk->fd != fwd`:
* Messaggio di errore: `malloc(): largebin double linked list corrupted (bk)`
* **Controlli durante la ricerca nel large bin (per indice):**
* `bck->fd-> bk != bck`:
* Messaggio di errore: `malloc(): corrupted unsorted chunks`
* **Controlli durante la ricerca nel large bin (prossimo pi√π grande):**
* `bck->fd-> bk != bck`:
* Messaggio di errore: `malloc(): corrupted unsorted chunks2`
* **Controlli durante l'uso del Top chunk:**
* `chunksize(av->top) > av->system_mem`:
* Messaggio di errore: `malloc(): corrupted top size`

## `tcache_get_n`

* **Controlli in `tcache_get_n`:**
* Se il chunk √® disallineato:
* Messaggio di errore: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Controlli in `tcache_thread_shutdown`:**
* Se il chunk √® disallineato:
* Messaggio di errore: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Controlli in `__libc_realloc`:**
* Se il puntatore vecchio √® disallineato o la dimensione era errata:
* Messaggio di errore: `realloc(): invalid pointer`

## `_int_free`

Per ulteriori informazioni controlla:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Controlli all'inizio di `_int_free`:**
* Il puntatore √® allineato:
* Messaggio di errore: `free(): invalid pointer`
* Dimensione maggiore di `MINSIZE` e dimensione anche allineata:
* Messaggio di errore: `free(): invalid size`
* **Controlli in `_int_free` tcache:**
* Se ci sono pi√π voci di `mp_.tcache_count`:
* Messaggio di errore: `free(): too many chunks detected in tcache`
* Se l'entrata non √® allineata:
* Messaggio di errore: `free(): unaligned chunk detected in tcache 2`
* Se il chunk liberato era gi√† stato liberato ed √® presente come chunk nel tcache:
* Messaggio di errore: `free(): double free detected in tcache 2`
* **Controlli in `_int_free` fast bin:**
* Se la dimensione del chunk √® invalida (troppo grande o piccola) attiva:
* Messaggio di errore: `free(): invalid next size (fast)`
* Se il chunk aggiunto era gi√† il top del fast bin:
* Messaggio di errore: `double free or corruption (fasttop)`
* Se la dimensione del chunk in cima ha una dimensione diversa da quella del chunk che stiamo aggiungendo:
* Messaggio di errore: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

* **Controlli in `_int_free_merge_chunk`:**
* Se il chunk √® il top chunk:
* Messaggio di errore: `double free or corruption (top)`
* Se il chunk successivo √® al di fuori dei confini dell'arena:
* Messaggio di errore: `double free or corruption (out)`
* Se il chunk non √® contrassegnato come utilizzato (nel prev\_inuse del chunk successivo):
* Messaggio di errore: `double free or corruption (!prev)`
* Se il chunk successivo ha una dimensione troppo piccola o troppo grande:
* Messaggio di errore: `free(): invalid next size (normal)`
* Se il chunk precedente non √® in uso, cercher√† di consolidare. Ma, se il `prev_size` differisce dalla dimensione indicata nel chunk precedente:
* Messaggio di errore: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Controlli in `_int_free_create_chunk`:**
* Aggiungendo un chunk nel bin non ordinato, controlla se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Messaggio di errore: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Controlli in `do_check_malloc_state`:**
* Se il fast bin chunk √® disallineato:
* Messaggio di errore: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Controlli in `malloc_consolidate`:**
* Se il fast bin chunk √® disallineato:
* Messaggio di errore: `malloc_consolidate(): unaligned fastbin chunk detected`
* Se la dimensione del fast bin chunk √® errata:
* Messaggio di errore: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Controlli in `_int_realloc`:**
* La dimensione √® troppo grande o troppo piccola:
* Messaggio di errore: `realloc(): invalid old size`
* La dimensione del chunk successivo √® troppo grande o troppo piccola:
* Messaggio di errore: `realloc(): invalid next size`

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
