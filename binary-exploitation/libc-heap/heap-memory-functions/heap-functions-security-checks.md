# 힙 함수 보안 검사

{% hint style="success" %}
AWS 해킹 학습 및 실습:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 학습 및 실습: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃허브 저장소에 PR을 제출하여 해킹 요령을 공유하세요.

</details>
{% endhint %}

## unlink

더 많은 정보는 다음을 확인하세요:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

수행된 검사의 요약입니다:

* 청크의 지정된 크기가 다음 청크에 표시된 `prev_size`와 동일한지 확인
* 오류 메시지: `corrupted size vs. prev_size`
* 또한 `P->fd->bk == P` 및 `P->bk->fw == P`인지 확인
* 오류 메시지: `corrupted double-linked list`
* 청크가 작지 않은 경우, `P->fd_nextsize->bk_nextsize == P` 및 `P->bk_nextsize->fd_nextsize == P`를 확인
* 오류 메시지: `corrupted double-linked list (not small)`

## \_int\_malloc

더 많은 정보는 다음을 확인하세요:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **빠른 bin 검색 중 수행되는 검사:**
* 청크가 정렬되지 않은 경우:
* 오류 메시지: `malloc(): unaligned fastbin chunk detected 2`
* 전진 청크가 정렬되지 않은 경우:
* 오류 메시지: `malloc(): unaligned fastbin chunk detected`
* 빠른 bin의 인덱스로 인해 반환된 청크의 크기가 올바르지 않은 경우:
* 오류 메시지: `malloc(): memory corruption (fast)`
* tcache를 채우는 데 사용된 모든 청크가 정렬되지 않은 경우:
* 오류 메시지: `malloc(): unaligned fastbin chunk detected 3`
* **작은 bin 검색 중 수행되는 검사:**
* `victim->bk->fd != victim`인 경우:
* 오류 메시지: `malloc(): smallbin double linked list corrupted`
* **합병 중 수행되는 검사** 각 빠른 bin 청크에 대해 수행됨:&#x20;
* 청크가 정렬되지 않은 경우 트리거:
* 오류 메시지: `malloc_consolidate(): unaligned fastbin chunk detected`
* 청크가 인덱스로 인해 있어야 하는 크기와 다른 경우:
* 오류 메시지: `malloc_consolidate(): invalid chunk size`
* 이전 청크가 사용 중이 아니고 이전 청크의 크기가 prev\_chunk에 의해 표시된 크기와 다른 경우:
* 오류 메시지: `corrupted size vs. prev_size in fastbins`
* **정렬되지 않은 bin 검색 중 수행되는 검사**:
* 청크 크기가 이상한 경우 (너무 작거나 너무 큼):&#x20;
* 오류 메시지: `malloc(): invalid size (unsorted)`
* 다음 청크 크기가 이상한 경우 (너무 작거나 너무 큼):
* 오류 메시지: `malloc(): invalid next size (unsorted)`
* 다음 청크가 표시하는 이전 크기가 청크의 크기와 다른 경우:
* 오류 메시지: `malloc(): mismatching next->prev_size (unsorted)`
* `victim->bck->fd == victim`이 아니거나 `victim->fd == av (arena)`가 아닌 경우:
* 오류 메시지: `malloc(): unsorted double linked list corrupted`
* 항상 마지막 것을 확인하고 있으므로, 그것의 fd는 항상 아레나 구조체를 가리켜야 함.
* 다음 청크가 이전이 사용 중이 아님을 나타내지 않는 경우:
* 오류 메시지: `malloc(): invalid next->prev_inuse (unsorted)`
* `fwd->bk_nextsize->fd_nextsize != fwd`인 경우:
* 오류 메시지: `malloc(): largebin double linked list corrupted (nextsize)`
* `fwd->bk->fd != fwd`인 경우:
* 오류 메시지: `malloc(): largebin double linked list corrupted (bk)`
* **큰 bin (인덱스별) 검색 중 수행되는 검사:**
* `bck->fd-> bk != bck`인 경우:
* 오류 메시지: `malloc(): corrupted unsorted chunks`
* **큰 bin (다음으로 더 큰) 검색 중 수행되는 검사:**
* `bck->fd-> bk != bck`인 경우:
* 오류 메시지: `malloc(): corrupted unsorted chunks2`
* **상단 청크 사용 중 수행되는 검사:**
* `chunksize(av->top) > av->system_mem`인 경우:
* 오류 메시지: `malloc(): corrupted top size`

## `tcache_get_n`

* **`tcache_get_n`에서의 검사:**
* 청크가 정렬되지 않은 경우:
* 오류 메시지: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **`tcache_thread_shutdown`에서의 검사:**
* 청크가 정렬되지 않은 경우:
* 오류 메시지: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **`__libc_realloc`에서의 검사:**
* 이전 포인터가 정렬되지 않았거나 크기가 잘못된 경우:
* 오류 메시지: `realloc(): invalid pointer`

## `_int_free`

더 많은 정보는 다음을 확인하세요:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **`_int_free` 시작 시 수행되는 검사:**
* 포인터가 정렬되어 있는지:
* 오류 메시지: `free(): invalid pointer`
* `MINSIZE`보다 크고 크기도 정렬되어 있는 경우:
* 오류 메시지: `free(): invalid size`
* **`_int_free` tcache에서의 검사:**
* `mp_.tcache_count`보다 많은 항목이 있는 경우:
* 오류 메시지: `free(): too many chunks detected in tcache`
* 항목이 정렬되어 있지 않은 경우:
* 오류 메시지: `free(): unaligned chunk detected in tcache 2`
* 이미 해제된 청크이며 tcache에 청크로서 존재하는 경우:
* 오류 메시지: `free(): double free detected in tcache 2`
* **`_int_free` fast bin에서의 검사:**
* 청크의 크기가 잘못된 경우 (너무 크거나 작음) 트리거:
* 오류 메시지: `free(): invalid next size (fast)`
* 추가된 청크가 이미 fast bin의 맨 위에 있는 경우:
* 오류 메시지: `double free or corruption (fasttop)`
* 맨 위의 청크의 크기가 추가하려는 청크의 크기와 다른 경우:
* 오류 메시지: `invalid fastbin entry (free)`
## **`_int_free_merge_chunk`**

* **`_int_free_merge_chunk`에서의 확인 사항:**
* 청크가 top 청크인 경우:
* 에러 메시지: `double free or corruption (top)`
* 다음 청크가 아레나의 경계를 벗어나는 경우:
* 에러 메시지: `double free or corruption (out)`
* 청크가 사용 중으로 표시되지 않은 경우 (다음 청크의 prev\_inuse에서):
* 에러 메시지: `double free or corruption (!prev)`
* 다음 청크의 크기가 너무 작거나 너무 큰 경우:
* 에러 메시지: `free(): invalid next size (normal)`
* 이전 청크가 사용 중이 아닌 경우, 병합을 시도합니다. 그러나, `prev_size`가 이전 청크에서 표시된 크기와 다른 경우:
* 에러 메시지: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **`_int_free_create_chunk`에서의 확인 사항:**
* 정렬되지 않은 bin에 청크를 추가할 때, `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`를 확인합니다:
* 에러 메시지: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **`do_check_malloc_state`에서의 확인 사항:**
* 정렬되지 않은 fast bin 청크가 맞지 않는 경우:
* 에러 메시지: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **`malloc_consolidate`에서의 확인 사항:**
* 정렬되지 않은 fast bin 청크가 맞지 않는 경우:
* 에러 메시지: `malloc_consolidate(): unaligned fastbin chunk detected`
* 올바르지 않은 fast bin 청크 크기인 경우:
* 에러 메시지: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **`_int_realloc`에서의 확인 사항:**
* 크기가 너무 크거나 너무 작은 경우:
* 에러 메시지: `realloc(): invalid old size`
* 다음 청크의 크기가 너무 크거나 너무 작은 경우:
* 에러 메시지: `realloc(): invalid next size`
