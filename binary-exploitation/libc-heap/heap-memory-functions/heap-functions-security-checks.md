# Heap-Funktionen Sicherheitspr√ºfungen

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## unlink

F√ºr weitere Informationen siehe:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Dies ist eine Zusammenfassung der durchgef√ºhrten Pr√ºfungen:

* √úberpr√ºfe, ob die angegebene Gr√∂√üe des Chunks mit der `prev_size` √ºbereinstimmt, die im n√§chsten Chunk angegeben ist
* Fehlermeldung: `corrupted size vs. prev_size`
* √úberpr√ºfe auch, dass `P->fd->bk == P` und `P->bk->fw == P`
* Fehlermeldung: `corrupted double-linked list`
* Wenn der Chunk nicht klein ist, √ºberpr√ºfe, dass `P->fd_nextsize->bk_nextsize == P` und `P->bk_nextsize->fd_nextsize == P`
* Fehlermeldung: `corrupted double-linked list (not small)`

## \_int\_malloc

F√ºr weitere Informationen siehe:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Pr√ºfungen w√§hrend der schnellen Bin-Suche:**
* Wenn der Chunk nicht ausgerichtet ist:
* Fehlermeldung: `malloc(): unaligned fastbin chunk detected 2`
* Wenn der vorw√§rts gerichtete Chunk nicht ausgerichtet ist:
* Fehlermeldung: `malloc(): unaligned fastbin chunk detected`
* Wenn der zur√ºckgegebene Chunk eine Gr√∂√üe hat, die aufgrund seines Index in der schnellen Bin nicht korrekt ist:
* Fehlermeldung: `malloc(): memory corruption (fast)`
* Wenn ein Chunk, der verwendet wird, um den tcache zu f√ºllen, nicht ausgerichtet ist:
* Fehlermeldung: `malloc(): unaligned fastbin chunk detected 3`
* **Pr√ºfungen w√§hrend der kleinen Bin-Suche:**
* Wenn `victim->bk->fd != victim`:
* Fehlermeldung: `malloc(): smallbin double linked list corrupted`
* **Pr√ºfungen w√§hrend der Konsolidierung** f√ºr jeden schnellen Bin-Chunk:&#x20;
* Wenn der Chunk nicht ausgerichtet ist, wird ausgel√∂st:
* Fehlermeldung: `malloc_consolidate(): unaligned fastbin chunk detected`
* Wenn der Chunk eine andere Gr√∂√üe hat als die, die er haben sollte, aufgrund des Index, in dem er sich befindet:
* Fehlermeldung: `malloc_consolidate(): invalid chunk size`
* Wenn der vorherige Chunk nicht in Gebrauch ist und der vorherige Chunk eine andere Gr√∂√üe hat als die, die von prev\_chunk angegeben ist:
* Fehlermeldung: `corrupted size vs. prev_size in fastbins`
* **Pr√ºfungen w√§hrend der unsortierten Bin-Suche**:
* Wenn die Chunk-Gr√∂√üe seltsam ist (zu klein oder zu gro√ü):&#x20;
* Fehlermeldung: `malloc(): invalid size (unsorted)`
* Wenn die Gr√∂√üe des n√§chsten Chunks seltsam ist (zu klein oder zu gro√ü):
* Fehlermeldung: `malloc(): invalid next size (unsorted)`
* Wenn die vorherige Gr√∂√üe, die vom n√§chsten Chunk angegeben wird, von der Gr√∂√üe des Chunks abweicht:
* Fehlermeldung: `malloc(): mismatching next->prev_size (unsorted)`
* Wenn nicht `victim->bck->fd == victim` oder nicht `victim->fd == av (arena)`:
* Fehlermeldung: `malloc(): unsorted double linked list corrupted`
* Da wir immer den letzten √ºberpr√ºfen, sollte sein fd immer auf die Arena-Struktur zeigen.
* Wenn der n√§chste Chunk nicht angibt, dass der vorherige in Gebrauch ist:
* Fehlermeldung: `malloc(): invalid next->prev_inuse (unsorted)`
* Wenn `fwd->bk_nextsize->fd_nextsize != fwd`:
* Fehlermeldung: `malloc(): largebin double linked list corrupted (nextsize)`
* Wenn `fwd->bk->fd != fwd`:
* Fehlermeldung: `malloc(): largebin double linked list corrupted (bk)`
* **Pr√ºfungen w√§hrend der gro√üen Bin (nach Index) Suche:**
* `bck->fd-> bk != bck`:
* Fehlermeldung: `malloc(): corrupted unsorted chunks`
* **Pr√ºfungen w√§hrend der gro√üen Bin (n√§chster gr√∂√üerer) Suche:**
* `bck->fd-> bk != bck`:
* Fehlermeldung: `malloc(): corrupted unsorted chunks2`
* **Pr√ºfungen w√§hrend der Verwendung des Top-Chunks:**
* `chunksize(av->top) > av->system_mem`:
* Fehlermeldung: `malloc(): corrupted top size`

## `tcache_get_n`

* **Pr√ºfungen in `tcache_get_n`:**
* Wenn der Chunk nicht ausgerichtet ist:
* Fehlermeldung: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Pr√ºfungen in `tcache_thread_shutdown`:**
* Wenn der Chunk nicht ausgerichtet ist:
* Fehlermeldung: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Pr√ºfungen in `__libc_realloc`:**
* Wenn der alte Zeiger nicht ausgerichtet ist oder die Gr√∂√üe falsch war:
* Fehlermeldung: `realloc(): invalid pointer`

## `_int_free`

F√ºr weitere Informationen siehe:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Pr√ºfungen zu Beginn von `_int_free`:**
* Zeiger ist ausgerichtet:
* Fehlermeldung: `free(): invalid pointer`
* Gr√∂√üe gr√∂√üer als `MINSIZE` und Gr√∂√üe ebenfalls ausgerichtet:
* Fehlermeldung: `free(): invalid size`
* **Pr√ºfungen im `_int_free` tcache:**
* Wenn es mehr Eintr√§ge als `mp_.tcache_count` gibt:
* Fehlermeldung: `free(): too many chunks detected in tcache`
* Wenn der Eintrag nicht ausgerichtet ist:
* Fehlermeldung: `free(): unaligned chunk detected in tcache 2`
* Wenn der freigegebene Chunk bereits freigegeben wurde und als Chunk im tcache vorhanden ist:
* Fehlermeldung: `free(): double free detected in tcache 2`
* **Pr√ºfungen im `_int_free` schnellen Bin:**
* Wenn die Gr√∂√üe des Chunks ung√ºltig ist (zu gro√ü oder zu klein), wird ausgel√∂st:
* Fehlermeldung: `free(): invalid next size (fast)`
* Wenn der hinzugef√ºgte Chunk bereits der Top des schnellen Bins war:
* Fehlermeldung: `double free or corruption (fasttop)`
* Wenn die Gr√∂√üe des Chunks an der Spitze eine andere Gr√∂√üe hat als der Chunk, den wir hinzuf√ºgen:
* Fehlermeldung: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

* **Pr√ºfungen in `_int_free_merge_chunk`:**
* Wenn der Chunk der Top-Chunk ist:
* Fehlermeldung: `double free or corruption (top)`
* Wenn der n√§chste Chunk au√üerhalb der Grenzen der Arena liegt:
* Fehlermeldung: `double free or corruption (out)`
* Wenn der Chunk nicht als verwendet markiert ist (im prev\_inuse des folgenden Chunks):
* Fehlermeldung: `double free or corruption (!prev)`
* Wenn der n√§chste Chunk eine zu kleine oder zu gro√üe Gr√∂√üe hat:
* Fehlermeldung: `free(): invalid next size (normal)`
* Wenn der vorherige Chunk nicht in Gebrauch ist, wird versucht, zu konsolidieren. Aber wenn die `prev_size` von der Gr√∂√üe abweicht, die im vorherigen Chunk angegeben ist:
* Fehlermeldung: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Pr√ºfungen in `_int_free_create_chunk`:**
* Hinzuf√ºgen eines Chunks in die unsortierte Bin, √ºberpr√ºfe, ob `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Fehlermeldung: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Pr√ºfungen in `do_check_malloc_state`:**
* Wenn der schnelle Bin-Chunk nicht ausgerichtet ist:
* Fehlermeldung: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Pr√ºfungen in `malloc_consolidate`:**
* Wenn der schnelle Bin-Chunk nicht ausgerichtet ist:
* Fehlermeldung: `malloc_consolidate(): unaligned fastbin chunk detected`
* Wenn die Gr√∂√üe des schnellen Bin-Chunks falsch ist:
* Fehlermeldung: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Pr√ºfungen in `_int_realloc`:**
* Gr√∂√üe ist zu gro√ü oder zu klein:
* Fehlermeldung: `realloc(): invalid old size`
* Gr√∂√üe des n√§chsten Chunks ist zu gro√ü oder zu klein:
* Fehlermeldung: `realloc(): invalid next size`

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
