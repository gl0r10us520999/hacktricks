# V√©rifications de s√©curit√© des fonctions de tas

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## unlink

Pour plus d'informations, consultez :

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Voici un r√©sum√© des v√©rifications effectu√©es :

* V√©rifiez si la taille indiqu√©e du morceau est la m√™me que le `prev_size` indiqu√© dans le morceau suivant
* Message d'erreur : `corrupted size vs. prev_size`
* V√©rifiez √©galement que `P->fd->bk == P` et `P->bk->fw == P`
* Message d'erreur : `corrupted double-linked list`
* Si le morceau n'est pas petit, v√©rifiez que `P->fd_nextsize->bk_nextsize == P` et `P->bk_nextsize->fd_nextsize == P`
* Message d'erreur : `corrupted double-linked list (not small)`

## \_int\_malloc

Pour plus d'informations, consultez :

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **V√©rifications lors de la recherche dans le fast bin :**
* Si le morceau est mal align√© :
* Message d'erreur : `malloc(): unaligned fastbin chunk detected 2`
* Si le morceau suivant est mal align√© :
* Message d'erreur : `malloc(): unaligned fastbin chunk detected`
* Si le morceau retourn√© a une taille incorrecte √† cause de son index dans le fast bin :
* Message d'erreur : `malloc(): memory corruption (fast)`
* Si un morceau utilis√© pour remplir le tcache est mal align√© :
* Message d'erreur : `malloc(): unaligned fastbin chunk detected 3`
* **V√©rifications lors de la recherche dans le small bin :**
* Si `victim->bk->fd != victim` :
* Message d'erreur : `malloc(): smallbin double linked list corrupted`
* **V√©rifications lors de la consolidation** effectu√©es pour chaque morceau de fast bin :&#x20;
* Si le morceau est mal align√©, d√©clenchez :
* Message d'erreur : `malloc_consolidate(): unaligned fastbin chunk detected`
* Si le morceau a une taille diff√©rente de celle qu'il devrait avoir √† cause de l'index dans lequel il se trouve :
* Message d'erreur : `malloc_consolidate(): invalid chunk size`
* Si le morceau pr√©c√©dent n'est pas utilis√© et que le morceau pr√©c√©dent a une taille diff√©rente de celle indiqu√©e par prev\_chunk :
* Message d'erreur : `corrupted size vs. prev_size in fastbins`
* **V√©rifications lors de la recherche dans le unsorted bin :**
* Si la taille du morceau est √©trange (trop petite ou trop grande) :&#x20;
* Message d'erreur : `malloc(): invalid size (unsorted)`
* Si la taille du morceau suivant est √©trange (trop petite ou trop grande) :
* Message d'erreur : `malloc(): invalid next size (unsorted)`
* Si la taille pr√©c√©dente indiqu√©e par le morceau suivant diff√®re de la taille du morceau :
* Message d'erreur : `malloc(): mismatching next->prev_size (unsorted)`
* Si `victim->bck->fd != victim` ou `victim->fd != av (arena)` :
* Message d'erreur : `malloc(): unsorted double linked list corrupted`
* Comme nous v√©rifions toujours le dernier, son fd devrait toujours pointer vers la structure arena.
* Si le morceau suivant n'indique pas que le pr√©c√©dent est utilis√© :
* Message d'erreur : `malloc(): invalid next->prev_inuse (unsorted)`
* Si `fwd->bk_nextsize->fd_nextsize != fwd` :
* Message d'erreur : `malloc(): largebin double linked list corrupted (nextsize)`
* Si `fwd->bk->fd != fwd` :
* Message d'erreur : `malloc(): largebin double linked list corrupted (bk)`
* **V√©rifications lors de la recherche dans le large bin (par index) :**
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc(): corrupted unsorted chunks`
* **V√©rifications lors de la recherche dans le large bin (suivant plus grand) :**
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc(): corrupted unsorted chunks2`
* **V√©rifications lors de l'utilisation du Top chunk :**
* `chunksize(av->top) > av->system_mem` :
* Message d'erreur : `malloc(): corrupted top size`

## `tcache_get_n`

* **V√©rifications dans `tcache_get_n` :**
* Si le morceau est mal align√© :
* Message d'erreur : `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **V√©rifications dans `tcache_thread_shutdown` :**
* Si le morceau est mal align√© :
* Message d'erreur : `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **V√©rifications dans `__libc_realloc` :**
* Si l'ancien pointeur est mal align√© ou si la taille √©tait incorrecte :
* Message d'erreur : `realloc(): invalid pointer`

## `_int_free`

Pour plus d'informations, consultez :

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **V√©rifications au d√©but de `_int_free` :**
* Le pointeur est align√© :
* Message d'erreur : `free(): invalid pointer`
* Taille sup√©rieure √† `MINSIZE` et taille √©galement align√©e :
* Message d'erreur : `free(): invalid size`
* **V√©rifications dans le tcache de `_int_free` :**
* S'il y a plus d'entr√©es que `mp_.tcache_count` :
* Message d'erreur : `free(): too many chunks detected in tcache`
* Si l'entr√©e n'est pas align√©e :
* Message d'erreur : `free(): unaligned chunk detected in tcache 2`
* Si le morceau lib√©r√© avait d√©j√† √©t√© lib√©r√© et est pr√©sent comme morceau dans le tcache :
* Message d'erreur : `free(): double free detected in tcache 2`
* **V√©rifications dans le fast bin de `_int_free` :**
* Si la taille du morceau est invalide (trop grande ou trop petite), d√©clenchez :
* Message d'erreur : `free(): invalid next size (fast)`
* Si le morceau ajout√© √©tait d√©j√† le haut du fast bin :
* Message d'erreur : `double free or corruption (fasttop)`
* Si la taille du morceau au sommet a une taille diff√©rente de celle du morceau que nous ajoutons :
* Message d'erreur : `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

* **V√©rifications dans `_int_free_merge_chunk` :**
* Si le morceau est le top chunk :
* Message d'erreur : `double free or corruption (top)`
* Si le morceau suivant est en dehors des limites de l'ar√®ne :
* Message d'erreur : `double free or corruption (out)`
* Si le morceau n'est pas marqu√© comme utilis√© (dans le prev\_inuse du morceau suivant) :
* Message d'erreur : `double free or corruption (!prev)`
* Si le morceau suivant a une taille trop petite ou trop grande :
* Message d'erreur : `free(): invalid next size (normal)`
* Si le morceau pr√©c√©dent n'est pas utilis√©, il essaiera de consolider. Mais, si le `prev_size` diff√®re de la taille indiqu√©e dans le morceau pr√©c√©dent :
* Message d'erreur : `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **V√©rifications dans `_int_free_create_chunk` :**
* En ajoutant un morceau dans le unsorted bin, v√©rifiez si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` :
* Message d'erreur : `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **V√©rifications dans `do_check_malloc_state` :**
* Si le fast bin chunk est mal align√© :
* Message d'erreur : `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **V√©rifications dans `malloc_consolidate` :**
* Si le fast bin chunk est mal align√© :
* Message d'erreur : `malloc_consolidate(): unaligned fastbin chunk detected`
* Si la taille du fast bin chunk est incorrecte :
* Message d'erreur : `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **V√©rifications dans `_int_realloc` :**
* La taille est trop grande ou trop petite :
* Message d'erreur : `realloc(): invalid old size`
* La taille du morceau suivant est trop grande ou trop petite :
* Message d'erreur : `realloc(): invalid next size`

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
