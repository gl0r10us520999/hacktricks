# Bins & Memory Allocations

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Temel Bilgiler

Chunk'larÄ±n nasÄ±l depolandÄ±ÄŸÄ±nÄ± daha verimli hale getirmek iÃ§in her chunk sadece bir baÄŸlÄ± liste iÃ§inde deÄŸildir, birkaÃ§ tÃ¼r vardÄ±r. Bunlar binlerdir ve 5 tÃ¼r bin vardÄ±r: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) kÃ¼Ã§Ã¼k binler, 63 bÃ¼yÃ¼k binler, 1 sÄ±ralanmamÄ±ÅŸ bin, 10 hÄ±zlÄ± bin ve her bir iÅŸ parÃ§acÄ±ÄŸÄ± iÃ§in 64 tcache bin.

Her sÄ±ralanmamÄ±ÅŸ, kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k bin iÃ§in baÅŸlangÄ±Ã§ adresi aynÄ± dizinin iÃ§indedir. 0. indeks kullanÄ±lmaz, 1 sÄ±ralanmamÄ±ÅŸ bindir, 2-64 arasÄ± kÃ¼Ã§Ã¼k binlerdir ve 65-127 arasÄ± bÃ¼yÃ¼k binlerdir.

### Tcache (Ä°ÅŸ ParÃ§acÄ±ÄŸÄ± BaÅŸÄ±na Ã–nbellek) Binleri

Ä°ÅŸ parÃ§acÄ±klarÄ± kendi heap'lerine sahip olmaya Ã§alÄ±ÅŸsalar da (bkz. [Arenas](bins-and-memory-allocations.md#arenas) ve [Subheaps](bins-and-memory-allocations.md#subheaps)), Ã§ok sayÄ±da iÅŸ parÃ§acÄ±ÄŸÄ±na sahip bir sÃ¼recin (Ã¶rneÄŸin bir web sunucusu) **baÅŸka iÅŸ parÃ§acÄ±klarÄ±yla heap'i paylaÅŸma olasÄ±lÄ±ÄŸÄ± vardÄ±r**. Bu durumda, ana Ã§Ã¶zÃ¼m **kilitlerin** kullanÄ±lmasÄ±dÄ±r, bu da **iÅŸ parÃ§acÄ±klarÄ±nÄ± Ã¶nemli Ã¶lÃ§Ã¼de yavaÅŸlatabilir**.

Bu nedenle, bir tcache, chunk'larÄ± birleÅŸtirmeyen **tek baÄŸlÄ± liste** ÅŸeklinde bir iÅŸ parÃ§acÄ±ÄŸÄ± baÅŸÄ±na hÄ±zlÄ± bir bin gibidir. Her iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n **64 tek baÄŸlÄ± tcache bin'i** vardÄ±r. Her bin, [64-bit sistemlerde 24 ile 1032B ve 32-bit sistemlerde 12 ile 516B arasÄ±nda](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) [7 aynÄ± boyutta chunk](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) alabilir.

**Bir iÅŸ parÃ§acÄ±ÄŸÄ± bir chunk'Ä± serbest bÄ±raktÄ±ÄŸÄ±nda**, **eÄŸer tcache'de tahsis edilemeyecek kadar bÃ¼yÃ¼k deÄŸilse** ve ilgili tcache bin **dolu deÄŸilse** (zaten 7 chunk), **orada tahsis edilecektir**. EÄŸer tcache'e giremiyorsa, serbest bÄ±rakma iÅŸlemini kÃ¼resel olarak gerÃ§ekleÅŸtirebilmek iÃ§in heap kilidini beklemesi gerekecektir.

**Bir chunk tahsis edildiÄŸinde**, eÄŸer **Tcache'de gerekli boyutta serbest bir chunk varsa, onu kullanacaktÄ±r**, yoksa, kÃ¼resel binlerde bir tane bulabilmek veya yenisini oluÅŸturabilmek iÃ§in heap kilidini beklemesi gerekecektir.\
AyrÄ±ca bir optimizasyon vardÄ±r, bu durumda, heap kilidi varken, iÅŸ parÃ§acÄ±ÄŸÄ± **istenen boyuttaki heap chunk'larÄ± (7) ile Tcache'ini dolduracaktÄ±r**, bÃ¶ylece daha fazlasÄ±na ihtiyaÃ§ duyarsa, Tcache'de bulacaktÄ±r.

<details>

<summary>Add a tcache chunk example</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
free(chunk);
return 0;
}
```
Derleyin ve ana fonksiyondaki ret opcode'unda bir kesme noktasÄ± ile hata ayÄ±klayÄ±n. ArdÄ±ndan gef ile kullanÄ±lan tcache bin'ini gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=1] â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```
</details>

#### Tcache YapÄ±larÄ± ve FonksiyonlarÄ±

AÅŸaÄŸÄ±daki kodda **max bins** ve **chunks per index**'i, Ã§ift serbest bÄ±rakmalarÄ± Ã¶nlemek iÃ§in oluÅŸturulan **`tcache_entry`** yapÄ±sÄ±nÄ± ve her bir thread'in bin'in her indeksine ait adresleri saklamak iÃ§in kullandÄ±ÄŸÄ± **`tcache_perthread_struct`** yapÄ±sÄ±nÄ± gÃ¶rmek mÃ¼mkÃ¼ndÃ¼r.

<details>

<summary><code>tcache_entry</code> ve <code>tcache_perthread_struct</code></summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c

/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

/* Only used to pre-fill the tunables.  */
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

/* When "x" is from chunksize().  */
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
/* When "x" is a user-provided size.  */
# define usize2tidx(x) csize2tidx (request2size (x))

/* With rounding and alignment, the bins are...
idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
idx 1   bytes 25..40 or 13..20
idx 2   bytes 41..56 or 21..28
etc.  */

/* This is another arbitrary limit, which tunables can change.  Each
tcache bin will hold at most this number of chunks.  */
# define TCACHE_FILL_COUNT 7

/* Maximum chunks in tcache bins for tunables.  This value must fit the range
of tcache->counts[] entries, else they may overflow.  */
# define MAX_TCACHE_COUNT UINT16_MAX

[...]

typedef struct tcache_entry
{
struct tcache_entry *next;
/* This field exists to detect double frees.  */
uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
per-thread cache (hence "tcache_perthread_struct").  Keeping
overall size low is mildly important.  Note that COUNTS and ENTRIES
are redundant (we could have just counted the linked list each
time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
uint16_t counts[TCACHE_MAX_BINS];
tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
</details>

`__tcache_init` fonksiyonu, `tcache_perthread_struct` objesi iÃ§in alan oluÅŸturan ve tahsis eden fonksiyondur.

<details>

<summary>tcache_init kodu</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3241C1-L3274C2

static void
tcache_init(void)
{
mstate ar_ptr;
void *victim = 0;
const size_t bytes = sizeof (tcache_perthread_struct);

if (tcache_shutting_down)
return;

arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}


if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

/* In a low memory situation, we may not be able to allocate memory
- in which case, we just keep trying later.  However, we
typically do this very early, so either there is sufficient
memory, or there isn't enough memory to do non-trivial
allocations anyway.  */
if (victim)
{
tcache = (tcache_perthread_struct *) victim;
memset (tcache, 0, sizeof (tcache_perthread_struct));
}

}
```
</details>

#### Tcache Ä°ndeksleri

Tcache, boyuta baÄŸlÄ± olarak birkaÃ§ bin iÃ§erir ve **her indeksin ilk parÃ§asÄ±na ve indeks baÅŸÄ±na parÃ§a sayÄ±sÄ±na iÅŸaret eden baÅŸlangÄ±Ã§ iÅŸaretÃ§ileri bir parÃ§a iÃ§inde bulunur**. Bu, bu bilgiyi (genellikle ilk olanÄ±) iÃ§eren parÃ§ayÄ± bulmanÄ±n, tÃ¼m tcache baÅŸlangÄ±Ã§ noktalarÄ±nÄ± ve Tcache parÃ§alarÄ±nÄ±n sayÄ±sÄ±nÄ± bulmayÄ± mÃ¼mkÃ¼n kÄ±ldÄ±ÄŸÄ± anlamÄ±na gelir.

### HÄ±zlÄ± Bins

HÄ±zlÄ± bins, **kÃ¼Ã§Ã¼k parÃ§alar iÃ§in bellek tahsisini hÄ±zlandÄ±rmak** amacÄ±yla, yakÄ±n zamanda serbest bÄ±rakÄ±lan parÃ§alarÄ± hÄ±zlÄ± eriÅŸim yapÄ±sÄ±nda tutmak iÃ§in tasarlanmÄ±ÅŸtÄ±r. Bu binler, Son Giren Ä°lk Ã‡Ä±kar (LIFO) yaklaÅŸÄ±mÄ±nÄ± kullanÄ±r, bu da **en son serbest bÄ±rakÄ±lan parÃ§anÄ±n** yeni bir tahsis talebi olduÄŸunda ilk olarak yeniden kullanÄ±lacaÄŸÄ± anlamÄ±na gelir. Bu davranÄ±ÅŸ hÄ±z aÃ§Ä±sÄ±ndan avantajlÄ±dÄ±r, Ã§Ã¼nkÃ¼ bir yÄ±ÄŸÄ±nÄ±n (LIFO) Ã¼stÃ¼nden eklemek ve Ã§Ä±karmak, bir kuyruÄŸa (FIFO) gÃ¶re daha hÄ±zlÄ±dÄ±r.

AyrÄ±ca, **hÄ±zlÄ± bins tek baÄŸlÄ± listeler** kullanÄ±r, Ã§ift baÄŸlÄ± deÄŸil, bu da hÄ±zÄ± daha da artÄ±rÄ±r. HÄ±zlÄ± bins'teki parÃ§alar komÅŸularÄ±yla birleÅŸtirilmediÄŸinden, ortadan Ã§Ä±karÄ±lmasÄ±na izin veren karmaÅŸÄ±k bir yapÄ±ya ihtiyaÃ§ yoktur. Tek baÄŸlÄ± liste, bu iÅŸlemler iÃ§in daha basit ve hÄ±zlÄ±dÄ±r.

Temelde burada olan, baÅŸlÄ±ÄŸÄ±n (kontrol edilecek ilk parÃ§aya iÅŸaretÃ§i) her zaman o boyuttaki en son serbest bÄ±rakÄ±lan parÃ§aya iÅŸaret etmesidir. Yani:

* O boyutta yeni bir parÃ§a tahsis edildiÄŸinde, baÅŸlÄ±k kullanÄ±lacak bir serbest parÃ§aya iÅŸaret eder. Bu serbest parÃ§a, kullanÄ±lacak bir sonraki parÃ§aya iÅŸaret ettiÄŸinden, bu adres baÅŸlÄ±kta saklanÄ±r, bÃ¶ylece bir sonraki tahsis nereden mevcut bir parÃ§a alacaÄŸÄ±nÄ± bilir.
* Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, serbest parÃ§a mevcut olan parÃ§anÄ±n adresini saklayacak ve bu yeni serbest bÄ±rakÄ±lan parÃ§anÄ±n adresi baÅŸlÄ±ÄŸa konulacaktÄ±r.

BaÄŸlÄ± listenin maksimum boyutu `0x80`'dir ve `0x20` boyutundaki bir parÃ§a `0` indeksinde, `0x30` boyutundaki bir parÃ§a `1` indeksinde olacak ÅŸekilde dÃ¼zenlenmiÅŸtir...

{% hint style="danger" %}
HÄ±zlÄ± bins'teki parÃ§alar mevcut olarak ayarlanmamÄ±ÅŸtÄ±r, bu nedenle Ã§evresindeki diÄŸer serbest parÃ§alarla birleÅŸtirilmek yerine bir sÃ¼re hÄ±zlÄ± bin parÃ§alarÄ± olarak tutulurlar.
{% endhint %}
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Fastbins

An array of lists holding recently freed small chunks.  Fastbins
are not doubly linked.  It is faster to single-link them, and
since chunks are never removed from the middles of these lists,
double linking is not necessary. Also, unlike regular bins, they
are not even processed in FIFO order (they use faster LIFO) since
ordering doesn't much matter in the transient contexts in which
fastbins are normally used.

Chunks in fastbins keep their inuse bit set, so they cannot
be consolidated with other free chunks. malloc_consolidate
releases all chunks in fastbins and consolidates them with
other free chunks.
*/

typedef struct malloc_chunk *mfastbinptr;
#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)


/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
```
<details>

<summary>HÄ±zlÄ± bir parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[8];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 8; i++) {
chunks[i] = malloc(24);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
Not edin ki, aynÄ± boyutta 8 parÃ§a tahsis edip serbest bÄ±rakÄ±yoruz, bÃ¶ylece tcache'i dolduruyoruz ve sekizinci parÃ§a hÄ±zlÄ± parÃ§aya kaydediliyor.

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klayÄ±n. ArdÄ±ndan `gef` ile tcache kutusunun dolu olduÄŸunu ve bir parÃ§anÄ±n hÄ±zlÄ± kutuda olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=7] â†  Chunk(addr=0xaaaaaaac1770, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1750, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1730, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1710, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16f0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16d0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20]  â†  Chunk(addr=0xaaaaaaac1790, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
Fastbins[idx=1, size=0x30] 0x00
```
</details>

### SÄ±ralanmamÄ±ÅŸ kutu

SÄ±ralanmamÄ±ÅŸ kutu, bellek tahsisini daha hÄ±zlÄ± hale getirmek iÃ§in yÄ±ÄŸÄ±n yÃ¶neticisi tarafÄ±ndan kullanÄ±lan bir **Ã¶nbellek**'tir. Ä°ÅŸte nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±: Bir program bir parÃ§a serbest bÄ±raktÄ±ÄŸÄ±nda ve bu parÃ§a bir tcache veya hÄ±zlÄ± kutuda tahsis edilemiyorsa ve Ã¼st parÃ§ayla Ã§akÄ±ÅŸmÄ±yorsa, yÄ±ÄŸÄ±n yÃ¶neticisi hemen onu belirli bir kÃ¼Ã§Ã¼k veya bÃ¼yÃ¼k kutuya koymaz. Bunun yerine, Ã¶nce **komÅŸu serbest parÃ§alarla birleÅŸtirmeyi dener** ve daha bÃ¼yÃ¼k bir serbest bellek bloÄŸu oluÅŸturur. ArdÄ±ndan, bu yeni parÃ§ayÄ± "sÄ±ralanmamÄ±ÅŸ kutu" olarak adlandÄ±rÄ±lan genel bir kutuya yerleÅŸtirir.

Bir program **bellek istediÄŸinde**, yÄ±ÄŸÄ±n yÃ¶neticisi **sÄ±ralanmamÄ±ÅŸ kutuyu kontrol eder** ve yeterli boyutta bir parÃ§a olup olmadÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼r. EÄŸer bulursa, hemen kullanÄ±r. EÄŸer sÄ±ralanmamÄ±ÅŸ kutuda uygun bir parÃ§a bulamazsa, bu listedeki tÃ¼m parÃ§alarÄ± boyutlarÄ±na gÃ¶re kÃ¼Ã§Ã¼k veya bÃ¼yÃ¼k kutularÄ±na taÅŸÄ±r.

Daha bÃ¼yÃ¼k bir parÃ§a iki yarÄ±ya bÃ¶lÃ¼nÃ¼rse ve geri kalan MINSIZE'den bÃ¼yÃ¼kse, sÄ±ralanmamÄ±ÅŸ kutuya geri yerleÅŸtirileceÄŸini unutmayÄ±n.

Yani, sÄ±ralanmamÄ±ÅŸ kutu, yakÄ±n zamanda serbest bÄ±rakÄ±lan belleÄŸi hÄ±zlÄ± bir ÅŸekilde yeniden kullanarak bellek tahsisini hÄ±zlandÄ±rmanÄ±n ve zaman alÄ±cÄ± arama ve birleÅŸtirme ihtiyaÃ§larÄ±nÄ± azaltmanÄ±n bir yoludur.

{% hint style="danger" %}
FarklÄ± kategorilerdeki parÃ§alar olsa bile, eÄŸer mevcut bir parÃ§a baÅŸka bir mevcut parÃ§a ile Ã§akÄ±ÅŸÄ±yorsa (baÅŸlangÄ±Ã§ta farklÄ± kutulara ait olsalar bile), birleÅŸtirileceklerdir.
{% endhint %}

<details>

<summary>SÄ±ralanmamÄ±ÅŸ bir parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[9];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
Not edin ki, aynÄ± boyutta 9 parÃ§a ayÄ±rÄ±p serbest bÄ±rakÄ±yoruz, bÃ¶ylece **tcache'i dolduruyoruz** ve sekizinci parÃ§a **fastbin iÃ§in Ã§ok bÃ¼yÃ¼k olduÄŸu iÃ§in** sÄ±ralanmamÄ±ÅŸ kutuda saklanÄ±yor ve dokuzuncu parÃ§a serbest bÄ±rakÄ±lmadÄ±ÄŸÄ± iÃ§in dokuzuncu ve sekizinci **Ã¼st parÃ§ayla birleÅŸtirilmiyor**.

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klayÄ±n. ArdÄ±ndan `gef` ile tcache kutusunun dolu olduÄŸunu ve bir parÃ§anÄ±n sÄ±ralanmamÄ±ÅŸ kutuda olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] unsorted_bins[0]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
```
</details>

### KÃ¼Ã§Ã¼k Bins

KÃ¼Ã§Ã¼k bins, bÃ¼yÃ¼k bins'lerden daha hÄ±zlÄ±dÄ±r ancak hÄ±zlÄ± bins'lerden daha yavaÅŸtÄ±r.

62 binin her biri **aynÄ± boyutta parÃ§alar** iÃ§erecektir: 16, 24, ... (32 bit'te maksimum boyut 504 byte ve 64 bit'te 1024 byte). Bu, bir alanÄ±n tahsis edilmesi gereken binin bulunmasÄ±nda ve bu listelerdeki giriÅŸlerin eklenip kaldÄ±rÄ±lmasÄ±nda hÄ±z saÄŸlar.

KÃ¼Ã§Ã¼k binin boyutu, binin indeksine gÃ¶re ÅŸu ÅŸekilde hesaplanÄ±r:

* En kÃ¼Ã§Ã¼k boyut: 2\*4\*indeks (Ã¶rneÄŸin, indeks 5 -> 40)
* En bÃ¼yÃ¼k boyut: 2\*8\*indeks (Ã¶rneÄŸin, indeks 5 -> 80)
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
+ SMALLBIN_CORRECTION)
```
KÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k kutular arasÄ±nda seÃ§im yapmak iÃ§in fonksiyon:
```c
#define bin_index(sz) \
((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
```
<details>

<summary>KÃ¼Ã§Ã¼k bir parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[10];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

chunks[9] = malloc(0x110);

return 0;
}
```
Not edin ki 9 adet aynÄ± boyutta parÃ§a ayÄ±rÄ±p serbest bÄ±raktÄ±ÄŸÄ±mÄ±zda, bunlar **tcache'i doldurur** ve sekizinci parÃ§a **fastbin iÃ§in Ã§ok bÃ¼yÃ¼k olduÄŸu** iÃ§in sÄ±ralanmamÄ±ÅŸ kutuda saklanÄ±r ve dokuzuncu parÃ§a serbest bÄ±rakÄ±lmadÄ±ÄŸÄ± iÃ§in dokuzuncu ve sekizinci parÃ§alar **Ã¼st parÃ§ayla birleÅŸtirilmez**. Sonra 0x110 boyutunda daha bÃ¼yÃ¼k bir parÃ§a ayÄ±rdÄ±ÄŸÄ±mÄ±zda, **sÄ±ralanmamÄ±ÅŸ kutudaki parÃ§a kÃ¼Ã§Ã¼k kutuya geÃ§er**.

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klayÄ±n. ArdÄ±ndan `gef` ile tcache kutusunun dolu olduÄŸunu ve bir parÃ§anÄ±n kÃ¼Ã§Ã¼k kutuda olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] small_bins[16]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 small non-empty bins.
```
</details>

### BÃ¼yÃ¼k kutular

KÃ¼Ã§Ã¼k kutularÄ±n sabit boyutlardaki parÃ§alarÄ± yÃ¶nettiÄŸi gibi, her **bÃ¼yÃ¼k kutu bir dizi parÃ§a boyutunu yÃ¶netir**. Bu daha esnektir ve sistemin **Ã§eÅŸitli boyutlarÄ±** ayrÄ± bir kutuya ihtiyaÃ§ duymadan karÅŸÄ±lamasÄ±na olanak tanÄ±r.

Bir bellek ayÄ±rÄ±cÄ±da, bÃ¼yÃ¼k kutular kÃ¼Ã§Ã¼k kutularÄ±n bittiÄŸi yerden baÅŸlar. BÃ¼yÃ¼k kutularÄ±n aralÄ±klarÄ± giderek bÃ¼yÃ¼r; bu, ilk kutunun 512 ile 576 byte arasÄ±ndaki parÃ§alarÄ± kapsayabileceÄŸi, bir sonraki kutunun ise 576 ile 640 byte arasÄ±ndaki parÃ§alarÄ± kapsayabileceÄŸi anlamÄ±na gelir. Bu desen devam eder ve en bÃ¼yÃ¼k kutu 1MB Ã¼zerindeki tÃ¼m parÃ§alarÄ± iÃ§erir.

BÃ¼yÃ¼k kutular, en iyi uyumu bulmak iÃ§in **farklÄ± parÃ§a boyutlarÄ± listesini sÄ±ralayÄ±p aramak zorunda olduklarÄ±ndan** kÃ¼Ã§Ã¼k kutulara kÄ±yasla daha yavaÅŸ Ã§alÄ±ÅŸÄ±r. Bir parÃ§a bÃ¼yÃ¼k bir kutuya eklendiÄŸinde, sÄ±ralanmasÄ± gerekir ve bellek tahsis edildiÄŸinde sistem doÄŸru parÃ§ayÄ± bulmalÄ±dÄ±r. Bu ek iÅŸ, onlarÄ± **daha yavaÅŸ** hale getirir, ancak bÃ¼yÃ¼k tahsisatlar kÃ¼Ã§Ã¼k olanlardan daha az yaygÄ±n olduÄŸundan, bu kabul edilebilir bir deÄŸiÅŸ tokuÅŸtur.

Åunlar vardÄ±r:

* 64B aralÄ±ÄŸÄ±nda 32 kutu (kÃ¼Ã§Ã¼k kutularla Ã§akÄ±ÅŸÄ±r)
* 512B aralÄ±ÄŸÄ±nda 16 kutu (kÃ¼Ã§Ã¼k kutularla Ã§akÄ±ÅŸÄ±r)
* 4096B aralÄ±ÄŸÄ±nda 8 kutu (kÄ±smen kÃ¼Ã§Ã¼k kutularla Ã§akÄ±ÅŸÄ±r)
* 32768B aralÄ±ÄŸÄ±nda 4 kutu
* 262144B aralÄ±ÄŸÄ±nda 2 kutu
* Kalan boyutlar iÃ§in 1 kutu

<details>

<summary>BÃ¼yÃ¼k kutu boyutlarÄ± kodu</summary>
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

#define largebin_index_32(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index_32_big(sz)                                            \
(((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index(sz) \
(SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
: largebin_index_32 (sz))
```
</details>

<details>

<summary>BÃ¼yÃ¼k bir parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[2];

chunks[0] = malloc(0x1500);
chunks[1] = malloc(0x1500);
free(chunks[0]);
chunks[0] = malloc(0x2000);

return 0;
}
```
2 bÃ¼yÃ¼k tahsis yapÄ±lÄ±r, ardÄ±ndan biri serbest bÄ±rakÄ±lÄ±r (bunu sÄ±ralanmamÄ±ÅŸ kutuya koyar) ve daha bÃ¼yÃ¼k bir tahsis yapÄ±lÄ±r (serbest olanÄ± sÄ±ralanmamÄ±ÅŸ kutudan bÃ¼yÃ¼k kutuya taÅŸÄ±r).

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klayÄ±n. ArdÄ±ndan `gef` ile tcache kutusunun dolu olduÄŸunu ve bir parÃ§anÄ±n bÃ¼yÃ¼k kutuda olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bin
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All tcachebins are empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in 0 small non-empty bins.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Large Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] large_bins[100]: fw=0xaaaaaaac1290, bk=0xaaaaaaac1290
â†’   Chunk(addr=0xaaaaaaac12a0, size=0x1510, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 large non-empty bins.
```
</details>

### Ãœst ParÃ§a
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Top

The top-most available chunk (i.e., the one bordering the end of
available memory) is treated specially. It is never included in
any bin, is used only if no other chunk is available, and is
released back to the system if it is very large (see
M_TRIM_THRESHOLD).  Because top initially
points to its own bin with initial zero size, thus forcing
extension on the first malloc request, we avoid having any special
code in malloc to check whether it even exists yet. But we still
need to do so when getting memory from system, so we make
initial_top treat the bin as a legal but unusable chunk during the
interval between initialization and the first call to
sysmalloc. (This is somewhat delicate, since it relies on
the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
```
Temelde, bu mevcut tÃ¼m yÄ±ÄŸÄ±nlarÄ± iÃ§eren bir parÃ§a. Bir malloc gerÃ§ekleÅŸtirildiÄŸinde, kullanÄ±lacak herhangi bir boÅŸ parÃ§a yoksa, bu Ã¼st parÃ§a boyutunu azaltarak gerekli alanÄ± saÄŸlar.\
Ãœst ParÃ§aya iÅŸaretÃ§i `malloc_state` yapÄ±sÄ±nda saklanÄ±r.

AyrÄ±ca, baÅŸlangÄ±Ã§ta, sÄ±ralanmamÄ±ÅŸ parÃ§ayÄ± Ã¼st parÃ§a olarak kullanmak mÃ¼mkÃ¼ndÃ¼r.

<details>

<summary>Ãœst ParÃ§a Ã¶rneÄŸini gÃ¶zlemleyin</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
return 0;
}
```
`main`'in `ret` opcode'unda bir kesme noktasÄ± ile derleyip hata ayÄ±kladÄ±ktan sonra, malloc'un `0xaaaaaaac12a0` adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ ve bunlarÄ±n parÃ§alarÄ± olduÄŸunu gÃ¶rdÃ¼m:
```bash
gefâ¤  heap chunks
Chunk(addr=0xaaaaaaac1010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac1010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12a0     41 41 41 41 41 41 41 00 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac12c0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12c0     41 64 64 72 65 73 73 20 6f 66 20 74 68 65 20 63    Address of the c]
Chunk(addr=0xaaaaaaac16d0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac16d0     41 41 41 41 41 41 41 0a 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac1ae0, size=0x20530, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  top chunk
```
Burada en Ã¼st parÃ§a adresinin `0xaaaaaaac1ae0` olduÄŸu gÃ¶rÃ¼lebilir. Bu sÃ¼rpriz deÄŸil Ã§Ã¼nkÃ¼ son tahsis edilen parÃ§a `0xaaaaaaac12a0` adresindeydi ve boyutu `0x410` idi ve `0xaaaaaaac12a0 + 0x410 = 0xaaaaaaac1ae0` .\
AyrÄ±ca, en Ã¼st parÃ§anÄ±n uzunluÄŸunu parÃ§a baÅŸlÄ±ÄŸÄ±nda gÃ¶rmek de mÃ¼mkÃ¼ndÃ¼r:
```bash
gefâ¤  x/8wx 0xaaaaaaac1ae0 - 16
0xaaaaaaac1ad0:	0x00000000	0x00000000	0x00020531	0x00000000
0xaaaaaaac1ae0:	0x00000000	0x00000000	0x00000000	0x00000000
```
</details>

### Son Kalan

malloc kullanÄ±ldÄ±ÄŸÄ±nda ve bir parÃ§a bÃ¶lÃ¼ndÃ¼ÄŸÃ¼nde (Ã¶rneÄŸin, sÄ±ralanmamÄ±ÅŸ kutudan veya Ã¼st parÃ§adan), bÃ¶lÃ¼nen parÃ§anÄ±n geri kalanÄ±ndan oluÅŸturulan parÃ§aya Son Kalan denir ve iÅŸaretÃ§isi `malloc_state` yapÄ±sÄ±nda saklanÄ±r.

## Tahsis AkÄ±ÅŸÄ±

Kontrol et:

{% content-ref url="heap-memory-functions/malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](heap-memory-functions/malloc-and-sysmalloc.md)
{% endcontent-ref %}

## Serbest AkÄ±ÅŸÄ±

Kontrol et:

{% content-ref url="heap-memory-functions/free.md" %}
[free.md](heap-memory-functions/free.md)
{% endcontent-ref %}

## YÄ±ÄŸÄ±n FonksiyonlarÄ± GÃ¼venlik Kontrolleri

YÄ±ÄŸÄ±nda yaygÄ±n olarak kullanÄ±lan fonksiyonlar tarafÄ±ndan gerÃ§ekleÅŸtirilen gÃ¼venlik kontrollerini kontrol et:

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## Referanslar

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/)

{% hint style="success" %}
AWS Hacking Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.**

</details>
{% endhint %}
