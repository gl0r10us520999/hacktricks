# Bins & Memory Allocations

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Podstawowe informacje

Aby poprawiÄ‡ efektywnoÅ›Ä‡ przechowywania kawaÅ‚kÃ³w, kaÅ¼dy kawaÅ‚ek nie jest tylko w jednej liÅ›cie powiÄ…zanej, ale istnieje kilka typÃ³w. To sÄ… pojemniki i jest 5 typÃ³w pojemnikÃ³w: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) maÅ‚e pojemniki, 63 duÅ¼e pojemniki, 1 nieposortowany pojemnik, 10 szybkie pojemniki i 64 pojemniki tcache na wÄ…tek.

PoczÄ…tkowy adres do kaÅ¼dego nieposortowanego, maÅ‚ego i duÅ¼ego pojemnika znajduje siÄ™ w tej samej tablicy. Indeks 0 jest nieuÅ¼ywany, 1 to nieposortowany pojemnik, pojemniki 2-64 to maÅ‚e pojemniki, a pojemniki 65-127 to duÅ¼e pojemniki.

### Pojemniki Tcache (Cache na wÄ…tek)

Mimo Å¼e wÄ…tki starajÄ… siÄ™ mieÄ‡ wÅ‚asny sterta (zobacz [Arenas](bins-and-memory-allocations.md#arenas) i [Subheaps](bins-and-memory-allocations.md#subheaps)), istnieje moÅ¼liwoÅ›Ä‡, Å¼e proces z wieloma wÄ…tkami (jak serwer WWW) **bÄ™dzie dzieliÄ‡ stertÄ™ z innymi wÄ…tkami**. W takim przypadku gÅ‚Ã³wnym rozwiÄ…zaniem jest uÅ¼ycie **blokad**, ktÃ³re mogÄ… **znaczÄ…co spowolniÄ‡ wÄ…tki**.

Dlatego tcache jest podobny do szybkiego pojemnika na wÄ…tek w tym, Å¼e jest to **pojedyncza lista powiÄ…zana**, ktÃ³ra nie Å‚Ä…czy kawaÅ‚kÃ³w. KaÅ¼dy wÄ…tek ma **64 pojedynczo powiÄ…zane pojemniki tcache**. KaÅ¼dy pojemnik moÅ¼e mieÄ‡ maksymalnie [7 kawaÅ‚kÃ³w o tej samej wielkoÅ›ci](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) w zakresie od [24 do 1032B na systemach 64-bitowych i od 12 do 516B na systemach 32-bitowych](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Kiedy wÄ…tek zwalnia** kawaÅ‚ek, **jeÅ›li nie jest zbyt duÅ¼y** do przydzielenia w tcache i odpowiedni pojemnik tcache **nie jest peÅ‚ny** (juÅ¼ 7 kawaÅ‚kÃ³w), **zostanie przydzielony tam**. JeÅ›li nie moÅ¼e trafiÄ‡ do tcache, bÄ™dzie musiaÅ‚ poczekaÄ‡ na blokadÄ™ sterty, aby mÃ³c wykonaÄ‡ operacjÄ™ zwolnienia globalnie.

Kiedy **kawaÅ‚ek jest przydzielany**, jeÅ›li istnieje wolny kawaÅ‚ek o potrzebnym rozmiarze w **Tcache, to go uÅ¼yje**, jeÅ›li nie, bÄ™dzie musiaÅ‚ poczekaÄ‡ na blokadÄ™ sterty, aby mÃ³c znaleÅºÄ‡ jeden w globalnych pojemnikach lub stworzyÄ‡ nowy.\
Istnieje rÃ³wnieÅ¼ optymalizacja, w tym przypadku, majÄ…c blokadÄ™ sterty, wÄ…tek **napeÅ‚ni swoje Tcache kawaÅ‚kami sterty (7) o Å¼Ä…danym rozmiarze**, wiÄ™c w przypadku potrzeby wiÄ™cej, znajdzie je w Tcache.

<details>

<summary>Dodaj przykÅ‚ad kawaÅ‚ka tcache</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
free(chunk);
return 0;
}
```
Skompiluj to i zdebuguj z punktem przerwania w opcode ret z funkcji main. NastÄ™pnie z gef moÅ¼esz zobaczyÄ‡ uÅ¼ywanÄ… bin tcache:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=1] â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```
</details>

#### Struktury i funkcje Tcache

W poniÅ¼szym kodzie moÅ¼na zobaczyÄ‡ **max bins** i **chunks per index**, strukturÄ™ **`tcache_entry`** stworzonÄ… w celu unikniÄ™cia podwÃ³jnych zwolnieÅ„ oraz **`tcache_perthread_struct`**, strukturÄ™, ktÃ³rÄ… kaÅ¼dy wÄ…tek uÅ¼ywa do przechowywania adresÃ³w do kaÅ¼dego indeksu kosza.

<details>

<summary><code>tcache_entry</code> i <code>tcache_perthread_struct</code></summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c

/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

/* Only used to pre-fill the tunables.  */
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

/* When "x" is from chunksize().  */
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
/* When "x" is a user-provided size.  */
# define usize2tidx(x) csize2tidx (request2size (x))

/* With rounding and alignment, the bins are...
idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
idx 1   bytes 25..40 or 13..20
idx 2   bytes 41..56 or 21..28
etc.  */

/* This is another arbitrary limit, which tunables can change.  Each
tcache bin will hold at most this number of chunks.  */
# define TCACHE_FILL_COUNT 7

/* Maximum chunks in tcache bins for tunables.  This value must fit the range
of tcache->counts[] entries, else they may overflow.  */
# define MAX_TCACHE_COUNT UINT16_MAX

[...]

typedef struct tcache_entry
{
struct tcache_entry *next;
/* This field exists to detect double frees.  */
uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
per-thread cache (hence "tcache_perthread_struct").  Keeping
overall size low is mildly important.  Note that COUNTS and ENTRIES
are redundant (we could have just counted the linked list each
time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
uint16_t counts[TCACHE_MAX_BINS];
tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
</details>

Funkcja `__tcache_init` jest funkcjÄ…, ktÃ³ra tworzy i przydziela miejsce dla obiektu `tcache_perthread_struct`.

<details>

<summary>kod tcache_init</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3241C1-L3274C2

static void
tcache_init(void)
{
mstate ar_ptr;
void *victim = 0;
const size_t bytes = sizeof (tcache_perthread_struct);

if (tcache_shutting_down)
return;

arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}


if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

/* In a low memory situation, we may not be able to allocate memory
- in which case, we just keep trying later.  However, we
typically do this very early, so either there is sufficient
memory, or there isn't enough memory to do non-trivial
allocations anyway.  */
if (victim)
{
tcache = (tcache_perthread_struct *) victim;
memset (tcache, 0, sizeof (tcache_perthread_struct));
}

}
```
</details>

#### Indeksy Tcache

Tcache ma kilka binÃ³w w zaleÅ¼noÅ›ci od rozmiaru, a poczÄ…tkowe wskaÅºniki do **pierwszego kawaÅ‚ka kaÅ¼dego indeksu oraz iloÅ›Ä‡ kawaÅ‚kÃ³w na indeks znajdujÄ… siÄ™ wewnÄ…trz kawaÅ‚ka**. Oznacza to, Å¼e lokalizujÄ…c kawaÅ‚ek z tymi informacjami (zwykle pierwszym), moÅ¼na znaleÅºÄ‡ wszystkie poczÄ…tkowe punkty tcache oraz iloÅ›Ä‡ kawaÅ‚kÃ³w Tcache.

### Szybkie biny

Szybkie biny sÄ… zaprojektowane w celu **przyspieszenia alokacji pamiÄ™ci dla maÅ‚ych kawaÅ‚kÃ³w** poprzez przechowywanie niedawno zwolnionych kawaÅ‚kÃ³w w strukturze szybkiego dostÄ™pu. Te biny uÅ¼ywajÄ… podejÅ›cia Last-In, First-Out (LIFO), co oznacza, Å¼e **najbardziej niedawno zwolniony kawaÅ‚ek jest pierwszym**, ktÃ³ry zostanie ponownie uÅ¼yty, gdy pojawi siÄ™ nowe Å¼Ä…danie alokacji. To zachowanie jest korzystne dla szybkoÅ›ci, poniewaÅ¼ szybciej jest wstawiaÄ‡ i usuwaÄ‡ z gÃ³ry stosu (LIFO) w porÃ³wnaniu do kolejki (FIFO).

Dodatkowo, **szybkie biny uÅ¼ywajÄ… pojedynczo powiÄ…zanych list**, a nie podwÃ³jnie powiÄ…zanych, co dodatkowo poprawia szybkoÅ›Ä‡. PoniewaÅ¼ kawaÅ‚ki w szybkich binach nie sÄ… Å‚Ä…czone z sÄ…siadami, nie ma potrzeby skomplikowanej struktury, ktÃ³ra pozwalaÅ‚aby na usuwanie z Å›rodka. Pojedynczo powiÄ…zana lista jest prostsza i szybsza dla tych operacji.

W zasadzie, co siÄ™ tutaj dzieje, to to, Å¼e nagÅ‚Ã³wek (wskaÅºnik do pierwszego kawaÅ‚ka do sprawdzenia) zawsze wskazuje na ostatnio zwolniony kawaÅ‚ek tego rozmiaru. Tak wiÄ™c:

* Gdy nowy kawaÅ‚ek jest alokowany tego rozmiaru, nagÅ‚Ã³wek wskazuje na wolny kawaÅ‚ek do uÅ¼ycia. PoniewaÅ¼ ten wolny kawaÅ‚ek wskazuje na nastÄ™pny do uÅ¼ycia, ten adres jest przechowywany w nagÅ‚Ã³wku, aby nastÄ™pna alokacja wiedziaÅ‚a, skÄ…d wziÄ…Ä‡ dostÄ™pny kawaÅ‚ek
* Gdy kawaÅ‚ek jest zwalniany, wolny kawaÅ‚ek zapisze adres do aktualnie dostÄ™pnego kawaÅ‚ka, a adres do tego nowo zwolnionego kawaÅ‚ka zostanie umieszczony w nagÅ‚Ã³wku

Maksymalny rozmiar listy powiÄ…zanej wynosi `0x80` i sÄ… one zorganizowane tak, Å¼e kawaÅ‚ek o rozmiarze `0x20` bÄ™dzie w indeksie `0`, kawaÅ‚ek o rozmiarze `0x30` bÄ™dzie w indeksie `1`...

{% hint style="danger" %}
KawaÅ‚ki w szybkich binach nie sÄ… ustawione jako dostÄ™pne, wiÄ™c sÄ… utrzymywane jako kawaÅ‚ki szybkich binÃ³w przez pewien czas, zamiast mÃ³c Å‚Ä…czyÄ‡ siÄ™ z innymi wolnymi kawaÅ‚kami je otaczajÄ…cymi.
{% endhint %}
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Fastbins

An array of lists holding recently freed small chunks.  Fastbins
are not doubly linked.  It is faster to single-link them, and
since chunks are never removed from the middles of these lists,
double linking is not necessary. Also, unlike regular bins, they
are not even processed in FIFO order (they use faster LIFO) since
ordering doesn't much matter in the transient contexts in which
fastbins are normally used.

Chunks in fastbins keep their inuse bit set, so they cannot
be consolidated with other free chunks. malloc_consolidate
releases all chunks in fastbins and consolidates them with
other free chunks.
*/

typedef struct malloc_chunk *mfastbinptr;
#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)


/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
```
<details>

<summary>Dodaj przykÅ‚ad kawaÅ‚ka fastbin</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[8];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 8; i++) {
chunks[i] = malloc(24);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 8 kawaÅ‚kÃ³w tej samej wielkoÅ›ci, aby wypeÅ‚niÅ‚y tcache, a Ã³smy jest przechowywany w szybkim kawaÅ‚ku.

Skompiluj to i zdebuguj z punktem przerwania w opcode `ret` funkcji `main`. NastÄ™pnie z `gef` moÅ¼esz zobaczyÄ‡, Å¼e bin tcache jest peÅ‚ny, a jeden kawaÅ‚ek znajduje siÄ™ w szybkim binie:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=7] â†  Chunk(addr=0xaaaaaaac1770, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1750, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1730, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1710, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16f0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16d0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20]  â†  Chunk(addr=0xaaaaaaac1790, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
Fastbins[idx=1, size=0x30] 0x00
```
</details>

### Unsorted bin

Unsorted bin to **cache** uÅ¼ywany przez menedÅ¼era pamiÄ™ci do szybszej alokacji pamiÄ™ci. Oto jak to dziaÅ‚a: Kiedy program zwalnia kawaÅ‚ek pamiÄ™ci, a ten kawaÅ‚ek nie moÅ¼e byÄ‡ przydzielony w tcache lub fast bin i nie koliduje z top chunk, menedÅ¼er pamiÄ™ci nie umieszcza go od razu w konkretnym maÅ‚ym lub duÅ¼ym binie. Zamiast tego najpierw prÃ³buje **poÅ‚Ä…czyÄ‡ go z sÄ…siednimi wolnymi kawaÅ‚kami**, aby stworzyÄ‡ wiÄ™kszy blok wolnej pamiÄ™ci. NastÄ™pnie umieszcza ten nowy kawaÅ‚ek w ogÃ³lnym binie zwanym "unsorted bin."

Kiedy program **prosi o pamiÄ™Ä‡**, menedÅ¼er pamiÄ™ci **sprawdza unsorted bin**, aby zobaczyÄ‡, czy jest kawaÅ‚ek o wystarczajÄ…cej wielkoÅ›ci. JeÅ›li znajdzie taki kawaÅ‚ek, uÅ¼ywa go od razu. JeÅ›li nie znajdzie odpowiedniego kawaÅ‚ka w unsorted bin, przenosi wszystkie kawaÅ‚ki z tej listy do ich odpowiednich binÃ³w, maÅ‚ych lub duÅ¼ych, w zaleÅ¼noÅ›ci od ich rozmiaru.

NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e jeÅ›li wiÄ™kszy kawaÅ‚ek zostanie podzielony na 2 czÄ™Å›ci, a reszta jest wiÄ™ksza niÅ¼ MINSIZE, zostanie ponownie umieszczona w unsorted bin.

Tak wiÄ™c unsorted bin to sposÃ³b na przyspieszenie alokacji pamiÄ™ci poprzez szybkie ponowne wykorzystanie niedawno zwolnionej pamiÄ™ci i zmniejszenie potrzeby czasochÅ‚onnych wyszukiwaÅ„ i Å‚Ä…czeÅ„.

{% hint style="danger" %}
NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e nawet jeÅ›li kawaÅ‚ki sÄ… rÃ³Å¼nych kategorii, jeÅ›li dostÄ™pny kawaÅ‚ek koliduje z innym dostÄ™pnym kawaÅ‚kiem (nawet jeÅ›li pierwotnie naleÅ¼Ä… do rÃ³Å¼nych binÃ³w), zostanÄ… poÅ‚Ä…czone.
{% endhint %}

<details>

<summary>Dodaj przykÅ‚ad unsorted chunk</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[9];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 9 kawaÅ‚kÃ³w tej samej wielkoÅ›ci, aby **wypeÅ‚niÄ‡ tcache**, a Ã³smy jest przechowywany w niesortowanym binie, poniewaÅ¼ jest **za duÅ¼y dla fastbin**, a dziewiÄ…ty nie jest zwolniony, wiÄ™c dziewiÄ…ty i Ã³smy **nie sÄ… scalane z gÃ³rnym kawaÅ‚kiem**.

Skompiluj to i zdebuguj z punktem przerwania w opcode `ret` z funkcji `main`. NastÄ™pnie z `gef` moÅ¼esz zobaczyÄ‡, Å¼e bin tcache jest peÅ‚ny, a jeden kawaÅ‚ek znajduje siÄ™ w niesortowanym binie:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] unsorted_bins[0]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
```
</details>

### MaÅ‚e Biny

MaÅ‚e biny sÄ… szybsze niÅ¼ duÅ¼e biny, ale wolniejsze niÅ¼ szybkie biny.

KaÅ¼dy bin z 62 bÄ™dzie miaÅ‚ **kawaÅ‚ki tej samej wielkoÅ›ci**: 16, 24, ... (z maksymalnym rozmiarem 504 bajtÃ³w w 32 bitach i 1024 w 64 bitach). To pomaga w szybkoÅ›ci znajdowania binu, w ktÃ³rym powinno byÄ‡ przydzielone miejsce, oraz w dodawaniu i usuwaniu wpisÃ³w z tych list.

Tak oblicza siÄ™ rozmiar maÅ‚ego binu w zaleÅ¼noÅ›ci od indeksu binu:

* Najmniejszy rozmiar: 2\*4\*indeks (np. indeks 5 -> 40)
* NajwiÄ™kszy rozmiar: 2\*8\*indeks (np. indeks 5 -> 80)
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
+ SMALLBIN_CORRECTION)
```
Funkcja do wyboru miÄ™dzy maÅ‚ymi a duÅ¼ymi pojemnikami:
```c
#define bin_index(sz) \
((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
```
<details>

<summary>Dodaj przykÅ‚ad maÅ‚ego kawaÅ‚ka</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[10];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

chunks[9] = malloc(0x110);

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 9 kawaÅ‚kÃ³w tej samej wielkoÅ›ci, aby **wypeÅ‚niÄ‡ tcache**, a Ã³smy jest przechowywany w niesortowanym binie, poniewaÅ¼ jest **za duÅ¼y dla fastbin**, a dziewiÄ…ty nie jest zwolniony, wiÄ™c dziewiÄ…ty i Ã³smy **nie sÄ… scalane z gÃ³rnym kawaÅ‚kiem**. NastÄ™pnie alokujemy wiÄ™kszy kawaÅ‚ek o rozmiarze 0x110, co powoduje, Å¼e **kawaÅ‚ek w niesortowanym binie trafia do maÅ‚ego binu**.

Skompiluj to i debuguj z punktem przerwania w opcode `ret` funkcji `main`. NastÄ™pnie z `gef` moÅ¼esz zobaczyÄ‡, Å¼e bin tcache jest peÅ‚ny, a jeden kawaÅ‚ek znajduje siÄ™ w maÅ‚ym binie:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] small_bins[16]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 small non-empty bins.
```
</details>

### DuÅ¼e biny

W przeciwieÅ„stwie do maÅ‚ych binÃ³w, ktÃ³re zarzÄ…dzajÄ… kawaÅ‚kami o staÅ‚ych rozmiarach, kaÅ¼dy **duÅ¼y bin obsÅ‚uguje zakres rozmiarÃ³w kawaÅ‚kÃ³w**. To jest bardziej elastyczne, pozwalajÄ…c systemowi na dostosowanie siÄ™ do **rÃ³Å¼nych rozmiarÃ³w** bez potrzeby posiadania oddzielnego binu dla kaÅ¼dego rozmiaru.

W alokatorze pamiÄ™ci, duÅ¼e biny zaczynajÄ… siÄ™ tam, gdzie koÅ„czÄ… siÄ™ maÅ‚e biny. Zakresy dla duÅ¼ych binÃ³w rosnÄ… stopniowo, co oznacza, Å¼e pierwszy bin moÅ¼e obejmowaÄ‡ kawaÅ‚ki od 512 do 576 bajtÃ³w, podczas gdy nastÄ™pny obejmuje od 576 do 640 bajtÃ³w. Ten wzÃ³r siÄ™ powtarza, a najwiÄ™kszy bin zawiera wszystkie kawaÅ‚ki powyÅ¼ej 1MB.

DuÅ¼e biny dziaÅ‚ajÄ… wolniej w porÃ³wnaniu do maÅ‚ych binÃ³w, poniewaÅ¼ muszÄ… **sortowaÄ‡ i przeszukiwaÄ‡ listÄ™ kawaÅ‚kÃ³w o rÃ³Å¼nych rozmiarach, aby znaleÅºÄ‡ najlepsze dopasowanie** dla alokacji. Gdy kawaÅ‚ek jest wstawiany do duÅ¼ego binu, musi byÄ‡ posortowany, a gdy pamiÄ™Ä‡ jest alokowana, system musi znaleÅºÄ‡ odpowiedni kawaÅ‚ek. Ta dodatkowa praca sprawia, Å¼e sÄ… **wolniejsze**, ale poniewaÅ¼ duÅ¼e alokacje sÄ… mniej powszechne niÅ¼ maÅ‚e, jest to akceptowalny kompromis.

SÄ…:

* 32 biny o zakresie 64B (kolidujÄ… z maÅ‚ymi binami)
* 16 binÃ³w o zakresie 512B (kolidujÄ… z maÅ‚ymi binami)
* 8 binÃ³w o zakresie 4096B (czÄ™Å›ciowo kolidujÄ… z maÅ‚ymi binami)
* 4 biny o zakresie 32768B
* 2 biny o zakresie 262144B
* 1 bin dla pozostaÅ‚ych rozmiarÃ³w

<details>

<summary>Kod rozmiarÃ³w duÅ¼ych binÃ³w</summary>
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

#define largebin_index_32(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index_32_big(sz)                                            \
(((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index(sz) \
(SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
: largebin_index_32 (sz))
```
</details>

<details>

<summary>Dodaj przykÅ‚ad duÅ¼ego kawaÅ‚ka</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[2];

chunks[0] = malloc(0x1500);
chunks[1] = malloc(0x1500);
free(chunks[0]);
chunks[0] = malloc(0x2000);

return 0;
}
```
2 duÅ¼e alokacje sÄ… wykonywane, nastÄ™pnie jedna jest zwalniana (umieszczajÄ…c jÄ… w nieposortowanej binie), a nastÄ™pnie dokonywana jest wiÄ™ksza alokacja (przenoszÄ…c zwolnionÄ… z nieposortowanej biny do duÅ¼ej biny).

Skompiluj to i zdebuguj z punktem przerwania w opcode `ret` z funkcji `main`. NastÄ™pnie z `gef` moÅ¼esz zobaczyÄ‡, Å¼e bin tcache jest peÅ‚ny, a jeden kawaÅ‚ek znajduje siÄ™ w duÅ¼ej binie:
```bash
gefâ¤  heap bin
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All tcachebins are empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in 0 small non-empty bins.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Large Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] large_bins[100]: fw=0xaaaaaaac1290, bk=0xaaaaaaac1290
â†’   Chunk(addr=0xaaaaaaac12a0, size=0x1510, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 large non-empty bins.
```
</details>

### GÃ³rny kawaÅ‚ek
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Top

The top-most available chunk (i.e., the one bordering the end of
available memory) is treated specially. It is never included in
any bin, is used only if no other chunk is available, and is
released back to the system if it is very large (see
M_TRIM_THRESHOLD).  Because top initially
points to its own bin with initial zero size, thus forcing
extension on the first malloc request, we avoid having any special
code in malloc to check whether it even exists yet. But we still
need to do so when getting memory from system, so we make
initial_top treat the bin as a legal but unusable chunk during the
interval between initialization and the first call to
sysmalloc. (This is somewhat delicate, since it relies on
the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
```
W zasadzie jest to kawaÅ‚ek zawierajÄ…cy caÅ‚Ä… aktualnie dostÄ™pnÄ… pamiÄ™Ä‡ na stercie. Gdy wykonywana jest operacja malloc, jeÅ›li nie ma dostÄ™pnego wolnego kawaÅ‚ka do uÅ¼ycia, ten kawaÅ‚ek na gÃ³rze zmniejszy swÃ³j rozmiar, aby daÄ‡ potrzebnÄ… przestrzeÅ„.\
WskaÅºnik do Top Chunk jest przechowywany w strukturze `malloc_state`.

Ponadto, na poczÄ…tku moÅ¼liwe jest uÅ¼ycie nieposortowanego kawaÅ‚ka jako top chunk.

<details>

<summary>Obserwuj przykÅ‚ad Top Chunk</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
return 0;
}
```
Po skompilowaniu i zdebuggowaniu go z punktem przerwania w opcode `ret` funkcji `main` zobaczyÅ‚em, Å¼e malloc zwrÃ³ciÅ‚ adres `0xaaaaaaac12a0`, a oto kawaÅ‚ki:
```bash
gefâ¤  heap chunks
Chunk(addr=0xaaaaaaac1010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac1010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12a0     41 41 41 41 41 41 41 00 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac12c0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12c0     41 64 64 72 65 73 73 20 6f 66 20 74 68 65 20 63    Address of the c]
Chunk(addr=0xaaaaaaac16d0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac16d0     41 41 41 41 41 41 41 0a 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac1ae0, size=0x20530, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  top chunk
```
Gdzie moÅ¼na zobaczyÄ‡, Å¼e gÃ³rny kawaÅ‚ek znajduje siÄ™ pod adresem `0xaaaaaaac1ae0`. To nie jest zaskoczeniem, poniewaÅ¼ ostatnio przydzielony kawaÅ‚ek znajdowaÅ‚ siÄ™ w `0xaaaaaaac12a0` o rozmiarze `0x410`, a `0xaaaaaaac12a0 + 0x410 = 0xaaaaaaac1ae0`.\
MoÅ¼na rÃ³wnieÅ¼ zobaczyÄ‡ dÅ‚ugoÅ›Ä‡ gÃ³rnego kawaÅ‚ka w jego nagÅ‚Ã³wku kawaÅ‚ka:
```bash
gefâ¤  x/8wx 0xaaaaaaac1ae0 - 16
0xaaaaaaac1ad0:	0x00000000	0x00000000	0x00020531	0x00000000
0xaaaaaaac1ae0:	0x00000000	0x00000000	0x00000000	0x00000000
```
</details>

### Ostatni Reszta

Gdy uÅ¼ywana jest funkcja malloc i kawaÅ‚ek jest dzielony (na przykÅ‚ad z nieposortowanego koszyka lub z gÃ³rnego kawaÅ‚ka), kawaÅ‚ek utworzony z reszty podzielonego kawaÅ‚ka nazywany jest OstatniÄ… ResztÄ…, a jego wskaÅºnik jest przechowywany w strukturze `malloc_state`.

## PrzepÅ‚yw Alokacji

SprawdÅº:

{% content-ref url="heap-memory-functions/malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](heap-memory-functions/malloc-and-sysmalloc.md)
{% endcontent-ref %}

## PrzepÅ‚yw Zwolnienia

SprawdÅº:

{% content-ref url="heap-memory-functions/free.md" %}
[free.md](heap-memory-functions/free.md)
{% endcontent-ref %}

## Kontrole BezpieczeÅ„stwa Funkcji Stosu

SprawdÅº kontrole bezpieczeÅ„stwa wykonywane przez czÄ™sto uÅ¼ywane funkcje w stosie w:

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## Referencje

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/)

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}
