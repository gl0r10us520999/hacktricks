# CGroups

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Treinamento HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Treinamento HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

**Linux Control Groups**, ou **cgroups**, s√£o um recurso do kernel Linux que permite a aloca√ß√£o, limita√ß√£o e prioriza√ß√£o de recursos do sistema como CPU, mem√≥ria e E/S de disco entre grupos de processos. Eles oferecem um mecanismo para **gerenciar e isolar o uso de recursos** de cole√ß√µes de processos, ben√©fico para fins como limita√ß√£o de recursos, isolamento de carga de trabalho e prioriza√ß√£o de recursos entre diferentes grupos de processos.

Existem **duas vers√µes de cgroups**: vers√£o 1 e vers√£o 2. Ambas podem ser usadas simultaneamente em um sistema. A distin√ß√£o principal √© que **cgroups vers√£o 2** introduz uma **estrutura hier√°rquica em forma de √°rvore**, permitindo uma distribui√ß√£o de recursos mais detalhada e sutil entre grupos de processos. Al√©m disso, a vers√£o 2 traz v√°rias melhorias, incluindo:

Al√©m da nova organiza√ß√£o hier√°rquica, cgroups vers√£o 2 tamb√©m introduziu **outras mudan√ßas e melhorias**, como suporte para **novos controladores de recursos**, melhor suporte para aplicativos legados e melhor desempenho.

No geral, cgroups **vers√£o 2 oferece mais recursos e melhor desempenho** do que a vers√£o 1, mas esta √∫ltima ainda pode ser usada em certos cen√°rios onde a compatibilidade com sistemas mais antigos √© uma preocupa√ß√£o.

Voc√™ pode listar os cgroups v1 e v2 para qualquer processo olhando para o arquivo cgroup em /proc/\<pid>. Voc√™ pode come√ßar olhando para os cgroups do seu shell com este comando:
```shell-session
$ cat /proc/self/cgroup
12:rdma:/
11:net_cls,net_prio:/
10:perf_event:/
9:cpuset:/
8:cpu,cpuacct:/user.slice
7:blkio:/user.slice
6:memory:/user.slice 5:pids:/user.slice/user-1000.slice/session-2.scope 4:devices:/user.slice
3:freezer:/
2:hugetlb:/testcgroup
1:name=systemd:/user.slice/user-1000.slice/session-2.scope
0::/user.slice/user-1000.slice/session-2.scope
```
A estrutura de sa√≠da √© a seguinte:

* **N√∫meros 2-12**: cgroups v1, com cada linha representando um cgroup diferente. Os controladores para estes s√£o especificados ao lado do n√∫mero.
* **N√∫mero 1**: Tamb√©m cgroups v1, mas exclusivamente para fins de gerenciamento (definido por, por exemplo, systemd), e n√£o possui um controlador.
* **N√∫mero 0**: Representa cgroups v2. Nenhum controlador √© listado, e esta linha √© exclusiva em sistemas que executam apenas cgroups v2.
* Os **nomes s√£o hier√°rquicos**, assemelhando-se a caminhos de arquivos, indicando a estrutura e rela√ß√£o entre diferentes cgroups.
* Nomes como /user.slice ou /system.slice especificam a categoriza√ß√£o de cgroups, com user.slice tipicamente para sess√µes de login gerenciadas pelo systemd e system.slice para servi√ßos do sistema.

### Visualizando cgroups

O sistema de arquivos √© tipicamente utilizado para acessar **cgroups**, divergindo da interface de chamada de sistema Unix tradicionalmente usada para intera√ß√µes com o kernel. Para investigar a configura√ß√£o de cgroups de um shell, deve-se examinar o arquivo **/proc/self/cgroup**, que revela o cgroup do shell. Em seguida, navegando at√© o diret√≥rio **/sys/fs/cgroup** (ou **`/sys/fs/cgroup/unified`**), e localizando um diret√≥rio que compartilha o nome do cgroup, pode-se observar v√°rias configura√ß√µes e informa√ß√µes de uso de recursos pertinentes ao cgroup.

![Sistema de Arquivos Cgroup](<../../../.gitbook/assets/image (1128).png>)

Os arquivos de interface chave para cgroups s√£o prefixados com **cgroup**. O arquivo **cgroup.procs**, que pode ser visualizado com comandos padr√£o como cat, lista os processos dentro do cgroup. Outro arquivo, **cgroup.threads**, inclui informa√ß√µes sobre threads.

![Cgroup Procs](<../../../.gitbook/assets/image (281).png>)

Cgroups que gerenciam shells normalmente englobam dois controladores que regulam o uso de mem√≥ria e a contagem de processos. Para interagir com um controlador, deve-se consultar os arquivos com o prefixo do controlador. Por exemplo, **pids.current** seria referenciado para determinar a contagem de threads no cgroup.

![Mem√≥ria do Cgroup](<../../../.gitbook/assets/image (677).png>)

A indica√ß√£o de **max** em um valor sugere a aus√™ncia de um limite espec√≠fico para o cgroup. No entanto, devido √† natureza hier√°rquica dos cgroups, limites podem ser impostos por um cgroup em um n√≠vel inferior na hierarquia de diret√≥rios.

### Manipulando e Criando cgroups

Processos s√£o atribu√≠dos a cgroups escrevendo seu ID de Processo (PID) no arquivo `cgroup.procs`. Isso requer privil√©gios de root. Por exemplo, para adicionar um processo:
```bash
echo [pid] > cgroup.procs
```
Da mesma forma, **modificar atributos do cgroup, como definir um limite de PID**, √© feito escrevendo o valor desejado no arquivo relevante. Para definir um m√°ximo de 3.000 PIDs para um cgroup:
```bash
echo 3000 > pids.max
```
**Criar novos cgroups** envolve criar um novo subdiret√≥rio dentro da hierarquia do cgroup, o que faz com que o kernel gere automaticamente os arquivos de interface necess√°rios. Embora cgroups sem processos ativos possam ser removidos com `rmdir`, esteja ciente de certas restri√ß√µes:

- **Os processos s√≥ podem ser colocados em cgroups folha** (ou seja, os mais aninhados em uma hierarquia).
- **Um cgroup n√£o pode possuir um controlador ausente em seu pai**.
- **Controladores para cgroups filhos devem ser declarados explicitamente** no arquivo `cgroup.subtree_control`. Por exemplo, para habilitar os controladores de CPU e PID em um cgroup filho:
```bash
echo "+cpu +pids" > cgroup.subtree_control
```
O **cgroup raiz** √© uma exce√ß√£o a essas regras, permitindo o posicionamento direto de processos. Isso pode ser usado para remover processos do gerenciamento do systemd.

**Monitorar o uso da CPU** dentro de um cgroup √© poss√≠vel atrav√©s do arquivo `cpu.stat`, exibindo o tempo total de CPU consumido, √∫til para rastrear o uso em subprocessos de um servi√ßo:

<figure><img src="../../../.gitbook/assets/image (908).png" alt=""><figcaption><p>Estat√≠sticas de uso da CPU conforme mostrado no arquivo cpu.stat</p></figcaption></figure>

## Refer√™ncias

* **Livro: How Linux Works, 3¬™ Edi√ß√£o: O Que Todo Superusu√°rio Deve Saber Por Brian Ward**
