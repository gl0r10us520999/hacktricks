# CGroups

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** 💬 [**στην ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα χάκερ κάνοντας υποβολή PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του GitHub.

</details>
{% endhint %}

## Βασικές Πληροφορίες

**Οι Ομάδες Ελέγχου Linux**, ή **cgroups**, είναι μια λειτουργία του πυρήνα του Linux που επιτρέπει την κατανομή, περιορισμό και προτεραιοποίηση των πόρων του συστήματος όπως CPU, μνήμη και διακίνηση δίσκου μεταξύ ομάδων διεργασιών. Προσφέρουν ένα μηχανισμό για τη **διαχείριση και απομόνωση της χρήσης πόρων** συλλογών διεργασιών, χρήσιμος για σκοπούς όπως περιορισμός πόρων, απομόνωση φορτίου εργασίας και προτεραιοποίηση πόρων μεταξύ διαφορετικών ομάδων διεργασιών.

Υπάρχουν **δύο εκδόσεις των cgroups**: έκδοση 1 και έκδοση 2. Και οι δύο μπορούν να χρησιμοποιηθούν ταυτόχρονα σε ένα σύστημα. Η κύρια διάκριση είναι ότι η **έκδοση 2 των cgroups** εισάγει μια **ιεραρχική, δενδρική δομή**, επιτρέποντας πιο λεπτομερή κατανομή πόρων μεταξύ ομάδων διεργασιών. Επιπλέον, η έκδοση 2 φέρνει διάφορες βελτιώσεις, συμπεριλαμβανομένων:

Εκτός από τη νέα ιεραρχική οργάνωση, η έκδοση 2 των cgroups εισήγαγε επίσης **πολλές άλλες αλλαγές και βελτιώσεις**, όπως υποστήριξη για **νέους ελεγκτές πόρων**, καλύτερη υποστήριξη για παλαιές εφαρμογές και βελτιωμένη απόδοση.

Συνολικά, η έκδοση 2 των cgroups προσφέρει περισσότερες λειτουργίες και καλύτερη απόδοση από την έκδοση 1, αλλά η τελευταία εξακολουθεί να χρησιμοποιείται σε ορισμένα σενάρια όπου η συμβατότητα με παλαιότερα συστήματα είναι ανησυχία.

Μπορείτε να εμφανίσετε τα cgroups v1 και v2 για οποιαδήποτε διεργασία διαβάζοντας το αρχείο cgroup της /proc/\<pid>. Μπορείτε να ξεκινήσετε ελέγχοντας τα cgroups του κέλυφος σας με αυτήν την εντολή:
```shell-session
$ cat /proc/self/cgroup
12:rdma:/
11:net_cls,net_prio:/
10:perf_event:/
9:cpuset:/
8:cpu,cpuacct:/user.slice
7:blkio:/user.slice
6:memory:/user.slice 5:pids:/user.slice/user-1000.slice/session-2.scope 4:devices:/user.slice
3:freezer:/
2:hugetlb:/testcgroup
1:name=systemd:/user.slice/user-1000.slice/session-2.scope
0::/user.slice/user-1000.slice/session-2.scope
```
### Προβολή cgroups

Η δομή εξόδου είναι η ακόλουθη:

* **Αριθμοί 2-12**: cgroups v1, με κάθε γραμμή να αντιστοιχεί σε διαφορετικό cgroup. Οι ελεγκτές για αυτούς καθορίζονται δίπλα στον αριθμό.
* **Αριθμός 1**: Επίσης cgroups v1, αλλά αποκλειστικά για σκοπούς διαχείρισης (ορίζεται από, π.χ., το systemd), και λείπει ένας ελεγκτής.
* **Αριθμός 0**: Αντιπροσωπεύει cgroups v2. Δεν αναφέρονται ελεγκτές, και αυτή η γραμμή είναι αποκλειστική σε συστήματα που εκτελούν μόνο cgroups v2.
* Τα **ονόματα είναι ιεραρχικά**, μοιάζοντας με διαδρομές αρχείων, υποδεικνύοντας τη δομή και τη σχέση μεταξύ διαφορετικών cgroups.
* **Ονόματα όπως /user.slice ή /system.slice** υποδεικνύουν την κατηγοριοποίηση των cgroups, με το user.slice συνήθως για συνεδρίες σύνδεσης που διαχειρίζεται το systemd και το system.slice για υπηρεσίες συστήματος.

Το σύστημα αρχείων χρησιμοποιείται τυπικά για την πρόσβαση στα **cgroups**, αποκλίνοντας από τη διεπαφή κλήσης συστήματος Unix που χρησιμοποιείται παραδοσιακά για τις διεπικοινωνίες πυρήνα. Για να εξετάσετε τη διαμόρφωση cgroup ενός κελύφους, πρέπει να εξετάσετε το αρχείο **/proc/self/cgroup**, το οποίο αποκαλύπτει το cgroup του κελύφους. Στη συνέχεια, πλοηγούμενοι στον κατάλογο **/sys/fs/cgroup** (ή **`/sys/fs/cgroup/unified`**) και εντοπίζοντας έναν κατάλογο που μοιράζεται το όνομα του cgroup, μπορεί κανείς να παρατηρήσει διάφορες ρυθμίσεις και πληροφορίες χρήσης πόρων που αφορούν το cgroup.

![Σύστημα Αρχείων Cgroup](<../../../.gitbook/assets/image (1128).png>)

Τα κύρια αρχεία διεπαφής για τα cgroups έχουν πρόθεμα **cgroup**. Το αρχείο **cgroup.procs**, το οποίο μπορεί να προβληθεί με τυπικές εντολές όπως cat, αναφέρει τις διεργασίες εντός του cgroup. Ένα άλλο αρχείο, **cgroup.threads**, περιλαμβάνει πληροφορίες νημάτων.

![Cgroup Διεργασίες](<../../../.gitbook/assets/image (281).png>)

Τα cgroups που διαχειρίζονται κελύφη συνήθως περιλαμβάνουν δύο ελεγκτές που ρυθμίζουν τη χρήση μνήμης και τον αριθμό διεργασιών. Για να αλληλεπιδράσετε με έναν ελεγκτή, πρέπει να εξετάσετε τα αρχεία που φέρουν το πρόθεμα του ελεγκτή. Για παράδειγμα, το **pids.current** θα αναφερθεί για να διαπιστώσει τον αριθμό των νημάτων στο cgroup.

![Cgroup Μνήμη](<../../../.gitbook/assets/image (677).png>)

Η ένδειξη **max** σε μια τιμή υποδηλώνει την απουσία συγκεκριμένου ορίου για το cgroup. Ωστόσο, λόγω της ιεραρχικής φύσης των cgroups, τα όρια ενδέχεται να επιβάλλονται από ένα cgroup σε χαμηλότερο επίπεδο στην ιεραρχία καταλόγων.

### Επεξεργασία και Δημιουργία cgroups

Οι διεργασίες ανατίθενται σε cgroups με το **γράψιμο του Αναγνωριστικού Διεργασίας (PID) τους στο αρχείο `cgroup.procs`**. Αυτό απαιτεί δικαιώματα ρίζας. Για παράδειγμα, για να προσθέσετε μια διεργασία:
```bash
echo [pid] > cgroup.procs
```
Αντίστοιχα, **η τροποποίηση των χαρακτηριστικών του cgroup, όπως η ρύθμιση ενός ορίου PID**, γίνεται με τον εγγραφή της επιθυμητής τιμής στο σχετικό αρχείο. Για να ορίσετε ένα μέγιστο των 3.000 PIDs για ένα cgroup:
```bash
echo 3000 > pids.max
```
**Δημιουργία νέων cgroups** περιλαμβάνει τη δημιουργία ενός νέου υποκαταλόγου εντός της ιεραρχίας cgroup, η οποία προκαλεί τον πυρήνα να δημιουργήσει αυτόματα τα απαραίτητα αρχεία διεπαφής. Αν και τα cgroups χωρίς ενεργές διεργασίες μπορούν να αφαιρεθούν με `rmdir`, να λάβετε υπόψη ορισμένους περιορισμούς:

* **Οι διεργασίες μπορούν να τοποθετηθούν μόνο σε leaf cgroups** (δηλαδή, στους πιο εσωτερικούς σε μια ιεραρχία).
* **Ένα cgroup δεν μπορεί να έχει έναν ελεγκτή που λείπει από τον γονικό του**.
* **Οι ελεγκτές για τα παιδικά cgroups πρέπει να δηλωθούν ρητά** στο αρχείο `cgroup.subtree_control`. Για παράδειγμα, για να ενεργοποιήσετε τους ελεγκτές CPU και PID σε ένα παιδικό cgroup:
```bash
echo "+cpu +pids" > cgroup.subtree_control
```
Το **root cgroup** είναι μια εξαίρεση από αυτούς τους κανόνες, επιτρέποντας την άμεση τοποθέτηση διεργασιών. Αυτό μπορεί να χρησιμοποιηθεί για να αφαιρέσετε διεργασίες από τη διαχείριση του systemd.

**Η παρακολούθηση της χρήσης CPU** εντός ενός cgroup είναι δυνατή μέσω του αρχείου `cpu.stat`, εμφανίζοντας το συνολικό χρόνο CPU που καταναλώθηκε, χρήσιμο για την παρακολούθηση της χρήσης ανάμεσα στις υποδιεργασίες ενός υπηρεσίας:

<figure><img src="../../../.gitbook/assets/image (908).png" alt=""><figcaption><p>Στατιστικά χρήσης CPU όπως φαίνονται στο αρχείο cpu.stat</p></figcaption></figure>

## Αναφορές

* **Βιβλίο: How Linux Works, 3η έκδοση: Αυτό που Κάθε Υπερχρήστης Πρέπει να Γνωρίζει Από τον Brian Ward**
