# 스택 카나리

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop) 확인하기!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 리포지토리에 PR을 제출하여 해킹 트릭을 공유하세요.**

</details>
{% endhint %}

## **스택가드 및 스택쉴드**

**스택가드**는 **EIP (Extended Instruction Pointer)** 앞에 **카나리**로 알려진 특별한 값을 삽입합니다. 이 값은 `0x000aff0d`로, 널, 줄 바꿈, EOF, 캐리지 리턴을 나타내어 버퍼 오버플로우로부터 보호합니다. 그러나 `recv()`, `memcpy()`, `read()`, `bcopy()`와 같은 함수는 여전히 취약하며, **EBP (Base Pointer)**를 보호하지 않습니다.

**스택쉴드**는 **글로벌 리턴 스택**을 유지하여 모든 리턴 주소(**EIPs**)를 저장함으로써 스택가드보다 더 정교한 접근 방식을 취합니다. 이 설정은 오버플로우가 발생하더라도 해를 끼치지 않도록 하며, 저장된 주소와 실제 리턴 주소를 비교하여 오버플로우 발생 여부를 감지할 수 있습니다. 또한, 스택쉴드는 리턴 주소를 경계 값과 비교하여 **EIP**가 예상 데이터 공간 외부를 가리키는지 확인할 수 있습니다. 그러나 이 보호는 Return-to-libc, ROP (Return-Oriented Programming) 또는 ret2ret와 같은 기술을 통해 우회될 수 있어, 스택쉴드도 지역 변수를 보호하지 않습니다.

## **스택 스매시 프로텍터 (ProPolice) `-fstack-protector`:**

이 메커니즘은 **EBP** 앞에 **카나리**를 배치하고, 지역 변수를 재조직하여 버퍼를 더 높은 메모리 주소에 위치시켜 다른 변수를 덮어쓰지 않도록 합니다. 또한, 지역 변수 위에 스택에서 전달된 인수를 안전하게 복사하고 이 복사본을 인수로 사용합니다. 그러나 8개 미만의 요소를 가진 배열이나 사용자 구조 내의 버퍼는 보호하지 않습니다.

**카나리**는 `/dev/urandom`에서 파생된 랜덤 숫자이거나 기본값 `0xff0a0000`입니다. 이는 **TLS (Thread Local Storage)**에 저장되어, 스레드 간에 공유 메모리 공간이 스레드별 글로벌 또는 정적 변수를 가질 수 있도록 합니다. 이러한 변수는 처음에 부모 프로세스에서 복사되며, 자식 프로세스는 부모나 형제에게 영향을 주지 않고 데이터를 변경할 수 있습니다. 그럼에도 불구하고 **`fork()`를 사용하여 새로운 카나리를 생성하지 않으면 모든 프로세스(부모 및 자식)가 동일한 카나리를 공유하게 되어 취약해집니다.** **i386** 아키텍처에서는 카나리가 `gs:0x14`에 저장되고, **x86\_64**에서는 `fs:0x28`에 저장됩니다.

이 지역 보호는 공격에 취약한 버퍼가 있는 함수를 식별하고, 이러한 함수의 시작 부분에 카나리를 배치하기 위해 코드를 주입하며, 끝 부분에서 그 무결성을 확인합니다.

웹 서버가 `fork()`를 사용할 때, 카나리 바이트를 바이트 단위로 추측하는 무차별 대입 공격을 가능하게 합니다. 그러나 `fork()` 후에 `execve()`를 사용하면 메모리 공간이 덮어쓰여져 공격이 무효화됩니다. `vfork()`는 자식 프로세스가 쓰기를 시도할 때까지 복제를 하지 않고 실행할 수 있게 하여, 그 시점에 복제가 생성되어 프로세스 생성 및 메모리 처리에 대한 다른 접근 방식을 제공합니다.

### 길이

`x64` 바이너리에서 카나리 쿠키는 **`0x8`** 바이트 쿼드워드입니다. **첫 7바이트는 랜덤**이고 마지막 바이트는 **널 바이트**입니다.

`x86` 바이너리에서 카나리 쿠키는 **`0x4`** 바이트 더블워드입니다. **첫 3바이트는 랜덤**이고 마지막 바이트는 **널 바이트**입니다.

{% hint style="danger" %}
두 카나리의 가장 낮은 유효 바이트는 널 바이트입니다. 이는 스택에서 낮은 주소에서 오는 첫 번째 바이트이기 때문에 **문자열을 읽는 함수는 이를 읽기 전에 멈춥니다.**
{% endhint %}

## 우회

**카나리를 유출한 후** 자신의 값으로 덮어쓰는 것(예: 버퍼 오버플로우).

* **자식 프로세스에서 카나리가 포크되면** 한 바이트씩 **무차별 대입**이 가능할 수 있습니다:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* 바이너리에 흥미로운 **유출 또는 임의 읽기 취약점**이 있다면 이를 유출할 수 있습니다:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **스택에 저장된 포인터 덮어쓰기**

스택 오버플로우에 취약한 스택은 **덮어쓸 수 있는 문자열 또는 함수의 주소를 포함할 수 있습니다**. 이를 통해 스택 카나리에 도달할 필요 없이 취약점을 악용할 수 있습니다. 확인하세요:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **마스터 및 스레드 카나리 모두 수정하기**

카나리로 보호된 스레드 함수에서의 버퍼 오버플로우는 스레드의 마스터 카나리를 수정하는 데 사용될 수 있습니다. 결과적으로, 두 개의 동일한(수정된) 카나리를 사용하여 검사를 수행하므로 완화가 무용지물이 됩니다.

* **`__stack_chk_fail`의 GOT 항목 수정하기**

바이너리에 Partial RELRO가 있는 경우, 임의 쓰기를 사용하여 `__stack_chk_fail`의 GOT 항목을 수정하여 카나리가 수정되더라도 프로그램을 차단하지 않는 더미 함수로 만들 수 있습니다.

## 참고 문헌

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64비트, PIE 없음, nx, 스레드 및 마스터 카나리 수정.
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* 64비트, PIE 없음, nx, write-what-where 원시. `__stack_chk_fail`의 GOT 항목 수정.

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop) 확인하기!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 리포지토리에 PR을 제출하여 해킹 트릭을 공유하세요.**

</details>
{% endhint %}
