# Stack Canaries

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PR's in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **StackGuard en StackShield**

**StackGuard** voeg 'n spesiale waarde bekend as 'n **canary** voor die **EIP (Extended Instruction Pointer)** in, spesifiek `0x000aff0d` (wat null, newline, EOF, carriage return verteenwoordig) om teen buffer oorgange te beskerm. Tog bly funksies soos `recv()`, `memcpy()`, `read()`, en `bcopy()` kwesbaar, en dit beskerm nie die **EBP (Base Pointer)** nie.

**StackShield** neem 'n meer gesofistikeerde benadering as StackGuard deur 'n **Global Return Stack** te handhaaf, wat alle terugkeer adresse (**EIPs**) stoor. Hierdie opstelling verseker dat enige oorgang nie skade aanrig nie, aangesien dit 'n vergelyking tussen gestoor en werklike terugkeer adresse toelaat om oorgang voorvalle te ontdek. Boonop kan StackShield die terugkeer adres teen 'n grenswaarde nagaan om te bepaal of die **EIP** buite die verwagte dataruimte wys. Tog kan hierdie beskerming omseil word deur tegnieke soos Return-to-libc, ROP (Return-Oriented Programming), of ret2ret, wat aandui dat StackShield ook nie plaaslike veranderlikes beskerm nie.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Hierdie meganisme plaas 'n **canary** voor die **EBP**, en reorganiseer plaaslike veranderlikes om buffers op ho√´r geheue adresse te posisioneer, wat voorkom dat hulle ander veranderlikes oorskry. Dit kopieer ook veilig argumente wat op die stapel bo plaaslike veranderlikes oorgedra word en gebruik hierdie kopie√´ as argumente. Tog beskerm dit nie arrays met minder as 8 elemente of buffers binne 'n gebruiker se struktuur nie.

Die **canary** is 'n ewekansige getal wat afgelei is van `/dev/urandom` of 'n standaardwaarde van `0xff0a0000`. Dit word gestoor in **TLS (Thread Local Storage)**, wat dit moontlik maak dat gedeelde geheue ruimtes oor threads thread-spesifieke globale of statiese veranderlikes het. Hierdie veranderlikes word aanvanklik van die ouer proses gekopieer, en kind proses kan hul data verander sonder om die ouer of broers en susters te be√Ønvloed. Nietemin, as 'n **`fork()` gebruik word sonder om 'n nuwe canary te skep, deel alle prosesse (ouer en kinders) dieselfde canary**, wat dit kwesbaar maak. Op die **i386** argitektuur, word die canary gestoor by `gs:0x14`, en op **x86\_64**, by `fs:0x28`.

Hierdie plaaslike beskerming identifiseer funksies met buffers wat kwesbaar is vir aanvalle en spuit kode aan die begin van hierdie funksies om die canary te plaas, en aan die einde om sy integriteit te verifieer.

Wanneer 'n webbediener `fork()` gebruik, stel dit 'n brute-force aanval in staat om die canary byte vir byte te raai. Tog, die gebruik van `execve()` na `fork()` oorskry die geheue ruimte, wat die aanval ontken. `vfork()` laat die kind proses toe om uit te voer sonder duplisering totdat dit probeer om te skryf, op watter punt 'n duplikaat geskep word, wat 'n ander benadering tot proses skepping en geheue hantering bied.

### Lengtes

In `x64` bin√™re, is die canary koekie 'n **`0x8`** byte qword. Die **eerste sewe bytes is ewekansig** en die laaste byte is 'n **null byte.**

In `x86` bin√™re, is die canary koekie 'n **`0x4`** byte dword. Die **eerste drie bytes is ewekansig** en die laaste byte is 'n **null byte.**

{% hint style="danger" %}
Die minste betekenisvolle byte van beide canaries is 'n null byte omdat dit die eerste in die stapel sal wees wat van laer adresse kom en daarom **sal funksies wat strings lees stop voordat dit dit lees**.
{% endhint %}

## Bypasses

**Lek die canary** en oorskry dit dan (bv. buffer overflow) met sy eie waarde.

* As die **canary in kind proses gefork is** kan dit moontlik wees om dit **brute-force** een byte op 'n slag:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* As daar 'n interessante **lek of arbitr√™re lees kwesbaarheid** in die bin√™re is, kan dit moontlik wees om dit te lek:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Oorskrywing van stapel gestoor pointers**

Die stapel wat kwesbaar is vir 'n stapel oorgang kan **adresse na strings of funksies bevat wat oorgeskryf kan word** om die kwesbaarheid te benut sonder om die stapel canary te bereik. Kyk:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Wysig beide meester en thread canary**

'n Buffer overflow in 'n gedrade funksie wat met canary beskerm word, kan gebruik word om die meester canary van die thread te wysig. As gevolg hiervan is die mitigering nutteloos omdat die kontrole gebruik word met twee canaries wat dieselfde is (alhoewel gewysig).

* **Wysig die GOT inskrywing van `__stack_chk_fail`**

As die bin√™re Partial RELRO het, kan jy 'n arbitr√™re skrywe gebruik om die GOT inskrywing van `__stack_chk_fail` te wysig om 'n dummy funksie te wees wat nie die program blokkeer as die canary gewysig word nie.

## Verwysings

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bits, geen PIE, nx, wysig thread en meester canary.
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* 64 bits, geen PIE, nx, write-what-where primitive. Wysig GOT inskrywing van `__stack_chk_fail`.

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PR's in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
