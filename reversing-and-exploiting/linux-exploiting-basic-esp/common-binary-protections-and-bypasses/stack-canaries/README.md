# Stack Canaries

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## **StackGuard ve StackShield**

**StackGuard**, **EIP (Genişletilmiş Talimat İşaretçisi)**'nden önce, özellikle `0x000aff0d` (null, yeni satır, EOF, satır sonu) olarak bilinen özel bir değeri **canary** olarak ekler ve bu, tampon taşmalarına karşı koruma sağlar. Ancak, `recv()`, `memcpy()`, `read()` ve `bcopy()` gibi fonksiyonlar hala savunmasızdır ve **EBP (Temel İşaretçi)**'yi korumaz.

**StackShield**, **Global Return Stack**'i koruyarak daha sofistike bir yaklaşım benimser; bu, tüm dönüş adreslerini (**EIP'leri**) saklar. Bu yapı, herhangi bir taşmanın zarar vermemesini sağlar, çünkü saklanan ve gerçek dönüş adresleri arasında bir karşılaştırma yapılmasına olanak tanır. Ayrıca, StackShield, dönüş adresini bir sınır değeri ile kontrol ederek **EIP**'nin beklenen veri alanının dışına işaret edip etmediğini tespit edebilir. Ancak, bu koruma, Return-to-libc, ROP (Return-Oriented Programming) veya ret2ret gibi tekniklerle aşılabilir; bu da StackShield'in yerel değişkenleri korumadığı anlamına gelir.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Bu mekanizma, **EBP**'den önce bir **canary** yerleştirir ve yerel değişkenleri, diğer değişkenleri ezmelerini önlemek için daha yüksek bellek adreslerinde konumlandıracak şekilde yeniden düzenler. Ayrıca, yerel değişkenlerin üzerinde yığılan argümanları güvenli bir şekilde kopyalar ve bu kopyaları argüman olarak kullanır. Ancak, 8'den az eleman içeren dizileri veya bir kullanıcının yapısı içindeki tamponları korumaz.

**Canary**, `/dev/urandom`'dan türetilen rastgele bir sayıdır veya varsayılan değeri `0xff0a0000`'dır. **TLS (İş Parçacığı Yerel Depolama)**'da saklanır ve bu, iş parçacıkları arasında paylaşılan bellek alanlarının iş parçacığına özgü global veya statik değişkenlere sahip olmasına olanak tanır. Bu değişkenler başlangıçta ana süreçten kopyalanır ve çocuk süreçler, ana veya kardeşleri etkilemeden verilerini değiştirebilir. Ancak, eğer **`fork()` yeni bir canary oluşturmadan kullanılırsa, tüm süreçler (ana ve çocuklar) aynı canary'yi paylaşır** ve bu da onu savunmasız hale getirir. **i386** mimarisinde, canary `gs:0x14`'te, **x86\_64**'te ise `fs:0x28`'de saklanır.

Bu yerel koruma, saldırılara karşı savunmasız tamponlara sahip fonksiyonları tanımlar ve bu fonksiyonların başına canary yerleştirmek için kod enjekte eder ve sonunda bütünlüğünü doğrulamak için kod ekler.

Bir web sunucusu `fork()` kullandığında, canary'yi byte byte tahmin etmek için bir brute-force saldırısına olanak tanır. Ancak, `fork()`'tan sonra `execve()` kullanmak bellek alanını üzerine yazarak saldırıyı geçersiz kılar. `vfork()` çocuk sürecin yazma girişiminde bulunana kadar kopyalamadan çalışmasına izin verir; bu noktada bir kopya oluşturulur ve bu, süreç oluşturma ve bellek yönetimi için farklı bir yaklaşım sunar.

### Uzunluklar

`x64` ikili dosyalarında, canary çerezi **`0x8`** byte qword'dur. **İlk yedi byte rastgeledir** ve son byte bir **null byte**'dır.

`x86` ikili dosyalarında, canary çerezi **`0x4`** byte dword'dur. **İlk üç byte rastgeledir** ve son byte bir **null byte**'dır.

{% hint style="danger" %}
Her iki canary'nin en az anlamlı byte'ı bir null byte'dır çünkü bu, daha düşük adreslerden gelen yığında ilk olacak ve bu nedenle **string okuyan fonksiyonlar onu okumadan duracaktır**.
{% endhint %}

## Bypass'ler

**Canary'yi sızdırmak** ve ardından kendi değeriyle (örneğin, tampon taşması) üzerine yazmak.

* Eğer **canary çocuk süreçlerde fork edilirse**, her seferinde bir byte brute-force yapmak mümkün olabilir:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Eğer ikili dosyada ilginç bir **sızıntı veya keyfi okuma açığı** varsa, onu sızdırmak mümkün olabilir:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Yığın üzerinde saklanan işaretçileri ezmek**

Yığın, bir yığın taşmasına karşı savunmasız olabilir ve **string'lere veya işlevlere ait adresleri içerebilir**; bu adresler, canary'ye ulaşmadan açığı istismar etmek için üzerine yazılabilir. Kontrol edin:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Hem ana hem de iş parçacığı canary'sini değiştirmek**

Canary ile korunan bir iş parçacıklı fonksiyonda bir tampon taşması, iş parçacığının ana canary'sini değiştirmek için kullanılabilir. Sonuç olarak, bu önlem işe yaramaz çünkü kontrol, aynı (ancak değiştirilmiş) iki canary ile kullanılır.

* **`__stack_chk_fail` GOT girişini değiştirmek**

Eğer ikili dosya Kısmi RELRO'ya sahipse, o zaman canary değiştiğinde programı engellemeyen sahte bir fonksiyon olacak şekilde `__stack_chk_fail`'in GOT girişini değiştirmek için keyfi bir yazma işlemi kullanabilirsiniz.

## Referanslar

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bit, PIE yok, nx, iş parçacığı ve ana canary'yi değiştirin.
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* 64 bit, PIE yok, nx, write-what-where primitive. `__stack_chk_fail`'in GOT girişini değiştirin.

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
