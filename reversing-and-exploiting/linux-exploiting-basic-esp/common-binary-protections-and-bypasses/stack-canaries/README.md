# Stack Canaries

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **StackGuard y StackShield**

**StackGuard** inserta un valor especial conocido como **canario** antes del **EIP (Puntero de Instrucci칩n Extendida)**, espec칤ficamente `0x000aff0d` (que representa null, nueva l칤nea, EOF, retorno de carro) para proteger contra desbordamientos de b칰fer. Sin embargo, funciones como `recv()`, `memcpy()`, `read()`, y `bcopy()` siguen siendo vulnerables, y no protege el **EBP (Puntero Base)**.

**StackShield** adopta un enfoque m치s sofisticado que StackGuard al mantener una **Pila de Retorno Global**, que almacena todas las direcciones de retorno (**EIPs**). Esta configuraci칩n asegura que cualquier desbordamiento no cause da침o, ya que permite una comparaci칩n entre las direcciones de retorno almacenadas y las reales para detectar ocurrencias de desbordamiento. Adem치s, StackShield puede verificar la direcci칩n de retorno contra un valor l칤mite para detectar si el **EIP** apunta fuera del espacio de datos esperado. Sin embargo, esta protecci칩n puede ser eludida a trav칠s de t칠cnicas como Return-to-libc, ROP (Programaci칩n Orientada a Retorno), o ret2ret, lo que indica que StackShield tampoco protege las variables locales.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Este mecanismo coloca un **canario** antes del **EBP**, y reorganiza las variables locales para posicionar los b칰feres en direcciones de memoria m치s altas, evitando que sobrescriban otras variables. Tambi칠n copia de manera segura los argumentos pasados en la pila por encima de las variables locales y utiliza estas copias como argumentos. Sin embargo, no protege los arreglos con menos de 8 elementos o los b칰feres dentro de la estructura de un usuario.

El **canario** es un n칰mero aleatorio derivado de `/dev/urandom` o un valor predeterminado de `0xff0a0000`. Se almacena en **TLS (Almacenamiento Local de Hilos)**, permitiendo que los espacios de memoria compartidos entre hilos tengan variables globales o est치ticas espec칤ficas del hilo. Estas variables se copian inicialmente del proceso padre, y los procesos hijos pueden alterar sus datos sin afectar al padre o a los hermanos. Sin embargo, si se utiliza un **`fork()` sin crear un nuevo canario, todos los procesos (padre e hijos) comparten el mismo canario**, lo que lo hace vulnerable. En la arquitectura **i386**, el canario se almacena en `gs:0x14`, y en **x86\_64**, en `fs:0x28`.

Esta protecci칩n local identifica funciones con b칰feres vulnerables a ataques e inyecta c칩digo al inicio de estas funciones para colocar el canario, y al final para verificar su integridad.

Cuando un servidor web utiliza `fork()`, permite un ataque de fuerza bruta para adivinar el canario byte por byte. Sin embargo, usar `execve()` despu칠s de `fork()` sobrescribe el espacio de memoria, negando el ataque. `vfork()` permite que el proceso hijo se ejecute sin duplicaci칩n hasta que intente escribir, momento en el cual se crea una duplicaci칩n, ofreciendo un enfoque diferente para la creaci칩n de procesos y el manejo de memoria.

### Longitudes

En binarios `x64`, la cookie del canario es un **`0x8`** byte qword. Los **primeros siete bytes son aleatorios** y el 칰ltimo byte es un **byte nulo.**

En binarios `x86`, la cookie del canario es un **`0x4`** byte dword. Los **primeros tres bytes son aleatorios** y el 칰ltimo byte es un **byte nulo.**

{% hint style="danger" %}
El byte menos significativo de ambos canarios es un byte nulo porque ser치 el primero en la pila proveniente de direcciones m치s bajas y, por lo tanto, **las funciones que leen cadenas se detendr치n antes de leerlo**.
{% endhint %}

## Bypasses

**Filtrar el canario** y luego sobrescribirlo (por ejemplo, desbordamiento de b칰fer) con su propio valor.

* Si el **canario se bifurca en procesos hijos**, podr칤a ser posible **forzarlo** byte por byte:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Si hay alguna **filtraci칩n interesante o vulnerabilidad de lectura arbitraria** en el binario, podr칤a ser posible filtrarlo:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescribiendo punteros almacenados en la pila**

La pila vulnerable a un desbordamiento de pila podr칤a **contener direcciones a cadenas o funciones que pueden ser sobrescritas** para explotar la vulnerabilidad sin necesidad de alcanzar el canario de pila. Ver:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificando tanto el canario maestro como el de hilo**

Un desbordamiento de b칰fer en una funci칩n con hilos protegida con canario puede ser utilizado para modificar el canario maestro del hilo. Como resultado, la mitigaci칩n es in칰til porque la verificaci칩n se utiliza con dos canarios que son los mismos (aunque modificados).

* **Modificar la entrada GOT de `__stack_chk_fail`**

Si el binario tiene Partial RELRO, entonces puedes usar una escritura arbitraria para modificar la entrada GOT de `__stack_chk_fail` para que sea una funci칩n ficticia que no bloquee el programa si el canario se modifica.

## Referencias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bits, no PIE, nx, modificar canario de hilo y maestro.
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* 64 bits, no PIE, nx, primitive write-what-where. Modificar entrada GOT de `__stack_chk_fail`.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
