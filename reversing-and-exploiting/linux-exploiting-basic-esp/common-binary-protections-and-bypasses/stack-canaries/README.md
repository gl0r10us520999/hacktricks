# Stack Canaries

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## **StackGuard e StackShield**

**StackGuard** insere um valor especial conhecido como **can√°rio** antes do **EIP (Extended Instruction Pointer)**, especificamente `0x000aff0d` (representando null, newline, EOF, carriage return) para proteger contra estouros de buffer. No entanto, fun√ß√µes como `recv()`, `memcpy()`, `read()`, e `bcopy()` permanecem vulner√°veis, e n√£o protege o **EBP (Base Pointer)**.

**StackShield** adota uma abordagem mais sofisticada do que StackGuard, mantendo uma **Global Return Stack**, que armazena todos os endere√ßos de retorno (**EIPs**). Essa configura√ß√£o garante que qualquer estouro n√£o cause danos, pois permite uma compara√ß√£o entre os endere√ßos de retorno armazenados e os reais para detectar ocorr√™ncias de estouro. Al√©m disso, o StackShield pode verificar o endere√ßo de retorno em rela√ß√£o a um valor limite para detectar se o **EIP** aponta fora do espa√ßo de dados esperado. No entanto, essa prote√ß√£o pode ser contornada por t√©cnicas como Return-to-libc, ROP (Return-Oriented Programming), ou ret2ret, indicando que o StackShield tamb√©m n√£o protege vari√°veis locais.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Esse mecanismo coloca um **can√°rio** antes do **EBP**, e reorganiza vari√°veis locais para posicionar buffers em endere√ßos de mem√≥ria mais altos, impedindo que eles sobrescrevam outras vari√°veis. Ele tamb√©m copia de forma segura os argumentos passados na pilha acima das vari√°veis locais e usa essas c√≥pias como argumentos. No entanto, n√£o protege arrays com menos de 8 elementos ou buffers dentro de uma estrutura de usu√°rio.

O **can√°rio** √© um n√∫mero aleat√≥rio derivado de `/dev/urandom` ou um valor padr√£o de `0xff0a0000`. Ele √© armazenado em **TLS (Thread Local Storage)**, permitindo que espa√ßos de mem√≥ria compartilhados entre threads tenham vari√°veis globais ou est√°ticas espec√≠ficas da thread. Essas vari√°veis s√£o inicialmente copiadas do processo pai, e os processos filhos podem alterar seus dados sem afetar o pai ou irm√£os. No entanto, se um **`fork()` for usado sem criar um novo can√°rio, todos os processos (pai e filhos) compartilham o mesmo can√°rio**, tornando-o vulner√°vel. Na arquitetura **i386**, o can√°rio √© armazenado em `gs:0x14`, e em **x86\_64**, em `fs:0x28`.

Essa prote√ß√£o local identifica fun√ß√µes com buffers vulner√°veis a ataques e injeta c√≥digo no in√≠cio dessas fun√ß√µes para colocar o can√°rio, e no final para verificar sua integridade.

Quando um servidor web usa `fork()`, ele permite um ataque de for√ßa bruta para adivinhar o byte do can√°rio byte a byte. No entanto, usar `execve()` ap√≥s `fork()` sobrescreve o espa√ßo de mem√≥ria, negando o ataque. `vfork()` permite que o processo filho execute sem duplica√ß√£o at√© que tente escrever, momento em que uma duplicata √© criada, oferecendo uma abordagem diferente para a cria√ß√£o de processos e manipula√ß√£o de mem√≥ria.

### Comprimentos

Em bin√°rios `x64`, o cookie do can√°rio √© um **`0x8`** byte qword. Os **primeiros sete bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo.**

Em bin√°rios `x86`, o cookie do can√°rio √© um **`0x4`** byte dword. Os **primeiros tr√™s bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo.**

{% hint style="danger" %}
O byte menos significativo de ambos os can√°rios √© um byte nulo porque ser√° o primeiro na pilha vindo de endere√ßos mais baixos e, portanto, **fun√ß√µes que leem strings parar√£o antes de l√™-lo**.
{% endhint %}

## Bypasses

**Vazar o can√°rio** e depois sobrescrev√™-lo (por exemplo, estouro de buffer) com seu pr√≥prio valor.

* Se o **can√°rio for duplicado em processos filhos**, pode ser poss√≠vel **for√ßar** um byte de cada vez:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Se houver algum **vazamento interessante ou vulnerabilidade de leitura arbitr√°ria** no bin√°rio, pode ser poss√≠vel vaz√°-lo:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescrevendo ponteiros armazenados na pilha**

A pilha vulner√°vel a um estouro de pilha pode **cont√©m endere√ßos para strings ou fun√ß√µes que podem ser sobrescritos** a fim de explorar a vulnerabilidade sem precisar alcan√ßar o can√°rio da pilha. Confira:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificando tanto o can√°rio mestre quanto o da thread**

Um estouro de buffer em uma fun√ß√£o com threads protegida com can√°rio pode ser usado para modificar o can√°rio mestre da thread. Como resultado, a mitiga√ß√£o √© in√∫til porque a verifica√ß√£o √© feita com dois can√°rios que s√£o os mesmos (embora modificados).

* **Modificar a entrada GOT de `__stack_chk_fail`**

Se o bin√°rio tiver Partial RELRO, ent√£o voc√™ pode usar uma escrita arbitr√°ria para modificar a entrada GOT de `__stack_chk_fail` para ser uma fun√ß√£o fict√≠cia que n√£o bloqueia o programa se o can√°rio for modificado.

## Refer√™ncias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bits, sem PIE, nx, modificar can√°rio da thread e mestre.
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* 64 bits, sem PIE, nx, primitive write-what-where. Modificar entrada GOT de `__stack_chk_fail`.

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
