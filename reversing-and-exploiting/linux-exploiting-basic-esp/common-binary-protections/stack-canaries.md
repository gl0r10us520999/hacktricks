# Ochrona stosu

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>

## **StackGuard i StackShield**

**StackGuard** wstawia specjalną wartość znana jako **kanarka** przed **EIP (Extended Instruction Pointer)**, konkretnie `0x000aff0d` (reprezentującą null, znak nowej linii, EOF, powrót karetki) w celu ochrony przed przepełnieniem bufora. Jednak funkcje takie jak `recv()`, `memcpy()`, `read()` i `bcopy()` pozostają podatne, a także nie chroni **EBP (Base Pointer)**.

**StackShield** stosuje bardziej zaawansowane podejście niż StackGuard, utrzymując **Globalny Stos Powrotu**, który przechowuje wszystkie adresy powrotu (**EIP**). Ten układ zapewnia, że przepełnienie nie powoduje szkód, ponieważ umożliwia porównanie przechowywanych i rzeczywistych adresów powrotu w celu wykrycia wystąpienia przepełnienia. Dodatkowo, StackShield może sprawdzić adres powrotu względem wartości granicznej, aby wykryć, czy **EIP** wskazuje poza oczekiwaną przestrzeń danych. Jednak ta ochrona może być obejścia za pomocą technik takich jak Return-to-libc, ROP (Return-Oriented Programming) lub ret2ret, co wskazuje, że StackShield również nie chroni zmiennych lokalnych.

## **Protector Stack Smash (ProPolice) `-fstack-protector`:**

Ten mechanizm umieszcza **kanarkę** przed **EBP** i przestawia zmienne lokalne, aby umieścić bufory na wyższych adresach pamięci, zapobiegając nadpisywaniu innych zmiennych. Bezpiecznie kopiuje również argumenty przekazane na stosie powyżej zmiennych lokalnych i używa tych kopii jako argumentów. Jednak nie chroni tablic o mniej niż 8 elementach ani buforów w strukturze użytkownika.

**Kanarka** to losowa liczba pochodząca z `/dev/urandom` lub domyślna wartość `0xff0a0000`. Jest przechowywana w **TLS (Thread Local Storage)**, co pozwala na współdzielone przestrzenie pamięci między wątkami, aby miały wątkowo specyficzne zmienne globalne lub statyczne. Te zmienne są początkowo kopiowane z procesu nadrzędnego, a procesy potomne mogą zmieniać swoje dane bez wpływu na proces nadrzędny lub rodzeństwo. Niemniej jednak, jeśli używane jest **`fork()` bez tworzenia nowej kanarki, wszystkie procesy (rodzic i dzieci) dzielą tę samą kanarkę**, co czyni ją podatną. Na architekturze **i386**, kanarka jest przechowywana pod adresem `gs:0x14`, a na **x86\_64** pod adresem `fs:0x28`.

Ta lokalna ochrona identyfikuje funkcje z buforami podatnymi na ataki i wstrzykuje kod na początku tych funkcji, aby umieścić kanarkę, a na końcu weryfikuje jej integralność.

Gdy serwer WWW używa `fork()`, umożliwia atak brute-force w celu odgadnięcia kanarki bajt po bajcie. Jednak używając `execve()` po `fork()` nadpisuje przestrzeń pamięci, unieważniając atak. `vfork()` pozwala procesowi potomnemu wykonywać się bez duplikacji, aż spróbuje zapisać, wtedy tworzony jest duplikat, oferując inny sposób tworzenia procesów i zarządzania pamięcią.

## Ominięcia

* **Ujawnienie kanarki** a następnie nadpisanie jej (np. przepełnienie bufora) własną wartością.
* Jeśli kanarka jest klonowana w procesach potomnych, możliwe jest brutalne jej odgadnięcie po jednym bajcie.
* Jeśli w binarnym istnieje jakaś interesująca luka wyciekowa, może być możliwe jej ujawnienie.
