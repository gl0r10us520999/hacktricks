# Stack Canaries

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e ai [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## **StackGuard e StackShield**

**StackGuard** inserisce un valore speciale noto come **canary** prima dell'**EIP (Extended Instruction Pointer)**, specificamente `0x000aff0d` (rappresentante null, newline, EOF, carriage return) per proteggersi dagli overflow di buffer. Tuttavia, funzioni come `recv()`, `memcpy()`, `read()`, e `bcopy()` rimangono vulnerabili, e non protegge l'**EBP (Base Pointer)**.

**StackShield** adotta un approccio pi√π sofisticato rispetto a StackGuard mantenendo uno **Stack di Ritorno Globale**, che memorizza tutti gli indirizzi di ritorno (**EIP**). Questa configurazione garantisce che eventuali overflow non causino danni, poich√© consente di confrontare gli indirizzi di ritorno memorizzati con quelli effettivi per rilevare eventuali overflow. Inoltre, StackShield pu√≤ controllare l'indirizzo di ritorno rispetto a un valore di confine per rilevare se l'**EIP** punta al di fuori dello spazio dati previsto. Tuttavia, questa protezione pu√≤ essere aggirata attraverso tecniche come Return-to-libc, ROP (Return-Oriented Programming), o ret2ret, indicando che StackShield non protegge nemmeno le variabili locali.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Questo meccanismo posiziona un **canary** prima dell'**EBP**, e riorganizza le variabili locali posizionando i buffer a indirizzi di memoria pi√π alti, impedendo loro di sovrascrivere altre variabili. Copia in modo sicuro gli argomenti passati nello stack sopra le variabili locali e utilizza queste copie come argomenti. Tuttavia, non protegge gli array con meno di 8 elementi o i buffer all'interno di una struttura dell'utente.

Il **canary** √® un numero casuale derivato da `/dev/urandom` o un valore predefinito di `0xff0a0000`. Viene memorizzato in **TLS (Thread Local Storage)**, consentendo a spazi di memoria condivisi tra thread di avere variabili globali o statiche specifiche del thread. Queste variabili vengono inizialmente copiate dal processo genitore, e i processi figli possono modificare i loro dati senza influenzare il genitore o i fratelli. Tuttavia, se viene utilizzato un **`fork()` senza creare un nuovo canary, tutti i processi (genitore e figli) condividono lo stesso canary**, rendendolo vulnerabile. Sull'architettura **i386**, il canary √® memorizzato a `gs:0x14`, e su **x86\_64**, a `fs:0x28`.

Questa protezione locale identifica le funzioni con buffer vulnerabili agli attacchi e inietta codice all'inizio di queste funzioni per posizionare il canary, e alla fine per verificare la sua integrit√†.

Quando un server web utilizza `fork()`, consente un attacco di forza bruta per indovinare il byte del canary per byte. Tuttavia, utilizzando `execve()` dopo `fork()` sovrascrive lo spazio di memoria, annullando l'attacco. `vfork()` consente al processo figlio di eseguire senza duplicazione fino a quando tenta di scrivere, momento in cui viene creata una duplicazione, offrendo un approccio diverso alla creazione di processi e alla gestione della memoria.

## Bypass

* **Leak del canary** e quindi sovrascriverlo (ad esempio, overflow del buffer) con il proprio valore.
* Se il canary viene forkato nei processi figlio potrebbe essere possibile forzarlo uno byte alla volta.
* Se c'√® qualche vulnerabilit√† di leak interessante nel binario potrebbe essere possibile effettuare un leak.
