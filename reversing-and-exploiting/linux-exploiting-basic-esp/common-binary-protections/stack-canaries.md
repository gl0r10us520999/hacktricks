# Mlinzi wa Stack na Mlinzi wa Stack

**StackGuard** inaweka thamani maalum inayoitwa **canary** kabla ya **EIP (Extended Instruction Pointer)**, kwa usahihi `0x000aff0d` (inayowakilisha null, newline, EOF, carriage return) kulinda dhidi ya buffer overflows. Walakini, kazi kama vile `recv()`, `memcpy()`, `read()`, na `bcopy()` bado ziko hatarini, na hailinganishi **EBP (Base Pointer)**.

**StackShield** inachukua njia yenye utata zaidi kuliko StackGuard kwa kudumisha **Global Return Stack**, ambayo hifadhi anwani zote za kurudi (**EIPs**). Hii inahakikisha kuwa kuzidi kwa buffer haisababishi madhara, kwani inaruhusu kulinganisha kati ya anwani zilizohifadhiwa na anwani halisi za kurudi ili kugundua matukio ya kuzidi. Kwa kuongezea, StackShield inaweza kuchunguza anwani ya kurudi dhidi ya thamani ya mpaka ili kugundua ikiwa **EIP** inaelekeza nje ya nafasi ya data inayotarajiwa. Walakini, kinga hii inaweza kuzungukwa kupitia mbinu kama Return-to-libc, ROP (Return-Oriented Programming), au ret2ret, ikionyesha kuwa StackShield pia hailinganishi na maelezo ya ndani.

## **Mlinzi wa Stack Smash (ProPolice) `-fstack-protector`:**

Mbinu hii inaweka **canary** kabla ya **EBP**, na kurekebisha upya maelezo ya ndani ili kuweka mabufa kwenye anwani za kumbukumbu za juu, kuzuia kuzidi kuandika maelezo mengine. Pia inakopi salama hoja zilizopitishwa kwenye mstari juu ya maelezo ya ndani na kutumia nakala hizi kama hoja. Walakini, hailinganishi mabara yenye vipengele chini ya vipengele 8 au mabufa ndani ya muundo wa mtumiaji.

**Canary** ni nambari ya nasibu inayotokana na `/dev/urandom` au thamani ya msingi ya `0xff0a0000`. Imehifadhiwa katika **TLS (Thread Local Storage)**, ikiruhusu nafasi za kumbukumbu zilizoshirikiwa kati ya nyuzi kuwa na maelezo ya ndani ya nyuzi maalum. Maelezo haya ya ndani ya nyuzi kwa kawaida huchukuliwa kutoka kwa mchakato mzazi, na michakato ya watoto inaweza kubadilisha data yao bila kuathiri mzazi au ndugu. Walakini, ikiwa **`fork()` inatumika bila kuunda canary mpya, michakato yote (mzazi na watoto) wanashiriki canary sawa**, ikifanya iwe hatarini. Kwenye usanifu wa **i386**, canary imehifadhiwa kwa `gs:0x14`, na kwenye **x86\_64**, kwa `fs:0x28`.

Kinga hii ya ndani inatambua kazi zenye mabufa yanayoweza kushambuliwa na kuingiza nambari mwanzoni mwa kazi hizi kuweka canary, na mwishoni kuhakiki uadilifu wake.

Wakati seva ya wavuti inatumia `fork()`, inawezesha shambulio la kufikiria kuhusu canary kwa kila baiti. Walakini, kutumia `execve()` baada ya `fork()` kunaharibu nafasi ya kumbukumbu, kufuta shambulio. `vfork()` inaruhusu mchakato wa mtoto kutekelezwa bila kuiga hadi jaribio la kuandika, wakati huo mchakato wa nakala unajengwa, kutoa njia tofauti ya uundaji wa mchakato na utunzaji wa kumbukumbu.

## Kuzidi

* **Kuvuja kwa canary** na kisha kuibadilisha (k.m. buffer overflow) na thamani yake.
* Ikiwa canary inaundwa katika michakato ya watoto inaweza kuwa inawezekana kufikiria kila baiti moja kwa wakati.
* Ikiwa kuna ukiukaji wa kuvuja wa kuvutia katika binary inaweza kuwa inawezekana kuvuja.
