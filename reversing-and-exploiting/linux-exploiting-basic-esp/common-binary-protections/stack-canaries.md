# スタックキャナリー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を入手する
- 独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションである[**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する
- **Discordグループ**に**参加**💬(https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で**フォロー**する🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
- **HackTricks**（https://github.com/carlospolop/hacktricks）と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>

## **StackGuardとStackShield**

**StackGuard**は、**EIP（Extended Instruction Pointer）**の前に特別な値である**キャナリー**を挿入します。具体的には、バッファオーバーフローから保護するために`0x000aff0d`（null、改行、EOF、復帰）を挿入します。ただし、`recv()`、`memcpy()`、`read()`、`bcopy()`などの関数は脆弱のままであり、**EBP（Base Pointer）**を保護しません。

**StackShield**は、**グローバルリターンスタック**を維持することで、StackGuardよりも洗練されたアプローチを取ります。このセットアップにより、オーバーフローが害を及ぼさないように、格納された実際のリターンアドレスと比較してオーバーフローの発生を検出することができます。さらに、StackShieldはリターンアドレスを境界値と比較して、**EIP**が予想されるデータスペースの外を指しているかどうかを検出することができます。ただし、この保護はReturn-to-libc、ROP（Return-Oriented Programming）、ret2retなどのテクニックによって回避される可能性があり、StackShieldもローカル変数を保護しません。

## **スタックスマッシュプロテクタ（ProPolice）`-fstack-protector`:**

このメカニズムは、**EBP**の前に**キャナリー**を配置し、ローカル変数を再配置してバッファをより高いメモリアドレスに配置し、他の変数を上書きしないようにします。また、スタックに渡された引数をローカル変数の上に配置し、これらのコピーを引数として使用します。ただし、8つ未満の要素を持つ配列やユーザー構造体内のバッファを保護しません。

**キャナリー**は、`/dev/urandom`から派生したランダムな数値またはデフォルト値の`0xff0a0000`から取得されます。これは**TLS（スレッドローカルストレージ）**に保存され、スレッド間で共有されるメモリスペースを持つことができます。これらの変数は最初に親プロセスからコピーされ、子プロセスは親や兄弟に影響を与えることなくデータを変更できます。ただし、新しいキャナリーを作成せずに**`fork()`**を使用すると、すべてのプロセス（親と子）が同じキャナリーを共有するため、脆弱になります。**i386**アーキテクチャでは、キャナリーは`gs:0x14`に、**x86\_64**では`fs:0x28`に保存されます。

このローカル保護は、攻撃に脆弱なバッファを持つ関数を特定し、これらの関数の先頭にコードを挿入してキャナリーを配置し、最後にその整合性を検証します。

Webサーバーが`fork()`を使用すると、キャナリーバイトを1バイトずつ推測する総当たり攻撃が可能になります。ただし、`fork()`の後に`execve()`を使用すると、メモリスペースが上書きされ、攻撃が無効になります。`vfork()`は、子プロセスが書き込みを試みるまで複製を作成せずに実行できるため、プロセスの作成とメモリの処理に異なるアプローチを提供します。

## バイパス

- **キャナリーを漏洩**してからそれを上書きする（例：バッファオーバーフロー）。
- キャナリーが子プロセスでフォークされている場合、1バイトずつ総当たり攻撃することが可能です。
- バイナリ内の興味深いリーク脆弱性がある場合、それを漏洩する可能性があります。
