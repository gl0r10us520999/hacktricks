# Canaries de la pile

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **StackGuard et StackShield**

**StackGuard** ins√®re une valeur sp√©ciale appel√©e **canary** avant l'**EIP (Extended Instruction Pointer)**, sp√©cifiquement `0x000aff0d` (repr√©sentant null, saut de ligne, EOF, retour chariot) pour se prot√©ger contre les d√©bordements de tampon. Cependant, des fonctions comme `recv()`, `memcpy()`, `read()`, et `bcopy()` restent vuln√©rables, et il ne prot√®ge pas l'**EBP (Base Pointer)**.

**StackShield** adopte une approche plus sophistiqu√©e que StackGuard en maintenant une **pile de retour globale**, qui stocke toutes les adresses de retour (**EIP**). Cette configuration garantit qu'un d√©bordement ne cause aucun dommage, car elle permet une comparaison entre les adresses de retour stock√©es et r√©elles pour d√©tecter les occurrences de d√©bordement. De plus, StackShield peut v√©rifier l'adresse de retour par rapport √† une valeur limite pour d√©tecter si l'**EIP** pointe en dehors de l'espace de donn√©es attendu. Cependant, cette protection peut √™tre contourn√©e √† travers des techniques comme Return-to-libc, ROP (Return-Oriented Programming), ou ret2ret, indiquant que StackShield ne prot√®ge pas non plus les variables locales.

## **Protecteur d'√©crasement de pile (ProPolice) `-fstack-protector`:**

Ce m√©canisme place un **canary** avant l'**EBP**, et r√©organise les variables locales pour positionner les tampons √† des adresses m√©moire plus √©lev√©es, les emp√™chant d'√©craser d'autres variables. Il copie √©galement de mani√®re s√©curis√©e les arguments pass√©s sur la pile au-dessus des variables locales et utilise ces copies comme arguments. Cependant, il ne prot√®ge pas les tableaux avec moins de 8 √©l√©ments ou les tampons √† l'int√©rieur d'une structure utilisateur.

Le **canary** est un nombre al√©atoire d√©riv√© de `/dev/urandom` ou d'une valeur par d√©faut de `0xff0a0000`. Il est stock√© dans le **TLS (Thread Local Storage)**, permettant aux espaces m√©moire partag√©s entre les threads d'avoir des variables globales ou statiques sp√©cifiques au thread. Ces variables sont initialement copi√©es du processus parent, et les processus enfants peuvent modifier leurs donn√©es sans affecter le parent ou les fr√®res et s≈ìurs. N√©anmoins, si un **`fork()` est utilis√© sans cr√©er un nouveau canary, tous les processus (parent et enfants) partagent le m√™me canary**, le rendant vuln√©rable. Sur l'architecture **i386**, le canary est stock√© √† `gs:0x14`, et sur **x86\_64**, √† `fs:0x28`.

Cette protection locale identifie les fonctions avec des tampons vuln√©rables aux attaques et injecte du code au d√©but de ces fonctions pour placer le canary, et √† la fin pour v√©rifier son int√©grit√©.

Lorsqu'un serveur web utilise `fork()`, cela permet une attaque par force brute pour deviner le byte du canary par byte. Cependant, en utilisant `execve()` apr√®s `fork()`, l'espace m√©moire est √©cras√©, annulant l'attaque. `vfork()` permet au processus enfant d'ex√©cuter sans duplication jusqu'√† ce qu'il tente d'√©crire, √† ce moment-l√† une duplication est cr√©√©e, offrant une approche diff√©rente √† la cr√©ation de processus et √† la gestion de la m√©moire.

## Contournements

* **Fuite du canary** puis √©crasement (par exemple, d√©bordement de tampon) avec sa propre valeur.
* Si le canary est fork√© dans les processus enfants, il pourrait √™tre possible de le deviner un byte √† la fois par force brute.
* S'il existe une vuln√©rabilit√© de fuite int√©ressante dans le binaire, il pourrait √™tre possible de la divulguer.
