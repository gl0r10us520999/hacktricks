# Reversing Tools & Basic Methods

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

**Try Hard Security Group**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Alati za Reversing bazirani na ImGui-u

Softver:

* ReverseKit: [https://github.com/zer0condition/ReverseKit](https://github.com/zer0condition/ReverseKit)

## Wasm dekompajler / Wat kompajler

Online:

* Koristite [https://webassembly.github.io/wabt/demo/wasm2wat/index.html](https://webassembly.github.io/wabt/demo/wasm2wat/index.html) za **dekompajliranje** iz wasm (binarno) u wat (čisti tekst)
* Koristite [https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/) za **kompajliranje** iz wat u wasm
* Možete takođe probati da koristite [https://wwwg.github.io/web-wasmdec/](https://wwwg.github.io/web-wasmdec/) za dekompajliranje

Softver:

* [https://www.pnfsoftware.com/jeb/demo](https://www.pnfsoftware.com/jeb/demo)
* [https://github.com/wwwg/wasmdec](https://github.com/wwwg/wasmdec)

## .NET dekompajler

### [dotPeek](https://www.jetbrains.com/decompiler/)

dotPeek je dekompajler koji **dekompajlira i analizira više formata**, uključujući **biblioteke** (.dll), **Windows metapodatke** (.winmd) i **izvršne datoteke** (.exe). Nakon dekompajliranja, skup može biti sačuvan kao Visual Studio projekat (.csproj).

Prednost ovde je da ako izgubljeni izvorni kod zahteva obnovu iz zastarele skupštine, ova akcija može uštedeti vreme. Nadalje, dotPeek pruža korisnu navigaciju kroz dekompajlirani kod, čineći ga jednim od savršenih alata za **Xamarin analizu algoritma.**

### [.NET Reflector](https://www.red-gate.com/products/reflector/)

Sa sveobuhvatnim modelom dodataka i API-jem koji proširuje alat da odgovara vašim tačnim potrebama, .NET Reflector štedi vreme i pojednostavljuje razvoj. Pogledajmo mnoštvo usluga za reverzno inženjerstvo koje ovaj alat pruža:

* Pruža uvid u to kako podaci prolaze kroz biblioteku ili komponentu
* Pruža uvid u implementaciju i upotrebu .NET jezika i okvira
* Pronalazi nedokumentovanu i neeksponiranu funkcionalnost kako bi se više iskoristile API-ji i tehnologije koje se koriste.
* Pronalazi zavisnosti i različite skupove
* Pronalazi tačnu lokaciju grešaka u vašem kodu, komponentama trećih strana i bibliotekama.
* Debaguje izvor sveg .NET koda sa kojim radite.

### [ILSpy](https://github.com/icsharpcode/ILSpy) & [dnSpy](https://github.com/dnSpy/dnSpy/releases)

[ILSpy dodatak za Visual Studio Code](https://github.com/icsharpcode/ilspy-vscode): Možete ga imati na bilo kom OS-u (možete ga instalirati direktno iz VSCode-a, nije potrebno preuzimanje sa gita. Kliknite na **Extensions** i **pretražite ILSpy**).\
Ako trebate **dekompajlirati**, **izmeniti** i **ponovo kompajlirati** možete koristiti [**dnSpy**](https://github.com/dnSpy/dnSpy/releases) ili aktivno održavanu verziju, [**dnSpyEx**](https://github.com/dnSpyEx/dnSpy/releases). (**Desni klik -> Modify Method** da promenite nešto unutar funkcije).

### DNSpy Logging

Da biste omogućili **DNSpy-u da beleži neke informacije u datoteku**, možete koristiti ovaj isječak:

```cs
using System.IO;
path = "C:\\inetpub\\temp\\MyTest2.txt";
File.AppendAllText(path, "Password: " + password + "\n");
```

### DNSpy Debugiranje

Da biste debagovali kod koristeći DNSpy, treba da:

Prvo, promenite **Atribute skupa podataka** koji se odnose na **debugiranje**:

![](<../../.gitbook/assets/image (278).png>)

```aspnet
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```

Do:

```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default |
DebuggableAttribute.DebuggingModes.DisableOptimizations |
DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints |
DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

I kliknite na **compile**:

![](<../../.gitbook/assets/image (314) (1) (1).png>)

Zatim sačuvajte novu datoteku preko _**File >> Save module...**_:

![](<../../.gitbook/assets/image (279).png>)

Ovo je neophodno jer ako to ne uradite, u **runtime-u** će biti primenjene neke **optimizacije** na kod i moguće je da prilikom **debugiranja** **break-point** nikada neće biti dostignut ili neke **promenljive neće postojati**.

Zatim, ako se vaša .NET aplikacija **pokreće** preko **IIS-a**, možete je **restartovati** sa:

```
iisreset /noforce
```

Zatim, kako biste započeli sa debagovanjem, trebalo bi da zatvorite sve otvorene datoteke i unutar **Debug taba** izaberete **Attach to Process...**:

![](<../../.gitbook/assets/image (280).png>)

Zatim izaberite **w3wp.exe** da se povežete sa **IIS serverom** i kliknite na **attach**:

![](<../../.gitbook/assets/image (281).png>)

Sada kada debagujemo proces, vreme je da ga zaustavimo i učitamo sve module. Prvo kliknite na _Debug >> Break All_ a zatim kliknite na _**Debug >> Windows >> Modules**_:

![](<../../.gitbook/assets/image (286).png>)

![](<../../.gitbook/assets/image (283).png>)

Kliknite na bilo koji modul u **Modules** i izaberite **Open All Modules**:

![](<../../.gitbook/assets/image (284).png>)

Desni klik na bilo koji modul u **Assembly Exploreru** i kliknite na **Sort Assemblies**:

![](<../../.gitbook/assets/image (285).png>)

## Java dekompajler

[https://github.com/skylot/jadx](https://github.com/skylot/jadx)\
[https://github.com/java-decompiler/jd-gui/releases](https://github.com/java-decompiler/jd-gui/releases)

## Debagovanje DLL-ova

### Korišćenje IDA

* **Učitajte rundll32** (64-bitni u C:\Windows\System32\rundll32.exe i 32-bitni u C:\Windows\SysWOW64\rundll32.exe)
* Izaberite **Windbg** debager
* Izaberite "**Suspend on library load/unload**"

![](<../../.gitbook/assets/image (135).png>)

* Konfigurišite **parametre** izvršenja postavljajući **putanju do DLL-a** i funkciju koju želite da pozovete:

![](<../../.gitbook/assets/image (136).png>)

Zatim, kada započnete sa debagovanjem, **izvršenje će biti zaustavljeno kada se svaki DLL učita**, zatim, kada rundll32 učita vaš DLL, izvršenje će biti zaustavljeno.

Ali, kako možete pristupiti kodu DLL-a koji je učitan? Korišćenjem ovog metoda, ne znam kako.

### Korišćenje x64dbg/x32dbg

* **Učitajte rundll32** (64-bitni u C:\Windows\System32\rundll32.exe i 32-bitni u C:\Windows\SysWOW64\rundll32.exe)
* **Promenite Command Line** ( _File --> Change Command Line_ ) i postavite putanju do dll-a i funkciju koju želite da pozovete, na primer: "C:\Windows\SysWOW64\rundll32.exe" "Z:\shared\Cybercamp\rev2\\\14.ridii\_2.dll",DLLMain
* Promenite _Options --> Settings_ i izaberite "**DLL Entry**".
* Zatim **pokrenite izvršenje**, debager će se zaustaviti na svakom dll main, u nekom trenutku ćete **zastati u dll Entry vašeg dll-a**. Odande, jednostavno potražite tačke gde želite postaviti prekid.

Primetite da kada je izvršenje zaustavljeno iz bilo kog razloga u win64dbg-u možete videti **u kojem kodu se nalazite** gledajući u **vrhu prozora win64dbg**:

![](<../../.gitbook/assets/image (137).png>)

Zatim, gledajući ovo, možete videti kada je izvršenje zaustavljeno u dll-u koji želite da debagujete.

## GUI aplikacije / Video igre

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) je koristan program za pronalaženje gde su važne vrednosti sačuvane unutar memorije pokrenute igre i njihovo menjanje. Više informacija u:

{% content-ref url="cheat-engine.md" %}
[cheat-engine.md](cheat-engine.md)
{% endcontent-ref %}

## ARM & MIPS

{% embed url="https://github.com/nongiach/arm_now" %}

## Shellkodovi

### Debagovanje shellkoda sa blobrunnerom

[**Blobrunner**](https://github.com/OALabs/BlobRunner) će **dodeliti** shellkod unutar prostora memorije, **pokazati** vam **adresu memorije** gde je shellkod dodeljen i **zaustaviti** izvršenje.\
Zatim, treba da **povežete debager** (Ida ili x64dbg) sa procesom i postavite **prekid na označenu adresu memorije** i **nastavite** izvršenje. Na ovaj način ćete debagovati shellkod.

Stranica sa izdanjima na githubu sadrži zipove sa kompilovanim izdanjima: [https://github.com/OALabs/BlobRunner/releases/tag/v0.0.5](https://github.com/OALabs/BlobRunner/releases/tag/v0.0.5)\
Možete pronaći malo izmenjenu verziju Blobrunnera na sledećem linku. Da biste je kompajlirali, jednostavno **napravite C/C++ projekat u Visual Studio Code-u, kopirajte i nalepite kod i izgradite ga**.

{% content-ref url="blobrunner.md" %}
[blobrunner.md](blobrunner.md)
{% endcontent-ref %}

### Debagovanje shellkoda sa jmp2it

[**jmp2it** ](https://github.com/adamkramer/jmp2it/releases/tag/v1.4)je vrlo sličan blobrunneru. On će **dodeliti** shellkod unutar prostora memorije i pokrenuti **večnu petlju**. Zatim treba da **povežete debager** sa procesom, **pokrenete, sačekate 2-5 sekundi i pritisnete stop** i naći ćete se unutar **večne petlje**. Skočite na sledeću instrukciju večne petlje jer će to biti poziv shellkodu, i na kraju ćete se naći kako izvršavate shellkod.

![](<../../.gitbook/assets/image (397).png>)

Možete preuzeti kompilovanu verziju [jmp2it sa stranice sa izdanjima](https://github.com/adamkramer/jmp2it/releases/).

### Debagovanje shellkoda korišćenjem Cutter-a

[**Cutter**](https://github.com/rizinorg/cutter/releases/tag/v1.12.0) je GUI za radare. Korišćenjem Cutter-a možete emulirati shellkod i dinamički ga inspicirati.

Imajte na umu da Cutter vam omogućava da "Otvorite datoteku" i "Otvorite shellkod". U mom slučaju, kada sam otvorio shellkod kao datoteku, dekompajlirao ga je ispravno, ali kada sam ga otvorio kao shellkod, nije:

![](<../../.gitbook/assets/image (400).png>)

Da biste započeli emulaciju na mestu gde želite, postavite prekidnu tačku tamo i izgleda da će Cutter automatski pokrenuti emulaciju od tamo:

![](<../../.gitbook/assets/image (399).png>)

![](<../../.gitbook/assets/image (401).png>)

Možete videti stek na primer unutar heksadecimalnog prikaza:

![](<../../.gitbook/assets/image (402).png>)

### Dekodiranje shellkoda i dobijanje izvršenih funkcija

Treba da probate [**scdbg**](http://sandsprite.com/blogs/index.php?uid=7\&pid=152).\
Reći će vam stvari poput **koje funkcije** shellkod koristi i da li se shellkod **dekodira** u memoriji.

```bash
scdbg.exe -f shellcode # Get info
scdbg.exe -f shellcode -r #show analysis report at end of run
scdbg.exe -f shellcode -i -r #enable interactive hooks (file and network) and show analysis report at end of run
scdbg.exe -f shellcode -d #Dump decoded shellcode
scdbg.exe -f shellcode /findsc #Find offset where starts
scdbg.exe -f shellcode /foff 0x0000004D #Start the executing in that offset
```

scDbg takođe ima grafički pokretač gde možete izabrati opcije koje želite i izvršiti shellcode

![](<../../.gitbook/assets/image (398).png>)

Opcija **Create Dump** će izbaciti konačni shellcode ako je bilo kakva promena urađena na shellcode-u dinamički u memoriji (korisno za preuzimanje dekodiranog shellcode-a). **Start offset** može biti koristan da se shellcode pokrene na određenom offsetu. Opcija **Debug Shell** je korisna za debugovanje shellcode-a koristeći scDbg terminal (međutim, smatram da su bilo koje od opcija objašnjenih ranije bolje za ovu svrhu jer ćete moći koristiti Ida ili x64dbg).

### Disasembliranje korišćenjem CyberChefa

Otpremite svoj fajl sa shellcode-om kao ulaz i koristite sledeći recept za dekompilaciju: [https://gchq.github.io/CyberChef/#recipe=To\_Hex('Space',0)Disassemble\_x86('32','Full%20x86%20architecture',16,0,true,true)](https://gchq.github.io/CyberChef/#recipe=To\_Hex\('Space',0\)Disassemble\_x86\('32','Full%20x86%20architecture',16,0,true,true\))

## [Movfuscator](https://github.com/xoreaxeaxeax/movfuscator)

Ovaj obfuscator **modifikuje sve instrukcije za `mov`** (da, zaista kul). Takođe koristi prekide da promeni tok izvršavanja. Za više informacija o tome kako funkcioniše:

* [https://www.youtube.com/watch?v=2VF\_wPkiBJY](https://www.youtube.com/watch?v=2VF\_wPkiBJY)
* [https://github.com/xoreaxeaxeax/movfuscator/blob/master/slides/domas\_2015\_the\_movfuscator.pdf](https://github.com/xoreaxeaxeax/movfuscator/blob/master/slides/domas\_2015\_the\_movfuscator.pdf)

Ako imate sreće, [demovfuscator](https://github.com/kirschju/demovfuscator) će deobfuskovati binarni fajl. Ima nekoliko zavisnosti

```
apt-get install libcapstone-dev
apt-get install libz3-dev
```

I [instaliraj keystone](https://github.com/keystone-engine/keystone/blob/master/docs/COMPILE-NIX.md) (`apt-get install cmake; mkdir build; cd build; ../make-share.sh; make install`)

Ako igrate **CTF, ovaj workaround za pronalaženje zastave** može biti veoma koristan: [https://dustri.org/b/defeating-the-recons-movfuscator-crackme.html](https://dustri.org/b/defeating-the-recons-movfuscator-crackme.html)

## Rust

Da biste pronašli **ulaznu tačku**, pretražite funkcije po `::main` kao u:

![](<../../.gitbook/assets/image (612).png>)

U ovom slučaju, binarni fajl se zvao authenticator, pa je prilično očigledno da je ovo interesantna glavna funkcija.\
Imajući **ime** **funkcija** koje se pozivaju, pretražite ih na **Internetu** da biste saznali o njihovim **ulazima** i **izlazima**.

## **Delphi**

Za Delphi kompilovane binarne fajlove možete koristiti [https://github.com/crypto2011/IDR](https://github.com/crypto2011/IDR)

Ako morate da obrnete Delphi binarni fajl, predlažem vam da koristite IDA dodatak [https://github.com/Coldzer0/IDA-For-Delphi](https://github.com/Coldzer0/IDA-For-Delphi)

Samo pritisnite **ATL+f7** (uvozite python dodatak u IDA) i izaberite python dodatak.

Ovaj dodatak će izvršiti binarni fajl i dinamički rešiti imena funkcija na početku debagovanja. Nakon pokretanja debagovanja ponovo pritisnite dugme Start (zelena strelica ili f9) i prekidač će se aktivirati na početku stvarnog koda.

Takođe je veoma interesantno jer ako pritisnete dugme u grafičkoj aplikaciji, debager će se zaustaviti u funkciji koju izvršava to dugme.

## Golang

Ako morate da obrnete Golang binarni fajl, predlažem vam da koristite IDA dodatak [https://github.com/sibears/IDAGolangHelper](https://github.com/sibears/IDAGolangHelper)

Samo pritisnite **ATL+f7** (uvozite python dodatak u IDA) i izaberite python dodatak.

Ovo će rešiti imena funkcija.

## Kompajlirani Python

Na ovoj stranici možete pronaći kako da dobijete python kod iz ELF/EXE python kompajliranog binarnog fajla:

{% content-ref url="../../generic-methodologies-and-resources/basic-forensic-methodology/specific-software-file-type-tricks/.pyc.md" %}
[.pyc.md](../../generic-methodologies-and-resources/basic-forensic-methodology/specific-software-file-type-tricks/.pyc.md)
{% endcontent-ref %}

## GBA - Game Body Advance

Ako dobijete **binarni** fajl GBA igre, možete koristiti različite alate za **emulaciju** i **debugovanje**:

* [**no$gba**](https://problemkaputt.de/gba.htm) (_Preuzmite debug verziju_) - Sadrži debager sa interfejsom
* [**mgba** ](https://mgba.io)- Sadrži CLI debager
* [**gba-ghidra-loader**](https://github.com/pudii/gba-ghidra-loader) - Ghidra dodatak
* [**GhidraGBA**](https://github.com/SiD3W4y/GhidraGBA) - Ghidra dodatak

U [**no$gba**](https://problemkaputt.de/gba.htm), u _**Options --> Emulation Setup --> Controls**_\*\* \*\* možete videti kako da pritisnete Game Boy Advance **dugmiće**

![](<../../.gitbook/assets/image (578).png>)

Kada se pritisne, svako **dugme ima vrednost** koja ga identifikuje:

```
A = 1
B = 2
SELECT = 4
START = 8
RIGHT = 16
LEFT = 32
UP = 64
DOWN = 128
R = 256
L = 256
```

Dakle, u ovakvom programu, interesantan deo će biti **kako program tretira korisnički unos**. Na adresi **0x4000130** pronaći ćete često korišćenu funkciju: **KEYINPUT**.

![](<../../.gitbook/assets/image (579).png>)

Na prethodnoj slici možete videti da se funkcija poziva iz **FUN\_080015a8** (adrese: _0x080015fa_ i _0x080017ac_).

U toj funkciji, nakon nekih inicijalnih operacija (bez ikakvog značaja):

```c
void FUN_080015a8(void)

{
ushort uVar1;
undefined4 uVar2;
undefined4 uVar3;
ushort uVar4;
int iVar5;
ushort *puVar6;
undefined *local_2c;

DISPCNT = 0x1140;
FUN_08000a74();
FUN_08000ce4(1);
DISPCNT = 0x404;
FUN_08000dd0(&DAT_02009584,0x6000000,&DAT_030000dc);
FUN_08000354(&DAT_030000dc,0x3c);
uVar4 = DAT_030004d8;
```

Pronađen je ovaj kod:

```c
do {
DAT_030004da = uVar4; //This is the last key pressed
DAT_030004d8 = KEYINPUT | 0xfc00;
puVar6 = &DAT_0200b03c;
uVar4 = DAT_030004d8;
do {
uVar2 = DAT_030004dc;
uVar1 = *puVar6;
if ((uVar1 & DAT_030004da & ~uVar4) != 0) {
```

Poslednji if proverava da li je **`uVar4`** u **poslednjim ključevima** i nije trenutni ključ, takođe nazvan puštanje dugmeta (trenutni ključ je smešten u **`uVar1`**).

```c
if (uVar1 == 4) {
DAT_030000d4 = 0;
uVar3 = FUN_08001c24(DAT_030004dc);
FUN_08001868(uVar2,0,uVar3);
DAT_05000000 = 0x1483;
FUN_08001844(&DAT_0200ba18);
FUN_08001844(&DAT_0200ba20,&DAT_0200ba40);
DAT_030000d8 = 0;
uVar4 = DAT_030004d8;
}
else {
if (uVar1 == 8) {
if (DAT_030000d8 == 0xf3) {
DISPCNT = 0x404;
FUN_08000dd0(&DAT_02008aac,0x6000000,&DAT_030000dc);
FUN_08000354(&DAT_030000dc,0x3c);
uVar4 = DAT_030004d8;
}
}
else {
if (DAT_030000d4 < 8) {
DAT_030000d4 = DAT_030000d4 + 1;
FUN_08000864();
if (uVar1 == 0x10) {
DAT_030000d8 = DAT_030000d8 + 0x3a;
```

U prethodnom kodu možete videti da upoređujemo **uVar1** (mesto gde je **vrednost pritisnutog dugmeta**) sa nekim vrednostima:

* Prvo se upoređuje sa **vrednošću 4** (dugme **SELECT**): U izazovu ovo dugme čisti ekran
* Zatim se upoređuje sa **vrednošću 8** (dugme **START**): U izazovu se proverava da li je kod validan za dobijanje zastave.
* U ovom slučaju se varijabla **`DAT_030000d8`** upoređuje sa 0xf3 i ako je vrednost ista, izvršava se određeni kod.
* U svim ostalim slučajevima se proverava neka kont (`DAT_030000d4`). To je kont jer se dodaje 1 odmah nakon unosa koda.\
  Ako je manje od 8, nešto što uključuje **dodavanje** vrednosti u **`DAT_030000d8`** se radi (u osnovi se dodaju vrednosti pritisnutih tastera u ovu promenljivu dok je kont manji od 8).

Dakle, u ovom izazovu, znajući vrednosti dugmadi, trebalo je **pritisnuti kombinaciju dužine manje od 8 čija rezultujuća zbirka bude 0xf3.**

**Reference za ovaj tutorijal:** [**https://exp.codes/Nostalgia/**](https://exp.codes/Nostalgia/)

## Game Boy

{% embed url="https://www.youtube.com/watch?v=VVbRe7wr3G4" %}

## Kursevi

* [https://github.com/0xZ0F/Z0FCourse\_ReverseEngineering](https://github.com/0xZ0F/Z0FCourse\_ReverseEngineering)
* [https://github.com/malrev/ABD](https://github.com/malrev/ABD) (Deobfuskacija binarnog koda)

**Try Hard Security Group**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA ČLANSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
