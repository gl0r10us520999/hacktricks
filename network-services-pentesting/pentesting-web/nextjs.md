# NextJS

{% hint style="success" %}
Lerne & Ã¼be AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & Ã¼be GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>UnterstÃ¼tze HackTricks</summary>

* ÃœberprÃ¼fe die [**AbonnementplÃ¤ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** ğŸ’¬ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Allgemeine Architektur einer Next.js Anwendung

### Typische Dateistruktur

Ein Standard-Next.js-Projekt folgt einer spezifischen Datei- und Verzeichnisstruktur, die seine Funktionen wie Routing, API-Endpunkte und Verwaltung statischer Assets erleichtert. Hier ist ein typisches Layout:
```lua
my-nextjs-app/
â”œâ”€â”€ node_modules/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ logo.png
â”‚   â””â”€â”€ favicon.ico
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ hello/
â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”œâ”€â”€ page.tsx
â”‚   â”œâ”€â”€ about/
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â””â”€â”€ Footer.tsx
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â””â”€â”€ Home.module.css
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ api.ts
â”œâ”€â”€ .env.local
â”œâ”€â”€ next.config.js
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â””â”€â”€ yarn.lock / package-lock.json

```
### Kernverzeichnisse und Dateien

* **public/:** Beherbergt statische Assets wie Bilder, Schriftarten und andere Dateien. Dateien hier sind am Stammverzeichnis (`/`) zugÃ¤nglich.
* **app/:** Zentrales Verzeichnis fÃ¼r die Seiten, Layouts, Komponenten und API-Routen Ihrer Anwendung. Umfasst das **App Router**-Paradigma, das erweiterte Routing-Funktionen und die Trennung von Server- und Client-Komponenten ermÃ¶glicht.
* **app/layout.tsx:** Definiert das Hauptlayout fÃ¼r Ihre Anwendung, das alle Seiten umschlieÃŸt und konsistente UI-Elemente wie Kopfzeilen, FuÃŸzeilen und Navigationsleisten bereitstellt.
* **app/page.tsx:** Dient als Einstiegspunkt fÃ¼r die Stammroute `/`, die die Startseite rendert.
* **app/\[route]/page.tsx:** Behandelt statische und dynamische Routen. Jedes Verzeichnis innerhalb von `app/` stellt ein Routen-Segment dar, und `page.tsx` innerhalb dieser Verzeichnisse entspricht der Komponente der Route.
* **app/api/:** EnthÃ¤lt API-Routen, die es Ihnen ermÃ¶glichen, serverlose Funktionen zu erstellen, die HTTP-Anfragen verarbeiten. Diese Routen ersetzen das traditionelle Verzeichnis `pages/api`.
* **app/components/:** Beherbergt wiederverwendbare React-Komponenten, die in verschiedenen Seiten und Layouts verwendet werden kÃ¶nnen.
* **app/styles/:** EnthÃ¤lt globale CSS-Dateien und CSS-Module fÃ¼r komponentenspezifisches Styling.
* **app/utils/:** Beinhaltet Hilfsfunktionen, Hilfsmodule und andere nicht-UI-Logik, die in der gesamten Anwendung geteilt werden kann.
* **.env.local:** Speichert Umgebungsvariablen, die spezifisch fÃ¼r die lokale Entwicklungsumgebung sind. Diese Variablen werden **nicht** in die Versionskontrolle Ã¼bernommen.
* **next.config.js:** Passt das Verhalten von Next.js an, einschlieÃŸlich webpack-Konfigurationen, Umgebungsvariablen und Sicherheitseinstellungen.
* **tsconfig.json:** Konfiguriert die TypeScript-Einstellungen fÃ¼r das Projekt, ermÃ¶glicht TypÃ¼berprÃ¼fungen und andere TypeScript-Funktionen.
* **package.json:** Verwaltet die AbhÃ¤ngigkeiten, Skripte und Metadaten des Projekts.
* **README.md:** Bietet Dokumentation und Informationen Ã¼ber das Projekt, einschlieÃŸlich Einrichtungsanleitungen, Nutzungshinweisen und anderen relevanten Details.
* **yarn.lock / package-lock.json:** Sperrt die AbhÃ¤ngigkeiten des Projekts auf bestimmte Versionen, um konsistente Installationen in verschiedenen Umgebungen sicherzustellen.

## Client-Seite in Next.js

### Dateibasiertes Routing im `app`-Verzeichnis

Das `app`-Verzeichnis ist das Fundament des Routings in den neuesten Next.js-Versionen. Es nutzt das Dateisystem, um Routen zu definieren, was das Routing-Management intuitiv und skalierbar macht.

<details>

<summary>Behandlung des Stammverzeichnisses /</summary>

**Dateistruktur:**
```arduino
my-nextjs-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ public/
â”œâ”€â”€ next.config.js
â””â”€â”€ ...
```
**Wichtige Dateien:**

* **`app/page.tsx`**: Behandelt Anfragen an den Stamm-Pfad `/`.
* **`app/layout.tsx`**: Definiert das Layout fÃ¼r die Anwendung, das alle Seiten umschlieÃŸt.

**Implementierung:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**ErklÃ¤rung:**

* **Routen-Definition:** Die `page.tsx`-Datei direkt im `app`-Verzeichnis entspricht der `/`-Route.
* **Rendering:** Diese Komponente rendert den Inhalt fÃ¼r die Startseite.
* **Layout-Integration:** Die `HomePage`-Komponente wird von der `layout.tsx` umschlossen, die Header, Footer und andere gemeinsame Elemente enthalten kann.

</details>

<details>

<summary>Verarbeitung anderer statischer Pfade</summary>



**Beispiel: `/about`-Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ about/
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ public/
â”œâ”€â”€ next.config.js
â””â”€â”€ ...
```
**Implementierung:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
);
}
```
**ErklÃ¤rung:**

* **Routen-Definition:** Die `page.tsx`-Datei im `about`-Ordner entspricht der `/about`-Route.
* **Rendering:** Diese Komponente rendert den Inhalt fÃ¼r die Ãœber-Seite.

</details>

<details>

<summary>Dynamische Routen</summary>

Dynamische Routen ermÃ¶glichen die Handhabung von Pfaden mit variablen Segmenten, wodurch Anwendungen Inhalte basierend auf Parametern wie IDs, Slugs usw. anzeigen kÃ¶nnen.

**Beispiel: `/posts/[id]` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ public/
â”œâ”€â”€ next.config.js
â””â”€â”€ ...
```
**Implementierung:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**ErklÃ¤rung:**

* **Dynamisches Segment:** `[id]` bezeichnet ein dynamisches Segment in der Route, das den `id`-Parameter aus der URL erfasst.
* **Zugriff auf Parameter:** Das `params`-Objekt enthÃ¤lt die dynamischen Parameter, die innerhalb der Komponente zugÃ¤nglich sind.
* **Routenabgleich:** Jeder Pfad, der mit `/posts/*` Ã¼bereinstimmt, wie z.B. `/posts/1`, `/posts/abc` usw., wird von dieser Komponente verarbeitet.

</details>

<details>

<summary>Verschachtelte Routen</summary>



Next.js unterstÃ¼tzt verschachtelte Routen, die hierarchische Routenstrukturen ermÃ¶glichen, die der Verzeichnisstruktur entsprechen.

**Beispiel: `/dashboard/settings/profile` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â”‚   â””â”€â”€ profile/
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ public/
â”œâ”€â”€ next.config.js
â””â”€â”€ ...
```
**Implementierung:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**ErklÃ¤rung:**

* **Tiefe Verschachtelung:** Die `page.tsx`-Datei im Verzeichnis `dashboard/settings/profile/` entspricht dem `/dashboard/settings/profile`-Pfad.
* **Hierarchie-Reflexion:** Die Verzeichnisstruktur spiegelt den URL-Pfad wider, was die Wartbarkeit und Klarheit verbessert.

</details>

<details>

<summary>Catch-All-Routen</summary>

Catch-All-Routen behandeln mehrere verschachtelte Segmente oder unbekannte Pfade und bieten FlexibilitÃ¤t bei der Routenverarbeitung.

**Beispiel: `/*` Route**

**Dateistruktur:**
```arduino
my-nextjs-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ [..slug]/
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ public/
â”œâ”€â”€ next.config.js
â””â”€â”€ ...
```
**Implementierung:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] };
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params;
const fullPath = `/${slug.join('/')}`;

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
);
}
```
**ErklÃ¤rung:**

* **Catch-All Segment:** `[...slug]` erfasst alle verbleibenden Pfadsegmente als Array.
* **Verwendung:** NÃ¼tzlich fÃ¼r die Handhabung dynamischer Routing-Szenarien wie benutzergenerierte Pfade, verschachtelte Kategorien usw.
* **Routenabgleich:** Pfade wie `/anything/here`, `/foo/bar/baz` usw. werden von dieser Komponente verarbeitet.

</details>

### Potenzielle Client-Seitige Schwachstellen

WÃ¤hrend Next.js eine sichere Grundlage bietet, kÃ¶nnen unsachgemÃ¤ÃŸe Programmierpraktiken Schwachstellen einfÃ¼hren. Wichtige client-seitige Schwachstellen sind:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-Angriffe treten auf, wenn bÃ¶sartige Skripte in vertrauenswÃ¼rdige Websites injiziert werden. Angreifer kÃ¶nnen Skripte in den Browsern der Benutzer ausfÃ¼hren, Daten stehlen oder Aktionen im Namen des Benutzers durchfÃ¼hren.

**Beispiel fÃ¼r anfÃ¤lligen Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
}
```
**Warum es anfÃ¤llig ist:** Die Verwendung von `dangerouslySetInnerHTML` mit nicht vertrauenswÃ¼rdigen Eingaben ermÃ¶glicht es Angreifern, bÃ¶sartige Skripte einzuschleusen.

</details>

<details>

<summary>Client-Seitige Template-Injection</summary>

Tritt auf, wenn Benutzereingaben in Templates unsachgemÃ¤ÃŸ behandelt werden, was es Angreifern ermÃ¶glicht, Templates oder AusdrÃ¼cke einzuschleusen und auszufÃ¼hren.

**Beispiel fÃ¼r anfÃ¤lligen Code:**
```jsx
import React from 'react';
import ejs from 'ejs';

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data);
return <div dangerouslySetInnerHTML={{ __html: html }} />;
}
```
**Warum es anfÃ¤llig ist:** Wenn `template` oder `data` bÃ¶sartigen Inhalt enthalten, kann dies zur AusfÃ¼hrung von unbeabsichtigtem Code fÃ¼hren.

</details>

<details>

<summary>Client Path Traversal</summary>

Es handelt sich um eine Schwachstelle, die Angreifern ermÃ¶glicht, clientseitige Pfade zu manipulieren, um unbeabsichtigte Aktionen durchzufÃ¼hren, wie z.B. Cross-Site Request Forgery (CSRF). Im Gegensatz zur serverseitigen Pfadtraversierung, die das Dateisystem des Servers angreift, konzentriert sich CSPT darauf, clientseitige Mechanismen auszunutzen, um legitime API-Anfragen an bÃ¶sartige Endpunkte umzuleiten.

**Beispiel fÃ¼r anfÃ¤lligen Code:**

Eine Next.js-Anwendung ermÃ¶glicht es Benutzern, Dateien hochzuladen und herunterzuladen. Die Download-Funktion wird auf der Client-Seite implementiert, wo Benutzer den Dateipfad angeben kÃ¶nnen, um herunterzuladen.
```jsx
// pages/download.js
import { useState } from 'react';

export default function DownloadPage() {
const [filePath, setFilePath] = useState('');

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then(response => response.blob())
.then(blob => {
const url = window.URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = filePath;
a.click();
});
};

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
);
}
```
#### Angriffsszenario

1. **Ziel des Angreifers**: DurchfÃ¼hrung eines CSRF-Angriffs, um eine kritische Datei (z. B. `admin/config.json`) zu lÃ¶schen, indem der `filePath` manipuliert wird.
2. **Ausnutzung von CSPT**:
* **BÃ¶sartige Eingabe**: Der Angreifer erstellt eine URL mit einem manipulierten `filePath`, wie z. B. `../deleteFile/config.json`.
* **Resultierender API-Aufruf**: Der clientseitige Code sendet eine Anfrage an `/api/files/../deleteFile/config.json`.
* **Verarbeitung durch den Server**: Wenn der Server den `filePath` nicht validiert, verarbeitet er die Anfrage und kÃ¶nnte sensible Dateien lÃ¶schen oder offenlegen.
3. **AusfÃ¼hrung von CSRF**:
* **Erstellter Link**: Der Angreifer sendet dem Opfer einen Link oder bettet ein bÃ¶sartiges Skript ein, das die Download-Anfrage mit dem manipulierten `filePath` auslÃ¶st.
* **Ergebnis**: Das Opfer fÃ¼hrt unwissentlich die Aktion aus, was zu unbefugtem Datei-Zugriff oder -LÃ¶schung fÃ¼hrt.

#### Warum es anfÃ¤llig ist

* **Fehlende Eingabevalidierung**: Die clientseitige Anwendung erlaubt beliebige `filePath`-Eingaben, was Pfadtraversal ermÃ¶glicht.
* **Vertrauen auf Client-Eingaben**: Die serverseitige API vertraut und verarbeitet den `filePath` ohne SanitÃ¤rmaÃŸnahmen.
* **Potenzielle API-Aktionen**: Wenn der API-Endpunkt zustandsverÃ¤ndernde Aktionen durchfÃ¼hrt (z. B. lÃ¶schen, Dateien Ã¤ndern), kann er Ã¼ber CSPT ausgenutzt werden.

</details>

## Server-Seite in Next.js

### Server-Seitiges Rendering (SSR)

Seiten werden bei jeder Anfrage auf dem Server gerendert, sodass der Benutzer vollstÃ¤ndig gerendertes HTML erhÃ¤lt. In diesem Fall sollten Sie Ihren eigenen benutzerdefinierten Server erstellen, um die Anfragen zu verarbeiten.

**AnwendungsfÃ¤lle:**

* Dynamische Inhalte, die sich hÃ¤ufig Ã¤ndern.
* SEO-Optimierung, da Suchmaschinen die vollstÃ¤ndig gerenderte Seite crawlen kÃ¶nnen.

**Implementierung:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch('https://api.example.com/data');
const data = await res.json();
return { props: { data } };
}

function HomePage({ data }) {
return <div>{data.title}</div>;
}

export default HomePage;
```
### Statische Seitenerstellung (SSG)

Seiten werden zur Build-Zeit vorgerendert, was zu schnelleren Ladezeiten und einer reduzierten Serverlast fÃ¼hrt.

**AnwendungsfÃ¤lle:**

* Inhalte, die sich nicht hÃ¤ufig Ã¤ndern.
* Blogs, Dokumentation, Marketingseiten.

**Implementierung:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch('https://api.example.com/data');
const data = await res.json();
return { props: { data }, revalidate: 60 }; // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>;
}

export default HomePage;
```
### Serverless Functions (API-Routen)

Next.js ermÃ¶glicht die Erstellung von API-Endpunkten als serverlose Funktionen. Diese Funktionen werden nach Bedarf ausgefÃ¼hrt, ohne dass ein dedizierter Server erforderlich ist.

**AnwendungsfÃ¤lle:**

* Verarbeitung von FormularÃ¼bermittlungen.
* Interaktion mit Datenbanken.
* Datenverarbeitung oder Integration mit Drittanbieter-APIs.

**Implementierung:**

Mit der EinfÃ¼hrung des `app`-Verzeichnisses in Next.js 13 sind Routing und API-Verwaltung flexibler und leistungsfÃ¤higer geworden. Dieser moderne Ansatz steht in engem Zusammenhang mit dem dateibasierten Routing-System, bietet jedoch erweiterte Funktionen, einschlieÃŸlich UnterstÃ¼tzung fÃ¼r Server- und Client-Komponenten.

#### Grundlegender Routen-Handler

**Dateistruktur:**
```go
my-nextjs-app/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ hello/
â”‚           â””â”€â”€ route.js
â”œâ”€â”€ package.json
â””â”€â”€ ...
```
**Implementierung:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: 'Hello from App Router!' }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}

// Client-side fetch to access the API endpoint
fetch('/api/submit', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ name: 'John Doe' }),
})
.then((res) => res.json())
.then((data) => console.log(data));
```
**ErklÃ¤rung:**

* **Standort:** API-Routen befinden sich im Verzeichnis `app/api/`.
* **Dateibenennung:** Jeder API-Endpunkt befindet sich in seinem eigenen Ordner, der eine `route.js` oder `route.ts`-Datei enthÃ¤lt.
* **Exportierte Funktionen:** Anstelle eines einzelnen Standardexports werden spezifische HTTP-Methodenfunktionen (z. B. `GET`, `POST`) exportiert.
* **Antwortverarbeitung:** Verwenden Sie den `Response`-Konstruktor, um Antworten zurÃ¼ckzugeben, was mehr Kontrolle Ã¼ber Header und Statuscodes ermÃ¶glicht.

#### So gehen Sie mit anderen Pfaden und Methoden um:

<details>

<summary>Verarbeitung spezifischer HTTP-Methoden</summary>

Next.js 13+ ermÃ¶glicht es Ihnen, Handler fÃ¼r spezifische HTTP-Methoden innerhalb derselben `route.js` oder `route.ts`-Datei zu definieren, was klareren und besser organisierten Code fÃ¶rdert.

**Beispiel:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params;
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: 'Jane Doe' }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}

export async function PUT(request, { params }) {
const { id } = params;
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}

export async function DELETE(request, { params }) {
const { id } = params;
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}
```
**ErklÃ¤rung:**

* **Mehrere Exporte:** Jede HTTP-Methode (`GET`, `PUT`, `DELETE`) hat ihre eigene exportierte Funktion.
* **Parameter:** Das zweite Argument ermÃ¶glicht den Zugriff auf Routenparameter Ã¼ber `params`.
* **Erweiterte Antworten:** GrÃ¶ÃŸere Kontrolle Ã¼ber Antwortobjekte, die eine prÃ¤zise Verwaltung von Headern und Statuscodes ermÃ¶glicht.

</details>

<details>

<summary>Catch-All und Verschachtelte Routen</summary>



Next.js 13+ unterstÃ¼tzt erweiterte Routing-Funktionen wie Catch-All-Routen und verschachtelte API-Routen, die dynamischere und skalierbarere API-Strukturen ermÃ¶glichen.

**Catch-All-Routenbeispiel:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params;
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}
```
**ErklÃ¤rung:**

* **Syntax:** `[...]` bezeichnet ein Catch-All-Segment, das alle verschachtelten Pfade erfasst.
* **Verwendung:** NÃ¼tzlich fÃ¼r APIs, die unterschiedliche Routen-Tiefen oder dynamische Segmente verarbeiten mÃ¼ssen.

**Beispiel fÃ¼r verschachtelte Routen:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params;
// Fetch specific comment for a post
return new Response(JSON.stringify({ postId, commentId, comment: 'Great post!' }), {
status: 200,
headers: { 'Content-Type': 'application/json' },
});
}
```
**ErklÃ¤rung:**

* **Tiefe Verschachtelung:** ErmÃ¶glicht hierarchische API-Strukturen, die Ressourcenbeziehungen widerspiegeln.
* **Parameterzugriff:** Einfacher Zugriff auf mehrere Routenparameter Ã¼ber das `params`-Objekt.

</details>

<details>

<summary>Verarbeitung von API-Routen in Next.js 12 und frÃ¼her</summary>

## API-Routen im `pages`-Verzeichnis (Next.js 12 und frÃ¼her)

Bevor Next.js 13 das `app`-Verzeichnis und verbesserte Routing-Funktionen einfÃ¼hrte, wurden API-Routen hauptsÃ¤chlich im `pages`-Verzeichnis definiert. Dieser Ansatz wird immer noch hÃ¤ufig verwendet und in Next.js 12 und frÃ¼heren Versionen unterstÃ¼tzt.

#### Grundlegende API-Route

**Dateistruktur:**
```go
goCopy codemy-nextjs-app/
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ hello.js
â”œâ”€â”€ package.json
â””â”€â”€ ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**ErklÃ¤rung:**

* **Standort:** API-Routen befinden sich im Verzeichnis `pages/api/`.
* **Export:** Verwenden Sie `export default`, um die Handler-Funktion zu definieren.
* **Funktionssignatur:** Der Handler erhÃ¤lt die Objekte `req` (HTTP-Anfrage) und `res` (HTTP-Antwort).
* **Routing:** Der Dateiname (`hello.js`) entspricht dem Endpunkt `/api/hello`.

#### Dynamische API-Routen

**Dateistruktur:**
```bash
bashCopy codemy-nextjs-app/
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ users/
â”‚           â””â”€â”€ [id].js
â”œâ”€â”€ package.json
â””â”€â”€ ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**ErklÃ¤rung:**

* **Dynamische Segmente:** Eckige Klammern (`[id].js`) kennzeichnen dynamische Routen-Segmente.
* **Zugriff auf Parameter:** Verwenden Sie `req.query.id`, um auf den dynamischen Parameter zuzugreifen.
* **Verarbeitung von Methoden:** Nutzen Sie bedingte Logik, um verschiedene HTTP-Methoden (`GET`, `PUT`, `DELETE` usw.) zu verarbeiten.

#### Verarbeitung verschiedener HTTP-Methoden

WÃ¤hrend das grundlegende API-Routenbeispiel alle HTTP-Methoden innerhalb einer einzigen Funktion behandelt, kÃ¶nnen Sie Ihren Code so strukturieren, dass jede Methode explizit fÃ¼r bessere Klarheit und Wartbarkeit behandelt wird.

**Beispiel:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Best Practices:**

* **Trennung der Anliegen:** Logik fÃ¼r verschiedene HTTP-Methoden klar trennen.
* **Antwortkonsistenz:** Konsistente Antwortstrukturen sicherstellen, um die Handhabung auf der Client-Seite zu erleichtern.
* **Fehlerbehandlung:** Nicht unterstÃ¼tzte Methoden und unerwartete Fehler elegant behandeln.

</details>

### CORS-Konfiguration

Steuern Sie, welche UrsprÃ¼nge auf Ihre API-Routen zugreifen kÃ¶nnen, um Cross-Origin Resource Sharing (CORS) -Schwachstellen zu mindern.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: 'Public Data' }), {
status: 200,
headers: {
'Access-Control-Allow-Origin': '*', // Allows any origin
'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
},
});
}
```
Beachten Sie, dass **CORS auch in allen API-Routen** innerhalb der **`middleware.ts`**-Datei konfiguriert werden kann:
```javascript
// app/middleware.ts

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
const allowedOrigins = ['https://yourdomain.com', 'https://sub.yourdomain.com'];
const origin = request.headers.get('Origin');

const response = NextResponse.next();

if (allowedOrigins.includes(origin || '')) {
response.headers.set('Access-Control-Allow-Origin', origin || '');
response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === 'OPTIONS') {
return new Response(null, {
status: 204,
headers: response.headers,
});
}

return response;
}

export const config = {
matcher: '/api/:path*', // Apply to all API routes
};

```
**Problem:**

* **`Access-Control-Allow-Origin: '*'`:** Erlaubt jeder Website den Zugriff auf die API, was potenziell bÃ¶sartigen Seiten ermÃ¶glicht, ohne EinschrÃ¤nkungen mit Ihrer API zu interagieren.
* **Breite Methoden-Erlaubnis:** Das Zulassen aller Methoden kann Angreifern ermÃ¶glichen, unerwÃ¼nschte Aktionen durchzufÃ¼hren.

**Wie Angreifer es ausnutzen:**

Angreifer kÃ¶nnen bÃ¶sartige Websites erstellen, die Anfragen an Ihre API senden, und dabei Funktionen wie Datenabruf, Datenmanipulation oder das AuslÃ¶sen unerwÃ¼nschter Aktionen im Namen authentifizierter Benutzer missbrauchen.

{% content-ref url="../../pentesting-web/cors-bypass.md" %}
[cors-bypass.md](../../pentesting-web/cors-bypass.md)
{% endcontent-ref %}

### Servercode-Exposition auf der Client-Seite

Es kann einfach sein, **Code, der vom Server verwendet wird, auch im Code zu verwenden, der auf der Client-Seite exponiert und verwendet wird**. Der beste Weg, um sicherzustellen, dass eine Datei mit Code niemals auf der Client-Seite exponiert wird, ist die Verwendung dieses Imports zu Beginn der Datei:
```js
import "server-only";
```
## SchlÃ¼sseldateien und ihre Rollen

### `middleware.ts` / `middleware.js`

**Standort:** Wurzel des Projekts oder innerhalb von `src/`.

**Zweck:** FÃ¼hrt Code in der serverseitigen serverlosen Funktion aus, bevor eine Anfrage verarbeitet wird, was Aufgaben wie Authentifizierung, Weiterleitungen oder das Ã„ndern von Antworten ermÃ¶glicht.

**AusfÃ¼hrungsfluss:**

1. **Eingehende Anfrage:** Die Middleware fÃ¤ngt die Anfrage ab.
2. **Verarbeitung:** FÃ¼hrt Operationen basierend auf der Anfrage durch (z. B. ÃœberprÃ¼fung der Authentifizierung).
3. **AntwortÃ¤nderung:** Kann die Antwort Ã¤ndern oder die Kontrolle an den nÃ¤chsten Handler Ã¼bergeben.

**BeispielanwendungsfÃ¤lle:**

* Umleitung nicht authentifizierter Benutzer.
* HinzufÃ¼gen benutzerdefinierter Header.
* Protokollierung von Anfragen.

**Beispielkonfiguration:**
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone();
if (!req.cookies.has('token')) {
url.pathname = '/login';
return NextResponse.redirect(url);
}
return NextResponse.next();
}

export const config = {
matcher: ['/protected/:path*'],
};
```
### `next.config.js`

**Standort:** Wurzel des Projekts.

**Zweck:** Konfiguriert das Verhalten von Next.js, aktiviert oder deaktiviert Funktionen, passt Webpack-Konfigurationen an, setzt Umgebungsvariablen und konfiguriert mehrere Sicherheitsfunktionen.

**Wichtige Sicherheitskonfigurationen:**

<details>

<summary>Sicherheitsheader</summary>

Sicherheitsheader verbessern die Sicherheit Ihrer Anwendung, indem sie Browser anweisen, wie sie mit Inhalten umgehen sollen. Sie helfen, verschiedene Angriffe wie Cross-Site Scripting (XSS), Clickjacking und MIME-Typ-Sniffing zu mindern:

* Content Security Policy (CSP)
* X-Frame-Options
* X-Content-Type-Options
* Strict-Transport-Security (HSTS)
* Referrer Policy

**Beispiele:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: '/(.*)', // Apply to all routes
headers: [
{
key: 'X-Frame-Options',
value: 'DENY',
},
{
key: 'Content-Security-Policy',
value: "default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: 'X-Content-Type-Options',
value: 'nosniff',
},
{
key: 'Strict-Transport-Security',
value: 'max-age=63072000; includeSubDomains; preload', // Enforces HTTPS
},
{
key: 'Referrer-Policy',
value: 'no-referrer', // Completely hides referrer
},
// Additional headers...
],
},
];
},
};
```
</details>

<details>

<summary>Bildoptimierungseinstellungen</summary>

Next.js optimiert Bilder fÃ¼r die Leistung, aber Fehlkonfigurationen kÃ¶nnen zu SicherheitsanfÃ¤lligkeiten fÃ¼hren, wie z.B. das Zulassen von nicht vertrauenswÃ¼rdigen Quellen, die schÃ¤dlichen Inhalt injizieren.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ['*'], // Allows images from any domain
},
};
```
**Problem:**

* **`'*'`:** Erlaubt das Laden von Bildern aus jeder externen Quelle, einschlieÃŸlich untrusted oder bÃ¶sartiger Domains. Angreifer kÃ¶nnen Bilder hosten, die bÃ¶sartige Payloads oder Inhalte enthalten, die Benutzer irrefÃ¼hren.
* Ein weiteres Problem kÃ¶nnte sein, eine Domain zuzulassen **wo jeder ein Bild hochladen kann** (wie `raw.githubusercontent.com`)

**Wie Angreifer es ausnutzen:**

Durch das Injizieren von Bildern aus bÃ¶sartigen Quellen kÃ¶nnen Angreifer Phishing-Angriffe durchfÃ¼hren, irrefÃ¼hrende Informationen anzeigen oder Schwachstellen in Bildrendering-Bibliotheken ausnutzen.

</details>

<details>

<summary>Umgebungsvariablen-Exposition</summary>

Verwalten Sie sensible Informationen wie API-SchlÃ¼ssel und Datenbankanmeldeinformationen sicher, ohne sie dem Client auszusetzen.

#### a. Exponieren sensibler Variablen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
};
```
**Problem:**

* **`SECRET_API_KEY`:** Ohne das `NEXT_PUBLIC_` PrÃ¤fix gibt Next.js keine Variablen an den Client weiter. Wenn es jedoch fÃ¤lschlicherweise mit dem PrÃ¤fix versehen wird (z. B. `NEXT_PUBLIC_SECRET_API_KEY`), wird es auf der Client-Seite zugÃ¤nglich.

**Wie Angreifer es ausnutzen:**

Wenn sensible Variablen dem Client ausgesetzt sind, kÃ¶nnen Angreifer sie abrufen, indem sie den Client-seitigen Code oder Netzwerk-Anfragen inspizieren, und unbefugten Zugriff auf APIs, Datenbanken oder andere Dienste erlangen.

</details>

<details>

<summary>Redirects</summary>

Verwalten Sie URL-Weiterleitungen und -Umschreibungen innerhalb Ihrer Anwendung, um sicherzustellen, dass Benutzer angemessen geleitet werden, ohne offene Redirect-Schwachstellen einzufÃ¼hren.

#### a. Open Redirect Vulnerability

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: '/redirect',
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
];
},
};
```
**Problem:**

* **Dynamisches Ziel:** ErmÃ¶glicht es Benutzern, jede URL anzugeben, was offene Umleitungsangriffe ermÃ¶glicht.
* **Vertrauen auf Benutzereingaben:** Umleitungen zu von Benutzern bereitgestellten URLs ohne Validierung kÃ¶nnen zu Phishing, Malware-Verbreitung oder Diebstahl von Anmeldeinformationen fÃ¼hren.

**Wie Angreifer es ausnutzen:**

Angreifer kÃ¶nnen URLs erstellen, die scheinbar von Ihrer Domain stammen, aber Benutzer auf bÃ¶sartige Seiten umleiten. Zum Beispiel:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Benutzer, die der ursprÃ¼nglichen Domain vertrauen, kÃ¶nnten unwissentlich zu schÃ¤dlichen Websites navigieren.

</details>

<details>

<summary>Webpack-Konfiguration</summary>

Passen Sie die Webpack-Konfigurationen fÃ¼r Ihre Next.js-Anwendung an, die unbeabsichtigt SicherheitsanfÃ¤lligkeiten einfÃ¼hren kÃ¶nnen, wenn sie nicht vorsichtig behandelt werden.

#### a. Sensible Module offenlegen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias['@sensitive'] = path.join(__dirname, 'secret-folder');
}
return config;
},
};
```
**Problem:**

* **Exponieren sensibler Pfade:** Das Aliasing sensibler Verzeichnisse und das Zulassen des Zugriffs von der Client-Seite kÃ¶nnen vertrauliche Informationen leaken.
* **BÃ¼ndeln von Geheimnissen:** Wenn sensible Dateien fÃ¼r den Client gebÃ¼ndelt werden, werden deren Inhalte Ã¼ber Quellkarten oder durch Inspektion des Client-Seiten-Codes zugÃ¤nglich.

**Wie Angreifer es ausnutzen:**

Angreifer kÃ¶nnen auf die Verzeichnisstruktur der Anwendung zugreifen oder diese rekonstruieren, wodurch sie potenziell sensible Dateien oder Daten finden und ausnutzen kÃ¶nnen.

</details>

### `pages/_app.js` und `pages/_document.js`

#### **`pages/_app.js`**

**Zweck:** Ãœberschreibt die Standard-App-Komponente und ermÃ¶glicht globale ZustÃ¤nde, Stile und Layout-Komponenten.

**AnwendungsfÃ¤lle:**

* Injizieren von globalem CSS.
* HinzufÃ¼gen von Layout-Wrappern.
* Integrieren von Zustandsverwaltungsbibliotheken.

**Beispiel:**
```jsx
// pages/_app.js
import '../styles/globals.css';

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />;
}

export default MyApp;
```
#### **`pages/_document.js`**

**Zweck:** Ãœberschreibt das Standarddokument und ermÃ¶glicht die Anpassung der HTML- und Body-Tags.

**AnwendungsfÃ¤lle:**

* Ã„ndern der `<html>`- oder `<body>`-Tags.
* HinzufÃ¼gen von Meta-Tags oder benutzerdefinierten Skripten.
* Integration von Schriftarten von Drittanbietern.

**Beispiel:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from 'next/document';

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>
{/* Custom fonts or meta tags */}
</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
);
}
}

export default MyDocument;
```
### Custom Server (Optional)

**Zweck:** WÃ¤hrend Next.js mit einem integrierten Server geliefert wird, kÃ¶nnen Sie einen benutzerdefinierten Server fÃ¼r erweiterte AnwendungsfÃ¤lle wie benutzerdefinierte Routen oder die Integration mit bestehenden Backend-Diensten erstellen.

**Hinweis:** Die Verwendung eines benutzerdefinierten Servers kann die Bereitstellungsoptionen einschrÃ¤nken, insbesondere auf Plattformen wie Vercel, die fÃ¼r den integrierten Server von Next.js optimieren.

**Beispiel:**
```javascript
// server.js
const express = require('express');
const next = require('next');

const dev = process.env.NODE_ENV !== 'production';
const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
const server = express();

// Custom route
server.get('/a', (req, res) => {
return app.render(req, res, '/a');
});

// Default handler
server.all('*', (req, res) => {
return handle(req, res);
});

server.listen(3000, (err) => {
if (err) throw err;
console.log('> Ready on http://localhost:3000');
});
});
```
***

## ZusÃ¤tzliche architektonische und sicherheitstechnische Ãœberlegungen

### Umgebungsvariablen und Konfiguration

**Zweck:** Sensible Informationen und Konfigurationseinstellungen auÃŸerhalb des Codes verwalten.

**Best Practices:**

* **Verwenden Sie `.env`-Dateien:** Speichern Sie Variablen wie API-SchlÃ¼ssel in `.env.local` (von der Versionskontrolle ausgeschlossen).
* **Greifen Sie sicher auf Variablen zu:** Verwenden Sie `process.env.VARIABLE_NAME`, um auf Umgebungsvariablen zuzugreifen.
* **Nie Geheimnisse auf dem Client offenlegen:** Stellen Sie sicher, dass sensible Variablen nur serverseitig verwendet werden.

**Beispiel:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
};
```
**Hinweis:** Um Variablen nur auf der Serverseite einzuschrÃ¤nken, lassen Sie sie aus dem `env`-Objekt weg oder prefixen Sie sie mit `NEXT_PUBLIC_` fÃ¼r die Client-Exposition.

### Authentifizierung und Autorisierung

**Ansatz:**

* **Sitzungsbasierte Authentifizierung:** Verwenden Sie Cookies zur Verwaltung von Benutzersitzungen.
* **Token-basierte Authentifizierung:** Implementieren Sie JWTs fÃ¼r zustandslose Authentifizierung.
* **Drittanbieter:** Integrieren Sie sich mit OAuth-Anbietern (z. B. Google, GitHub) unter Verwendung von Bibliotheken wie `next-auth`.

**Sicherheitspraktiken:**

* **Sichere Cookies:** Setzen Sie die Attribute `HttpOnly`, `Secure` und `SameSite`.
* **Passwort-Hashing:** Hashen Sie PasswÃ¶rter immer, bevor Sie sie speichern.
* **Eingabevalidierung:** Verhindern Sie Injektionsangriffe, indem Sie Eingaben validieren und bereinigen.

**Beispiel:**
```javascript
// pages/api/login.js
import { sign } from 'jsonwebtoken';
import { serialize } from 'cookie';

export default async function handler(req, res) {
const { username, password } = req.body;

// Validate user credentials
if (username === 'admin' && password === 'password') {
const token = sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });
res.setHeader('Set-Cookie', serialize('auth', token, { path: '/', httpOnly: true, secure: true, sameSite: 'strict' }));
res.status(200).json({ message: 'Logged in' });
} else {
res.status(401).json({ error: 'Invalid credentials' });
}
}
```
### Performance-Optimierung

**Strategien:**

* **Bildoptimierung:** Verwenden Sie die `next/image`-Komponente von Next.js fÃ¼r automatische Bildoptimierung.
* **Code-Splitting:** Nutzen Sie dynamische Importe, um Code zu splitten und die anfÃ¤nglichen Ladezeiten zu reduzieren.
* **Caching:** Implementieren Sie Caching-Strategien fÃ¼r API-Antworten und statische Assets.
* **Lazy Loading:** Laden Sie Komponenten oder Assets nur, wenn sie benÃ¶tigt werden.

**Beispiel:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('../components/HeavyComponent'), {
loading: () => <p>Loading...</p>,
});
```
{% hint style="success" %}
Lerne & Ã¼be AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & Ã¼be GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>UnterstÃ¼tze HackTricks</summary>

* ÃœberprÃ¼fe die [**AbonnementplÃ¤ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** ğŸ’¬ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
