# Nginx

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** bizi takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

<figure><img src="/.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Web uygulamalarınız, ağınız ve bulutunuz hakkında bir hacker perspektifi edinin**

**Gerçek iş etkisi olan kritik, istismar edilebilir güvenlik açıklarını bulun ve raporlayın.** Saldırı yüzeyini haritalamak, ayrıcalıkları artırmanıza izin veren güvenlik sorunlarını bulmak ve temel kanıtları toplamak için otomatik istismarları kullanmak için 20'den fazla özel aracımızı kullanın, böylece sıkı çalışmanızı ikna edici raporlara dönüştürün.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Eksik kök konumu <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root direktifi** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği düşünün:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada, `/etc/nginx` kök dizin olarak belirlenmiştir. Bu ayar, `/hello.txt` gibi belirtilen kök dizin içindeki dosyalara erişim sağlar. Ancak, yalnızca belirli bir konum (`/hello.txt`) tanımlandığını belirtmek önemlidir. Kök konumu için (`location / {...}`) herhangi bir yapılandırma yoktur. Bu eksiklik, kök direktifinin küresel olarak uygulanması anlamına gelir ve kök yolu `/` altındaki dosyalara erişim sağlar.

Bu yapılandırmadan kaynaklanan kritik bir güvenlik dikkati vardır. `GET /nginx.conf` gibi basit bir `GET` isteği, `/etc/nginx/nginx.conf` konumundaki Nginx yapılandırma dosyasını sunarak hassas bilgileri açığa çıkarabilir. Kökü daha az hassas bir dizine, örneğin `/etc` olarak ayarlamak bu riski azaltabilir, ancak yine de diğer kritik dosyalara, diğer yapılandırma dosyalarına, erişim günlüklerine ve hatta HTTP temel kimlik doğrulaması için kullanılan şifrelenmiş kimlik bilgilerine istenmeyen erişim izni verebilir.

## Alias LFI Yanlış Yapılandırması <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx yapılandırma dosyalarında, "location" direktifleri için dikkatli bir inceleme gereklidir. Yerel Dosya Dahil Etme (LFI) olarak bilinen bir zafiyet, aşağıdaki gibi bir yapılandırma aracılığıyla istemeden tanıtılabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri, hedef dizin dışındaki dosyalara erişim girişimi olarak yorumlaması nedeniyle LFI saldırılarına açıktır ve bu da `/path/images/../flag.txt` olarak çözülmektedir. Bu hata, saldırganların web üzerinden erişilememesi gereken dosyaları sunucunun dosya sisteminden almasına olanak tanır.

Bu güvenlik açığını azaltmak için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı kontrol ederek şu gibi direktifleri nasıl atlayacağınızı öğrenin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Güvensiz değişken kullanımı / HTTP İstek Bölme <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Zayıf değişkenler `$uri` ve `$document_uri` ve bunlar `$request_uri` ile değiştirilerek düzeltilebilir.

Bir regex de şu şekilde zayıf olabilir:

`location ~ /docs/([^/])? { … $1 … }` - Zayıf&#x20;

`location ~ /docs/([^/\s])? { … $1 … }` - Zayıf değil (boşlukları kontrol ediyor)

`location ~ /docs/(.*)? { … $1 … }`  - Zayıf değil
{% endhint %}

Nginx yapılandırmasındaki bir zayıflık aşağıdaki örnekle gösterilmektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde \r (Carriage Return) ve \n (Line Feed) karakterleri yeni satır karakterlerini belirtir ve URL kodlu formları `%0d%0a` olarak temsil edilir. Bu karakterleri yanlış yapılandırılmış bir sunucuya yapılan bir isteğe (örneğin, `http://localhost/%0d%0aDetectify:%20clrf`) dahil etmek, sunucunun `Detectify` adında yeni bir başlık oluşturmasına neden olur. Bu, $uri değişkeninin URL kodlu yeni satır karakterlerini çözmesi nedeniyle gerçekleşir ve yanıt içinde beklenmeyen bir başlık oluşur:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF enjeksiyonu ve yanıt bölme riskleri hakkında daha fazla bilgi edinin [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ayrıca bu teknik [**bu konuşmada açıklanmıştır**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) bazı savunmasız örnekler ve tespit mekanizmaları ile. Örneğin, bu yanlış yapılandırmayı bir kara kutu perspektifinden tespit etmek için bu istekleri kullanabilirsiniz:

* `https://example.com/%20X` - Herhangi bir HTTP kodu
* `https://example.com/%20H` - 400 Bad Request

Eğer savunmasızsa, ilki "X" herhangi bir HTTP yöntemi olarak dönecek ve ikincisi H geçerli bir yöntem olmadığından bir hata dönecektir. Böylece sunucu şunları alacak: `GET / H HTTP/1.1` ve bu hata tetiklenecektir.

Diğer tespit örnekleri şunlar olabilir:

* `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Herhangi bir HTTP kodu
* `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

O konuşmada sunulan bazı savunmasız yapılandırmalar şunlardı:

* **`$uri`**'nin son URL'de olduğu gibi ayarlandığını not edin.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Tekrar **`$uri`**'nin URL'de (bu sefer bir parametre içinde) olduğunu not edin.
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Şimdi AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

**Kullanıcı tarafından sağlanan verilerin**, belirli koşullar altında **Nginx değişkeni** olarak ele alınabileceği keşfedilmiştir. Bu davranışın nedeni biraz belirsiz kalmakla birlikte, nadir ya da doğrulaması basit değildir. Bu anomali, HackerOne'da yayınlanan bir güvenlik raporunda vurgulanmıştır, [buradan](https://hackerone.com/reports/370094) görüntülenebilir. Hata mesajı üzerindeki daha fazla araştırma, bunun [Nginx'in kod tabanındaki SSI filtre modülünde](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) meydana geldiğini belirlemiş ve Sunucu Tarafı Dahil Etmelerin (SSI) kök neden olduğunu ortaya çıkarmıştır.

Bu **yanlış yapılandırmayı tespit etmek** için, değişken yazdırmasını test etmek amacıyla bir referer başlığı ayarlamayı içeren aşağıdaki komut çalıştırılabilir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Bu yanlış yapılandırma için sistemler arasında yapılan taramalar, bir kullanıcının Nginx değişkenlerini yazdırabileceği birden fazla örneği ortaya çıkardı. Ancak, savunmasız örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının bir ölçüde başarılı olduğunu göstermektedir.

## Ham arka uç yanıtı okuma

Nginx, arka uç tarafından üretilen hataların ve HTTP başlıklarının yakalanmasına olanak tanıyan `proxy_pass` aracılığıyla bir özellik sunar; bu, dahili hata mesajlarını ve başlıkları gizlemeyi amaçlar. Bu, Nginx'in arka uç hatalarına yanıt olarak özel hata sayfaları sunmasıyla gerçekleştirilir. Ancak, Nginx geçersiz bir HTTP isteğiyle karşılaştığında zorluklar ortaya çıkar. Böyle bir istek, alındığı gibi arka uca iletilir ve arka ucun ham yanıtı, Nginx'in müdahalesi olmadan doğrudan istemciye gönderilir.

Bir uWSGI uygulamasını içeren örnek bir senaryoyu düşünün:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bunu yönetmek için Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Bu direktif, Nginx'in 300'den büyük bir durum koduna sahip arka uç yanıtları için özel bir yanıt sunmasını sağlar. Örneğimiz olan uWSGI uygulaması için, `500 Hatası` yanıtının Nginx tarafından yakalanıp işlenmesini garanti eder.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): İsminden de anlaşılacağı gibi, bu direktif belirtilen HTTP başlıklarını istemciden gizler, gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx bunu normal şekilde işler ve herhangi bir gizli başlık ifşa etmeden standart bir hata yanıtı döner. Ancak, geçersiz bir HTTP isteği bu mekanizmayı atlayarak, gizli başlıklar ve hata mesajları da dahil olmak üzere ham arka uç yanıtlarının ifşasına neden olur.

## merge\_slashes kapalı

Varsayılan olarak, Nginx'in **`merge_slashes` direktifi** **`açık`** olarak ayarlanmıştır; bu, bir URL'deki birden fazla ileri eğik çizgiyi tek bir eğik çizgiye sıkıştırır. Bu özellik, URL işleme sürecini kolaylaştırırken, Nginx'in arkasındaki uygulamalarda, özellikle yerel dosya dahil etme (LFI) saldırılarına yatkın olanlarda, güvenlik açıklarını gizleyebilir. Güvenlik uzmanları **Danny Robinson ve Rotem Bar**, Nginx'in ters proxy olarak hareket ettiği durumlarda bu varsayılan davranışla ilişkili potansiyel riskleri vurgulamışlardır.

Bu tür riskleri azaltmak için, bu güvenlik açıklarına duyarlı uygulamalar için **`merge_slashes` direktifini kapatmak** önerilir. Bu, Nginx'in URL yapısını değiştirmeden uygulamaya istekleri iletmesini sağlar ve böylece temel güvenlik sorunlarını gizlemez.

Daha fazla bilgi için [Danny Robinson ve Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d) bağlantısını kontrol edin.

### **Maclicious Yanıt Başlıkları**

[**bu yazıda**](https://mizu.re/post/cors-playground) gösterildiği gibi, web sunucusundan gelen yanıtta mevcut olan belirli başlıklar, Nginx proxy'sinin davranışını değiştirecektir. Bunları [**belgelerde**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) kontrol edebilirsiniz:

* `X-Accel-Redirect`: Nginx'e bir isteği belirtilen bir konuma dahili olarak yönlendirmesini belirtir.
* `X-Accel-Buffering`: Nginx'in yanıtı tamponlayıp tamponlamayacağını kontrol eder.
* `X-Accel-Charset`: X-Accel-Redirect kullanıldığında yanıt için karakter setini ayarlar.
* `X-Accel-Expires`: X-Accel-Redirect kullanıldığında yanıtın son kullanma süresini ayarlar.
* `X-Accel-Limit-Rate`: X-Accel-Redirect kullanıldığında yanıtlar için transfer hızını sınırlar.

Örneğin, **`X-Accel-Redirect`** başlığı, nginx'de dahili bir **yönlendirme** oluşturur. Yani, **`root /`** gibi bir nginx yapılandırmasına sahip olmak ve web sunucusundan **`X-Accel-Redirect: .env`** ile bir yanıt almak, nginx'in **`/.env`** içeriğini göndermesine neden olacaktır (Path Traversal).

### **Map Direktifinde Varsayılan Değer**

**Nginx yapılandırmasında**, `map` direktifi genellikle **yetkilendirme kontrolü** rolü oynar. Yaygın bir hata, **varsayılan** bir değer belirtmemektir; bu da yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default` olmadan, **kötü niyetli bir kullanıcı** `/map-poc` içindeki **tanımsız URI**'ye erişerek güvenliği atlayabilir. [Nginx kılavuzu](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) bu tür sorunları önlemek için bir **varsayılan değer** ayarlamayı önerir.

### **DNS Spoofing Açığı**

Nginx'e karşı DNS spoofing belirli koşullar altında mümkündür. Bir saldırgan, Nginx tarafından kullanılan **DNS sunucusunu** biliyorsa ve DNS sorgularını kesebiliyorsa, DNS kayıtlarını sahteleyebilir. Ancak, Nginx **localhost (127.0.0.1)** kullanacak şekilde yapılandırılmışsa, bu yöntem etkisizdir. Nginx, bir DNS sunucusunu aşağıdaki gibi belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Direktifleri**

**`proxy_pass`** direktifi, istekleri diğer sunuculara, ister dahili ister harici olarak yönlendirmek için kullanılır. **`internal`** direktifi, belirli konumların yalnızca Nginx içinde erişilebilir olmasını sağlar. Bu direktifler kendiliğinden zafiyet oluşturmasa da, yapılandırmaları güvenlik açıklarını önlemek için dikkatli bir şekilde incelenmelidir.

## proxy\_set\_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection başlıklarını geçirecek şekilde yapılandırılmışsa, korunan/dahili uç noktalarına erişmek için bir [**h2c Smuggling saldırısı**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir.

{% hint style="danger" %}
Bu zafiyet, bir saldırganın **`proxy_pass` uç noktası ile doğrudan bir bağlantı kurmasına** (bu durumda `http://backend:9999`) izin verecektir; bu içeriğin nginx tarafından kontrol edilmeyeceği anlamına gelir.
{% endhint %}

`/flag` çalmak için zayıf yapılandırma örneği [buradan](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Not edin ki `proxy_pass` belirli bir **yol** olan `http://backend:9999/socket.io` adresine işaret etse bile bağlantı `http://backend:9999` ile kurulacaktır, bu nedenle o iç uç noktası içinde **herhangi bir başka yolla iletişim kurabilirsiniz. Bu nedenle, proxy_pass URL'sinde bir yol belirtilip belirtilmediği önemli değildir.**
{% endhint %}

## Kendin dene

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla kendi savunmasız Nginx test sunucunuzu Docker kullanarak kurabileceğiniz bir GitHub deposu oluşturmuştur ve bunları kendiniz bulmayı deneyebilirsiniz!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz Araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin ana hedefi, güvenlik yanlış yapılandırmalarını önlemek ve hata tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlış yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Referanslar

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="/.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Web uygulamalarınız, ağınız ve bulutunuz hakkında bir hacker perspektifi edinin**

**Gerçek iş etkisi olan kritik, istismar edilebilir güvenlik açıklarını bulun ve raporlayın.** Saldırı yüzeyini haritalamak, ayrıcalıkları artırmanıza izin veren güvenlik sorunlarını bulmak ve temel kanıtları toplamak için otomatik istismarları kullanmak için 20'den fazla özel aracımızı kullanın, böylece sıkı çalışmanızı ikna edici raporlara dönüştürebilirsiniz.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking ipuçlarını paylaşmak için [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.**

</details>
{% endhint %}
