# HTTP Response Smuggling / Desync

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}

**La tecnica di questo post √® stata presa dal video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desincronizzazione della Coda delle Richieste HTTP

Prima di tutto, questa tecnica **sfrutta una vulnerabilit√† di HTTP Request Smuggling**, quindi devi sapere cos'√®:

La **principale** **differenza** tra questa tecnica e un comune HTTP Request smuggling √® che **invece** di **attaccare** la **richiesta** della **vittima** **aggiungendo un prefisso**, andremo a **leakare o modificare la risposta che la vittima riceve**. Questo viene fatto, invece di inviare 1 richiesta e mezza per abusare dell'HTTP Request smuggling, **inviando 2 richieste complete per desincronizzare la coda delle risposte dei proxy**.

Questo perch√© saremo in grado di **desincronizzare la coda delle risposte** in modo che la **risposta** della **richiesta** **legittima** della **vittima venga inviata all'attaccante**, o **iniettando contenuti controllati dall'attaccante nella risposta alla vittima**.

### Desync della Pipeline HTTP

HTTP/1.1 consente di richiedere **risorse diverse senza dover aspettare quelle precedenti**. Pertanto, se c'√® un **proxy** nel **mezzo**, √® compito del proxy **mantenere una corrispondenza sincronizzata delle richieste inviate al backend e delle risposte provenienti da esso**.

Tuttavia, c'√® un problema nella desincronizzazione della coda delle risposte. Se un attaccante invia un attacco di HTTP Response smuggling e le risposte alla **richiesta iniziale e a quella smuggled vengono risposte immediatamente**, la risposta smuggled non verr√† inserita nella coda della risposta della vittima ma verr√† **semplicemente scartata come errore**.

![](<../.gitbook/assets/image (633).png>)

Pertanto, √® necessario che la **richiesta smuggled** **richieda pi√π tempo per essere elaborata** all'interno del server backend. Pertanto, quando la richiesta smuggled viene elaborata, la comunicazione con l'attaccante sar√† terminata.

Se in questa situazione specifica una **vittima ha inviato una richiesta** e la **richiesta smuggled viene risolta prima** della richiesta legittima, la **risposta smuggled verr√† inviata alla vittima**. Pertanto, l'attaccante controller√† la **richiesta "eseguita" dalla vittima**.

Inoltre, se l'**attaccante esegue poi una richiesta** e la **risposta legittima** alla **richiesta** della **vittima** viene **risposta** **prima** della richiesta dell'attaccante. La **risposta alla vittima verr√† inviata all'attaccante**, **rubando** la risposta alla vittima (che pu√≤ contenere ad esempio l'intestazione **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Iniezioni Annidate Multiple

Un'altra **differenza interessante** con il comune **HTTP Request Smuggling** √® che, in un attacco di smuggling comune, l'**obiettivo** √® **modificare l'inizio della richiesta della vittima** in modo che esegua un'azione inaspettata. In un **attacco di HTTP Response smuggling**, poich√© stai **inviando richieste complete**, puoi **iniettare in un payload decine di risposte** che andranno a **desincronizzare decine di utenti** che riceveranno le **risposte iniettate**.

Oltre a poter **distribuire pi√π facilmente decine di exploit** tra utenti legittimi, questo potrebbe anche essere utilizzato per causare un **DoS** nel server.

### Organizzazione dell'Exploit

Come spiegato in precedenza, per abusare di questa tecnica, √® necessario che il **primo messaggio smuggled** nel server **richieda molto tempo per essere elaborato**.

Questa **richiesta che richiede tempo √® sufficiente** se vogliamo solo **cercare di rubare la risposta della vittima.** Ma se vuoi eseguire un exploit pi√π complesso, questa sar√† una struttura comune per l'exploit.

Prima di tutto la **richiesta iniziale** che sfrutta **HTTP** **Request** **smuggling**, poi la **richiesta che richiede tempo** e infine **1 o pi√π richieste payload** le cui risposte verranno inviate alle vittime.

## Abusare della Desincronizzazione della Coda delle Risposte HTTP

### Catturare le richieste di altri utenti <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Come con i payload noti di HTTP Request Smuggling, puoi **rubare la richiesta della vittima** con una differenza importante: in questo caso hai solo bisogno che il **contenuto inviato venga riflesso nella risposta**, **non √® necessario alcun storage persistente**.

Prima, l'attaccante invia un payload contenente una **richiesta POST finale con il parametro riflesso** alla fine e un grande Content-Length

![](<../.gitbook/assets/image (1053).png>)

Poi, una volta che la **richiesta iniziale** (blu) √® stata **elaborata** e **mentre** quella **sonnolenta** viene elaborata (gialla), la **prossima richiesta che arriva da una vittima** verr√† **aggiunta nella coda subito dopo il parametro riflesso**:

![](<../.gitbook/assets/image (794).png>)

Poi, la **vittima** ricever√† la **risposta alla richiesta sonnacchiosa** e se nel frattempo l'**attaccante** **ha inviato** **un'altra** **richiesta**, la **risposta dalla richiesta di contenuto riflesso verr√† inviata a lui**.

## Desincronizzazione della Risposta

Fino a questo punto, abbiamo imparato come abusare degli attacchi di HTTP Request Smuggling per **controllare** la **richiesta** **la cui** **risposta** un **client** ricever√† e come puoi poi **rubare la risposta che era destinata alla vittima**.

Ma √® ancora possibile **desincronizzare ancora di pi√π** le risposte.

Ci sono richieste interessanti come la **richiesta HEAD** che sono specificate per non avere **alcun contenuto all'interno del corpo delle risposte** e che dovrebbero (devono) **contenere il Content-Length** della richiesta come **se fosse una richiesta GET**.

Pertanto, se un attaccante **inietta** una **richiesta HEAD**, come in queste immagini:

![](<../.gitbook/assets/image (1107).png>)

Poi, **una volta che quella blu viene risolta per l'attaccante**, la prossima richiesta della vittima verr√† introdotta nella coda:

![](<../.gitbook/assets/image (999).png>)

Poi, la **vittima** ricever√† la **risposta** dalla **richiesta HEAD**, che **conterr√† un Content-Length ma nessun contenuto**. Pertanto, il proxy **non invier√† questa risposta** alla vittima, ma **attender√†** un **contenuto**, che in realt√† sar√† la **risposta alla richiesta gialla** (anch'essa iniettata dall'attaccante):

![](<../.gitbook/assets/image (735).png>)

### Confusione del Contenuto

Seguendo l'esempio precedente, sapendo che puoi **controllare il corpo** della richiesta la cui risposta ricever√† la vittima e che una **risposta HEAD** di solito contiene nelle sue intestazioni il **Content-Type e il Content-Length**, puoi **inviare una richiesta come la seguente** per **causare XSS** nella vittima senza che la pagina sia vulnerabile a XSS:

![](<../.gitbook/assets/image (688).png>)

### Avvelenamento della Cache

Abusando dell'attacco di Confusione del Contenuto desincronizzato della risposta precedentemente commentato, **se la cache memorizza la risposta alla richiesta eseguita dalla vittima e questa risposta √® una iniettata che causa un XSS, allora la cache √® avvelenata**.

Richiesta malevola contenente il payload XSS:

![](<../.gitbook/assets/image (614).png>)

Risposta malevola alla vittima che contiene l'intestazione che indica alla cache di memorizzare la risposta:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Nota che in questo caso se la **"vittima" √® l'attaccante** ora pu√≤ eseguire **avvelenamento della cache in URL arbitrari** poich√© pu√≤ **controllare l'URL che verr√† memorizzato nella cache** con la risposta malevola.
{% endhint %}

### Inganno della Cache Web

Questo attacco √® simile al precedente, ma **invece di iniettare un payload all'interno della cache, l'attaccante memorizzer√† informazioni sulla vittima all'interno della cache:**

![](<../.gitbook/assets/image (991).png>)

### Suddivisione della Risposta

L'**obiettivo** di questo attacco √® abusare nuovamente della **desincronizzazione** della **risposta** per **far s√¨ che il proxy invii una risposta generata al 100% dall'attaccante**.

Per raggiungere questo obiettivo, l'attaccante deve trovare un endpoint dell'applicazione web che **riflette alcuni valori all'interno della risposta** e **conoscere la lunghezza del contenuto della risposta HEAD**.

Invier√† un **exploit** come:

![](<../.gitbook/assets/image (911).png>)

Dopo che la prima richiesta √® stata risolta e restituita all'attaccante, la **richiesta della vittima viene aggiunta nella coda**:

![](<../.gitbook/assets/image (737).png>)

La vittima ricever√† come risposta la **risposta HEAD + il contenuto della risposta della seconda richiesta (contenente parte dei dati riflessi):**

![](<../.gitbook/assets/image (356).png>)

Tuttavia, nota come i **dati riflessi avessero una dimensione secondo il Content-Length** della **risposta HEAD** che **ha generato una risposta HTTP valida nella coda delle risposte**.

Pertanto, la **prossima richiesta della seconda vittima** ricever√† come **risposta qualcosa completamente creato dall'attaccante**. Poich√© la risposta √® completamente creata dall'attaccante, pu√≤ anche **far s√¨ che il proxy memorizzi nella cache la risposta**.

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
