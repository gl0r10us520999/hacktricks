# HTTP Response Smuggling / Desync

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

**La t√©cnica de este post fue tomada del video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desincronizaci√≥n de la Cola de Solicitudes HTTP

Primero que nada, esta t√©cnica **abusa de una vulnerabilidad de HTTP Request Smuggling**, as√≠ que necesitas saber qu√© es:

La **principal** **diferencia** entre esta t√©cnica y un com√∫n HTTP Request smuggling es que **en lugar de** **atacar** la **solicitud** de la **v√≠ctima** **agregando un prefijo a ella**, vamos a **filtrar o modificar la respuesta que recibe la v√≠ctima**. Esto se hace al enviar, en lugar de 1 solicitud y media para abusar del HTTP Request smuggling, **2 solicitudes completas para desincronizar la cola de respuestas de los proxies**.

Esto se debe a que vamos a poder **desincronizar la cola de respuestas** para que la **respuesta** de la **solicitud** **leg√≠tima** de la **v√≠ctima sea enviada al atacante**, o **inyectando contenido controlado por el atacante en la respuesta a la v√≠ctima**.

### Desync de Pipeline HTTP

HTTP/1.1 permite solicitar **diferentes recursos sin necesidad de esperar por los anteriores**. Por lo tanto, si hay un **proxy** en el **medio**, es tarea de los proxies **mantener un emparejamiento sincronizado de solicitudes enviadas al backend y respuestas que provienen de √©l**.

Sin embargo, hay un problema al desincronizar la cola de respuestas. Si un atacante env√≠a un ataque de HTTP Response smuggling y las respuestas a la **solicitud inicial y la smuggled son respondidas inmediatamente**, la respuesta smuggled no ser√° insertada dentro de la cola de respuestas de la v√≠ctima, sino que **simplemente ser√° descartada como un error**.

![](<../.gitbook/assets/image (633).png>)

Por lo tanto, es necesario que la **solicitud smuggled** **tome m√°s tiempo para ser procesada** dentro del servidor backend. Por lo tanto, para cuando la solicitud smuggled sea procesada, la comunicaci√≥n con el atacante habr√° terminado.

Si en esta situaci√≥n espec√≠fica una **v√≠ctima ha enviado una solicitud** y la **solicitud smuggled es respondida antes** que la solicitud leg√≠tima, la **respuesta smuggled ser√° enviada a la v√≠ctima**. Por lo tanto, el atacante estar√° **controlando la solicitud "realizada" por la v√≠ctima**.

Adem√°s, si el **atacante luego realiza una solicitud** y la **respuesta leg√≠tima** a la **solicitud** de la **v√≠ctima** es **respondida** **antes** que la solicitud del atacante. La **respuesta a la v√≠ctima ser√° enviada al atacante**, **robando** la respuesta a la v√≠ctima (que puede contener, por ejemplo, el encabezado **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Inyecciones M√∫ltiples Anidadas

Otra **diferencia interesante** con el com√∫n **HTTP Request Smuggling** es que, en un ataque de smuggling com√∫n, el **objetivo** es **modificar el inicio de la solicitud de la v√≠ctima** para que realice una acci√≥n inesperada. En un **ataque de HTTP Response smuggling**, como est√°s **enviando solicitudes completas**, puedes **inyectar en un payload decenas de respuestas** que estar√°n **desincronizando decenas de usuarios** que estar√°n **recibiendo** las **respuestas** **inyectadas**.

Aparte de poder **distribuir m√°s f√°cilmente decenas de exploits** entre usuarios leg√≠timos, esto tambi√©n podr√≠a ser utilizado para causar un **DoS** en el servidor.

### Organizaci√≥n del Exploit

Como se explic√≥ anteriormente, para abusar de esta t√©cnica, es necesario que el **primer mensaje smuggled** en el servidor **requiera mucho tiempo para ser procesado**.

Esta **solicitud que consume tiempo es suficiente** si solo queremos **intentar robar la respuesta de la v√≠ctima.** Pero si deseas realizar un exploit m√°s complejo, esta ser√° una estructura com√∫n para el exploit.

Primero la **solicitud inicial** abusando de **HTTP** **Request** **smuggling**, luego la **solicitud que consume tiempo** y luego **1 o m√°s solicitudes de payload** cuyas respuestas ser√°n enviadas a las v√≠ctimas.

## Abusando de la Desincronizaci√≥n de la Cola de Respuestas HTTP

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Al igual que con los payloads conocidos de HTTP Request Smuggling, puedes **robar la solicitud de la v√≠ctima** con una diferencia importante: En este caso solo necesitas que el **contenido enviado sea reflejado en la respuesta**, **no se necesita almacenamiento persistente**.

Primero, el atacante env√≠a un payload que contiene una **solicitud POST final con el par√°metro reflejado** al final y un gran Content-Length.

![](<../.gitbook/assets/image (1053).png>)

Luego, una vez que la **solicitud inicial** (azul) fue **procesada** y **mientras** la **solicitud lenta** est√° siendo procesada (amarillo), la **siguiente solicitud que llega de una v√≠ctima** se va a **agregar en la cola justo despu√©s del par√°metro reflejado**:

![](<../.gitbook/assets/image (794).png>)

Luego, la **v√≠ctima** recibir√° la **respuesta a la solicitud lenta** y si mientras tanto el **atacante** **envi√≥** **otra** **solicitud**, la **respuesta de la solicitud de contenido reflejado ser√° enviada a √©l**.

## Desincronizaci√≥n de Respuestas

Hasta este punto, hemos aprendido c√≥mo abusar de los ataques de HTTP Request Smuggling para **controlar** la **solicitud** **cuyo** **respuesta** un **cliente** va a **recibir** y c√≥mo puedes luego **robar la respuesta que estaba destinada a la v√≠ctima**.

Pero a√∫n es posible **desincronizar a√∫n** m√°s las respuestas.

Hay solicitudes interesantes como la **solicitud HEAD** que est√°n especificadas para no tener **ning√∫n contenido dentro del cuerpo de las respuestas** y que deben (deben) **contener el Content-Length** de la solicitud como **si fuera una solicitud GET**.

Por lo tanto, si un atacante **inyecta** una **solicitud HEAD**, como en estas im√°genes:

![](<../.gitbook/assets/image (1107).png>)

Luego, **una vez que la azul es respondida al atacante**, la siguiente solicitud de la v√≠ctima se va a introducir en la cola:

![](<../.gitbook/assets/image (999).png>)

Luego, la **v√≠ctima** recibir√° la **respuesta** de la **solicitud HEAD**, que **va a contener un Content-Length pero ning√∫n contenido en absoluto**. Por lo tanto, el proxy **no enviar√° esta respuesta** a la v√≠ctima, sino que **esperar√°** por alg√∫n **contenido**, que en realidad ser√° la **respuesta a la solicitud amarilla** (tambi√©n inyectada por el atacante):

![](<../.gitbook/assets/image (735).png>)

### Confusi√≥n de Contenido

Siguiendo el ejemplo anterior, sabiendo que puedes **controlar el cuerpo** de la solicitud cuya respuesta va a recibir la v√≠ctima y que una **respuesta HEAD** generalmente contiene en sus encabezados el **Content-Type y el Content-Length**, puedes **enviar una solicitud como la siguiente** para **causar XSS** en la v√≠ctima sin que la p√°gina sea vulnerable a XSS:

![](<../.gitbook/assets/image (688).png>)

### Envenenamiento de Cach√©

Abusando del ataque de desincronizaci√≥n de respuesta comentado anteriormente, **si la cach√© almacena la respuesta a la solicitud realizada por la v√≠ctima y esta respuesta es una inyectada que causa un XSS, entonces la cach√© est√° envenenada**.

Solicitud maliciosa que contiene el payload de XSS:

![](<../.gitbook/assets/image (614).png>)

Respuesta maliciosa a la v√≠ctima que contiene el encabezado que indica a la cach√© que almacene la respuesta:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Ten en cuenta que en este caso si la **"v√≠ctima" es el atacante** ahora puede realizar **envenenamiento de cach√© en URLs arbitrarias** ya que puede **controlar la URL que va a ser almacenada** con la respuesta maliciosa.
{% endhint %}

### Enga√±o de Cach√© Web

Este ataque es similar al anterior, pero **en lugar de inyectar un payload dentro de la cach√©, el atacante estar√° almacenando informaci√≥n de la v√≠ctima dentro de la cach√©:**

![](<../.gitbook/assets/image (991).png>)

### Divisi√≥n de Respuestas

El **objetivo** de este ataque es abusar nuevamente de la **desincronizaci√≥n de respuestas** para **hacer que el proxy env√≠e una respuesta 100% generada por el atacante**.

Para lograr esto, el atacante necesita encontrar un endpoint de la aplicaci√≥n web que est√© **reflejando algunos valores dentro de la respuesta** y **conocer el Content-Length de la respuesta HEAD**.

√âl enviar√° un **exploit** como:

![](<../.gitbook/assets/image (911).png>)

Despu√©s de que la primera solicitud sea resuelta y enviada de vuelta al atacante, la **solicitud de la v√≠ctima se agrega a la cola**:

![](<../.gitbook/assets/image (737).png>)

La v√≠ctima recibir√° como respuesta la **respuesta HEAD + el contenido de la respuesta de la segunda solicitud (contiene parte de los datos reflejados):**

![](<../.gitbook/assets/image (356).png>)

Sin embargo, nota c√≥mo los **datos reflejados ten√≠an un tama√±o de acuerdo al Content-Length** de la **respuesta HEAD** que **gener√≥ una respuesta HTTP v√°lida en la cola de respuestas**.

Por lo tanto, la **siguiente solicitud de la segunda v√≠ctima** estar√° **recibiendo** como **respuesta algo completamente elaborado por el atacante**. Como la respuesta es completamente elaborada por el atacante, tambi√©n puede **hacer que el proxy almacene la respuesta**.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
