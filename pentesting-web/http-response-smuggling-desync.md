# HTTP Response Smuggling / Desync

{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 分享黑客技巧。

</details>
{% endhint %}

**本帖的技术来自视频：** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## HTTP 请求队列去同步

首先，这种技术**利用了 HTTP 请求走私漏洞**，所以你需要知道这是什么：

这种技术与常见的 HTTP 请求走私的**主要区别**在于，**不是通过添加前缀来攻击受害者的请求**，而是**泄露或修改受害者收到的响应**。这是通过发送**两个完整的请求来去同步代理的响应队列**，而不是发送一个半请求来利用 HTTP 请求走私。

这是因为我们将能够**去同步响应队列**，使得**受害者的合法请求的响应被发送给攻击者**，或者通过**在响应中注入攻击者控制的内容**给受害者。

### HTTP 管道去同步

HTTP/1.1 允许请求**不同的资源而不需要等待之前的请求**。因此，如果中间有一个**代理**，那么代理的任务是**保持发送到后端的请求和来自后端的响应的同步匹配**。

然而，去同步响应队列存在一个问题。如果攻击者发送一个 HTTP 响应走私攻击，并且对**初始请求和走私请求的响应立即返回**，那么走私响应不会被插入到受害者响应的队列中，而是**作为错误被丢弃**。

![](<../.gitbook/assets/image (633).png>)

因此，需要**走私请求在后端服务器中处理的时间更长**。因此，当走私请求被处理时，与攻击者的通信将结束。

如果在这种特定情况下，**受害者发送了一个请求**，而**走私请求在合法请求之前被响应**，那么**走私响应将被发送给受害者**。因此，攻击者将**控制受害者“执行”的请求**。

此外，如果**攻击者随后执行一个请求**，而**对受害者请求的合法响应**在攻击者请求之前被**回答**。**对受害者的响应将被发送给攻击者**，**窃取**受害者的响应（例如，可能包含**Set-Cookie**头）。

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### 多重嵌套注入

与常见的**HTTP 请求走私**相比，另一个**有趣的区别**是，在常见的走私攻击中，**目标**是**修改受害者请求的开头**，以便执行意外的操作。在**HTTP 响应走私攻击**中，由于你**发送完整的请求**，你可以**在一个有效载荷中注入数十个响应**，这将**去同步数十个用户**，这些用户将**接收**被**注入的**响应。

除了能够**更轻松地在合法用户之间分发数十个漏洞**，这也可以用来导致服务器的**拒绝服务**。

### 漏洞组织

如前所述，为了利用这种技术，**第一个走私消息**进入服务器**需要花费大量时间进行处理**。

如果我们只是想**尝试窃取受害者的响应**，那么这个**耗时的请求就足够了**。但如果你想执行更复杂的漏洞，这将是漏洞的常见结构。

首先是**初始**请求，利用**HTTP** **请求** **走私**，然后是**耗时请求**，最后是**一个或多个有效载荷请求**，其响应将被发送给受害者。

## 利用 HTTP 响应队列去同步

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

与已知的 HTTP 请求走私有效载荷一样，你可以**窃取受害者的请求**，有一个重要的区别：在这种情况下，你只需要**发送的内容在响应中被反射**，**不需要持久存储**。

首先，攻击者发送一个有效载荷，包含一个**带有反射参数的最终 POST 请求**，并且有一个大的 Content-Length。

![](<../.gitbook/assets/image (1053).png>)

然后，一旦**初始请求**（蓝色）被**处理**，并且**而****耗时**的请求正在被处理（黄色），**来自受害者的下一个请求**将被**附加在反射参数之后**：

![](<../.gitbook/assets/image (794).png>)

然后，**受害者**将**接收**对**耗时**请求的**响应**，如果在此期间**攻击者****发送**了**另一个**请求，**反射内容请求的响应将被发送给他**。

## 响应去同步

到目前为止，我们已经学习了如何利用 HTTP 请求走私攻击来**控制**客户端将要**接收的**请求**的响应**，以及如何**窃取原本属于受害者的响应**。

但仍然可以**进一步去同步**响应。

有趣的请求如**HEAD**请求被指定为在响应体中**不包含任何内容**，并且应该（必须）**包含请求的 Content-Length**，就像**GET 请求**一样。

因此，如果攻击者**注入**一个**HEAD**请求，如下图所示：

![](<../.gitbook/assets/image (1107).png>)

然后，一旦**蓝色请求**被响应给攻击者，**下一个受害者请求**将被引入队列：

![](<../.gitbook/assets/image (999).png>)

然后，**受害者**将**接收**来自**HEAD**请求的**响应**，该响应**将包含一个 Content-Length，但没有任何内容**。因此，代理**不会将此响应发送给受害者，而是**等待**一些**内容**，实际上将是**对黄色请求的响应**（也由攻击者注入）：

![](<../.gitbook/assets/image (735).png>)

### 内容混淆

根据前面的例子，知道你可以**控制请求的主体**，其响应将被受害者接收，并且**HEAD** **响应**通常在其头部包含**Content-Type 和 Content-Length**，你可以**发送如下请求**以**在受害者中引发 XSS**，而页面并不容易受到 XSS 的影响：

![](<../.gitbook/assets/image (688).png>)

### 缓存中毒

利用之前提到的响应去同步内容混淆攻击，**如果缓存存储了受害者执行的请求的响应，并且该响应是一个导致 XSS 的注入响应，那么缓存就被毒化了**。

包含 XSS 有效载荷的恶意请求：

![](<../.gitbook/assets/image (614).png>)

包含指示缓存存储响应的头的恶意响应：

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
请注意，在这种情况下，如果**“受害者”是攻击者**，他现在可以在任意 URL 上执行**缓存中毒**，因为他可以**控制将被缓存的 URL**与恶意响应。
{% endhint %}

### Web 缓存欺骗

此攻击类似于前一个，但**不是在缓存中注入有效载荷，而是攻击者将在缓存中缓存受害者信息：**

![](<../.gitbook/assets/image (991).png>)

### 响应分割

此攻击的**目标**是再次利用**响应** **去同步**，以便**使代理发送 100% 由攻击者生成的响应**。

为了实现这一点，攻击者需要找到一个**在响应中反射某些值**的 Web 应用程序端点，并**知道 HEAD 响应的内容长度**。

他将发送一个**漏洞**，如下所示：

![](<../.gitbook/assets/image (911).png>)

在第一个请求被解决并返回给攻击者后，**受害者的请求将被添加到队列中**：

![](<../.gitbook/assets/image (737).png>)

受害者将接收到的响应是**HEAD 响应 + 第二个请求响应的内容（包含部分反射数据）：**

![](<../.gitbook/assets/image (356).png>)

然而，请注意**反射数据的大小与 HEAD 响应的 Content-Length 相符**，这**在响应队列中生成了一个有效的 HTTP 响应**。

因此，**第二个受害者的下一个请求**将**接收到**完全由攻击者构造的**响应**。由于响应完全由攻击者构造，他还可以**使代理缓存该响应**。

{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 分享黑客技巧。

</details>
{% endhint %}
