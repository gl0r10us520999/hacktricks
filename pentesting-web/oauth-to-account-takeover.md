# OAuth to Account takeover

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Basic Information <a href="#d4a8" id="d4a8"></a>

Το OAuth προσφέρει διάφορες εκδόσεις, με θεμελιώδεις πληροφορίες διαθέσιμες στην [τεκμηρίωση OAuth 2.0](https://oauth.net/2/). Αυτή η συζήτηση επικεντρώνεται κυρίως στον ευρέως χρησιμοποιούμενο [τύπο χορήγησης κωδικού εξουσιοδότησης OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/), παρέχοντας ένα **πλαίσιο εξουσιοδότησης που επιτρέπει σε μια εφαρμογή να έχει πρόσβαση ή να εκτελεί ενέργειες στον λογαριασμό ενός χρήστη σε άλλη εφαρμογή** (τον εξουσιοδοτημένο διακομιστή).

Σκεφτείτε μια υποθετική ιστοσελίδα _**https://example.com**_, σχεδιασμένη να **παρουσιάζει όλες τις αναρτήσεις σας στα μέσα κοινωνικής δικτύωσης**, συμπεριλαμβανομένων των ιδιωτικών. Για να το επιτύχει αυτό, χρησιμοποιείται το OAuth 2.0. _https://example.com_ θα ζητήσει την άδειά σας να **έχει πρόσβαση στις αναρτήσεις σας στα μέσα κοινωνικής δικτύωσης**. Ως αποτέλεσμα, θα εμφανιστεί μια οθόνη συγκατάθεσης στο _https://socialmedia.com_, περιγράφοντας τις **άδειες που ζητούνται και τον προγραμματιστή που υποβάλλει το αίτημα**. Μετά την εξουσιοδότησή σας, το _https://example.com_ αποκτά τη δυνατότητα να **έχει πρόσβαση στις αναρτήσεις σας εκ μέρους σας**.

Είναι σημαντικό να κατανοήσετε τα παρακάτω στοιχεία μέσα στο πλαίσιο του OAuth 2.0:

* **resource owner**: Εσείς, ως **χρήστης/οντότητα**, εξουσιοδοτείτε την πρόσβαση στους πόρους σας, όπως οι αναρτήσεις σας στα μέσα κοινωνικής δικτύωσης.
* **resource server**: Ο **διακομιστής που διαχειρίζεται τις αυθεντικοποιημένες αιτήσεις** αφού η εφαρμογή έχει εξασφαλίσει ένα `access token` εκ μέρους του `resource owner`, π.χ., **https://socialmedia.com**.
* **client application**: Η **εφαρμογή που ζητά εξουσιοδότηση** από τον `resource owner`, όπως **https://example.com**.
* **authorization server**: Ο **διακομιστής που εκδίδει `access tokens`** στην `client application` μετά την επιτυχή αυθεντικοποίηση του `resource owner` και την εξασφάλιση εξουσιοδότησης, π.χ., **https://socialmedia.com**.
* **client\_id**: Ένας δημόσιος, μοναδικός αναγνωριστικός αριθμός για την εφαρμογή.
* **client\_secret:** Ένα εμπιστευτικό κλειδί, γνωστό μόνο στην εφαρμογή και τον εξουσιοδοτημένο διακομιστή, που χρησιμοποιείται για τη δημιουργία `access_tokens`.
* **response\_type**: Μια τιμή που καθορίζει **τον τύπο του αιτούμενου token**, όπως `code`.
* **scope**: Το **επίπεδο πρόσβασης** που ζητά η `client application` από τον `resource owner`.
* **redirect\_uri**: Η **διεύθυνση URL στην οποία ανακατευθύνεται ο χρήστης μετά την εξουσιοδότηση**. Αυτό συνήθως πρέπει να ευθυγραμμίζεται με την προεγγεγραμμένη διεύθυνση URL ανακατεύθυνσης.
* **state**: Ένα παράμετρος για **τη διατήρηση δεδομένων κατά τη διάρκεια της ανακατεύθυνσης του χρήστη προς και από τον εξουσιοδοτημένο διακομιστή**. Η μοναδικότητά του είναι κρίσιμη για να λειτουργεί ως **μηχανισμός προστασίας CSRF**.
* **grant\_type**: Ένα παράμετρος που υποδεικνύει **τον τύπο χορήγησης και τον τύπο του token που θα επιστραφεί**.
* **code**: Ο κωδικός εξουσιοδότησης από τον `authorization server`, που χρησιμοποιείται σε συνδυασμό με `client_id` και `client_secret` από την client application για να αποκτήσει ένα `access_token`.
* **access\_token**: Το **token που χρησιμοποιεί η client application για αιτήσεις API** εκ μέρους του `resource owner`.
* **refresh\_token**: Επιτρέπει στην εφαρμογή να **αποκτήσει ένα νέο `access_token` χωρίς να ζητήσει ξανά από τον χρήστη**.

### Flow

Η **πραγματική ροή OAuth** προχωρά ως εξής:

1. Πλοηγείστε στο [https://example.com](https://example.com) και επιλέξτε το κουμπί “Ενσωμάτωση με Μέσα Κοινωνικής Δικτύωσης”.
2. Ο ιστότοπος στέλνει στη συνέχεια ένα αίτημα στο [https://socialmedia.com](https://socialmedia.com) ζητώντας την εξουσιοδότησή σας να επιτρέψετε στην εφαρμογή του https://example.com να έχει πρόσβαση στις αναρτήσεις σας. Το αίτημα διαμορφώνεται ως:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Στη συνέχεια, σας παρουσιάζεται μια σελίδα συγκατάθεσης.  
4. Μετά την έγκρισή σας, το Social Media στέλνει μια απάντηση στο `redirect_uri` με τις παραμέτρους `code` και `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com χρησιμοποιεί αυτόν τον `κώδικα`, μαζί με το `client_id` και το `client_secret`, για να κάνει ένα αίτημα από τον διακομιστή για να αποκτήσει ένα `access_token` εκ μέρους σας, επιτρέποντας την πρόσβαση στις άδειες που έχετε συναινέσει:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Τέλος, η διαδικασία ολοκληρώνεται καθώς το https://example.com χρησιμοποιεί το `access_token` σας για να κάνει μια κλήση API στα Social Media για πρόσβαση

## Ευπάθειες <a href="#id-323a" id="id-323a"></a>

### Ανοιχτό redirect\_uri <a href="#cc36" id="cc36"></a>

Το `redirect_uri` είναι κρίσιμο για την ασφάλεια στις υλοποιήσεις OAuth και OpenID, καθώς καθορίζει πού αποστέλλονται ευαίσθητα δεδομένα, όπως οι κωδικοί εξουσιοδότησης, μετά την εξουσιοδότηση. Εάν είναι κακώς ρυθμισμένο, θα μπορούσε να επιτρέψει στους επιτιθέμενους να ανακατευθύνουν αυτά τα αιτήματα σε κακόβουλους διακομιστές, διευκολύνοντας την κατάληψη λογαριασμού.

Οι τεχνικές εκμετάλλευσης ποικίλλουν ανάλογα με τη λογική επικύρωσης του διακομιστή εξουσιοδότησης. Μπορούν να κυμαίνονται από αυστηρή αντιστοίχιση διαδρομών έως αποδοχή οποιασδήποτε διεύθυνσης URL εντός του καθορισμένου τομέα ή υποκαταλόγου. Κοινές μέθοδοι εκμετάλλευσης περιλαμβάνουν ανοιχτές ανακατευθύνσεις, διαδρομές διαδρομής, εκμετάλλευση αδύναμων regex και HTML injection για κλοπή token.

Εκτός από το `redirect_uri`, άλλες παράμετροι OAuth και OpenID όπως `client_uri`, `policy_uri`, `tos_uri` και `initiate_login_uri` είναι επίσης ευάλωτες σε επιθέσεις ανακατεύθυνσης. Αυτές οι παράμετροι είναι προαιρετικές και η υποστήριξή τους ποικίλλει μεταξύ των διακομιστών.

Για εκείνους που στοχεύουν σε έναν διακομιστή OpenID, το endpoint ανακάλυψης (`**.well-known/openid-configuration**`) συχνά παραθέτει πολύτιμες λεπτομέρειες ρύθμισης όπως `registration_endpoint`, `request_uri_parameter_supported` και "`require_request_uri_registration`. Αυτές οι λεπτομέρειες μπορούν να βοηθήσουν στην αναγνώριση του endpoint εγγραφής και άλλων λεπτομερειών ρύθμισης του διακομιστή.

### XSS στην υλοποίηση ανακατεύθυνσης <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτή την αναφορά bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), μπορεί να είναι δυνατόν ότι το **URL ανακατεύθυνσης αντικατοπτρίζεται στην απόκριση** του διακομιστή μετά την αυθεντικοποίηση του χρήστη, είναι **ευάλωτο σε XSS**. Πιθανό payload για δοκιμή:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

Στις υλοποιήσεις OAuth, η κακή χρήση ή η παράλειψη της **`state` παραμέτρου** μπορεί να αυξήσει σημαντικά τον κίνδυνο επιθέσεων **Cross-Site Request Forgery (CSRF)**. Αυτή η ευπάθεια προκύπτει όταν η `state` παράμετρος είναι είτε **μη χρησιμοποιούμενη, χρησιμοποιούμενη ως στατική τιμή, ή μη σωστά επικυρωμένη**, επιτρέποντας στους επιτιθέμενους να παρακάμψουν τις προστασίες CSRF.

Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτό το γεγονός παρεμβαίνοντας στη διαδικασία εξουσιοδότησης για να συνδέσουν τον λογαριασμό τους με τον λογαριασμό ενός θύματος, οδηγώντας σε πιθανές **καταλήψεις λογαριασμών**. Αυτό είναι ιδιαίτερα κρίσιμο σε εφαρμογές όπου το OAuth χρησιμοποιείται για **σκοπούς αυθεντικοποίησης**.

Πραγματικά παραδείγματα αυτής της ευπάθειας έχουν καταγραφεί σε διάφορες **CTF προκλήσεις** και **πλατφόρμες hacking**, αναδεικνύοντας τις πρακτικές της επιπτώσεις. Το ζήτημα επεκτείνεται επίσης σε ενσωματώσεις με τρίτες υπηρεσίες όπως **Slack**, **Stripe**, και **PayPal**, όπου οι επιτιθέμενοι μπορούν να ανακατευθύνουν ειδοποιήσεις ή πληρωμές στους λογαριασμούς τους.

Η σωστή διαχείριση και επικύρωση της **`state` παραμέτρου** είναι κρίσιμη για την προστασία από CSRF και την ασφάλιση της ροής OAuth.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Χωρίς Επικύρωση Email κατά τη Δημιουργία Λογαριασμού**: Οι επιτιθέμενοι μπορούν προληπτικά να δημιουργήσουν έναν λογαριασμό χρησιμοποιώντας το email του θύματος. Εάν το θύμα αργότερα χρησιμοποιήσει μια τρίτη υπηρεσία για σύνδεση, η εφαρμογή μπορεί ακούσια να συνδέσει αυτόν τον τρίτο λογαριασμό με τον προδημιουργημένο λογαριασμό του επιτιθέμενου, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση.
2. **Εκμετάλλευση Χαλαρής Επικύρωσης Email στο OAuth**: Οι επιτιθέμενοι μπορεί να εκμεταλλευτούν υπηρεσίες OAuth που δεν επικυρώνουν emails, εγγραφόμενοι με την υπηρεσία τους και στη συνέχεια αλλάζοντας το email του λογαριασμού στο email του θύματος. Αυτή η μέθοδος κινδυνεύει επίσης με μη εξουσιοδοτημένη πρόσβαση στον λογαριασμό, παρόμοια με το πρώτο σενάριο αλλά μέσω διαφορετικού επιθετικού διαύλου.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Η αναγνώριση και η προστασία των μυστικών παραμέτρων OAuth είναι κρίσιμη. Ενώ η **`client_id`** μπορεί να αποκαλυφθεί με ασφάλεια, η αποκάλυψη της **`client_secret`** ενέχει σημαντικούς κινδύνους. Εάν η `client_secret` παραβιαστεί, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν την ταυτότητα και την εμπιστοσύνη της εφαρμογής για να **κλέψουν τα `access_tokens` χρηστών** και ιδιωτικές πληροφορίες.

Μια κοινή ευπάθεια προκύπτει όταν οι εφαρμογές χειρίζονται κατά λάθος την ανταλλαγή του κωδικού εξουσιοδότησης για ένα `access_token` στην πλευρά του πελάτη αντί στην πλευρά του διακομιστή. Αυτό το λάθος οδηγεί στην έκθεση της `client_secret`, επιτρέποντας στους επιτιθέμενους να δημιουργήσουν `access_tokens` υπό την κάλυψη της εφαρμογής. Επιπλέον, μέσω κοινωνικής μηχανικής, οι επιτιθέμενοι θα μπορούσαν να κλιμακώσουν τα προνόμια προσθέτοντας επιπλέον πεδία στην εξουσιοδότηση OAuth, εκμεταλλευόμενοι περαιτέρω την εμπιστοσύνη της εφαρμογής.

### Client Secret Bruteforce

Μπορείτε να προσπαθήσετε να **bruteforce την client\_secret** ενός παρόχου υπηρεσιών με τον πάροχο ταυτότητας προκειμένου να προσπαθήσετε να κλέψετε λογαριασμούς.\
Το αίτημα για BF μπορεί να μοιάζει με:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Μόλις ο πελάτης έχει τον **κωδικό και την κατάσταση**, αν είναι **αντανάκλαση μέσα στην κεφαλίδα Referer** όταν περιηγείται σε μια διαφορετική σελίδα, τότε είναι ευάλωτος.

### Access Token Stored in Browser History

Πηγαίνετε στο **ιστορικό του προγράμματος περιήγησης και ελέγξτε αν το access token είναι αποθηκευμένο εκεί**.

### Everlasting Authorization Code

Ο **κωδικός εξουσιοδότησης θα πρέπει να ζει μόνο για κάποιο χρονικό διάστημα για να περιορίσει το χρονικό παράθυρο όπου ένας επιτιθέμενος μπορεί να τον κλέψει και να τον χρησιμοποιήσει**.

### Authorization/Refresh Token not bound to client

Αν μπορείτε να αποκτήσετε τον **κωδικό εξουσιοδότησης και να τον χρησιμοποιήσετε με έναν διαφορετικό πελάτη, τότε μπορείτε να αναλάβετε άλλους λογαριασμούς**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Δείτε αυτή την ανάρτηση**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Σε αυτή την αναφορά bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) μπορείτε να δείτε ότι το **token** που **επιστρέφει το AWS Cognito** στον χρήστη μπορεί να έχει **αρκετές άδειες για να αντικαταστήσει τα δεδομένα του χρήστη**. Επομένως, αν μπορείτε να **αλλάξετε το email του χρήστη για ένα διαφορετικό email χρήστη**, μπορεί να είστε σε θέση να **αναλάβετε** άλλους λογαριασμούς.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Για περισσότερες λεπτομέρειες σχετικά με το πώς να εκμεταλλευτείτε το AWS cognito, ελέγξτε:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Εκμετάλλευση άλλων tokens <a href="#bda5" id="bda5"></a>

Όπως [**αναφέρεται σε αυτή τη μελέτη**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), οι ροές OAuth που αναμένουν να λάβουν το **token** (και όχι έναν κωδικό) θα μπορούσαν να είναι ευάλωτες αν δεν ελέγχουν ότι το token ανήκει στην εφαρμογή.

Αυτό συμβαίνει επειδή ένας **επιτιθέμενος** θα μπορούσε να δημιουργήσει μια **εφαρμογή που υποστηρίζει OAuth και να συνδεθεί με το Facebook** (για παράδειγμα) στην δική του εφαρμογή. Στη συνέχεια, μόλις ένα θύμα συνδεθεί με το Facebook στην **εφαρμογή του επιτιθέμενου**, ο επιτιθέμενος θα μπορούσε να αποκτήσει το **OAuth token του χρήστη που δόθηκε στην εφαρμογή του και να το χρησιμοποιήσει για να συνδεθεί στην εφαρμογή OAuth του θύματος χρησιμοποιώντας το token του χρήστη του θύματος**.

{% hint style="danger" %}
Επομένως, αν ο επιτιθέμενος καταφέρει να αποκτήσει πρόσβαση στην δική του εφαρμογή OAuth, θα είναι σε θέση να αναλάβει τον λογαριασμό του θύματος σε εφαρμογές που αναμένουν ένα token και δεν ελέγχουν αν το token έχει παραχωρηθεί στο ID της εφαρμογής τους.
{% endhint %}

### Δύο σύνδεσμοι & cookie <a href="#bda5" id="bda5"></a>

Σύμφωνα με [**αυτή τη μελέτη**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ήταν δυνατό να γίνει ένα θύμα να ανοίξει μια σελίδα με ένα **returnUrl** που δείχνει στον διακομιστή του επιτιθέμενου. Αυτή η πληροφορία θα **αποθηκευόταν σε ένα cookie (RU)** και σε ένα **μετέπειτα βήμα** το **prompt** θα **ρωτούσε** τον **χρήστη** αν θέλει να δώσει πρόσβαση σε αυτόν τον διακομιστή του επιτιθέμενου.

Για να παρακαμφθεί αυτό το prompt, ήταν δυνατό να ανοίξει μια καρτέλα για να ξεκινήσει τη **ροή Oauth** που θα ρύθμιζε αυτό το cookie RU χρησιμοποιώντας το **returnUrl**, να κλείσει την καρτέλα πριν εμφανιστεί το prompt και να ανοίξει μια νέα καρτέλα χωρίς αυτή την τιμή. Στη συνέχεια, το **prompt δεν θα ενημερώσει για τον διακομιστή του επιτιθέμενου**, αλλά το cookie θα ρυθμιστεί σε αυτόν, έτσι το **token θα σταλεί στον διακομιστή του επιτιθέμενου** κατά την ανακατεύθυνση.

### Παράκαμψη αλληλεπίδρασης prompt <a href="#bda5" id="bda5"></a>

Όπως εξηγείται [**σε αυτό το βίντεο**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), ορισμένες υλοποιήσεις OAuth επιτρέπουν να δηλωθεί η παράμετρος **`prompt`** GET ως None (**`&prompt=none`**) για να **αποτραπεί η επιβεβαίωση** της παραχωρηθείσας πρόσβασης σε ένα prompt στο διαδίκτυο αν είναι ήδη συνδεδεμένοι στην πλατφόρμα.

### response\_mode

Όπως [**εξηγείται σε αυτό το βίντεο**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), μπορεί να είναι δυνατό να δηλωθεί η παράμετρος **`response_mode`** για να δηλώσετε πού θέλετε να παρασχεθεί ο κωδικός στην τελική διεύθυνση URL:

* `response_mode=query` -> Ο κωδικός παρέχεται μέσα σε μια παράμετρο GET: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Ο κωδικός παρέχεται μέσα στην παράμετρο τμήματος της διεύθυνσης URL `#code=2397rf3gu93f`
* `response_mode=form_post` -> Ο κωδικός παρέχεται μέσα σε μια φόρμα POST με μια είσοδο που ονομάζεται `code` και την τιμή
* `response_mode=web_message` -> Ο κωδικός αποστέλλεται σε ένα μήνυμα post: `window.opener.postMessage({"code": "asdasdasd...`

### Ροή OAuth ROPC - Παράκαμψη 2 FA <a href="#b440" id="b440"></a>

Σύμφωνα με [**αυτή την ανάρτηση στο blog**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), αυτή είναι μια ροή OAuth που επιτρέπει τη σύνδεση μέσω **όνομα χρήστη** και **κωδικού πρόσβασης**. Αν κατά τη διάρκεια αυτής της απλής ροής επιστραφεί ένα **token** με πρόσβαση σε όλες τις ενέργειες που μπορεί να εκτελέσει ο χρήστης, τότε είναι δυνατό να παρακαμφθεί η 2FA χρησιμοποιώντας αυτό το token.

### ATO σε ιστοσελίδα που ανακατευθύνει με βάση το open redirect στον παραπομπέα <a href="#bda5" id="bda5"></a>

Αυτή η [**ανάρτηση στο blog**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) σχολιάζει πώς ήταν δυνατό να εκμεταλλευτεί ένα **open redirect** στην τιμή από τον **παραπομπέα** για να εκμεταλλευτεί το OAuth για ATO. Η επίθεση ήταν:

1. Το θύμα αποκτά πρόσβαση στην ιστοσελίδα του επιτιθέμενου
2. Το θύμα ανοίγει τον κακόβουλο σύνδεσμο και ένας opener ξεκινά τη ροή Google OAuth με `response_type=id_token,code&prompt=none` ως πρόσθετες παραμέτρους χρησιμοποιώντας ως **παραπομπέα την ιστοσελίδα του επιτιθέμενου**.
3. Στον opener, αφού ο πάροχος εξουσιοδοτήσει το θύμα, το στέλνει πίσω στην τιμή της παραμέτρου `redirect_uri` (ιστοσελίδα θύματος) με κωδικό 30X που διατηρεί ακόμα την ιστοσελίδα του επιτιθέμενου στον παραπομπέα.
4. Η ιστοσελίδα του θύματος **ενεργοποιεί το open redirect με βάση τον παραπομπέα** ανακατευθύνοντας τον χρήστη του θύματος στην ιστοσελίδα του επιτιθέμενου, καθώς το **`respose_type`** ήταν **`id_token,code`**, ο κωδικός θα σταλεί πίσω στον επιτιθέμενο στο **τμήμα** της διεύθυνσης URL επιτρέποντάς του να αναλάβει τον λογαριασμό του χρήστη μέσω Google στην ιστοσελίδα του θύματος.

### Παράμετροι SSRFs <a href="#bda5" id="bda5"></a>

[**Ελέγξτε αυτή την έρευνα**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Για περισσότερες λεπτομέρειες σχετικά με αυτή την τεχνική.**

Η Δυναμική Εγγραφή Πελάτη στο OAuth λειτουργεί ως λιγότερο προφανής αλλά κρίσιμος παράγοντας για τις ευπάθειες ασφαλείας, ειδικά για επιθέσεις **Server-Side Request Forgery (SSRF)**. Αυτό το endpoint επιτρέπει στους διακομιστές OAuth να λαμβάνουν λεπτομέρειες σχετικά με τις εφαρμογές πελατών, συμπεριλαμβανομένων ευαίσθητων URLs που θα μπορούσαν να εκμεταλλευτούν.

**Κύρια Σημεία:**

* **Δυναμική Εγγραφή Πελάτη** συχνά χαρτογραφείται σε `/register` και δέχεται λεπτομέρειες όπως `client_name`, `client_secret`, `redirect_uris`, και URLs για λογότυπα ή JSON Web Key Sets (JWKs) μέσω αιτημάτων POST.
* Αυτή η δυνατότητα συμμορφώνεται με τις προδιαγραφές που καθορίζονται στο **RFC7591** και **OpenID Connect Registration 1.0**, οι οποίες περιλαμβάνουν παραμέτρους που ενδέχεται να είναι ευάλωτες σε SSRF.
* Η διαδικασία εγγραφής μπορεί ακούσια να εκθέσει τους διακομιστές σε SSRF με διάφορους τρόπους:
* **`logo_uri`**: Ένα URL για το λογότυπο της εφαρμογής πελάτη που μπορεί να ανακτηθεί από τον διακομιστή, προκαλώντας SSRF ή οδηγώντας σε XSS αν το URL δεν διαχειριστεί σωστά.
* **`jwks_uri`**: Ένα URL στο έγγραφο JWK του πελάτη, το οποίο αν κατασκευαστεί κακόβουλα, μπορεί να προκαλέσει τον διακομιστή να κάνει εξωτερικά αιτήματα σε έναν διακομιστή που ελέγχεται από τον επιτιθέμενο.
* **`sector_identifier_uri`**: Αναφέρεται σε έναν πίνακα JSON των `redirect_uris`, τον οποίο ο διακομιστής μπορεί να ανακτήσει, δημιουργώντας μια ευκαιρία SSRF.
* **`request_uris`**: Λίστα επιτρεπόμενων URI αιτημάτων για τον πελάτη, που μπορεί να εκμεταλλευτεί αν ο διακομιστής ανακτήσει αυτά τα URI στην αρχή της διαδικασίας εξουσιοδότησης.

**Στρατηγική Εκμετάλλευσης:**

* Το SSRF μπορεί να ενεργοποιηθεί καταχωρώντας έναν νέο πελάτη με κακόβουλα URLs σε παραμέτρους όπως `logo_uri`, `jwks_uri`, ή `sector_identifier_uri`.
* Ενώ η άμεση εκμετάλλευση μέσω `request_uris` μπορεί να μετριαστεί από ελέγχους λευκής λίστας, η παροχή ενός προεγγεγραμμένου, ελεγχόμενου από τον επιτιθέμενο `request_uri` μπορεί να διευκολύνει το SSRF κατά τη διάρκεια της φάσης εξουσιοδότησης.

## Συνθήκες Αγώνα Παρόχων OAuth

Αν η πλατφόρμα που δοκιμάζετε είναι πάροχος OAuth [**διαβάστε αυτό για να δοκιμάσετε πιθανές Συνθήκες Αγώνα**](race-condition.md).

## Αναφορές

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε μας στο** **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
