# Browser Extension Pentesting Methodology

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Grundinformationen

Browsererweiterungen sind in JavaScript geschrieben und werden vom Browser im Hintergrund geladen. Sie haben ihr eigenes [DOM](https://www.w3schools.com/js/js_htmldom.asp), k√∂nnen jedoch mit den DOMs anderer Seiten interagieren. Das bedeutet, dass sie die Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit (CIA) anderer Seiten gef√§hrden k√∂nnen.

## Hauptkomponenten

Die Layouts von Erweiterungen sehen am besten aus, wenn sie visualisiert werden, und bestehen aus drei Komponenten. Lassen Sie uns jede Komponente im Detail betrachten.

<figure><img src="../../.gitbook/assets/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Inhalts-Skripte**

Jedes Inhalts-Skript hat direkten Zugriff auf das DOM einer **einzelnen Webseite** und ist damit potenziell sch√§dlichem Input ausgesetzt. Das Inhalts-Skript enth√§lt jedoch keine Berechtigungen, au√üer der F√§higkeit, Nachrichten an den Erweiterungskern zu senden.

### **Erweiterungskern**

Der Erweiterungskern enth√§lt die meisten Berechtigungen/Zugriffe der Erweiterung, kann jedoch nur √ºber [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) und Inhalts-Skripte mit Webinhalten interagieren. Au√üerdem hat der Erweiterungskern keinen direkten Zugriff auf die Hostmaschine.

### **Native Bin√§rdatei**

Die Erweiterung erlaubt eine native Bin√§rdatei, die **auf die Hostmaschine mit den vollst√§ndigen Berechtigungen des Benutzers zugreifen kann.** Die native Bin√§rdatei interagiert √ºber die standardm√§√üige Netscape Plugin Application Programming Interface ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)), die von Flash und anderen Browser-Plug-ins verwendet wird, mit dem Erweiterungskern.

### Grenzen

{% hint style="danger" %}
Um die vollst√§ndigen Berechtigungen des Benutzers zu erhalten, muss ein Angreifer die Erweiterung √ºberzeugen, sch√§dlichen Input vom Inhalts-Skript an den Kern der Erweiterung und vom Kern der Erweiterung an die native Bin√§rdatei weiterzugeben.
{% endhint %}

Jede Komponente der Erweiterung ist durch **starke Schutzgrenzen** voneinander getrennt. Jede Komponente l√§uft in einem **separaten Betriebssystemprozess**. Inhalts-Skripte und Erweiterungskerne laufen in **Sandbox-Prozessen**, die f√ºr die meisten Betriebssystemdienste nicht verf√ºgbar sind.

Dar√ºber hinaus sind Inhalts-Skripte von ihren zugeh√∂rigen Webseiten getrennt, indem sie **in einem separaten JavaScript-Heap** ausgef√ºhrt werden. Das Inhalts-Skript und die Webseite haben **Zugriff auf dasselbe zugrunde liegende DOM**, aber die beiden **tauschen niemals JavaScript-Zeiger aus**, was das Leaken von JavaScript-Funktionalit√§t verhindert.

## **`manifest.json`**

Eine Chrome-Erweiterung ist einfach ein ZIP-Ordner mit einer [.crx-Dateiendung](https://www.lifewire.com/crx-file-2620391). Der Kern der Erweiterung ist die **`manifest.json`**-Datei im Stammordner, die Layout, Berechtigungen und andere Konfigurationsoptionen angibt.

Beispiel:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Inhalts-Skripte werden **geladen**, wann immer der Benutzer zu einer √ºbereinstimmenden Seite **navigiert**, in unserem Fall zu jeder Seite, die dem **`https://example.com/*`** Ausdruck entspricht und nicht dem **`*://*/*/business*`** Regex entspricht. Sie werden **wie die eigenen Skripte der Seite** ausgef√ºhrt und haben beliebigen Zugriff auf das [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) der Seite.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Um weitere URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

Dies ist ein Beispielinhaltsskript, das einen Erkl√§rungsbutton zur Seite hinzuf√ºgt, wenn [die Storage-API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) verwendet wird, um den `message`-Wert aus dem Speicher der Erweiterung abzurufen.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Eine Nachricht wird an die Erweiterungsseiten vom Inhalts-Skript gesendet, wenn dieser Button geklickt wird, durch die Nutzung der [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Dies liegt an der Einschr√§nkung des Inhalts-Skripts im direkten Zugriff auf APIs, wobei `storage` zu den wenigen Ausnahmen geh√∂rt. F√ºr Funktionalit√§ten √ºber diese Ausnahmen hinaus werden Nachrichten an Erweiterungsseiten gesendet, mit denen Inhalts-Skripte kommunizieren k√∂nnen.

{% hint style="warning" %}
Je nach Browser k√∂nnen die F√§higkeiten des Inhalts-Skripts leicht variieren. F√ºr Chromium-basierte Browser ist die Liste der F√§higkeiten in der [Chrome Developers-Dokumentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities) verf√ºgbar, und f√ºr Firefox dient das [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) als prim√§re Quelle.\
Es ist auch bemerkenswert, dass Inhalts-Skripte die F√§higkeit haben, mit Hintergrund-Skripten zu kommunizieren, was es ihnen erm√∂glicht, Aktionen auszuf√ºhren und Antworten zur√ºckzugeben.
{% endhint %}

Um Inhalts-Skripte in Chrome anzuzeigen und zu debuggen, kann das Men√º der Chrome-Entwicklertools √ºber Optionen > Weitere Tools > Entwicklertools oder durch Dr√ºcken von Ctrl + Shift + I aufgerufen werden.

Sobald die Entwicklertools angezeigt werden, ist der **Quell-Tab** anzuklicken, gefolgt vom **Inhalts-Skripte**-Tab. Dies erm√∂glicht die Beobachtung von laufenden Inhalts-Skripten aus verschiedenen Erweiterungen und das Setzen von Haltepunkten, um den Ausf√ºhrungsfluss zu verfolgen.

### Eingespritzte Inhalts-Skripte

{% hint style="success" %}
Beachten Sie, dass **Inhalts-Skripte nicht zwingend erforderlich sind**, da es auch m√∂glich ist, Skripte **dynamisch** zu **injizieren** und sie **programmatisch** in Webseiten √ºber **`tabs.executeScript`** zu injizieren. Dies bietet tats√§chlich mehr **granulare Kontrollen**.
{% endhint %}

F√ºr die programmatische Injektion eines Inhalts-Skripts muss die Erweiterung [Host-Berechtigungen](https://developer.chrome.com/docs/extensions/reference/permissions) f√ºr die Seite haben, in die die Skripte injiziert werden sollen. Diese Berechtigungen k√∂nnen entweder durch **Anforderung** innerhalb des Manifests der Erweiterung oder vor√ºbergehend √ºber [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab) gesichert werden.

#### Beispiel f√ºr eine activeTab-basierte Erweiterung

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injiziere eine JS-Datei beim Klicken:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Funktion beim Klicken injizieren:**
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Beispiel mit Skriptberechtigungen
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Um weitere URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

### Content Scripts `run_at`

Das Feld `run_at` steuert **wann JavaScript-Dateien in die Webseite injiziert werden**. Der bevorzugte und Standardwert ist `"document_idle"`.

Die m√∂glichen Werte sind:

* **`document_idle`**: Wann immer m√∂glich
* **`document_start`**: Nach allen Dateien von `css`, aber bevor andere DOM-Elemente erstellt oder andere Skripte ausgef√ºhrt werden.
* **`document_end`**: Unmittelbar nachdem das DOM vollst√§ndig ist, aber bevor Unterressourcen wie Bilder und Frames geladen wurden.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
√úber **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Nachrichten, die von Inhalts-Skripten gesendet werden, werden von der **Hintergrundseite** empfangen, die eine zentrale Rolle bei der Koordination der Komponenten der Erweiterung spielt. Bemerkenswerterweise bleibt die Hintergrundseite w√§hrend der gesamten Lebensdauer der Erweiterung bestehen und arbeitet diskret ohne direkte Benutzerinteraktion. Sie verf√ºgt √ºber ihr eigenes Document Object Model (DOM), das komplexe Interaktionen und Zustandsverwaltung erm√∂glicht.

**Wichtige Punkte**:

* **Rolle der Hintergrundseite:** Dient als Nervenzentrum f√ºr die Erweiterung und sorgt f√ºr Kommunikation und Koordination zwischen den verschiedenen Teilen der Erweiterung.
* **Persistenz:** Es ist eine stets pr√§sente Entit√§t, die f√ºr den Benutzer unsichtbar, aber f√ºr die Funktionalit√§t der Erweiterung unerl√§sslich ist.
* **Automatische Generierung:** Wenn nicht ausdr√ºcklich definiert, wird der Browser automatisch eine Hintergrundseite erstellen. Diese automatisch generierte Seite enth√§lt alle Hintergrundskripte, die im Manifest der Erweiterung angegeben sind, und gew√§hrleistet den nahtlosen Betrieb der Hintergrundaufgaben der Erweiterung.

{% hint style="success" %}
Der Komfort, den der Browser bei der automatischen Generierung einer Hintergrundseite (wenn nicht ausdr√ºcklich deklariert) bietet, stellt sicher, dass alle notwendigen Hintergrundskripte integriert und betriebsbereit sind, was den Einrichtungsprozess der Erweiterung vereinfacht.
{% endhint %}

Beispiel f√ºr ein Hintergrundskript:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Es verwendet die [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage), um Nachrichten zu empfangen. Wenn eine `"explain"`-Nachricht empfangen wird, verwendet es die [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs), um eine Seite in einem neuen Tab zu √∂ffnen.

Um das Hintergrundskript zu debuggen, k√∂nnen Sie zu den **Erweiterungsdetails gehen und den Dienstarbeiter inspizieren.** Dies √∂ffnet die Entwicklertools mit dem Hintergrundskript:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Optionsseiten und andere

Browsererweiterungen k√∂nnen verschiedene Arten von Seiten enthalten:

* **Aktionsseiten** werden in einem **Dropdown angezeigt, wenn das Erweiterungssymbol** angeklickt wird.
* Seiten, die die Erweiterung **in einem neuen Tab l√§dt**.
* **Optionsseiten**: Diese Seite wird oben auf der Erweiterung angezeigt, wenn sie angeklickt wird. Im vorherigen Manifest konnte ich auf diese Seite zugreifen unter `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` oder durch Klicken:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Beachten Sie, dass diese Seiten nicht persistent sind wie Hintergrundseiten, da sie dynamisch Inhalte nach Bedarf laden. Trotz dessen teilen sie bestimmte F√§higkeiten mit der Hintergrundseite:

* **Kommunikation mit Inhalts-Skripten:** √Ñhnlich wie die Hintergrundseite k√∂nnen diese Seiten Nachrichten von Inhalts-Skripten empfangen, was die Interaktion innerhalb der Erweiterung erleichtert.
* **Zugriff auf erweiterungsspezifische APIs:** Diese Seiten haben umfassenden Zugriff auf erweiterungsspezifische APIs, vorbehaltlich der f√ºr die Erweiterung definierten Berechtigungen.

### `permissions` & `host_permissions`

**`permissions`** und **`host_permissions`** sind Eintr√§ge aus der `manifest.json`, die anzeigen, **welche Berechtigungen** die Browsererweiterung hat (Speicher, Standort...) und in **welchen Webseiten**.

Da Browsererweiterungen so **privilegiert** sein k√∂nnen, k√∂nnte eine b√∂sartige oder kompromittierte Erweiterung dem Angreifer **verschiedene Mittel erm√∂glichen, um sensible Informationen zu stehlen und den Benutzer auszuspionieren**.

√úberpr√ºfen Sie, wie diese Einstellungen funktionieren und wie sie missbraucht werden k√∂nnten in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Eine **Content-Sicherheitsrichtlinie** kann auch innerhalb der `manifest.json` deklariert werden. Wenn eine definiert ist, k√∂nnte sie **anf√§llig** sein.

Die Standardeinstellung f√ºr Seiten von Browsererweiterungen ist eher restriktiv:
```bash
script-src 'self'; object-src 'self';
```
F√ºr weitere Informationen zu CSP und potenziellen Umgehungen siehe:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Damit eine Webseite auf eine Seite einer Browsererweiterung zugreifen kann, beispielsweise eine `.html`-Seite, muss diese Seite im **`web_accessible_resources`**-Feld der `manifest.json` erw√§hnt werden.\
Zum Beispiel:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Diese Seiten sind √ºber URLs wie zug√§nglich:
```
chrome-extension://<extension-id>/message.html
```
In √∂ffentlichen Erweiterungen ist die **extension-id zug√§nglich**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Wenn jedoch der `manifest.json` Parameter **`use_dynamic_url`** verwendet wird, kann diese **id dynamisch** sein.

{% hint style="success" %}
Beachten Sie, dass selbst wenn eine Seite hier erw√§hnt wird, sie m√∂glicherweise **gegen ClickJacking gesch√ºtzt** ist, dank der **Content Security Policy**. Daher m√ºssen Sie dies auch √ºberpr√ºfen (frame-ancestors Abschnitt), bevor Sie best√§tigen, dass ein ClickJacking-Angriff m√∂glich ist.
{% endhint %}

Der Zugriff auf diese Seiten macht diese Seiten **potenziell anf√§llig f√ºr ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Wenn diese Seiten nur von der Erweiterung und nicht von zuf√§lligen URLs geladen werden d√ºrfen, k√∂nnte dies ClickJacking-Angriffe verhindern.
{% endhint %}

{% hint style="danger" %}
Beachten Sie, dass die Seiten aus **`web_accessible_resources`** und andere Seiten der Erweiterung ebenfalls in der Lage sind, **Hintergrundskripte zu kontaktieren**. Wenn eine dieser Seiten anf√§llig f√ºr **XSS** ist, k√∂nnte dies eine gr√∂√üere Verwundbarkeit er√∂ffnen.

Dar√ºber hinaus beachten Sie, dass Sie nur Seiten, die in **`web_accessible_resources`** angegeben sind, innerhalb von iframes √∂ffnen k√∂nnen, aber von einem neuen Tab aus ist es m√∂glich, auf jede Seite in der Erweiterung zuzugreifen, wenn Sie die Erweiterungs-ID kennen. Daher k√∂nnte, wenn ein XSS gefunden wird, das dieselben Parameter missbraucht, dies auch ausgenutzt werden, selbst wenn die Seite nicht in **`web_accessible_resources`** konfiguriert ist.
{% endhint %}

### `externally_connectable`

Laut den [**Docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) erkl√§rt die `"externally_connectable"` Manifest-Eigenschaft, **welche Erweiterungen und Webseiten sich** √ºber [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) und [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) mit Ihrer Erweiterung verbinden k√∂nnen.

* Wenn der **`externally_connectable`** Schl√ºssel **nicht** im Manifest Ihrer Erweiterung deklariert ist oder als **`"ids": ["*"]`** deklariert ist, **k√∂nnen alle Erweiterungen verbinden, aber keine Webseiten k√∂nnen verbinden**.
* Wenn **spezifische IDs angegeben sind**, wie in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **k√∂nnen nur diese Anwendungen** verbinden.
* Wenn **√úbereinstimmungen** angegeben sind, k√∂nnen diese Webanwendungen sich verbinden:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Wenn es als leer angegeben ist: **`"externally_connectable": {}`**, kann keine App oder Webseite eine Verbindung herstellen.

Je **weniger Erweiterungen und URLs** hier angegeben sind, desto **kleiner wird die Angriffsfl√§che** sein.

{% hint style="danger" %}
Wenn eine Webseite, die **anf√§llig f√ºr XSS oder √úbernahme** ist, in **`externally_connectable`** angegeben ist, kann ein Angreifer **Nachrichten direkt an das Hintergrundskript senden**, wodurch das Content-Skript und dessen CSP vollst√§ndig umgangen werden.

Daher ist dies ein **sehr m√§chtiger Bypass**.

Dar√ºber hinaus, wenn der Client eine b√∂sartige Erweiterung installiert, k√∂nnte diese, selbst wenn sie nicht mit der anf√§lligen Erweiterung kommunizieren darf, **XSS-Daten in eine erlaubte Webseite injizieren** oder die **`WebRequest`** oder **`DeclarativeNetRequest`** APIs missbrauchen, um Anfragen auf einer gezielten Domain zu manipulieren und eine Anfrage f√ºr eine **JavaScript-Datei** zu √§ndern. (Beachten Sie, dass CSP auf der gezielten Seite diese Angriffe verhindern k√∂nnte). Diese Idee stammt [**aus diesem Bericht**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Kommunikations√ºbersicht

### Erweiterung <--> WebApp

Um zwischen dem Content-Skript und der Webseite zu kommunizieren, werden normalerweise Post-Nachrichten verwendet. Daher finden Sie in der Webanwendung normalerweise Aufrufe der Funktion **`window.postMessage`** und im Content-Skript Listener wie **`window.addEventListener`**. Beachten Sie jedoch, dass die Erweiterung auch **mit der Webanwendung kommunizieren k√∂nnte, indem sie eine Post-Nachricht sendet** (und daher die Webseite dies erwarten sollte) oder einfach die Webseite dazu bringt, ein neues Skript zu laden.

### Innerhalb der Erweiterung

Normalerweise wird die Funktion **`chrome.runtime.sendMessage`** verwendet, um eine Nachricht innerhalb der Erweiterung zu senden (normalerweise vom `background`-Skript verarbeitet), und um sie zu empfangen und zu verarbeiten, wird ein Listener deklariert, der **`chrome.runtime.onMessage.addListener`** aufruft.

Es ist auch m√∂glich, **`chrome.runtime.connect()`** zu verwenden, um eine persistente Verbindung anstelle von einzelnen Nachrichten zu haben. Es ist m√∂glich, es zu verwenden, um **Nachrichten** zu **senden** und **zu empfangen**, wie im folgenden Beispiel:

<details>

<summary><code>chrome.runtime.connect()</code> Beispiel</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Es ist auch m√∂glich, Nachrichten von einem Hintergrundskript an ein Inhaltskript zu senden, das sich in einem bestimmten Tab befindet, indem **`chrome.tabs.sendMessage`** aufgerufen wird, wobei Sie die **ID des Tabs** angeben m√ºssen, an den die Nachricht gesendet werden soll.

### Von erlaubtem `externally_connectable` zur Erweiterung

**Webanwendungen und externe Browsererweiterungen, die in der `externally_connectable`-Konfiguration erlaubt sind**, k√∂nnen Anfragen senden mit:
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Wo es notwendig ist, die **Erweiterungs-ID** zu erw√§hnen.

### Native Messaging

Es ist m√∂glich, dass die Hintergrundskripte mit Bin√§rdateien im System kommunizieren, die **anf√§llig f√ºr kritische Sicherheitsanf√§lligkeiten wie RCEs** sein k√∂nnten, wenn diese Kommunikation nicht ordnungsgem√§√ü gesichert ist. [Mehr dazu sp√§ter](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
## Web **‚ÜîÔ∏é** Content Script Kommunikation

Die Umgebungen, in denen **Content-Skripte** arbeiten und wo die Host-Seiten existieren, sind **getrennt** voneinander, was **Isolation** gew√§hrleistet. Trotz dieser Isolation haben beide die F√§higkeit, mit dem **Document Object Model (DOM)** der Seite zu interagieren, einer gemeinsamen Ressource. Damit die Host-Seite mit dem **Content-Skript** oder indirekt mit der Erweiterung √ºber das Content-Skript kommunizieren kann, ist es erforderlich, das **DOM** zu nutzen, das von beiden Parteien als Kommunikationskanal zug√§nglich ist.

### Post-Nachrichten

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Eine sichere Post Message-Kommunikation sollte die Authentizit√§t der empfangenen Nachricht √ºberpr√ºfen, dies kann durch folgende Punkte geschehen:

* **`event.isTrusted`**: Dies ist nur dann True, wenn das Ereignis durch eine Benutzeraktion ausgel√∂st wurde.
* Das Inhalts-Skript k√∂nnte eine Nachricht nur erwarten, wenn der Benutzer eine Aktion ausf√ºhrt.
* **Ursprungsdom√§ne**: k√∂nnte eine Nachricht nur von einer erlaubten Liste von Dom√§nen erwarten.
* Wenn ein Regex verwendet wird, sei sehr vorsichtig.
* **Quelle**: `received_message.source !== window` kann verwendet werden, um zu √ºberpr√ºfen, ob die Nachricht **aus demselben Fenster** stammt, in dem das Inhalts-Skript lauscht.

Die vorherigen √úberpr√ºfungen k√∂nnten, selbst wenn sie durchgef√ºhrt werden, anf√§llig sein, also √ºberpr√ºfe auf der folgenden Seite **potenzielle Post Message-Byp√§sse**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Ein weiterer m√∂glicher Kommunikationsweg k√∂nnte √ºber **Iframe-URLs** erfolgen, ein Beispiel findest du in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Dies ist nicht "genau" ein Kommunikationsweg, aber das **Web und das Inhalts-Skript haben Zugriff auf das Web-DOM**. Wenn das **Inhalts-Skript** also Informationen daraus liest und das **Web-DOM** vertraut, k√∂nnte das Web diese Daten **modifizieren** (weil das Web nicht vertraut werden sollte oder weil das Web anf√§llig f√ºr XSS ist) und das **Inhalts-Skript** **kompromittieren**.

Ein Beispiel f√ºr ein **DOM-basiertes XSS zur Kompromittierung einer Browsererweiterung** findest du in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Kommunikation zwischen Inhalts-Skript **‚ÜîÔ∏é** Hintergrund-Skript

Ein Inhalts-Skript kann die Funktionen [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **oder** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) verwenden, um eine **einmalige JSON-serialisierbare** Nachricht zu senden.

Um die **Antwort** zu verarbeiten, verwende das zur√ºckgegebene **Promise**. Obwohl du aus Gr√ºnden der Abw√§rtskompatibilit√§t weiterhin eine **R√ºckruffunktion** als letzten Parameter √ºbergeben kannst.

Das Senden einer Anfrage von einem **Inhalts-Skript** sieht so aus:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Senden einer Anfrage von der **Erweiterung** (normalerweise einem **Hintergrundskript**). Beispiel, wie man eine Nachricht an das Inhaltskript im ausgew√§hlten Tab sendet:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Am **empfangenden Ende** m√ºssen Sie einen [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **Ereignis-Listener** einrichten, um die Nachricht zu verarbeiten. Dies sieht sowohl aus einem Inhalts-Skript als auch von einer Erweiterungsseite gleich aus.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Im hervorgehobenen Beispiel wurde **`sendResponse()`** synchron ausgef√ºhrt. Um den `onMessage`-Ereignis-Handler f√ºr die asynchrone Ausf√ºhrung von `sendResponse()` zu modifizieren, ist es unerl√§sslich, `return true;` einzuf√ºgen.

Eine wichtige √úberlegung ist, dass in Szenarien, in denen mehrere Seiten `onMessage`-Ereignisse empfangen sollen, **die erste Seite, die `sendResponse()`** f√ºr ein bestimmtes Ereignis ausf√ºhrt, die einzige sein wird, die die Antwort effektiv liefern kann. Alle nachfolgenden Antworten auf dasselbe Ereignis werden nicht ber√ºcksichtigt.

Beim Erstellen neuer Erweiterungen sollte die Pr√§ferenz auf Promises anstelle von Callbacks liegen. In Bezug auf die Verwendung von Callbacks wird die Funktion `sendResponse()` nur dann als g√ºltig angesehen, wenn sie direkt im synchronen Kontext ausgef√ºhrt wird oder wenn der Ereignis-Handler eine asynchrone Operation anzeigt, indem er `true` zur√ºckgibt. Sollten keine der Handler `true` zur√ºckgeben oder wenn die Funktion `sendResponse()` aus dem Speicher entfernt wird (garbage-collected), wird der mit der Funktion `sendMessage()` verbundene Callback standardm√§√üig ausgel√∂st.

## Native Messaging

Browsererweiterungen erm√∂glichen auch die Kommunikation mit **Binaries im System √ºber stdin**. Die Anwendung muss ein JSON installieren, das dies anzeigt, in einem JSON wie:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Wo der `name` der String ist, der an [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) oder [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) √ºbergeben wird, um mit der Anwendung von den Hintergrundskripten der Browsererweiterung zu kommunizieren. Der `path` ist der Pfad zur Bin√§rdatei, es gibt nur 1 g√ºltigen `type`, der stdio ist (verwende stdin und stdout) und die `allowed_origins` geben die Erweiterungen an, die darauf zugreifen k√∂nnen (und d√ºrfen kein Wildcard haben).

Chrome/Chromium wird nach diesem JSON in einigen Windows-Registrierungen und einigen Pfaden in macOS und Linux suchen (weitere Informationen in den [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

{% hint style="success" %}
Die Browsererweiterung ben√∂tigt auch die `nativeMessaing`-Berechtigung, um diese Kommunikation nutzen zu k√∂nnen.
{% endhint %}

So sieht ein Hintergrundskriptcode aus, der Nachrichten an eine native Anwendung sendet:
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
In [**diesem Blogbeitrag**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/) wird ein verwundbares Muster vorgeschlagen, das native Nachrichten missbraucht:

1. Die Browsererweiterung hat ein Wildcard-Muster f√ºr das Inhalts-Skript.
2. Das Inhalts-Skript √ºbergibt `postMessage`-Nachrichten an das Hintergrund-Skript mit `sendMessage`.
3. Das Hintergrund-Skript √ºbergibt die Nachricht an die native Anwendung mit `sendNativeMessage`.
4. Die native Anwendung verarbeitet die Nachricht gef√§hrlich, was zu einer Codeausf√ºhrung f√ºhrt.

Und darin wird ein Beispiel f√ºr **den √úbergang von jeder Seite zu RCE unter Ausnutzung einer Browsererweiterung erkl√§rt**.

## Sensible Informationen im Speicher/Code/Clipboard

Wenn eine Browsererweiterung **sensible Informationen in ihrem Speicher speichert**, k√∂nnten diese **ausgelesen** werden (insbesondere auf Windows-Maschinen) und nach diesen Informationen **gesucht** werden.

Daher **sollte der Speicher der Browsererweiterung nicht als sicher betrachtet werden** und **sensible Informationen** wie Anmeldeinformationen oder mnemonische Phrasen **sollten nicht gespeichert werden**.

Nat√ºrlich, **setzen Sie keine sensiblen Informationen in den Code**, da dieser **√∂ffentlich** sein wird.

Um den Speicher des Browsers auszulesen, k√∂nnten Sie **den Prozessspeicher auslesen** oder zu den **Einstellungen** der Browsererweiterung gehen, auf **`Pop-up inspizieren`** klicken -> Im **`Speicher`**-Bereich -> **`Snapshot erstellen`** und **`STRG+F`** verwenden, um im Snapshot nach sensiblen Informationen zu suchen.

Dar√ºber hinaus **sollten hochsensible Informationen wie mnemonische Schl√ºssel oder Passw√∂rter nicht in die Zwischenablage kopiert werden** (oder zumindest innerhalb weniger Sekunden von der Zwischenablage entfernt werden), da Prozesse, die die Zwischenablage √ºberwachen, sie dann erhalten k√∂nnen.

## Laden einer Erweiterung im Browser

1. **Laden Sie** die Browsererweiterung herunter und entpacken Sie sie.
2. Gehen Sie zu **`chrome://extensions/`** und **aktivieren** Sie den `Entwicklermodus`.
3. Klicken Sie auf die Schaltfl√§che **`Entpackte Erweiterung laden`**.

In **Firefox** gehen Sie zu **`about:debugging#/runtime/this-firefox`** und klicken auf die Schaltfl√§che **`Tempor√§re Erweiterung laden`**.

## Den Quellcode aus dem Store abrufen

Der Quellcode einer Chrome-Erweiterung kann auf verschiedene Weise abgerufen werden. Nachfolgend sind detaillierte Erkl√§rungen und Anweisungen f√ºr jede Option aufgef√ºhrt.

### Erweiterung als ZIP √ºber die Befehlszeile herunterladen

Der Quellcode einer Chrome-Erweiterung kann √ºber die Befehlszeile als ZIP-Datei heruntergeladen werden. Dies beinhaltet die Verwendung von `curl`, um die ZIP-Datei von einer bestimmten URL abzurufen und dann den Inhalt der ZIP-Datei in ein Verzeichnis zu extrahieren. Hier sind die Schritte:

1. Ersetzen Sie `"extension_id"` durch die tats√§chliche ID der Erweiterung.
2. F√ºhren Sie die folgenden Befehle aus:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Verwenden Sie die CRX Viewer-Website

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Verwenden Sie die CRX Viewer-Erweiterung

Eine weitere praktische Methode ist die Verwendung des Chrome Extension Source Viewer, ein Open-Source-Projekt. Es kann aus dem [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=de) installiert werden. Der Quellcode des Viewers ist in seinem [GitHub-Repository](https://github.com/Rob--W/crxviewer) verf√ºgbar.

### Quellcode der lokal installierten Erweiterung anzeigen

Chrome-Erweiterungen, die lokal installiert sind, k√∂nnen ebenfalls inspiziert werden. So geht's:

1. Greifen Sie auf Ihr lokales Chrome-Profilverzeichnis zu, indem Sie `chrome://version/` besuchen und das Feld "Profilpfad" finden.
2. Navigieren Sie zum Unterordner `Extensions/` innerhalb des Profilverzeichnisses.
3. Dieser Ordner enth√§lt alle installierten Erweiterungen, typischerweise mit ihrem Quellcode in einem lesbaren Format.

Um Erweiterungen zu identifizieren, k√∂nnen Sie ihre IDs den Namen zuordnen:

* Aktivieren Sie den Entwicklermodus auf der Seite `about:extensions`, um die IDs jeder Erweiterung zu sehen.
* Innerhalb des Ordners jeder Erweiterung enth√§lt die Datei `manifest.json` ein lesbares `name`-Feld, das Ihnen hilft, die Erweiterung zu identifizieren.

### Verwenden Sie einen Dateiarchivier oder -depacker

Gehen Sie zum Chrome Web Store und laden Sie die Erweiterung herunter. Die Datei hat die Erweiterung `.crx`. √Ñndern Sie die Dateierweiterung von `.crx` in `.zip`. Verwenden Sie einen beliebigen Dateiarchivier (wie WinRAR, 7-Zip usw.), um den Inhalt der ZIP-Datei zu extrahieren.

### Entwicklermodus in Chrome verwenden

√ñffnen Sie Chrome und gehen Sie zu `chrome://extensions/`. Aktivieren Sie "Entwicklermodus" oben rechts. Klicken Sie auf "Entpackte Erweiterung laden...". Navigieren Sie zum Verzeichnis Ihrer Erweiterung. Dies l√§dt den Quellcode nicht herunter, ist jedoch n√ºtzlich, um den Code einer bereits heruntergeladenen oder entwickelten Erweiterung anzuzeigen und zu √§ndern.

## Chrome-Erweiterungsmanifest-Datensatz

Um zu versuchen, anf√§llige Browsererweiterungen zu erkennen, k√∂nnen Sie das [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) verwenden und deren Manifestdateien auf potenziell anf√§llige Hinweise √ºberpr√ºfen. Zum Beispiel, um nach Erweiterungen mit mehr als 25000 Benutzern, `content_scripts` und der Berechtigung `nativeMessaging` zu suchen:

{% code overflow="wrap" %}
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
{% endcode %}

## Sicherheitspr√ºfungs-Checkliste

Obwohl Browsererweiterungen eine **begrenzte Angriffsfl√§che** haben, k√∂nnen einige von ihnen **Schwachstellen** oder **potenzielle Verbesserungen der Sicherheit** enthalten. Die folgenden sind die h√§ufigsten:

* [ ] **Berechtigungen** so weit wie m√∂glich **`permissions`** einschr√§nken
* [ ] **`host_permissions`** so weit wie m√∂glich **einschr√§nken**
* [ ] Eine **starke** **`content_security_policy`** verwenden
* [ ] **`externally_connectable`** so weit wie m√∂glich **einschr√§nken**, wenn keine ben√∂tigt wird und m√∂glich ist, lassen Sie es nicht standardm√§√üig, geben Sie **`{}`** an
* [ ] Wenn hier eine **URL, die anf√§llig f√ºr XSS oder √úbernahme ist**, erw√§hnt wird, kann ein Angreifer **Nachrichten direkt an die Hintergrundskripte senden**. Sehr m√§chtiger Umgehung.
* [ ] **`web_accessible_resources`** so weit wie m√∂glich **einschr√§nken**, sogar leer, wenn m√∂glich.
* [ ] Wenn **`web_accessible_resources`** nicht leer ist, √ºberpr√ºfen Sie [**ClickJacking**](browext-clickjacking.md)
* [ ] Wenn eine **Kommunikation** von der **Erweiterung** zur **Webseite** erfolgt, [**√ºberpr√ºfen Sie auf XSS**](browext-xss-example.md) **Schwachstellen**, die in der Kommunikation verursacht werden.
* [ ] Wenn Post-Nachrichten verwendet werden, √ºberpr√ºfen Sie auf [**Post-Nachrichten-Schwachstellen**](../postmessage-vulnerabilities/)**.**
* [ ] Wenn das **Inhalts-Skript auf DOM-Details zugreift**, √ºberpr√ºfen Sie, ob sie **kein XSS einf√ºhren**, wenn sie von der Webseite **modifiziert** werden
* [ ] Besondere Betonung, wenn diese Kommunikation auch in der **Kommunikation zwischen Inhalts-Skript und Hintergrundskript** beteiligt ist
* [ ] Wenn das Hintergrundskript √ºber **native Messaging** kommuniziert, √ºberpr√ºfen Sie, ob die Kommunikation sicher und bereinigt ist
* [ ] **Sensible Informationen sollten nicht** im Code der Browsererweiterung **gespeichert werden**
* [ ] **Sensible Informationen sollten nicht** im Speicher der Browsererweiterung **gespeichert werden**
* [ ] **Sensible Informationen sollten nicht** im **Dateisystem ungesch√ºtzt** gespeichert werden

## Risiken von Browsererweiterungen

* Die App [https://crxaminer.tech/](https://crxaminer.tech/) analysiert einige Daten wie die Berechtigungen, die die Browsererweiterung anfordert, um ein Risikoniveau f√ºr die Verwendung der Browsererweiterung anzugeben.

## Werkzeuge

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Zieht jede Chrome-Erweiterung von einem bereitgestellten Chrome-Webstore-Link.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **Viewer**: zeigt einfach eine JSON-h√ºbsch formatierte Version des Manifests der Erweiterung an.
* **Fingerprint-Analyse**: Erkennung von [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) und automatische Generierung von JavaScript zur Fingerabdruckerkennung von Chrome-Erweiterungen.
* **Potenzielle Clickjacking-Analyse**: Erkennung von HTML-Seiten der Erweiterung mit der **web\_accessible\_resources**-Richtlinie. Diese sind potenziell anf√§llig f√ºr Clickjacking, abh√§ngig vom Zweck der Seiten.
* **Berechtigungswarnungen Viewer**: zeigt eine Liste aller Chrome-Berechtigungsaufforderungswarnungen, die angezeigt werden, wenn ein Benutzer versucht, die Erweiterung zu installieren.
* **Gef√§hrliche Funktion(en)**: zeigt den Standort gef√§hrlicher Funktionen, die potenziell von einem Angreifer ausgenutzt werden k√∂nnten (z. B. Funktionen wie innerHTML, chrome.tabs.executeScript).
* **Einstiegspunkt(e)**: zeigt, wo die Erweiterung Benutzereingaben oder externe Eingaben entgegennimmt. Dies ist n√ºtzlich, um die Angriffsfl√§che einer Erweiterung zu verstehen und nach potenziellen Punkten zu suchen, um b√∂sartig gestaltete Daten an die Erweiterung zu senden.
* Sowohl die Scanner f√ºr gef√§hrliche Funktionen als auch die Einstiegspunkte haben Folgendes f√ºr ihre generierten Warnungen:
* Relevanter Codeausschnitt und Zeile, die die Warnung verursacht hat.
* Beschreibung des Problems.
* Eine Schaltfl√§che ‚ÄûDatei anzeigen‚Äú, um die vollst√§ndige Quelldatei mit dem Code anzuzeigen.
* Der Pfad der alarmierten Datei.
* Die vollst√§ndige Chrome-Erweiterungs-URI der alarmierten Datei.
* Den Typ der Datei, z. B. ein Hintergrundseiten-Skript, Inhalts-Skript, Browser-Aktion usw.
* Wenn die anf√§llige Zeile in einer JavaScript-Datei ist, die Pfade aller Seiten, auf denen sie enthalten ist, sowie den Typ dieser Seiten und den Status der [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
* **Content Security Policy (CSP) Analyzer und Umgehungspr√ºfer**: Dies wird Schw√§chen in der CSP Ihrer Erweiterung aufzeigen und auch potenzielle M√∂glichkeiten zur Umgehung Ihrer CSP aufgrund von aufgelisteten CDNs usw. aufzeigen.
* **Bekannte anf√§llige Bibliotheken**: Dies verwendet [Retire.js](https://retirejs.github.io/retire.js/), um die Verwendung bekannter anf√§lliger JavaScript-Bibliotheken zu √ºberpr√ºfen.
* Erweiterung und formatierte Versionen herunterladen.
* Die originale Erweiterung herunterladen.
* Eine versch√∂nerte Version der Erweiterung herunterladen (automatisch h√ºbsch formatierte HTML- und JavaScript-Dateien).
* Automatische Zwischenspeicherung der Scanergebnisse, das Ausf√ºhren eines Erweiterungsscans dauert beim ersten Ausf√ºhren eine gute Zeit. Beim zweiten Mal, vorausgesetzt, die Erweiterung wurde nicht aktualisiert, wird es aufgrund der zwischengespeicherten Ergebnisse fast sofort sein.
* Verlinkbare Bericht-URLs, um jemand anderem leicht einen von Tarnish generierten Erweiterungsbericht zu verlinken.

### [Neto](https://github.com/elevenpaths/neto)

Projekt Neto ist ein Python 3-Paket, das entwickelt wurde, um versteckte Funktionen von Browser-Plugins und -Erweiterungen f√ºr bekannte Browser wie Firefox und Chrome zu analysieren und zu entschl√ºsseln. Es automatisiert den Prozess des Entpackens der gepackten Dateien, um diese Funktionen aus relevanten Ressourcen in einer Erweiterung wie `manifest.json`, Lokalisierungsordnern oder JavaScript- und HTML-Quelldateien zu extrahieren.

## Referenzen

* **Danke an** [**@naivenom**](https://twitter.com/naivenom) **f√ºr die Hilfe mit dieser Methodik**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
