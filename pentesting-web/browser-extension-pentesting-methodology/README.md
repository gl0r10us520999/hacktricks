# Browser Extension Pentesting Methodology

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Extensions za kivinjari zimeandikwa kwa JavaScript na zinapakiwa na kivinjari katika hali ya nyuma. Ina [DOM](https://www.w3schools.com/js/js_htmldom.asp) yake lakini inaweza kuingiliana na DOM za tovuti nyingine. Hii inamaanisha kwamba inaweza kuhatarisha usiri, uadilifu, na upatikanaji (CIA) wa tovuti nyingine.

## Main Components

Muundo wa nyongeza unaonekana bora unapofikiriwa na unajumuisha vipengele vitatu. Hebu tuangalie kila kipengele kwa undani.

<figure><img src="../../.gitbook/assets/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Content Scripts**

Kila script ya maudhui ina ufikiaji wa moja kwa moja kwa DOM ya **ukurasa mmoja wa wavuti** na hivyo inakabiliwa na **ingizo linaloweza kuwa na madhara**. Hata hivyo, script ya maudhui haina ruhusa zaidi ya uwezo wa kutuma ujumbe kwa msingi wa nyongeza.

### **Extension Core**

Msingi wa nyongeza unajumuisha ruhusa nyingi za nyongeza, lakini msingi wa nyongeza unaweza kuingiliana tu na maudhui ya wavuti kupitia [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) na scripts za maudhui. Pia, msingi wa nyongeza haina ufikiaji wa moja kwa moja kwa mashine mwenyeji.

### **Native Binary**

Nyongeza inaruhusu binary asilia ambayo inaweza **kufikia mashine mwenyeji kwa ruhusa kamili ya mtumiaji.** Binary asilia inaingiliana na msingi wa nyongeza kupitia Kiolesura cha Programu ya Plugin ya Netscape ya kawaida ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) inayotumiwa na Flash na nyongeza nyingine za kivinjari.

### Boundaries

{% hint style="danger" %}
Ili kupata ruhusa kamili za mtumiaji, mshambuliaji lazima amshawishi nyongeza kupitisha ingizo la hatari kutoka kwa script ya maudhui hadi msingi wa nyongeza na kutoka kwa msingi wa nyongeza hadi binary asilia.
{% endhint %}

Kila kipengele cha nyongeza kimewekwa mbali na kingine kwa **mipaka yenye ulinzi mkali**. Kila kipengele kinakimbia katika **mchakato tofauti wa mfumo wa uendeshaji**. Scripts za maudhui na msingi wa nyongeza zinakimbia katika **mchakato wa sandbox** ambao haupatikani kwa huduma nyingi za mfumo wa uendeshaji.

Zaidi ya hayo, scripts za maudhui zimej separated kutoka kwa kurasa zao za wavuti kwa **kukimbia katika heap tofauti ya JavaScript**. Script ya maudhui na ukurasa wa wavuti zina **ufikiaji wa DOM sawa ya msingi**, lakini hizo mbili **hazibadilishani viashiria vya JavaScript**, kuzuia kuvuja kwa kazi za JavaScript.

## **`manifest.json`**

Nyongeza ya Chrome ni tu folda ya ZIP yenye [.crx file extension](https://www.lifewire.com/crx-file-2620391). Msingi wa nyongeza ni **`manifest.json`** faili katika mzizi wa folda, ambayo inaelezea muundo, ruhusa, na chaguzi zingine za usanidi.

Example:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content scripts zina **pakiwa** kila wakati mtumiaji **anapohamia kwenye ukurasa unaolingana**, katika kesi yetu ukurasa wowote unaolingana na **`https://example.com/*`** na usiozingatia regex ya **`*://*/*/business*`**. Zinatekelezwa **kama vile skripti za ukurasa wenyewe** na zina ufikiaji wa kiholela kwa [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) wa ukurasa.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Ili kujumuisha au kutengwa kwa URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

Hii ni mfano wa skripti ya maudhui ambayo itaongeza kitufe cha maelezo kwenye ukurasa wakati [API ya hifadhi](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) inatumika kupata thamani ya `message` kutoka kwenye hifadhi ya nyongeza.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Ujumbe unatumwa kwa kurasa za nyongeza na script ya maudhui wakati kitufe hiki kinapobonyezwa, kupitia matumizi ya [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Hii ni kutokana na kikomo cha script ya maudhui katika ufikiaji wa moja kwa moja wa APIs, ambapo `storage` ni miongoni mwa ubaguzi wachache. Kwa kazi zaidi ya ubaguzi hizi, ujumbe unatumwa kwa kurasa za nyongeza ambazo script za maudhui zinaweza kuwasiliana nazo.

{% hint style="warning" %}
Kulingana na kivinjari, uwezo wa script ya maudhui unaweza kutofautiana kidogo. Kwa kivinjari kinachotegemea Chromium, orodha ya uwezo inapatikana katika [Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), na kwa Firefox, [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) inatumika kama chanzo kikuu.\
Pia ni muhimu kutambua kwamba script za maudhui zina uwezo wa kuwasiliana na script za nyuma, na kuwapa uwezo wa kutekeleza vitendo na kurudisha majibu.
{% endhint %}

Ili kuona na kufanyia kazi script za maudhui katika Chrome, menyu ya zana za maendeleo za Chrome inaweza kufikiwa kutoka Chaguo > Zana zaidi > Zana za maendeleo AU kwa kubonyeza Ctrl + Shift + I.

Baada ya zana za maendeleo kuonyeshwa, **tab ya Chanzo** inapaswa kubonyezwa, ikifuatiwa na tab ya **Script za Maudhui**. Hii inaruhusu kuangalia script za maudhui zinazotumika kutoka nyongeza mbalimbali na kuweka alama za kuvunja ili kufuatilia mtiririko wa utekelezaji.

### Script za maudhui zilizowekwa

{% hint style="success" %}
Kumbuka kwamba **Script za Maudhui si lazima** kwani pia inawezekana **kuiingiza** script kwa **dynamically** na **kuziingiza kimaandishi** katika kurasa za wavuti kupitia **`tabs.executeScript`**. Hii kwa kweli inatoa **udhibiti wa kina** zaidi.
{% endhint %}

Kwa kuingiza script ya maudhui kimaandishi, nyongeza inahitaji kuwa na [idhini za mwenyeji](https://developer.chrome.com/docs/extensions/reference/permissions) kwa ukurasa ambao script zitakuwa zinaingizwa. Idhini hizi zinaweza kupatikana ama kwa **kuziomba** ndani ya hati ya nyongeza au kwa msingi wa muda kupitia [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Mfano wa nyongeza inayotegemea activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Ingiza faili la JS kwa kubonyeza:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Weka kazi** kwa kubonyeza:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Mfano na ruhusa za skripti
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Ili kujumuisha au kutengwa kwa URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

### Content Scripts `run_at`

Sehemu ya `run_at` inasimamia **wakati faili za JavaScript zinapoinjizwa kwenye ukurasa wa wavuti**. Thamani inayopendekezwa na ya default ni `"document_idle"`.

Thamani zinazowezekana ni:

* **`document_idle`**: Wakati wowote iwezekanavyo
* **`document_start`**: Baada ya faili zozote kutoka `css`, lakini kabla ya DOM nyingine yoyote kujengwa au script nyingine yoyote kuendeshwa.
* **`document_end`**: Mara moja baada ya DOM kukamilika, lakini kabla ya rasilimali ndogo kama picha na fremu kupakiwa.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Kupitia **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Meseji zinazotumwa na scripts za maudhui zinapokelewa na **ukurasa wa nyuma**, ambao unachukua jukumu kuu katika kuratibu vipengele vya nyongeza. Kwa kuzingatia, ukurasa wa nyuma unadumu wakati wa maisha ya nyongeza, ukifanya kazi kwa siri bila mwingiliano wa moja kwa moja na mtumiaji. Una mfano wake wa Hati ya Kitu (DOM), ikiruhusu mwingiliano tata na usimamizi wa hali.

**Mambo Muhimu**:

* **Jukumu la Ukurasa wa Nyuma:** Inafanya kazi kama kituo cha neva kwa nyongeza, kuhakikisha mawasiliano na uratibu kati ya sehemu mbalimbali za nyongeza.
* **Uendelevu:** Ni kiumbe kilichopo kila wakati, kisichoonekana kwa mtumiaji lakini muhimu kwa utendaji wa nyongeza.
* **Uundaji Otomatiki:** Ikiwa haijafafanuliwa wazi, kivinjari kitaunda kiotomatiki ukurasa wa nyuma. Ukurasa huu ulioundwa kiotomatiki utajumuisha scripts zote za nyuma zilizotajwa katika hati ya nyongeza, kuhakikisha uendeshaji wa bila mshono wa kazi za nyuma za nyongeza.

{% hint style="success" %}
Urahisi unaotolewa na kivinjari katika kuunda kiotomatiki ukurasa wa nyuma (wakati haujafafanuliwa wazi) unahakikisha kwamba scripts zote muhimu za nyuma zimejumuishwa na zinafanya kazi, zikifanya mchakato wa kuweka nyongeza kuwa rahisi.
{% endhint %}

Mfano wa script ya nyuma:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Inatumia [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) kusikiliza ujumbe. Wakati ujumbe wa `"explain"` unapopokelewa, inatumia [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) kufungua ukurasa katika tab mpya.

Ili kubaini skripti ya nyuma unaweza kwenda kwenye **maelezo ya nyongeza na kukagua huduma ya mfanyakazi,** hii itafungua zana za maendeleo na skripti ya nyuma:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Kurasa za Chaguo na Nyingine

Nyongeza za kivinjari zinaweza kuwa na aina mbalimbali za kurasa:

* **Kurasa za Kitendo** zinaonyeshwa katika **orodha ya kushuka wakati ikoni ya nyongeza** inabonyezwa.
* Kurasa ambazo nyongeza it **pakia katika tab mpya**.
* **Kurasa za Chaguo**: Ukurasa huu unaonyeshwa juu ya nyongeza wakati unabonyezwa. Katika hati ya awali Katika kesi yangu niliweza kufikia ukurasa huu katika `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` au kubonyeza:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Kumbuka kwamba kurasa hizi si za kudumu kama kurasa za nyuma kwani zinapakia maudhui kwa mahitaji. Licha ya hili, zinashiriki uwezo fulani na ukurasa wa nyuma:

* **Mawasiliano na Skripti za Maudhui:** Kama ilivyo kwa ukurasa wa nyuma, kurasa hizi zinaweza kupokea ujumbe kutoka kwa skripti za maudhui, kurahisisha mwingiliano ndani ya nyongeza.
* **Upatikanaji wa APIs za Maalum za Nyongeza:** Kurasa hizi zinafurahia upatikanaji mpana wa APIs za maalum za nyongeza, kulingana na ruhusa zilizofafanuliwa kwa nyongeza.

### `permissions` & `host_permissions`

**`permissions`** na **`host_permissions`** ni entries kutoka `manifest.json` ambazo zitaonyesha **ni ruhusa zipi** nyongeza za kivinjari zina (hifadhi, eneo...) na **katika kurasa zipi za wavuti**.

Kama nyongeza za kivinjari zinaweza kuwa na **mamlaka makubwa**, moja mbaya au moja iliyovunjwa inaweza kumruhusu mshambuliaji **njia tofauti za kuiba taarifa nyeti na kupeleleza mtumiaji**.

Angalia jinsi mipangilio hii inavyofanya kazi na jinsi inaweza kutumika vibaya katika:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

**sera ya usalama wa maudhui** inaweza kutangazwa pia ndani ya `manifest.json`. Ikiwa kuna moja iliyofafanuliwa, inaweza kuwa **hatari**.

Mipangilio ya default kwa kurasa za nyongeza za kivinjari ni ya kukatisha tamaa:
```bash
script-src 'self'; object-src 'self';
```
Kwa maelezo zaidi kuhusu CSP na uwezekano wa kupita angalia:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

ili kuruhusu ukurasa wa wavuti kufikia ukurasa wa Kiongezeo cha Kivinjari, ukurasa wa `.html` kwa mfano, ukurasa huu unahitaji kutajwa katika uwanja wa **`web_accessible_resources`** wa `manifest.json`.\
Kwa mfano:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Hizi kurasa zinapatikana katika URL kama:
```
chrome-extension://<extension-id>/message.html
```
Katika nyongeza za umma, **extension-id inapatikana**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Hata hivyo, ikiwa parameter ya `manifest.json` **`use_dynamic_url`** inatumika, **id hii inaweza kuwa ya dinamik**.

{% hint style="success" %}
Kumbuka kwamba hata kama ukurasa umeelezewa hapa, unaweza kuwa **ulindwa dhidi ya ClickJacking** kutokana na **Content Security Policy**. Hivyo unahitaji pia kuangalia (sehemu ya frame-ancestors) kabla ya kuthibitisha kuwa shambulio la ClickJacking linawezekana.
{% endhint %}

Kuruhusiwa kufikia kurasa hizi kunafanya kurasa hizi **kuwa na uwezekano wa kuwa na udhaifu wa ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Kuruhusu kurasa hizi kupakuliwa tu na nyongeza na si kwa URL za nasibu kunaweza kuzuia shambulio la ClickJacking.
{% endhint %}

{% hint style="danger" %}
Kumbuka kwamba kurasa kutoka **`web_accessible_resources`** na kurasa nyingine za nyongeza pia zina uwezo wa **kuwasiliana na scripts za nyuma**. Hivyo ikiwa moja ya kurasa hizi ina udhaifu wa **XSS** inaweza kufungua udhaifu mkubwa zaidi.

Zaidi ya hayo, kumbuka kwamba unaweza kufungua tu kurasa zilizoonyeshwa katika **`web_accessible_resources`** ndani ya iframes, lakini kutoka kwenye tab mpya inawezekana kufikia ukurasa wowote katika nyongeza ukijua extension ID. Hivyo, ikiwa XSS inapatikana ikitumia vigezo sawa, inaweza kutumika hata kama ukurasa haujawekwa katika **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Kulingana na [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), Mali ya `"externally_connectable"` katika manifest inatangaza **ni nyongeza zipi na kurasa za wavuti zinaweza kuungana** na nyongeza yako kupitia [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) na [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Ikiwa funguo ya **`externally_connectable`** **haijatangazwa** katika manifest ya nyongeza yako au imetangazwa kama **`"ids": ["*"]`**, **nyongeza zote zinaweza kuungana, lakini hakuna kurasa za wavuti zinaweza kuungana**.
* Ikiwa **IDs maalum zimeelezwa**, kama katika `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **ni hizo programu pekee** zinaweza kuungana.
* Ikiwa **mifano** imeelezwa, programu hizo za wavuti zitakuwa na uwezo wa kuungana:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Ikiwa imeelezwa kama tupu: **`"externally_connectable": {}`**, hakuna programu au wavuti itakayoweza kuungana.

Idadi **ndogo ya nyongeza na URL** zilizoorodheshwa hapa, **ndiyo ndogo zaidi ya uso wa shambulio** itakuwa.

{% hint style="danger" %}
Ikiwa ukurasa wa wavuti **unaotetereka kwa XSS au takeover** umeonyeshwa katika **`externally_connectable`**, mshambuliaji ataweza **kutuma ujumbe moja kwa moja kwa skripti ya nyuma**, akipita kabisa Skripti ya Maudhui na CSP yake.

Hivyo, hii ni **kikosi cha kupita chenye nguvu sana**.

Zaidi ya hayo, ikiwa mteja ataweka nyongeza ya uongo, hata kama hairuhusiwi kuwasiliana na nyongeza inayotetereka, inaweza kuingiza **data za XSS katika ukurasa wa wavuti ulioidhinishwa** au kutumia **`WebRequest`** au **`DeclarativeNetRequest`** APIs kubadilisha maombi kwenye kikoa kilicholengwa kubadilisha ombi la ukurasa kwa **faili ya JavaScript**. (Kumbuka kwamba CSP kwenye ukurasa uliohisiwa inaweza kuzuia mashambulizi haya). Wazo hili linatokana na [**hiki andiko**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Muhtasari wa mawasiliano

### Nyongeza <--> WebApp

Ili kuwasiliana kati ya skripti ya maudhui na ukurasa wa wavuti, ujumbe wa baada ya kawaida hutumiwa. Hivyo, katika programu ya wavuti mara nyingi utapata simu za kazi **`window.postMessage`** na katika skripti ya maudhui wasikilizaji kama **`window.addEventListener`**. Tafadhali kumbuka, hata hivyo, kwamba nyongeza inaweza pia **kuwasiliana na programu ya wavuti ikituma Ujumbe wa Post** (na hivyo wavuti inapaswa kuutarajia) au tu kufanya wavuti ipakue skripti mpya.

### Ndani ya nyongeza

Kawaida kazi **`chrome.runtime.sendMessage`** hutumiwa kutuma ujumbe ndani ya nyongeza (kawaida inashughulikiwa na skripti ya `background`) na ili kupokea na kushughulikia inatangazwa msikilizaji akitumia **`chrome.runtime.onMessage.addListener`**.

Pia inawezekana kutumia **`chrome.runtime.connect()`** kuwa na muunganisho wa kudumu badala ya kutuma ujumbe mmoja mmoja, inawezekana kuitumia **kutuma** na **kupokea** **ujumbe** kama katika mfano ufuatao:

<details>

<summary><code>chrome.runtime.connect()</code> mfano</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Pia inawezekana kutuma ujumbe kutoka kwa script ya nyuma hadi script ya maudhui iliyoko katika tab maalum kwa kuita **`chrome.tabs.sendMessage`** ambapo utahitaji kuashiria **ID ya tab** ya kutuma ujumbe.

### Kutoka kwa `externally_connectable` inayoruhusiwa hadi nyongeza

**Programu za wavuti na nyongeza za kivinjari za nje zinazoruhusiwa** katika usanidi wa `externally_connectable` zinaweza kutuma maombi kwa kutumia :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Mahali ambapo inahitajika kutaja **extension ID**.

### Native Messaging

Inawezekana kwa scripts za background kuwasiliana na binaries ndani ya mfumo, ambayo yanaweza kuwa **na udhaifu mkubwa kama RCEs** ikiwa mawasiliano haya hayajashughulikiwa ipasavyo. [Zaidi kuhusu hii baadaye](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
## Web **‚ÜîÔ∏é** Mawasiliano ya Skripti za Maudhui

Mazingira ambapo **skripti za maudhui** zinafanya kazi na ambapo kurasa za mwenyeji zipo ni **separated** kutoka kwa kila mmoja, kuhakikisha **isolation**. Licha ya **isolation** hii, zote zina uwezo wa kuingiliana na **Document Object Model (DOM)** ya ukurasa, rasilimali inayoshirikiwa. Ili ukurasa wa mwenyeji uweze kushiriki katika mawasiliano na **skripti ya maudhui**, au kwa njia isiyo ya moja kwa moja na nyongeza kupitia skripti ya maudhui, inahitajika kutumia **DOM** ambayo inapatikana na pande zote mbili kama njia ya mawasiliano.

### Post Messages

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Mawasiliano salama ya Post Message inapaswa kuangalia uhalali wa ujumbe ulipokelewa, hii inaweza kufanywa kwa kuangalia:

* **`event.isTrusted`**: Hii ni Kweli tu ikiwa tukio lilichochewa na kitendo cha mtumiaji
* Skripti ya maudhui inaweza kutarajia ujumbe tu ikiwa mtumiaji atafanya kitendo fulani
* **domeni ya asili**: inaweza kutarajia ujumbe tu kwenye orodha ya ruhusa ya domeni.
* Ikiwa regex inatumika, kuwa makini sana
* **Chanzo**: `received_message.source !== window` inaweza kutumika kuangalia ikiwa ujumbe ulikuwa **kutoka kwenye dirisha lile lile** ambapo Skripti ya Maudhui inasikiliza.

Ukaguzi wa awali, hata kama umefanywa, unaweza kuwa na udhaifu, hivyo angalia kwenye ukurasa ufuatao **mipango ya Post Message inayoweza kupuuziliwa mbali**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Njia nyingine inay posible ya mawasiliano inaweza kuwa kupitia **Iframe URLs**, unaweza kupata mfano katika:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Hii si "haswa" njia ya mawasiliano, lakini **mtandao na skripti ya maudhui zitakuwa na ufikiaji wa DOM ya wavuti**. Hivyo, ikiwa **skripti ya maudhui** inasoma taarifa fulani kutoka kwake, **ikitegemea DOM ya wavuti**, wavuti inaweza **kubadilisha data hii** (kwa sababu wavuti haipaswi kuaminika, au kwa sababu wavuti ina udhaifu wa XSS) na **kuathiri Skripti ya Maudhui**.

Unaweza pia kupata mfano wa **XSS inayotegemea DOM kuathiri upanuzi wa kivinjari** katika:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Mawasiliano ya Skripti ya Maudhui **‚ÜîÔ∏é** Skripti ya Nyuma

Skripti ya Maudhui inaweza kutumia kazi [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **au** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) kutuma ujumbe **wa mara moja unaoweza kubadilishwa kuwa JSON**.

Ili kushughulikia **jibu**, tumia **Promise** iliyorejeshwa. Ingawa, kwa ajili ya ulinganifu wa nyuma, bado unaweza kupitisha **callback** kama hoja ya mwisho.

Kutuma ombi kutoka kwa **skripti ya maudhui** inaonekana kama hii:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Kutuma ombi kutoka kwenye **extension** (kawaida ni **background script**). Mfano wa jinsi ya kutuma ujumbe kwa script ya maudhui katika tab iliyochaguliwa:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Katika **kipande cha kupokea**, unahitaji kuweka [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **mwanachama wa tukio** ili kushughulikia ujumbe. Hii inaonekana sawa kutoka kwa skripti ya maudhui au ukurasa wa nyongeza.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Katika mfano ulioangaziwa, **`sendResponse()`** ilitekelezwa kwa njia ya synchronous. Ili kubadilisha mhandisi wa tukio la `onMessage` kwa utekelezaji wa asynchronous wa `sendResponse()`, ni muhimu kuingiza `return true;`.

Kitu muhimu cha kuzingatia ni kwamba katika hali ambapo kurasa nyingi zimewekwa kupokea matukio ya `onMessage`, **kurasa ya kwanza kutekeleza `sendResponse()`** kwa tukio maalum itakuwa pekee inayoweza kutoa jibu kwa ufanisi. Majibu yoyote yanayofuata kwa tukio hilo hilo hayatazingatiwa.

Wakati wa kuunda nyongeza mpya, upendeleo unapaswa kuwa kwa ahadi badala ya callbacks. Kuhusu matumizi ya callbacks, kazi ya `sendResponse()` inachukuliwa kuwa halali tu ikiwa inatekelezwa moja kwa moja ndani ya muktadha wa synchronous, au ikiwa mhandisi wa tukio unaonyesha operesheni ya asynchronous kwa kurudisha `true`. Ikiwa hakuna mhandisi yeyote anayerudisha `true` au ikiwa kazi ya `sendResponse()` imeondolewa kutoka kwenye kumbukumbu (garbage-collected), callback inayohusiana na kazi ya `sendMessage()` itachochewa kwa default.

## Ujumbe wa Asili

Nyongeza za kivinjari pia zinaruhusu kuwasiliana na **binaries katika mfumo kupitia stdin**. Programu lazima iweke json ikionyesha hivyo katika json kama:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Wakati `name` ni mfuatano unaopitishwa kwa [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) au [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) ili kuwasiliana na programu kutoka kwa skripti za nyuma za nyongeza ya kivinjari. `path` ni njia ya binary, kuna aina 1 tu halali ambayo ni stdio (tumia stdin na stdout) na `allowed_origins` inaonyesha nyongeza ambazo zinaweza kuipata (na haziwezi kuwa na wildcard).

Chrome/Chromium itatafuta json hii katika baadhi ya usajili wa windows na baadhi ya njia katika macOS na Linux (maelezo zaidi katika [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

{% hint style="success" %}
Nyongeza ya kivinjari pia inahitaji ruhusa ya `nativeMessaing` kutangazwa ili iweze kutumia mawasiliano haya.
{% endhint %}

Hivi ndivyo inavyoonekana kama baadhi ya msimbo wa skripti za nyuma ukituma ujumbe kwa programu asilia:
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
Katika [**hiki kipande cha blogu**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), mfano wa muundo dhaifu unaotumia ujumbe wa asili unapendekezwa:

1. Kiongezeo cha kivinjari kina muundo wa wildcard kwa skripti ya maudhui.
2. Skripti ya maudhui inapita ujumbe wa `postMessage` kwa skripti ya nyuma kwa kutumia `sendMessage`.
3. Skripti ya nyuma inapita ujumbe kwa programu ya asili kwa kutumia `sendNativeMessage`.
4. Programu ya asili inashughulikia ujumbe kwa njia hatari, ikisababisha utekelezaji wa msimbo.

Na ndani yake mfano wa **kuenda kutoka ukurasa wowote hadi RCE kwa kutumia kiongezeo cha kivinjari unafafanuliwa**.

## Taarifa Nyeti Katika Kumbukumbu/Msimbo/Clipboard

Ikiwa Kiongezeo cha Kivinjari kina **taarifa nyeti ndani ya kumbukumbu yake**, hii inaweza **kutolewa** (hasa kwenye mashine za Windows) na **kutafutwa** kwa taarifa hii.

Kwa hivyo, kumbukumbu ya Kiongezeo cha Kivinjari **haipaswi kuzingatiwa kuwa salama** na **taarifa nyeti** kama vile akidi au maneno ya kumbukumbu **haipaswi kuhifadhiwa**.

Kwa hakika, usiweke **taarifa nyeti katika msimbo**, kwani itakuwa **ya umma**.

Ili kutoa kumbukumbu kutoka kwa kivinjari unaweza **kutoa kumbukumbu ya mchakato** au kwenda kwenye **mipangilio** ya kiongezeo cha kivinjari bonyeza **`Inspect pop-up`** -> Katika sehemu ya **`Memory`** -> **`Take a snaphost`** na **`CTRL+F`** kutafuta ndani ya picha ya kumbukumbu kwa taarifa nyeti.

Zaidi ya hayo, taarifa nyeti sana kama vile funguo za kumbukumbu au nywila **hazipaswi kuruhusiwa kunakiliwa kwenye clipboard** (au angalau kuondolewa kutoka kwenye clipboard ndani ya sekunde chache) kwa sababu basi michakato inayofuatilia clipboard itakuwa na uwezo wa kuzipata.

## Kupakia Kiongezeo Katika Kivinjari

1. **Pakua** Kiongezeo cha Kivinjari & uondoe zipu
2. Nenda kwenye **`chrome://extensions/`** na **wezesha** `Developer Mode`
3. Bonyeza kitufe cha **`Load unpacked`**

Katika **Firefox** unakwenda kwenye **`about:debugging#/runtime/this-firefox`** na bonyeza kitufe cha **`Load Temporary Add-on`**.

## Kupata msimbo wa chanzo kutoka dukani

Msimbo wa chanzo wa kiongezeo cha Chrome unaweza kupatikana kupitia njia mbalimbali. Hapa chini kuna maelezo ya kina na maagizo kwa kila chaguo.

### Pakua Kiongezeo kama ZIP kupitia Mstari wa Amri

Msimbo wa chanzo wa kiongezeo cha Chrome unaweza kupakuliwa kama faili ya ZIP kwa kutumia mstari wa amri. Hii inahusisha kutumia `curl` kupata faili ya ZIP kutoka URL maalum na kisha kutoa yaliyomo ya faili ya ZIP kwenye directory. Hapa kuna hatua:

1. Badilisha `"extension_id"` na ID halisi ya kiongezeo.
2. Tekeleza amri zifuatazo:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Tumia tovuti ya CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Tumia nyongeza ya CRX Viewer

Njia nyingine rahisi ni kutumia Chrome Extension Source Viewer, ambayo ni mradi wa chanzo wazi. Inaweza kupakuliwa kutoka [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Msimbo wa chanzo wa viewer upatikana katika [GitHub repository](https://github.com/Rob--W/crxviewer).

### Angalia chanzo cha nyongeza iliyosakinishwa kwa ndani

Nyongeza za Chrome zilizowekwa ndani pia zinaweza kukaguliwa. Hapa kuna jinsi:

1. Fikia saraka yako ya ndani ya profaili ya Chrome kwa kutembelea `chrome://version/` na kutafuta uwanja wa "Profile Path".
2. Tembea hadi kwenye folda ndogo ya `Extensions/` ndani ya saraka ya profaili.
3. Folda hii ina nyongeza zote zilizowekwa, kawaida zikiwa na msimbo wao wa chanzo katika muundo unaoweza kusomeka.

Ili kubaini nyongeza, unaweza kuoanisha vitambulisho vyao na majina:

* Washa Mode ya Developer kwenye ukurasa wa `about:extensions` ili kuona vitambulisho vya kila nyongeza.
* Ndani ya folda ya kila nyongeza, faili ya `manifest.json` ina uwanja wa `name` unaoweza kusomeka, ikikusaidia kubaini nyongeza hiyo.

### Tumia Mpakaji wa Faili au Unpacker

Nenda kwenye Chrome Web Store na upakue nyongeza. Faili itakuwa na kiambishi cha `.crx`. Badilisha kiambishi cha faili kutoka `.crx` hadi `.zip`. Tumia mpakaji wa faili yeyote (kama WinRAR, 7-Zip, nk.) kutoa yaliyomo ya faili ya ZIP.

### Tumia Mode ya Developer katika Chrome

Fungua Chrome na nenda kwenye `chrome://extensions/`. Washa "Developer mode" katika kona ya juu kulia. Bonyeza "Load unpacked extension...". Tembea hadi saraka ya nyongeza yako. Hii haisaidii kupakua msimbo wa chanzo, lakini ni muhimu kwa kuangalia na kubadilisha msimbo wa nyongeza ambayo tayari imeshapakwa au kuandaliwa.

## Seti ya data ya manifest ya nyongeza ya Chrome

Ili kujaribu kubaini nyongeza za kivinjari zenye udhaifu unaweza kutumia [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) na kuangalia faili zao za manifest kwa ishara zinazoweza kuwa na udhaifu. Kwa mfano kuangalia nyongeza zenye watumiaji zaidi ya 25000, `content_scripts` na ruhusa `nativeMessaing`:

{% code overflow="wrap" %}
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
{% endcode %}

## Orodha ya Ukaguzi wa Usalama

Ingawa Nyongeza za Kivinjari zina **uso wa shambulio ulio na mipaka**, baadhi yao wanaweza kuwa na **vulnerabilities** au **mabadiliko yanayoweza kuimarishwa**. Hizi hapa ni za kawaida zaidi:

* [ ] **Punguza** kadri iwezekanavyo **`permissions`** zinazohitajika
* [ ] **Punguza** kadri iwezekanavyo **`host_permissions`**
* [ ] Tumia **sera thabiti ya usalama wa maudhui** **`content_security_policy`**
* [ ] **Punguza** kadri iwezekanavyo **`externally_connectable`**, ikiwa hakuna inahitajika na inawezekana, usiache kwa chaguo-msingi, eleza **`{}`**
* [ ] Ikiwa **URL inayoweza kuathiriwa na XSS au kuchukuliwa** imetajwa hapa, mshambuliaji ataweza **kutuma ujumbe kwa scripts za nyuma moja kwa moja**. Njia yenye nguvu ya kupita.
* [ ] **Punguza** kadri iwezekanavyo **`web_accessible_resources`**, hata ikiwa ni tupu ikiwa inawezekana.
* [ ] Ikiwa **`web_accessible_resources`** si hakuna, angalia [**ClickJacking**](browext-clickjacking.md)
* [ ] Ikiwa mawasiliano yoyote yanatokea kutoka kwa **nyongeza** hadi **ukurasa wa wavuti**, [**angalia XSS**](browext-xss-example.md) **vulnerabilities** zilizotokana na mawasiliano.
* [ ] Ikiwa Ujumbe wa Post unatumiwa, angalia [**vulnerabilities za Ujumbe wa Post**](../postmessage-vulnerabilities/)**.**
* [ ] Ikiwa **Content Script inapata maelezo ya DOM**, angalia kwamba hazijaanzisha XSS ikiwa zitabadilishwa na wavuti
* [ ] Fanya mkazo maalum ikiwa mawasiliano haya yanahusishwa pia katika **mawasiliano ya Content Script -> Background script**
* [ ] Ikiwa script ya nyuma inawasiliana kupitia **ujumbe wa asili** angalia mawasiliano ni salama na yameondolewa
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **kod** ya Nyongeza ya Kivinjari
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **kumbukumbu** ya Nyongeza ya Kivinjari
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **mfumo wa faili usiolindwa**

## Hatari za Nyongeza za Kivinjari

* Programu [https://crxaminer.tech/](https://crxaminer.tech/) inachambua data kama ruhusa ambazo nyongeza ya kivinjari inahitaji ili kutoa kiwango cha hatari cha kutumia nyongeza ya kivinjari.

## Zana

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Inachukua nyongeza yoyote ya Chrome kutoka kiungo kilichotolewa cha duka la wavuti la Chrome.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **mtazamaji**: inaonyesha tu toleo la JSON lililopambwa la manifest ya nyongeza.
* **Uchambuzi wa Alama**: Ugunduzi wa [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) na uzalishaji wa moja kwa moja wa JavaScript ya alama ya nyongeza ya Chrome.
* **Uchambuzi wa Hatari ya Clickjacking**: Ugunduzi wa kurasa za HTML za nyongeza zenye mwelekeo wa [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) zilizowekwa. Hizi zinaweza kuwa na hatari ya clickjacking kulingana na kusudi la kurasa hizo.
* **Mtazamaji wa Onyo la Ruhusa**: unaonyesha orodha ya onyo zote za ruhusa za Chrome ambazo zitaonyeshwa wakati mtumiaji anajaribu kufunga nyongeza.
* **Kazi Hatari**: inaonyesha eneo la kazi hatari ambazo zinaweza kutumiwa na mshambuliaji (mfano, kazi kama innerHTML, chrome.tabs.executeScript).
* **Mahali pa Kuingia**: inaonyesha ambapo nyongeza inachukua pembejeo za mtumiaji/za nje. Hii ni muhimu kwa kuelewa eneo la uso la nyongeza na kutafuta maeneo yanayoweza kutumiwa kutuma data iliyoundwa kwa uovu kwa nyongeza.
* Wote skana za Kazi Hatari na Mahali pa Kuingia zina yafuatayo kwa arifa zao zilizozalishwa:
* Kipande cha msimbo kinachohusiana na mstari ulioleta arifa.
* Maelezo ya tatizo.
* Kitufe cha "Tazama Faili" ili kuona faili kamili ya chanzo inayohusisha msimbo.
* Njia ya faili iliyoonyeshwa.
* URI kamili ya nyongeza ya Chrome ya faili iliyoonyeshwa.
* Aina ya faili ni, kama vile script ya Ukurasa wa Nyuma, Script ya Maudhui, Kitendo cha Kivinjari, nk.
* Ikiwa mstari unaoweza kuathiriwa uko katika faili ya JavaScript, njia za kurasa zote ambapo imejumuishwa pamoja na aina za kurasa hizi, na hali ya [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
* **Mchambuzi wa Sera ya Usalama wa Maudhui (CSP) na mchakato wa kupita**: Hii itabainisha udhaifu katika CSP ya nyongeza yako na pia itaonyesha njia zozote zinazoweza kupita CSP yako kutokana na CDNs zilizoorodheshwa, nk.
* **Maktaba Zinazojulikana Kuwa na Vulnerabilities**: Hii inatumia [Retire.js](https://retirejs.github.io/retire.js/) kuangalia matumizi ya maktaba za JavaScript zinazojulikana kuwa na vulnerabilities.
* Pakua nyongeza na toleo lililopangwa.
* Pakua nyongeza asilia.
* Pakua toleo lililopambwa la nyongeza (HTML na JavaScript iliyopambwa kiotomatiki).
* Hifadhi kiotomatiki ya matokeo ya uchunguzi, kuendesha uchunguzi wa nyongeza kutachukua muda mzuri mara ya kwanza unapoendesha. Hata hivyo mara ya pili, ikiwa nyongeza haijasasishwa, itakuwa karibu mara moja kutokana na matokeo kuhifadhiwa.
* URL za Ripoti zinazoweza kuunganishwa, rahisi kuunganisha mtu mwingine kwenye ripoti ya nyongeza iliyozalishwa na tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Mradi wa Neto ni kifurushi cha Python 3 kilichoundwa kuchambua na kufichua vipengele vilivyofichwa vya nyongeza za kivinjari na nyongeza kwa vivinjari maarufu kama Firefox na Chrome. Inafanya mchakato wa kufungua faili zilizofungashwa ili kutoa vipengele hivi kutoka kwa rasilimali zinazohusiana katika nyongeza kama `manifest.json`, folda za lugha au faili za chanzo za Javascript na HTML.

## Marejeleo

* **Shukrani kwa** [**@naivenom**](https://twitter.com/naivenom) **kwa msaada na mbinu hii**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
