# LFI2RCE via Eternal waiting

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## Temel Bilgiler

Varsayılan olarak, bir dosya PHP'ye yüklendiğinde (beklemese bile), **`php[a-zA-Z0-9]{6}`** gibi bir isimle `/tmp` dizininde geçici bir dosya oluşturur, ancak bazı docker imajlarında oluşturulan dosyaların rakam içermediğini gördüm.

Yerel dosya dahil etmede, **o yüklenen dosyayı dahil etmeyi başarırsanız, RCE elde edersiniz**.

Varsayılan olarak, **PHP yalnızca tek bir istekte 20 dosya yüklemeye izin verir** (bu, `/etc/php/<version>/apache2/php.ini` dosyasında ayarlanmıştır):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Ayrıca, **potansiyel dosya adlarının sayısı 62\*62\*62\*62\*62\*62 = 56800235584**

### Diğer teknikler

Diğer teknikler, PHP protokollerine saldırmayı (yolun son kısmını kontrol ediyorsanız bunu başaramazsınız), dosyanın yolunu ifşa etmeyi, beklenen dosyaları kötüye kullanmayı veya **yüklenen geçici dosyaların silinmemesi için PHP'nin bir segmentasyon hatası yaşamasını sağlamayı** içerir.\
Bu teknik, **sıfır gün bulmaya gerek kalmadan** sonuncusuna **çok benzer**.

### Sonsuz bekleme tekniği

Bu teknikte **sadece bir göreli yolu kontrol etmemiz gerekiyor**. Dosyaları yüklemeyi ve **LFI'nin asla bitmemesini** sağlamayı başarabilirsek, **yüklenen dosyaları brute-force** yapacak ve **yüklenenlerden herhangi birini bulmak için "yeterince zaman"** elde edeceğiz.

**Bu tekniğin avantajları**:

* Sadece bir include içinde bir göreli yolu kontrol etmeniz gerekiyor
* Nginx veya log dosyalarına erişim için beklenmedik bir seviyeye ihtiyaç duymaz
* Segmentasyon hatası oluşturmak için bir 0 güne ihtiyaç duymaz
* Yol ifşasına ihtiyaç duymaz

Bu tekniğin **ana sorunları** şunlardır:

* Belirli bir dosya(lar)ın mevcut olmasına ihtiyaç var (daha fazlası olabilir)
* **Çılgın** miktarda potansiyel dosya adı: **56800235584**
* Sunucu **rakam kullanmıyorsa** toplam potansiyel miktar: **19770609664**
* Varsayılan olarak **tek bir istekte yalnızca 20 dosya** yüklenebilir.
* Kullanılan sunucunun **maksimum paralel işçi sayısı**.
* Bu limit, önceki limitlerle birlikte bu saldırının çok uzun sürmesine neden olabilir
* **PHP isteği için zaman aşımı**. İdeal olarak bu sonsuz olmalı veya geçici yüklenen dosyaları silmeden PHP sürecini öldürmelidir, aksi takdirde bu da bir sorun olacaktır

Peki, **PHP include'ını asla nasıl bitirebilirsiniz**? Sadece dosyayı **`/sys/kernel/security/apparmor/revision`** dahil ederek (**maalesef Docker konteynerlerinde mevcut değil...**).

Bunu sadece arayarak deneyin:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Varsayılan olarak, Apache **150 eşzamanlı bağlantıyı** destekler, [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) adresine göre bu sayı **8000'e** kadar artırılabilir. Bu modülle PHP kullanmak için şunu takip edin: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Varsayılan olarak, (testlerimde gördüğüm kadarıyla), bir **PHP süreci sonsuza kadar sürebilir**.

Hesap yapalım:

* **149 bağlantıyı** kullanarak **149 \* 20 = 2980 geçici dosya** oluşturabiliriz.
* Sonra, **son bağlantıyı** potansiyel dosyaları **brute-force** yapmak için kullanın.
* **10 istek/s** hızında süreler:
* 56800235584 / 2980 / 10 / 3600 \~= **530 saat** (265 saatte %50 şans)
* (rakam olmadan) 19770609664 / 2980 / 10 / 3600 \~= 185 saat (93 saatte %50 şans)

{% hint style="warning" %}
Önceki örnekte **diğer istemcileri tamamen DoS'liyoruz**!
{% endhint %}

Eğer Apache sunucusu geliştirilirse ve **4000 bağlantıyı** kötüye kullanabilirsek (maksimum sayıya yarı yol). `3999*20 = 79980` **dosya** oluşturabiliriz ve **sayı** yaklaşık **19.7 saate** veya **6.9 saate** (10 saat, 3.5 saat %50 şans) **düşecektir**.

## PHP-FMP

Eğer Apache için PHP betiklerini çalıştırmak için normal php modunu kullanmak yerine **web sayfası** **PHP-FMP** kullanıyorsa (bu, web sayfasının verimliliğini artırır, bu yüzden sıkça bulunur), tekniği geliştirmek için başka bir şey yapılabilir.

PHP-FMP, **`/etc/php/<php-version>/fpm/pool.d/www.conf`** dosyasında **`request_terminate_timeout`** **parametresini** **ayarlar**.\
Bu parametre, **PHP'ye yapılan isteğin ne zaman sona ereceğini** belirten maksimum saniye sayısını gösterir (varsayılan olarak sonsuzdur, ancak **parametre yorumdan çıkarıldığında 30s** olur). PHP tarafından işlenen bir isteğin belirtilen saniye sayısı dolduğunda, **öldürülür**. Bu, eğer istek geçici dosyalar yüklüyorsa, çünkü **php işlemesi durdurulmuşsa**, o **dosyaların silinmeyeceği** anlamına gelir. Bu nedenle, eğer bir isteğin o süre boyunca sürmesini sağlayabilirseniz, **silinmeyecek binlerce geçici dosya** oluşturabilirsiniz, bu da **onları bulma sürecini hızlandırır** ve platforma tüm bağlantıları tüketerek DoS olasılığını azaltır.

Bu nedenle, **DoS'tan kaçınmak için** bir **saldırganın aynı anda yalnızca 100 bağlantı kullanacağını** varsayalım ve php max işleme süresi **php-fmp** (`request_terminate_timeout`**)** **30s**. Bu nedenle, **saniyede** oluşturulabilecek **geçici dosya** sayısı `100*20/30 = 66.67`'dir.

Sonra, **10000 dosya** oluşturmak için bir saldırganın ihtiyacı olacak: **`10000/66.67 = 150s`** ( **100000 dosya** oluşturmak için süre **25dk** olacaktır).

Sonra, saldırgan bu **100 bağlantıyı** bir **arama brute-force** gerçekleştirmek için kullanabilir. \*\*\*\* 300 req/s hızında bu istismarı gerçekleştirmek için gereken süre şudur:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 saat** (2.63 saatte %50 şans)
* (100000 dosya ile) 56800235584 / 100000 / 300 / 3600 \~= **0.525 saat** (0.263 saatte %50 şans)

Evet, bir EC2 orta boyutlu örnekte 100000 geçici dosya oluşturmak mümkündür:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Zaman aşımını tetiklemek için **açıkça savunmasız LFI sayfasını dahil etmek yeterli olacaktır**, böylece sonsuz bir dahil etme döngüsüne girer.
{% endhint %}

## Nginx

Görünüşe göre varsayılan olarak Nginx aynı anda **512 paralel bağlantıyı** desteklemektedir (ve bu sayı artırılabilir).

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
