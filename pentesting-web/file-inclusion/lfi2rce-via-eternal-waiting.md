# LFI2RCE via Eternal waiting

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Grundinformationen

Standardm√§√üig, wenn eine Datei in PHP hochgeladen wird (auch wenn sie nicht damit rechnet), wird eine tempor√§re Datei in `/tmp` mit einem Namen wie **`php[a-zA-Z0-9]{6}`** erstellt, obwohl ich einige Docker-Images gesehen habe, bei denen die generierten Dateien keine Ziffern enthalten.

Bei einer lokalen Dateieinbindung, **wenn du es schaffst, diese hochgeladene Datei einzubinden, erh√§ltst du RCE**.

Beachte, dass PHP standardm√§√üig **nur 20 Dateien in einer einzigen Anfrage hochzuladen erlaubt** (festgelegt in `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Auch die **Anzahl der potenziellen Dateinamen betr√§gt 62\*62\*62\*62\*62\*62 = 56800235584**

### Andere Techniken

Andere Techniken basieren auf dem Angreifen von PHP-Protokollen (du wirst nicht in der Lage sein, wenn du nur den letzten Teil des Pfades kontrollierst), dem Offenlegen des Pfades der Datei, dem Missbrauch erwarteter Dateien oder **dem Verursachen eines Segmentierungsfehlers in PHP, sodass hochgeladene tempor√§re Dateien nicht gel√∂scht werden**.\
Diese Technik ist **sehr √§hnlich der letzten, erfordert jedoch kein Finden eines Zero-Day**.

### Ewige Warte-Technik

In dieser Technik **m√ºssen wir nur einen relativen Pfad kontrollieren**. Wenn es uns gelingt, Dateien hochzuladen und das **LFI niemals enden zu lassen**, haben wir "genug Zeit", um **hochgeladene Dateien zu brute-forcen** und **eine der hochgeladenen zu finden**.

**Vorteile dieser Technik**:

* Du musst nur einen relativen Pfad innerhalb eines Includes kontrollieren
* Erfordert kein nginx oder unerwarteten Zugriff auf Protokolldateien
* Erfordert keinen 0-Day, um einen Segmentierungsfehler zu verursachen
* Erfordert keine Pfadoffenlegung

Die **Hauptprobleme** dieser Technik sind:

* Es m√ºssen spezifische Datei(en) vorhanden sein (es k√∂nnten mehr sein)
* Die **wahnsinnige** Anzahl potenzieller Dateinamen: **56800235584**
* Wenn der Server **keine Ziffern verwendet**, betr√§gt die gesamte potenzielle Anzahl: **19770609664**
* Standardm√§√üig k√∂nnen **nur 20 Dateien** in einer **einzelnen Anfrage** hochgeladen werden.
* Die **maximale Anzahl paralleler Worker** des verwendeten Servers.
* Diese Grenze zusammen mit den vorherigen kann diesen Angriff zu lange dauern lassen
* **Timeout f√ºr eine PHP-Anfrage**. Idealerweise sollte dies ewig dauern oder den PHP-Prozess beenden, ohne die tempor√§r hochgeladenen Dateien zu l√∂schen, andernfalls wird dies auch ein Problem sein

Wie kannst du also **eine PHP-Include-Anweisung niemals enden lassen**? Indem du einfach die Datei **`/sys/kernel/security/apparmor/revision`** einf√ºgst (**leider nicht in Docker-Containern verf√ºgbar...**).

Versuche es einfach, indem du aufrufst:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Standardm√§√üig unterst√ºtzt Apache **150 gleichzeitige Verbindungen**. Laut [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) ist es m√∂glich, diese Zahl auf bis zu 8000 zu erh√∂hen. Folgen Sie diesem Link, um PHP mit diesem Modul zu verwenden: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Standardm√§√üig (wie ich in meinen Tests sehen kann) kann ein **PHP-Prozess ewig dauern**.

Lassen Sie uns einige Berechnungen anstellen:

* Wir k√∂nnen **149 Verbindungen** nutzen, um **149 \* 20 = 2980 tempor√§re Dateien** mit unserem Webshell zu generieren.
* Dann verwenden wir die **letzte Verbindung**, um **Brute-Force** potenzielle Dateien.
* Bei einer Geschwindigkeit von **10 Anfragen/s** sind die Zeiten:
* 56800235584 / 2980 / 10 / 3600 \~= **530 Stunden** (50% Chance in 265h)
* (ohne Ziffern) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% Chance in 93h)

{% hint style="warning" %}
Beachten Sie, dass wir im vorherigen Beispiel **andere Clients vollst√§ndig DoSen**!
{% endhint %}

Wenn der Apache-Server verbessert wird und wir **4000 Verbindungen** missbrauchen k√∂nnten (auf halbem Weg zur maximalen Anzahl). Wir k√∂nnten `3999*20 = 79980` **Dateien** erstellen und die **Zahl** w√ºrde auf etwa **19,7h** oder **6,9h** (10h, 3,5h 50% Chance) **reduziert**.

## PHP-FMP

Wenn anstelle des regul√§ren PHP-Moduls f√ºr Apache, um PHP-Skripte auszuf√ºhren, die **Webseite** **PHP-FMP** verwendet (dies verbessert die Effizienz der Webseite, daher ist es √ºblich, es zu finden), gibt es noch etwas, das getan werden kann, um die Technik zu verbessern.

PHP-FMP erm√∂glicht es, den **Parameter** **`request_terminate_timeout`** in **`/etc/php/<php-version>/fpm/pool.d/www.conf`** zu **konfigurieren**.\
Dieser Parameter gibt die maximale Anzahl von Sekunden an, **wann** die **Anfrage an PHP beendet werden muss** (standardm√§√üig unendlich, aber **30s, wenn der Parameter nicht auskommentiert ist**). Wenn eine Anfrage von PHP verarbeitet wird, wird die angegebene Anzahl von Sekunden **abgebrochen**. Das bedeutet, dass, wenn die Anfrage tempor√§re Dateien hochl√§dt, weil die **PHP-Verarbeitung gestoppt wurde**, diese **Dateien nicht gel√∂scht werden**. Daher, wenn Sie eine Anfrage so lange aufrechterhalten k√∂nnen, k√∂nnen Sie **tausende von tempor√§ren Dateien generieren**, die nicht gel√∂scht werden, was den Prozess der Auffindung beschleunigt und die Wahrscheinlichkeit eines DoS f√ºr die Plattform verringert, indem alle Verbindungen verbraucht werden.

Um also **DoS zu vermeiden**, nehmen wir an, dass ein **Angreifer nur 100 Verbindungen** gleichzeitig verwenden wird und die maximale Verarbeitungszeit von PHP durch **php-fmp** (`request_terminate_timeout`**)** **30s** betr√§gt. Daher betr√§gt die Anzahl der **tempor√§ren Dateien**, die **pro Sekunde** generiert werden k√∂nnen, `100*20/30 = 66.67`.

Um **10000 Dateien** zu generieren, w√ºrde ein Angreifer ben√∂tigen: **`10000/66.67 = 150s`** (um **100000 Dateien** zu generieren, w√ºrde die Zeit **25min** betragen).

Dann k√∂nnte der Angreifer diese **100 Verbindungen** nutzen, um eine **Brute-Force-Suche** durchzuf√ºhren. \*\*\*\* Bei einer Geschwindigkeit von 300 req/s betr√§gt die ben√∂tigte Zeit f√ºr die Ausnutzung Folgendes:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 Stunden** (50% Chance in 2.63h)
* (mit 100000 Dateien) 56800235584 / 100000 / 300 / 3600 \~= **0.525 Stunden** (50% Chance in 0.263h)

Ja, es ist m√∂glich, 100000 tempor√§re Dateien in einer EC2-Medium-Instanz zu generieren:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Beachten Sie, dass es ausreicht, die verwundbare LFI-Seite einzuschlie√üen, um den Timeout auszul√∂sen, sodass sie in eine ewige Einschluss-Schleife eintritt.
{% endhint %}

## Nginx

Es scheint, dass Nginx standardm√§√üig **512 parallele Verbindungen** gleichzeitig unterst√ºtzt (und diese Zahl kann verbessert werden).

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichen.

</details>
{% endhint %}
