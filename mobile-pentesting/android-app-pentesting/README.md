# Android Applications Pentesting

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się trikami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Dołącz do [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serwera, aby komunikować się z doświadczonymi hackerami i łowcami bugów!

**Hacking Insights**\
Zaangażuj się w treści, które zagłębiają się w emocje i wyzwania związane z hackingiem

**Real-Time Hack News**\
Bądź na bieżąco z dynamicznym światem hackingu dzięki wiadomościom i spostrzeżeniom w czasie rzeczywistym

**Latest Announcements**\
Bądź informowany o najnowszych programach bug bounty oraz istotnych aktualizacjach platform

**Dołącz do nas na** [**Discord**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hackerami już dziś!

## Android Applications Basics

Zaleca się rozpoczęcie od przeczytania tej strony, aby poznać **najważniejsze części związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem android (emulowanym lub fizycznym).\
**ADB** pozwala na kontrolowanie urządzeń zarówno przez **USB**, jak i **sieć** z komputera. To narzędzie umożliwia **kopiowanie** plików w obie strony, **instalację** i **odinstalację** aplikacji, **wykonywanie** poleceń powłoki, **tworzenie kopii zapasowych** danych, **odczytywanie** logów, wśród innych funkcji.

Zobacz poniższą listę [**Poleceń ADB**](adb-commands.md), aby dowiedzieć się, jak używać adb.

## Smali

Czasami interesujące jest **modyfikowanie kodu aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (może dobrze obfuskowanych haseł lub flag). Wtedy może być interesujące dekompilowanie apk, modyfikowanie kodu i ponowne kompilowanie go.\
[**W tym samouczku** możesz **dowiedzieć się, jak dekompilować APK, modyfikować kod Smali i ponownie kompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które będą przedstawione. Dlatego **zawsze miej na uwadze tę możliwość**.

## Inne interesujące triki

* [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
* **Pobierz APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
* Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
* Połącz wszystkie podziały i podstawowe pliki APK za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Analiza statyczna

Przede wszystkim, aby przeanalizować APK, powinieneś **rzucić okiem na kod Java** za pomocą dekompilatora.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Samo rzucenie okiem na **ciągi** APK pozwala na wyszukiwanie **haseł**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **kluczy** **api**, **szyfrowania**, **uuid bluetooth**, **tokenów** i wszystkiego, co może być interesujące... szukaj nawet **tylnych drzwi** do wykonania kodu lub tylnych drzwi autoryzacyjnych (twardo zakodowane dane administratora w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **adresy URL Firebase** i sprawdź, czy są źle skonfigurowane. [Więcej informacji na temat tego, czym jest Firebase i jak go wykorzystać, znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

**Badanie plików \_Manifest.xml**_\*\* i \*\*_**strings.xml**\_\*\* aplikacji może ujawnić potencjalne luki w zabezpieczeniach\*\*. Pliki te można uzyskać za pomocą dekompilatorów lub przez zmianę rozszerzenia pliku APK na .zip, a następnie rozpakowanie go.

**Luki** zidentyfikowane w **Manifest.xml** obejmują:

* **Aplikacje debugowalne**: Aplikacje ustawione jako debugowalne (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do wykorzystania. Aby uzyskać dalsze zrozumienie, jak wykorzystać aplikacje debugowalne, zapoznaj się z samouczkiem na temat znajdowania i wykorzystywania aplikacji debugowalnych na urządzeniu.
* **Ustawienia kopii zapasowej**: Atrybut `android:allowBackup="false"` powinien być wyraźnie ustawiony dla aplikacji zajmujących się wrażliwymi informacjami, aby zapobiec nieautoryzowanym kopiom zapasowym danych za pomocą adb, szczególnie gdy debugowanie USB jest włączone.
* **Bezpieczeństwo sieci**: Niestandardowe konfiguracje bezpieczeństwa sieci (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak przypinanie certyfikatów i ustawienia ruchu HTTP. Przykładem jest zezwolenie na ruch HTTP dla określonych domen.
* **Eksportowane aktywności i usługi**: Identyfikacja eksportowanych aktywności i usług w manifeście może uwydatnić komponenty, które mogą być nadużywane. Dalsza analiza podczas testów dynamicznych może ujawnić, jak wykorzystać te komponenty.
* **Dostawcy treści i FileProviders**: Ujawnione dostawcy treści mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być również dokładnie sprawdzona.
* **Odbiorniki rozgłoszeniowe i schematy URL**: Te komponenty mogą być wykorzystywane do eksploatacji, z szczególną uwagą na to, jak zarządzane są schematy URL w kontekście luk wejściowych.
* **Wersje SDK**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając znaczenie nieobsługiwania przestarzałych, podatnych wersji Androida z powodów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak klucze API, niestandardowe schematy i inne notatki dewelopera, co podkreśla potrzebę starannego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **złośliwa** **aplikacja** jest uruchamiana i **pozycjonuje się na wierzchu aplikacji ofiary**. Gdy widocznie zasłania aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, aby oszukać użytkownika, aby z nią interagował, podczas gdy przekazuje interakcję do aplikacji ofiary.\
W efekcie, **oślepia użytkownika, aby nie wiedział, że faktycznie wykonuje akcje w aplikacji ofiary**.

Więcej informacji znajdziesz w:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### Przechwytywanie zadań

**Aktywność** z ustawionym **`launchMode`** na **`singleTask`** bez zdefiniowanego `taskAffinity` jest podatna na przechwytywanie zadań. Oznacza to, że **aplikacja** może być zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przechwycić zadanie prawdziwej aplikacji** (więc użytkownik będzie interagował z **złośliwą aplikacją, myśląc, że używa prawdziwej**).

Więcej informacji w:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Niebezpieczne przechowywanie danych

**Przechowywanie wewnętrzne**

W Androidzie pliki **przechowywane** w **przechowywaniu wewnętrznym** są **zaplanowane** do bycia **dostępnymi** wyłącznie przez **aplikację**, która je **utworzyła**. Ten środek bezpieczeństwa jest **egzekwowany** przez system operacyjny Android i jest zazwyczaj wystarczający dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami wykorzystują tryby takie jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **zezwolić** na **dzielenie się** plikami między różnymi aplikacjami. Niemniej jednak, te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Analiza statyczna:**
* **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzane**. Te tryby **mogą potencjalnie ujawniać** pliki dla **niezamierzonego lub nieautoryzowanego dostępu**.
2. **Analiza dynamiczna:**
* **Zweryfikuj** **uprawnienia** ustawione na plikach utworzonych przez aplikację. Szczególnie **sprawdź**, czy jakiekolwiek pliki są **ustawione na bycie czytelnymi lub zapisywalnymi na całym świecie**. Może to stanowić istotne ryzyko bezpieczeństwa, ponieważ pozwoli **jakiejkolwiek aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia lub zamiaru, na **odczyt lub modyfikację** tych plików.

**Przechowywanie zewnętrzne**

Podczas pracy z plikami na **przechowywaniu zewnętrznym**, takim jak karty SD, należy podjąć pewne środki ostrożności:

1. **Dostępność**:
* Pliki na zewnętrznym przechowywaniu są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może uzyskać dostęp do tych plików.
2. **Problemy z bezpieczeństwem**:
* Biorąc pod uwagę łatwość dostępu, zaleca się **nieprzechowywanie wrażliwych informacji** na zewnętrznym przechowywaniu.
* Zewnętrzne przechowywanie może być usunięte lub dostępne przez każdą aplikację, co czyni je mniej bezpiecznym.
3. **Obsługa danych z zewnętrznego przechowywania**:
* Zawsze **przeprowadzaj walidację wejścia** na danych pobranych z zewnętrznego przechowywania. Jest to kluczowe, ponieważ dane pochodzą z nieznanego źródła.
* Przechowywanie plików wykonywalnych lub plików klas na zewnętrznym przechowywaniu do dynamicznego ładowania jest zdecydowanie odradzane.
* Jeśli Twoja aplikacja musi pobrać pliki wykonywalne z zewnętrznego przechowywania, upewnij się, że te pliki są **podpisane i kryptograficznie weryfikowane** przed ich dynamicznym załadowaniem. Ten krok jest kluczowy dla utrzymania integralności bezpieczeństwa Twojej aplikacji.

Zewnętrzne przechowywanie można **uzyskać** w `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

{% hint style="info" %}
Począwszy od Androida 4.4 (**API 17**), karta SD ma strukturę katalogów, która **ogranicza dostęp aplikacji do katalogu, który jest specjalnie przeznaczony dla tej aplikacji**. To zapobiega złośliwej aplikacji uzyskiwaniu dostępu do plików innej aplikacji w trybie odczytu lub zapisu.
{% endhint %}

**Wrażliwe dane przechowywane w postaci niezaszyfrowanej**

* **Preferencje współdzielone**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasami możliwe jest znalezienie wrażliwych informacji w postaci niezaszyfrowanej w tym folderze.
* **Bazy danych**: Android pozwala każdej aplikacji na łatwe zapisywanie baz danych sqlite w ścieżce `/data/data/<packagename>/databases/` i czasami możliwe jest znalezienie wrażliwych informacji w postaci niezaszyfrowanej w tym folderze.

### Uszkodzone TLS

**Akceptuj wszystkie certyfikaty**

Z jakiegoś powodu czasami deweloperzy akceptują wszystkie certyfikaty, nawet jeśli na przykład nazwa hosta nie pasuje do linii kodu, jak w poniższym przykładzie:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Niektórzy deweloperzy zapisują wrażliwe dane w lokalnej pamięci i szyfrują je kluczem zakodowanym/łatwym do przewidzenia w kodzie. Nie powinno się tego robić, ponieważ pewne odwracanie inżynieryjne może pozwolić atakującym na wydobycie poufnych informacji.

**Use of Insecure and/or Deprecated Algorithms**

Deweloperzy nie powinni używać **przestarzałych algorytmów** do przeprowadzania **sprawdzania** **autoryzacji**, **przechowywania** lub **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashe** są używane do przechowywania haseł, powinny być używane hashe odporne na brute-force z solą.

### Other checks

* Zaleca się **obfuskację APK**, aby utrudnić atakującym pracę inżynieryjną.
* Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna przeprowadzać **własne kontrole, aby sprawdzić, czy urządzenie jest zrootowane** i działać w konsekwencji.
* Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna sprawdzić, czy używany jest **emulator**.
* Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna **sprawdzić swoją integralność przed wykonaniem**, aby sprawdzić, czy została zmodyfikowana.
* Użyj [**APKiD**](https://github.com/rednaga/APKiD), aby sprawdzić, który kompilator/pakiet/obfuskator został użyty do zbudowania APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Other interesting functions

* **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
* **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
* [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Join [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server to communicate with experienced hackers and bug bounty hunters!

**Hacking Insights**\
Engage with content that delves into the thrill and challenges of hacking

**Real-Time Hack News**\
Keep up-to-date with fast-paced hacking world through real-time news and insights

**Latest Announcements**\
Stay informed with the newest bug bounties launching and crucial platform updates

**Join us on** [**Discord**](https://discord.com/invite/N3FrSbmwdy) and start collaborating with top hackers today!

***

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../.gitbook/assets/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

* [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
* Learn to set it up in this page:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
* [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

{% hint style="info" %}
When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.
{% endhint %}

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../.gitbook/assets/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Ustawienia**.
2. (Od Androida 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdziesz **Opcje dewelopera**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Deweloperzy powinni być ostrożni, aby nie ujawniać **informacji debugowania** publicznie, ponieważ może to prowadzić do wycieków wrażliwych danych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony wrażliwych informacji. **Pidcat** jest preferowane ze względu na łatwość użycia i czytelność.

{% hint style="warning" %}
Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
Anyway, it's still recommended to **not log sensitive information**.
{% endhint %}

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą nieumyślnie **ujawniać wrażliwe dane** z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, zaleca się **przechwycenie ruchu aplikacji** i sprawdzenie, czy jakiekolwiek wrażliwe informacje są wysyłane do usług stron trzecich.

### SQLite DBs

Większość aplikacji będzie używać **wewnętrznych baz danych SQLite** do zapisywania informacji. Podczas pentestów zwróć uwagę na **bazy danych** utworzone, nazwy **tabel** i **kolumn** oraz wszystkie **dane** zapisane, ponieważ możesz znaleźć **wrażliwe informacje** (co byłoby luką).\
Bazy danych powinny znajdować się w `/data/data/the.package.name/databases` jak `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/#activities)

You can also start an exported activity from adb:

* PackageName is com.example.demo
* Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF wykryje jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w aktywności, ale z powodu [tego](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko w starych wersjach (wersje API < 21).

{% hint style="info" %}
Zauważ, że obejście autoryzacji nie zawsze jest luką, zależy to od tego, jak działa obejście i jakie informacje są ujawniane.
{% endhint %}

**Wycieki wrażliwych informacji**

**Aktywności mogą również zwracać wyniki**. Jeśli uda ci się znaleźć eksportowaną i niechronioną aktywność wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, dochodzi do wycieku wrażliwych informacji.

#### Tapjacking

Jeśli tapjacking nie jest zapobiegany, możesz nadużyć eksportowanej aktywności, aby **zmusić użytkownika do wykonania nieoczekiwanych działań**. Aby uzyskać więcej informacji o [**tym, czym jest Tapjacking, kliknij tutaj**](./#tapjacking).

### Wykorzystywanie dostawców treści - Uzyskiwanie dostępu i manipulowanie wrażliwymi informacjami

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest dostawca treści.**](android-applications-basics.md#content-provider)\
Dostawcy treści są zasadniczo używani do **dzielenia się danymi**. Jeśli aplikacja ma dostępne dostawców treści, możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Interesujące jest również testowanie możliwych **iniekcji SQL** i **przechodzenia po ścieżkach**, ponieważ mogą być podatne.

[**Dowiedz się, jak wykorzystywać dostawców treści za pomocą Drozer.**](drozer-tutorial/#content-providers)

### **Wykorzystywanie usług**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest usługa.**](android-applications-basics.md#services)\
Pamiętaj, że działania usługi zaczynają się w metodzie `onStartCommand`.

Usługa to zasadniczo coś, co **może odbierać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś usługi, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **testować** ją **dynamicznie** w celu wyodrębnienia poufnych informacji, obejścia środków autoryzacji...\
[**Dowiedz się, jak wykorzystywać usługi za pomocą Drozer.**](drozer-tutorial/#services)

### **Wykorzystywanie odbiorników rozgłoszeniowych**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest odbiornik rozgłoszeniowy.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania odbiornika rozgłoszeniowego zaczynają się w metodzie `onReceive`.

Odbiornik rozgłoszeniowy będzie czekał na rodzaj wiadomości. W zależności od tego, jak odbiornik obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak wykorzystywać odbiorniki rozgłoszeniowe za pomocą Drozer.**](./#exploiting-broadcast-receivers)

### **Wykorzystywanie schematów / głębokich linków**

Możesz ręcznie szukać głębokich linków, używając narzędzi takich jak MobSF lub skryptów jak [ten](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **schemat** używając **adb** lub **przeglądarki**:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_Uwaga, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie otworzy aplikację, która powinna otworzyć ten link._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**Kod wykonany**

Aby znaleźć **kod, który będzie wykonany w aplikacji**, przejdź do aktywności wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie odbiera wrażliwych danych (jak hasła) za pomocą parametrów URL**, ponieważ każda inna aplikacja może **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy jakikolwiek deep link używa parametru wewnątrz ścieżki URL, jak: `https://api.example.com/v1/users/{username}`, w takim przypadku możesz wymusić przejście przez ścieżkę, uzyskując dostęp do czegoś takiego jak: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Zauważ, że jeśli znajdziesz poprawne punkty końcowe w aplikacji, możesz być w stanie spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **przejęcie konta** (jeśli możesz zmodyfikować dane użytkowników bez tokena CSRF, a podatny punkt końcowy używał poprawnej metody) i inne podatności. Więcej [informacji na ten temat tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Ciekawy raport o bug bounty [tutaj](https://hackerone.com/reports/855618) dotyczący linków (_/.well-known/assetlinks.json_).

### Wykrywanie i weryfikacja warstwy transportowej

* **Certyfikaty nie zawsze są odpowiednio sprawdzane** przez aplikacje Android. Często te aplikacje ignorują ostrzeżenia i akceptują certyfikaty samopodpisane lub, w niektórych przypadkach, wracają do używania połączeń HTTP.
* **Negocjacje podczas handshake SSL/TLS są czasami słabe**, stosując niebezpieczne zestawy szyfrów. Ta podatność sprawia, że połączenie jest podatne na ataki typu man-in-the-middle (MITM), umożliwiając atakującym odszyfrowanie danych.
* **Wycieki prywatnych informacji** są ryzykiem, gdy aplikacje uwierzytelniają się za pomocą bezpiecznych kanałów, ale następnie komunikują się przez niebezpieczne kanały w innych transakcjach. Takie podejście nie chroni wrażliwych danych, takich jak ciasteczka sesyjne czy dane użytkowników, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały mogą stwarzać poważne ryzyko. Szczegółowe kroki dotyczące weryfikacji certyfikatów serwera i rozwiązywania podatności można znaleźć w [**tym zasobie**](https://manifestsecurity.com/android-application-security-part-10/).

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera w porównaniu do znanej kopii przechowywanej w samej aplikacji. Metoda ta jest niezbędna do zapobiegania atakom MITM. Wdrożenie SSL Pinning jest zdecydowanie zalecane dla aplikacji obsługujących wrażliwe informacje.

#### Inspekcja ruchu

Aby zainstalować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może być niewidoczny przez proxy. Aby uzyskać instrukcje dotyczące instalacji niestandardowego certyfikatu CA, [**kliknij tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje celujące w **API Level 24 i wyżej** wymagają modyfikacji konfiguracji bezpieczeństwa sieci, aby zaakceptować certyfikat CA proxy. Ten krok jest kluczowy do inspekcji zaszyfrowanego ruchu. Aby uzyskać instrukcje dotyczące modyfikacji konfiguracji bezpieczeństwa sieci, [**zobacz ten samouczek**](make-apk-accept-ca-certificate.md).

#### Obejście SSL Pinning

Gdy SSL Pinning jest wdrożone, konieczne staje się jego obejście, aby zainspirować ruch HTTPS. Istnieje kilka metod w tym celu:

* Automatycznie **zmodyfikuj** **apk**, aby **obejść** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować roota, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową, co nie zawsze działa.
* Możesz użyć **Frida** (omówione poniżej), aby obejść tę ochronę. Oto przewodnik, jak używać Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* Możesz również spróbować **automatycznie obejść SSL Pinning** za pomocą [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* Możesz również spróbować **automatycznie obejść SSL Pinning** za pomocą **analizy dynamicznej MobSF** (wyjaśnionej poniżej)
* Jeśli nadal uważasz, że istnieje jakiś ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do burp za pomocą iptables**. Przeczytaj ten blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Szukanie powszechnych podatności w sieci

Ważne jest również, aby szukać powszechnych podatności w sieci w aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych miejscach.

### Frida

[Frida](https://www.frida.re) to zestaw narzędzi do dynamicznej instrumentacji dla programistów, inżynierów odwrotnych i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i podłączyć metody w czasie rzeczywistym, aby zmienić zachowanie, zmienić wartości, wyodrębnić wartości, uruchomić inny kod...**\
Jeśli chcesz przeprowadzić pentesting aplikacji Android, musisz wiedzieć, jak używać Frida.

* Naucz się, jak używać Frida: [**Samouczek Frida**](frida-tutorial/)
* Nieco "GUI" do działań z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection jest świetny do automatyzacji użycia Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* Możesz znaleźć kilka niesamowitych skryptów Frida tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
* Spróbuj obejść mechanizmy anty-debugging / anty-frida, ładując Frida, jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja przechowuje wrażliwe informacje w pamięci, których nie powinna przechowywać, takie jak hasła lub mnemoniki.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3), możesz zrzucić pamięć aplikacji za pomocą:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To będzie zrzut pamięci w folderze ./dump, a tam możesz użyć grep z czymś takim jak: 

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Wrażliwe dane w Keystore**

W systemie Android Keystore to najlepsze miejsce do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach **możliwe jest ich uzyskanie**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci niezaszyfrowanej**, testy penetracyjne powinny to sprawdzić jako użytkownik root lub ktoś z fizycznym dostępem do urządzenia mógłby być w stanie ukraść te dane.

Nawet jeśli aplikacja przechowuje dane w keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Ominięcie odcisku palca/biometrii**

Używając poniższego skryptu Frida, możliwe jest **ominięcie uwierzytelniania odciskiem palca**, które aplikacje Android mogą stosować w celu **ochrony niektórych wrażliwych obszarów:**

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **Obrazy tła**

Kiedy umieszczasz aplikację w tle, Android przechowuje **zrzut ekranu aplikacji**, aby po przywróceniu do pierwszego planu zaczęła ładować obraz przed aplikacją, co sprawia, że wygląda na to, że aplikacja została załadowana szybciej.

Jednakże, jeśli ten zrzut ekranu zawiera **wrażliwe informacje**, ktoś z dostępem do zrzutu może **ukraść te informacje** (zauważ, że potrzebujesz roota, aby uzyskać do niego dostęp).

Zrzuty ekranu są zazwyczaj przechowywane w: **`/data/system_ce/0/snapshots`**

Android zapewnia sposób na **zapobieganie przechwytywaniu zrzutów ekranu, ustawiając parametr układu FLAG\_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się w zrzutach ekranu lub wyświetlaniu na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator Aplikacji Android**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Wstrzykiwanie Intencji

Programiści często tworzą komponenty proxy, takie jak aktywności, usługi i odbiorniki rozgłoszeniowe, które obsługują te Intencje i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywoływania nieeksportowanych komponentów aplikacji lub uzyskiwania dostępu do wrażliwych dostawców treści poprzez błędne kierowanie tych Intencji. Znaczącym przykładem jest komponent `WebView`, który konwertuje adresy URL na obiekty `Intent` za pomocą `Intent.parseUri(...)`, a następnie je wykonuje, co może prowadzić do złośliwych wstrzyknięć Intencji.

### Kluczowe Wnioski

* **Wstrzykiwanie Intencji** jest podobne do problemu Open Redirect w sieci.
* Eksploity polegają na przekazywaniu obiektów `Intent` jako dodatkowych, które mogą być przekierowywane do wykonywania niebezpiecznych operacji.
* Może to ujawniać nieeksportowane komponenty i dostawców treści atakującym.
* Konwersja URL na `Intent` w `WebView` może ułatwiać niezamierzone działania.

### Wstrzyknięcia po stronie klienta Androida i inne

Prawdopodobnie znasz ten rodzaj podatności z sieci. Musisz być szczególnie ostrożny z tymi podatnościami w aplikacji Android:

* **Wstrzykiwanie SQL:** Przy obsłudze dynamicznych zapytań lub dostawców treści upewnij się, że używasz zapytań parametryzowanych.
* **Wstrzykiwanie JavaScript (XSS):** Sprawdź, czy obsługa JavaScript i wtyczek jest wyłączona dla wszelkich WebView (domyślnie wyłączona). [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
* **Inkluzja lokalnych plików:** WebView powinny mieć wyłączony dostęp do systemu plików (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
* **Eternal cookies**: W kilku przypadkach, gdy aplikacja androidowa kończy sesję, ciasteczko nie jest unieważniane lub może być nawet zapisywane na dysku.
* [**Bezpieczna flaga** w ciasteczkach](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hackerami i łowcami błędów!

**Wgląd w Hacking**\
Zaangażuj się w treści, które zagłębiają się w emocje i wyzwania związane z hackingiem.

**Aktualności Hackingowe w Czasie Rzeczywistym**\
Bądź na bieżąco z dynamicznym światem hackingu dzięki aktualnym wiadomościom i wglądom.

**Najnowsze Ogłoszenia**\
Bądź informowany o najnowszych nagrodach za błędy oraz istotnych aktualizacjach platformy.

**Dołącz do nas na** [**Discord**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hackerami już dziś!

## Analiza Automatyczna

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../.gitbook/assets/image (866).png>)

**Ocena podatności aplikacji** przy użyciu ładnego interfejsu internetowego. Możesz również przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować **Android**(apk)**, IOS**(ipa) **i Windows**(apx) aplikacje (_Aplikacje Windows muszą być analizowane z MobSF zainstalowanym na hoście Windows_).\
Również, jeśli stworzysz plik **ZIP** z kodem źródłowym aplikacji **Android** lub **IOS** (przejdź do folderu głównego aplikacji, wybierz wszystko i stwórz plik ZIP), będzie mógł go również analizować.

MobSF pozwala również na **diff/Compare** analizy oraz na integrację z **VirusTotal** (będziesz musiał ustawić swój klucz API w _MobSF/settings.py_ i włączyć go: `VT_ENABLED = TRUE` `VT_API_KEY = <Twój klucz API>` `VT_UPLOAD = TRUE`). Możesz również ustawić `VT_UPLOAD` na `False`, wtedy **hash** zostanie **przesłany** zamiast pliku.

### Wspomagana analiza dynamiczna z MobSF

**MobSF** może być również bardzo pomocny w **analizie dynamicznej** w **Android**, ale w tym przypadku będziesz musiał zainstalować MobSF i **genymotion** na swoim hoście (VM lub Docker nie zadziała). _Uwaga: Musisz **najpierw uruchomić VM w genymotion** a **potem MobSF.**_\
**MobSF dynamic analyser** może:

* **Zrzucić dane aplikacji** (URL-e, logi, schowek, zrzuty ekranu wykonane przez Ciebie, zrzuty ekranu wykonane przez "**Exported Activity Tester**", e-maile, bazy danych SQLite, pliki XML i inne utworzone pliki). Wszystko to odbywa się automatycznie, z wyjątkiem zrzutów ekranu, musisz nacisnąć, gdy chcesz zrzut ekranu lub musisz nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty ekranu wszystkich eksportowanych aktywności.
* Przechwytywać **ruch HTTPS**
* Używać **Frida** do uzyskiwania **informacji w czasie rzeczywistym**

Od wersji Android **> 5**, automatycznie **uruchomi Frida** i ustawi globalne ustawienia **proxy** do **przechwytywania** ruchu. Będzie przechwytywać tylko ruch z testowanej aplikacji.

**Frida**

Domyślnie użyje również niektórych skryptów Frida do **obejścia SSL pinning**, **wykrywania root** i **wykrywania debuggera** oraz do **monitorowania interesujących API**.\
MobSF może również **wywoływać eksportowane aktywności**, robić **zrzuty ekranu** z nich i **zapisywać** je do raportu.

Aby **rozpocząć** testowanie dynamiczne, naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida i "**Live API Monitor**", aby zobaczyć wszystkie wywołania do podłączonych metod, przekazywane argumenty i zwracane wartości (to pojawi się po naciśnięciu "Start Instrumentation").\
MobSF pozwala również na załadowanie własnych **skryptów Frida** (aby wysłać wyniki swoich skryptów Frida do MobSF, użyj funkcji `send()`). Ma również **kilka wstępnie napisanych skryptów**, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), wystarczy **je wybrać**, nacisnąć "**Load**" i nacisnąć "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../.gitbook/assets/image (419).png>)

Ponadto masz kilka dodatkowych funkcji Frida:

* **Enumerate Loaded Classes**: Wydrukuje wszystkie załadowane klasy
* **Capture Strings**: Wydrukuje wszystkie przechwycone ciągi podczas korzystania z aplikacji (bardzo hałaśliwe)
* **Capture String Comparisons**: Może być bardzo przydatne. Pokaże **2 porównywane ciągi** i czy wynik był prawdziwy czy fałszywy.
* **Enumerate Class Methods**: Podaj nazwę klasy (np. "java.io.File") i wydrukuje wszystkie metody klasy.
* **Search Class Pattern**: Wyszukaj klasy według wzoru
* **Trace Class Methods**: **Śledź** **całą klasę** (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod API Androida.

Gdy wybierzesz moduł pomocniczy, który chcesz użyć, musisz nacisnąć "**Start Instrumentation**" i zobaczysz wszystkie wyniki w "**Frida Live Logs**".

**Shell**

Mobsf oferuje również powłokę z niektórymi poleceniami **adb**, **komendami MobSF** i powszechnymi **poleceniami powłoki** na dole strony analizy dynamicznej. Niektóre interesujące polecenia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch http jest przechwytywany, możesz zobaczyć brzydki widok przechwyconego ruchu na "**HTTP(S) Traffic**" na dole lub ładniejszy widok w "**Start HTTPTools**" zielonym przycisku. Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxy** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _włącz Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzzować żądania http** i szukać luk.

{% hint style="info" %}
Po przeprowadzeniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będziesz w stanie ich naprawić z GUI. Możesz naprawić ustawienia proxy, wykonując:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Analiza dynamiczna wspomagana przez Inspeckage

Możesz pobrać narzędzie z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa **Hooków**, aby poinformować Cię **co się dzieje w aplikacji** podczas przeprowadzania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania analizy statycznej z interfejsem graficznym**

![](<../../.gitbook/assets/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie zostało zaprojektowane w celu wyszukiwania kilku **związanych z bezpieczeństwem podatności aplikacji Android**, zarówno w **kodzie źródłowym**, jak i w **spakowanych APK**. Narzędzie jest również **zdolne do tworzenia "Dowodu Koncepcji" wdrażalnego APK** oraz **komend ADB**, aby wykorzystać niektóre z wykrytych podatności (ujawnione aktywności, intencje, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Wyświetla wszystkie wyodrębnione pliki dla łatwego odniesienia
* Automatycznie dekompiluje pliki APK do formatu Java i Smali
* Analizuje AndroidManifest.xml pod kątem powszechnych luk i zachowań
* Statyczna analiza kodu źródłowego pod kątem powszechnych luk i zachowań
* Informacje o urządzeniu
* i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja działająca w wierszu poleceń, która może być używana w systemach Windows, MacOS X i Linux, analizująca pliki _.apk_ w poszukiwaniu luk. Robi to, dekompresując APK i stosując szereg reguł w celu wykrycia tych luk.

Wszystkie reguły są zgrupowane w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze pliki binarne z [strony pobierania](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (297).png>)

StaCoAn to **narzędzie wieloplatformowe**, które wspomaga programistów, łowców błędów i etycznych hakerów w przeprowadzaniu [analizy statycznej kodu](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik swojej aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i listy słów, aby uzyskać spersonalizowane doświadczenie.

Pobierz [najnowszą wersję](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności Android, który pomaga deweloperom lub hakerom znaleźć potencjalne luki w zabezpieczeniach aplikacji na Androida.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnych złośliwych zachowaniach rozwijanych przez aplikację na Androida.

Wykrywanie odbywa się za pomocą **analizy statycznej** bajtkodu Dalvik aplikacji, reprezentowanego jako **Smali**, z użyciem biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie szuka **typowych zachowań "złych" aplikacji**, takich jak: eksfiltracja identyfikatorów telekomunikacyjnych, przechwytywanie strumieni audio/wideo, modyfikacja danych PIM, wykonanie dowolnego kodu...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (595).png>)

**MARA** to **M**obile **A**pplication **R**everse engineering i **A**nalysis Framework. Jest to narzędzie, które łączy powszechnie używane narzędzia do inżynierii wstecznej i analizy aplikacji mobilnych, aby wspierać testowanie aplikacji mobilnych w kontekście zagrożeń bezpieczeństwa OWASP. Jego celem jest ułatwienie tego zadania i uczynienie go bardziej przyjaznym dla programistów aplikacji mobilnych i specjalistów ds. bezpieczeństwa.

Może:

* Ekstrahować kod Java i Smali przy użyciu różnych narzędzi
* Analizować APK za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Ekstrahować prywatne informacje z APK przy użyciu regexów.
* Analizować Manifest.
* Analizować znalezione domeny za pomocą: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania złośliwego oprogramowania: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Zauważ, że w zależności od usługi i konfiguracji, której używasz do obfuskacji kodu, sekrety mogą być obfuskowane lub nie.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard_\(software\))

Z [Wikipedia](https://en.wikipedia.org/wiki/ProGuard_\(software\)): **ProGuard** to narzędzie wiersza poleceń typu open source, które zmniejsza, optymalizuje i obfuskowało kod Java. Potrafi optymalizować bajty kodu oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest oprogramowaniem darmowym i jest dystrybuowane na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowane jako część Android SDK i działa podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku, jak deobfuskować apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnim razem, gdy sprawdzaliśmy, tryb działania Dexguard był:

* załaduj zasób jako InputStream;
* przekaż wynik do klasy dziedziczącej z FilterInputStream, aby go odszyfrować;
* wykonaj kilka bezużytecznych obfuskacji, aby zmarnować kilka minut czasu odwracającego;
* przekaż odszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
* w końcu załaduj wynikowy DEX jako zasób, używając metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i przewidywanie bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Simplify](https://github.com/CalebFenton/simplify)

To **ogólny deobfuskator androidowy.** Simplify **wirtualnie wykonuje aplikację**, aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, aby działał identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy typ optymalizacji jest prosty i ogólny, więc nie ma znaczenia, jaki konkretny typ obfuskacji jest używany.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak stworzono APK**. Identyfikuje wiele **kompilatorów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten samouczek, aby poznać kilka sztuczek na **temat odwracania niestandardowej obfuskacji**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Androida oparta na ubuntu-mate, która zawiera zbiór najnowszych frameworków, samouczków i laboratoriów od różnych geeków i badaczy bezpieczeństwa do inżynierii wstecznej i analizy złośliwego oprogramowania.

## References

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec)

## Yet to try

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Dołącz do [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hackerami i łowcami bugów!

**Hacking Insights**\
Zaangażuj się w treści, które zagłębiają się w emocje i wyzwania związane z hackingiem

**Real-Time Hack News**\
Bądź na bieżąco z dynamicznym światem hackingu dzięki wiadomościom i spostrzeżeniom w czasie rzeczywistym

**Latest Announcements**\
Bądź na bieżąco z najnowszymi nagrodami za błędy i istotnymi aktualizacjami platformy

**Dołącz do nas na** [**Discord**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hackerami już dziś!

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
