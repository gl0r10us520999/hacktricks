# Android Applications Pentesting

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Join [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server to communicate with experienced hackers and bug bounty hunters!

**Hacking Insights**\
해킹의 스릴과 도전에 대해 깊이 있는 콘텐츠에 참여하세요.

**Real-Time Hack News**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계의 최신 정보를 유지하세요.

**Latest Announcements**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 유지하세요.

**Join us on** [**Discord**](https://discord.com/invite/N3FrSbmwdy) and start collaborating with top hackers today!

## Android Applications Basics

이 페이지를 읽는 것을 강력히 권장합니다. **안드로이드 보안과 안드로이드 애플리케이션에서 가장 위험한 구성 요소와 관련된 가장 중요한 부분**에 대해 알아보세요:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

이것은 안드로이드 장치(에뮬레이트된 또는 물리적)에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB** 또는 **네트워크**를 통해 장치를 제어할 수 있게 해줍니다. 이 유틸리티는 **파일 복사**, **앱 설치 및 제거**, **셸 명령 실행**, **데이터 백업**, **로그 읽기** 등 여러 기능을 가능하게 합니다.

다음 [**ADB Commands**](adb-commands.md) 목록을 확인하여 adb 사용 방법을 배우세요.

## Smali

때때로 **숨겨진 정보**(아마도 잘 난독화된 비밀번호나 플래그)에 접근하기 위해 **애플리케이션 코드를 수정하는 것**이 흥미로울 수 있습니다. 그러므로 apk를 디컴파일하고 코드를 수정한 후 다시 컴파일하는 것이 흥미로울 수 있습니다.\
[**이 튜토리얼에서** APK를 디컴파일하고 Smali 코드를 수정한 후 새로운 기능으로 APK를 다시 컴파일하는 방법을 배울 수 있습니다](smali-changes.md). 이는 **동적 분석 중 여러 테스트의 대안으로 매우 유용할 수 있습니다**. 그러므로 **이 가능성을 항상 염두에 두세요**.

## Other interesting tricks

* [Play Store에서 위치 스푸핑하기](spoofing-your-location-in-play-store.md)
* **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
* 장치에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
* [APKEditor](https://github.com/REAndroid/APKEditor)를 사용하여 모든 분할 및 기본 APK를 병합합니다:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 정적 분석

우선, APK를 분석하기 위해서는 **디컴파일러를 사용하여 Java 코드를 살펴봐야 합니다**.\
자세한 디컴파일러 정보는 [**여기에서 확인하세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **문자열**을 살펴보면 **비밀번호**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** 키, **암호화**, **블루투스 UUID**, **토큰** 및 흥미로운 모든 것을 검색할 수 있습니다... 코드 실행 **백도어** 또는 인증 백도어(앱에 하드코딩된 관리자 자격 증명)도 찾아보세요.

**Firebase**

**Firebase URL**에 특별한 주의를 기울이고 잘못 구성되어 있는지 확인하세요. [Firebase에 대한 정보와 이를 악용하는 방법은 여기에서 확인하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션에 대한 기본 이해 - Manifest.xml, strings.xml

**애플리케이션의 \_Manifest.xml**_\*\* 및 \*\*_**strings.xml**\_\*\* 파일의 검토는 잠재적인 보안 취약점을 드러낼 수 있습니다\*\*. 이 파일들은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 변경한 후 압축을 풀어 접근할 수 있습니다.

**Manifest.xml**에서 식별된 **취약점**은 다음과 같습니다:

* **디버깅 가능한 애플리케이션**: _Manifest.xml_ 파일에서 디버깅 가능(`debuggable="true"`)으로 설정된 애플리케이션은 연결을 허용하여 악용될 위험이 있습니다. 디버깅 가능한 애플리케이션을 찾고 악용하는 방법에 대한 튜토리얼을 참조하세요.
* **백업 설정**: 민감한 정보를 다루는 애플리케이션의 경우 `android:allowBackup="false"` 속성을 명시적으로 설정하여 adb를 통한 무단 데이터 백업을 방지해야 합니다. 특히 USB 디버깅이 활성화된 경우에 그렇습니다.
* **네트워크 보안**: _res/xml/_의 사용자 정의 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 인증서 핀 및 HTTP 트래픽 설정과 같은 보안 세부정보를 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용하는 것입니다.
* **내보낸 활동 및 서비스**: 매니페스트에서 내보낸 활동 및 서비스를 식별하면 악용될 수 있는 구성 요소를 강조할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 구성 요소를 악용하는 방법을 밝혀낼 수 있습니다.
* **콘텐츠 제공자 및 파일 제공자**: 노출된 콘텐츠 제공자는 무단 접근 또는 데이터 수정이 가능할 수 있습니다. 파일 제공자의 구성도 면밀히 검토해야 합니다.
* **브로드캐스트 수신기 및 URL 스킴**: 이러한 구성 요소는 악용될 수 있으며, 입력 취약점에 대한 URL 스킴 관리 방법에 특히 주의해야 합니다.
* **SDK 버전**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 보안상의 이유로 구식의 취약한 Android 버전을 지원하지 않는 것이 중요합니다.

**strings.xml** 파일에서 API 키, 사용자 정의 스키마 및 기타 개발자 노트와 같은 민감한 정보를 발견할 수 있으며, 이러한 리소스를 신중하게 검토할 필요성을 강조합니다.

### 탭재킹

**탭재킹**은 **악의적인** **애플리케이션**이 실행되어 **희생 애플리케이션 위에 위치하는 공격**입니다. 희생 앱을 가시적으로 가리면, 사용자 인터페이스는 사용자가 상호작용하도록 속이도록 설계되어 있으며, 이 상호작용은 희생 앱으로 전달됩니다.\
결과적으로, 사용자는 실제로 희생 앱에서 작업을 수행하고 있다는 사실을 **모르게 됩니다**.

자세한 정보는 다음에서 확인하세요:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### 작업 하이재킹

**`launchMode`**가 **`singleTask`**로 설정되고 `taskAffinity`가 정의되지 않은 **활동**은 작업 하이재킹에 취약합니다. 이는 **애플리케이션**이 설치되고 실제 애플리케이션보다 먼저 실행될 경우 **실제 애플리케이션의 작업을 하이재킹할 수 있음을 의미합니다**(따라서 사용자는 **악의적인 애플리케이션과 상호작용하고 있다고 생각하게 됩니다**).

자세한 정보는 다음에서 확인하세요:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 안전하지 않은 데이터 저장

**내부 저장소**

Android에서 **내부** 저장소에 **저장된** 파일은 **생성한 앱**만 **접근할 수 있도록 설계**되어 있습니다. 이 보안 조치는 Android 운영 체제에 의해 **강제**되며, 대부분의 애플리케이션의 보안 요구 사항에 일반적으로 적합합니다. 그러나 개발자들은 때때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 파일이 서로 다른 애플리케이션 간에 **공유되도록 허용합니다**. 그러나 이러한 모드는 다른 애플리케이션, 특히 잠재적으로 악의적인 애플리케이션에 의한 파일 접근을 **제한하지 않습니다**.

1. **정적 분석:**
* `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용이 **면밀히 검토되어야 합니다**. 이러한 모드는 파일을 **예기치 않거나 무단 접근**에 노출시킬 수 있습니다.
2. **동적 분석:**
* 앱에서 생성된 파일에 설정된 **권한**을 **확인**하세요. 특히, 어떤 파일이 **전 세계적으로 읽거나 쓸 수 있도록 설정되어 있는지 확인**하세요. 이는 **어떤 애플리케이션**이든 장치에 설치된 애플리케이션이 이 파일을 **읽거나 수정**할 수 있게 하여 상당한 보안 위험을 초래할 수 있습니다.

**외부 저장소**

**외부 저장소**에서 파일을 다룰 때는 몇 가지 주의 사항이 있습니다:

1. **접근성**:
* 외부 저장소의 파일은 **전 세계적으로 읽고 쓸 수 있습니다**. 이는 모든 애플리케이션이나 사용자가 이러한 파일에 접근할 수 있음을 의미합니다.
2. **보안 문제**:
* 접근이 용이하므로 **민감한 정보를 외부 저장소에 저장하지 않는 것이 좋습니다**.
* 외부 저장소는 제거되거나 모든 애플리케이션에 의해 접근될 수 있어 보안이 떨어집니다.
3. **외부 저장소에서 데이터 처리**:
* 외부 저장소에서 검색한 데이터에 대해 항상 **입력 검증을 수행**하세요. 이는 데이터가 신뢰할 수 없는 출처에서 온 것이기 때문에 중요합니다.
* 동적 로딩을 위해 외부 저장소에 실행 파일이나 클래스 파일을 저장하는 것은 강력히 권장되지 않습니다.
* 애플리케이션이 외부 저장소에서 실행 파일을 검색해야 하는 경우, 이러한 파일이 **서명되고 암호학적으로 검증된 후 동적으로 로드되도록 해야 합니다**. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 중요합니다.

외부 저장소는 `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`에서 **접근할 수 있습니다**.

{% hint style="info" %}
Android 4.4 (**API 17**)부터 SD 카드에는 **앱에 특정한 디렉토리로의 접근을 제한하는 디렉토리 구조**가 있습니다. 이는 악의적인 애플리케이션이 다른 앱의 파일에 대한 읽기 또는 쓰기 접근을 얻는 것을 방지합니다.
{% endhint %}

**명확한 텍스트로 저장된 민감한 데이터**

* **공유 환경 설정**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 XML 파일을 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 명확한 텍스트로 민감한 정보를 찾을 수 있습니다.
* **데이터베이스**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 SQLite 데이터베이스를 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 명확한 텍스트로 민감한 정보를 찾을 수 있습니다.

### 손상된 TLS

**모든 인증서 수락**

어떤 이유로 개발자들이 호스트 이름이 코드의 다음 줄과 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

일부 개발자는 민감한 데이터를 로컬 저장소에 저장하고 코드에 하드코딩되거나 예측 가능한 키로 암호화합니다. 이는 리버싱을 통해 공격자가 기밀 정보를 추출할 수 있으므로 피해야 합니다.

**Use of Insecure and/or Deprecated Algorithms**

개발자는 **권장되지 않는 알고리즘**을 사용하여 **검증**을 수행하거나 **데이터를 저장**하거나 **전송**해서는 안 됩니다. 이러한 알고리즘에는 RC4, MD4, MD5, SHA1 등이 포함됩니다. 예를 들어 **해시**를 사용하여 비밀번호를 저장하는 경우, 소금을 사용하여 해시의 무차별 대입 공격에 **저항**할 수 있어야 합니다.

### Other checks

* 공격자가 리버스 엔지니어링 작업을 어렵게 하기 위해 **APK를 난독화**하는 것이 좋습니다.
* 앱이 민감한 경우(예: 은행 앱) **모바일이 루팅되었는지 확인하는 자체 검사를 수행**하고 그에 따라 행동해야 합니다.
* 앱이 민감한 경우(예: 은행 앱) **에뮬레이터**가 사용되고 있는지 확인해야 합니다.
* 앱이 민감한 경우(예: 은행 앱) **실행하기 전에 자체 무결성을 확인**하여 수정되었는지 확인해야 합니다.
* [**APKiD**](https://github.com/rednaga/APKiD)를 사용하여 APK를 빌드하는 데 사용된 컴파일러/패커/난독화 도구를 확인하세요.

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Other interesting functions

* **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
* **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
* [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Join [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server to communicate with experienced hackers and bug bounty hunters!

**Hacking Insights**\
Engage with content that delves into the thrill and challenges of hacking

**Real-Time Hack News**\
Keep up-to-date with fast-paced hacking world through real-time news and insights

**Latest Announcements**\
Stay informed with the newest bug bounties launching and crucial platform updates

**Join us on** [**Discord**](https://discord.com/invite/N3FrSbmwdy) and start collaborating with top hackers today!

***

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../.gitbook/assets/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

* [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
* Learn to set it up in this page:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
* [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

{% hint style="info" %}
When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.
{% endhint %}

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../.gitbook/assets/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

개발자는 **디버깅 정보**를 공개적으로 노출하는 것에 주의해야 하며, 이는 민감한 데이터 유출로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat` 도구를 권장합니다. **Pidcat**은 사용 용이성과 가독성 때문에 선호됩니다.

{% hint style="warning" %}
Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
Anyway, it's still recommended to **not log sensitive information**.
{% endhint %}

**Copy/Paste Buffer Caching**

Android의 **클립보드 기반** 프레임워크는 앱에서 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션**이 클립보드에 **접근**할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용 카드 세부정보와 같은 애플리케이션의 민감한 섹션에 대해 **복사/붙여넣기** 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **충돌**하고 **로그를 저장**하는 경우, 이러한 로그는 공격자에게 도움이 될 수 있으며, 특히 애플리케이션을 리버스 엔지니어링할 수 없는 경우 더욱 그렇습니다. 이 위험을 완화하기 위해 충돌 시 로그를 기록하지 않도록 하고, 로그를 네트워크를 통해 전송해야 하는 경우 SSL 채널을 통해 전송되도록 해야 합니다.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하여 개발자의 부적절한 구현으로 인해 민감한 데이터가 **유출**될 수 있습니다. 잠재적인 데이터 유출을 식별하기 위해 **애플리케이션의 트래픽을 가로채고** 제3자 서비스에 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용합니다. 펜테스트 중에 생성된 **데이터베이스**, **테이블** 및 **열**의 이름과 저장된 모든 **데이터**를 살펴보아야 하며, 여기서 **민감한 정보**(취약점이 될 수 있음)를 발견할 수 있습니다.\
데이터베이스는 `/data/data/the.package.name/databases`에 위치해야 하며, 예를 들어 `/data/data/com.mwr.example.sieve/databases`와 같습니다.

데이터베이스가 기밀 정보를 저장하고 **암호화**되어 있지만 애플리케이션 내에서 **비밀번호**를 **찾을 수** 있다면 여전히 **취약점**입니다.

`.tables`를 사용하여 테이블을 나열하고, `.schema <table_name>`을 사용하여 테이블의 열을 나열합니다.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**는 **Android 앱의 역할을 가정**하고 다른 앱과 상호작용할 수 있게 해줍니다. 이는 설치된 애플리케이션이 할 수 있는 **모든 작업**을 수행할 수 있으며, Android의 프로세스 간 통신(IPC) 메커니즘을 활용하고 기본 운영 체제와 상호작용할 수 있습니다.\
Drozer는 **내보낸 활동, 내보낸 서비스 및 콘텐츠 제공자**를 **악용**하는 데 유용한 도구입니다.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

활동이 내보내지면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**가 **내보내진** 활동이 있는 경우 **인증** 메커니즘을 **우회**하여 접근할 수 있습니다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/#activities)

You can also start an exported activity from adb:

* PackageName is com.example.demo
* Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF는 활동에서 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 감지하지만, [이것](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에, 이는 구버전(API 버전 < 21)에서만 위험한 것으로 보입니다.

{% hint style="info" %}
권한 우회가 항상 취약점은 아니라는 점에 유의해야 하며, 이는 우회가 어떻게 작동하는지와 어떤 정보가 노출되는지에 따라 다릅니다.
{% endhint %}

**민감한 정보 유출**

**활동은 결과를 반환할 수도 있습니다**. 만약 당신이 **`setResult`** 메서드를 호출하고 **민감한 정보를 반환하는** 내보내기된 보호되지 않은 활동을 찾는다면, 민감한 정보 유출이 발생한 것입니다.

#### Tapjacking

Tapjacking이 방지되지 않으면, 내보내기된 활동을 악용하여 **사용자가 예상치 못한 행동을 하도록 만들 수 있습니다**. [**Tapjacking이 무엇인지에 대한 더 많은 정보는 링크를 따라가세요**](./#tapjacking).

### 콘텐츠 제공자 악용 - 민감한 정보 접근 및 조작

[**콘텐츠 제공자가 무엇인지 새롭게 알고 싶다면 이 글을 읽어보세요.**](android-applications-basics.md#content-provider)\
콘텐츠 제공자는 기본적으로 **데이터를 공유하는 데 사용됩니다**. 앱에 사용 가능한 콘텐츠 제공자가 있다면, 그들로부터 **민감한** 데이터를 **추출할 수** 있을 것입니다. 또한 **SQL 인젝션** 및 **경로 탐색**의 가능성을 테스트하는 것도 흥미롭습니다. 이들은 취약할 수 있습니다.

[**Drozer로 콘텐츠 제공자를 악용하는 방법을 배우세요.**](drozer-tutorial/#content-providers)

### **서비스 악용**

[**서비스가 무엇인지 새롭게 알고 싶다면 이 글을 읽어보세요.**](android-applications-basics.md#services)\
서비스의 동작은 `onStartCommand` 메서드에서 시작된다는 점을 기억하세요.

서비스는 기본적으로 **데이터를 수신하고**, **처리**하며 **응답**(또는 응답하지 않을 수 있음)을 **반환**하는 것입니다. 따라서 애플리케이션이 일부 서비스를 내보내고 있다면, **코드를 확인**하여 그것이 무엇을 하는지 이해하고, **민감한 정보를 추출하기 위해 동적으로 테스트**해야 합니다. 인증 수단을 우회하는 것도 포함됩니다...\
[**Drozer로 서비스를 악용하는 방법을 배우세요.**](drozer-tutorial/#services)

### **브로드캐스트 수신기 악용**

[**브로드캐스트 수신기가 무엇인지 새롭게 알고 싶다면 이 글을 읽어보세요.**](android-applications-basics.md#broadcast-receivers)\
브로드캐스트 수신기의 동작은 `onReceive` 메서드에서 시작된다는 점을 기억하세요.

브로드캐스트 수신기는 특정 유형의 메시지를 기다리고 있습니다. 수신기가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Drozer로 브로드캐스트 수신기를 악용하는 방법을 배우세요.**](./#exploiting-broadcast-receivers)

### **스킴 / 딥 링크 악용**

MobSF와 같은 도구나 [이 스크립트](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)를 사용하여 딥 링크를 수동으로 찾을 수 있습니다.\
**adb** 또는 **브라우저**를 사용하여 선언된 **스킴**을 **열 수** 있습니다:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_패키지 이름을 **생략할 수** 있으며, 모바일은 자동으로 해당 링크를 열어야 하는 앱을 호출합니다._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**실행된 코드**

**앱에서 실행될 코드**를 찾으려면, 딥링크로 호출된 액티비티로 가서 **`onNewIntent`** 함수를 검색하세요.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**민감한 정보**

딥링크를 찾을 때마다 **URL 매개변수를 통해 민감한 데이터(예: 비밀번호)를 수신하지 않는지 확인하세요**, 다른 애플리케이션이 **딥링크를 가장하여 해당 데이터를 훔칠 수 있기 때문입니다!**

**경로의 매개변수**

**딥링크가 URL의 경로 내에서 매개변수를 사용하고 있는지 확인해야 합니다**. 예: `https://api.example.com/v1/users/{username}`. 이 경우, 다음과 같이 경로 탐색을 강제할 수 있습니다: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
애플리케이션 내에서 올바른 엔드포인트를 찾으면 **Open Redirect**(경로의 일부가 도메인 이름으로 사용되는 경우), **계정 탈취**(CSRF 토큰 없이 사용자 세부정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용하는 경우) 및 기타 취약점을 유발할 수 있습니다. 더 많은 [정보는 여기](http://dphoeniixx.com/2020/12/13-2/)에서 확인하세요.

**더 많은 예시**

링크에 대한 [흥미로운 버그 바운티 보고서](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

* **인증서는 Android 애플리케이션에서 항상 제대로 검사되지 않습니다**. 이러한 애플리케이션이 경고를 무시하고 자체 서명된 인증서를 수락하거나, 경우에 따라 HTTP 연결로 되돌아가는 경우가 흔합니다.
* **SSL/TLS 핸드셰이크 중 협상이 때때로 약합니다**, 안전하지 않은 암호 모음을 사용합니다. 이 취약점은 연결을 중간자 공격(MITM)에 취약하게 만들어 공격자가 데이터를 복호화할 수 있게 합니다.
* **민감한 정보의 유출**은 애플리케이션이 안전한 채널을 사용하여 인증하지만 다른 거래에 대해 비안전한 채널을 통해 통신할 때 위험이 있습니다. 이 접근 방식은 세션 쿠키나 사용자 세부정보와 같은 민감한 데이터를 악의적인 엔티티의 가로채기로부터 보호하지 못합니다.

#### 인증서 검증

**인증서 검증**에 집중하겠습니다. 보안을 강화하기 위해 서버의 인증서 무결성을 검증해야 합니다. 이는 안전하지 않은 TLS 구성과 암호화되지 않은 채널을 통한 민감한 데이터 전송이 상당한 위험을 초래할 수 있기 때문에 중요합니다. 서버 인증서를 검증하고 취약점을 해결하는 방법에 대한 자세한 단계는 [**이 리소스**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적인 지침을 제공합니다.

#### SSL 핀닝

SSL 핀닝은 애플리케이션이 서버의 인증서를 애플리케이션 내에 저장된 알려진 복사본과 비교하여 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 처리하는 애플리케이션에는 SSL 핀닝 구현이 강력히 권장됩니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 **프록시 도구의 인증서를 설치해야 합니다**(예: Burp). 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 표시되지 않을 수 있습니다. 사용자 정의 CA 인증서를 설치하는 방법에 대한 가이드는 [**여기를 클릭하세요**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API 레벨 24 이상**을 대상으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 네트워크 보안 구성을 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. 네트워크 보안 구성을 수정하는 방법에 대한 지침은 [**이 튜토리얼**](make-apk-accept-ca-certificate.md)을 참조하세요.

#### SSL 핀닝 우회

SSL 핀닝이 구현된 경우 HTTPS 트래픽을 검사하기 위해 이를 우회해야 합니다. 이를 위한 다양한 방법이 있습니다:

* **apk**를 자동으로 **수정하여** SSLPinning을 **우회**하는 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). 이 옵션의 가장 큰 장점은 SSL 핀닝을 우회하기 위해 루트가 필요하지 않지만, 애플리케이션을 삭제하고 새로 설치해야 하며, 항상 작동하지는 않습니다.
* **Frida**를 사용하여 이 보호를 우회할 수 있습니다(아래에서 논의됨). Burp+Frida+Genymotion을 사용하는 방법에 대한 가이드는 [여기](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)에서 확인하세요.
* **objection**을 사용하여 SSL 핀닝을 **자동으로 우회**할 수도 있습니다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSF 동적 분석**을 사용하여 SSL 핀닝을 **자동으로 우회**할 수도 있습니다(아래에서 설명됨).
* 여전히 캡처하지 못한 트래픽이 있다고 생각되면 **iptables를 사용하여 트래픽을 burp로 포워딩**해 볼 수 있습니다. 이 블로그를 읽어보세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반 웹 취약점 찾기

애플리케이션 내에서 일반 웹 취약점을 검색하는 것도 중요합니다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 정보는 이 요약의 범위를 넘어가지만, 다른 곳에서 광범위하게 다루어지고 있습니다.

### Frida

[Frida](https://www.frida.re)는 개발자, 리버스 엔지니어, 보안 연구자를 위한 동적 계측 툴킷입니다.\
**실행 중인 애플리케이션에 접근하고 런타임에서 메서드를 후킹하여 동작을 변경하고, 값을 변경하고, 값을 추출하고, 다른 코드를 실행할 수 있습니다...**\
Android 애플리케이션을 펜테스트하려면 Frida를 사용하는 방법을 알아야 합니다.

* Frida 사용 방법 배우기: [**Frida 튜토리얼**](frida-tutorial/)
* Frida로 작업하기 위한 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection은 Frida 사용을 자동화하는 데 훌륭합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* 여기에서 멋진 Frida 스크립트를 찾을 수 있습니다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
* Frida를 로드하여 안티 디버깅 / 안티 Frida 메커니즘을 우회해 보세요. [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)에서 지침을 확인하세요 (도구 [linjector](https://github.com/erfur/linjector-rs)).

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉과 같은 민감한 정보를 저장하고 있지 않은지 확인하세요.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하여 다음과 같이 앱의 메모리를 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 ./dump 폴더에 메모리를 덤프할 것이며, 그 안에서 다음과 같이 grep을 사용할 수 있습니다: 

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **키 저장소의 민감한 데이터**

안드로이드에서 키 저장소는 민감한 데이터를 저장하기에 가장 좋은 장소이지만, 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션이 여기에서 **민감한 데이터를 일반 텍스트로 저장하는 경향이 있기 때문에** 펜테스트는 이를 확인해야 하며, 루트 사용자 또는 장치에 물리적으로 접근할 수 있는 사람이 이 데이터를 훔칠 수 있습니다.

앱이 키 저장소에 데이터를 저장하더라도, 데이터는 암호화되어야 합니다.

키 저장소 내부의 데이터에 접근하려면 이 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **지문/생체 인식 우회**

다음 Frida 스크립트를 사용하면 **지문 인증을 우회**할 수 있습니다. Android 애플리케이션이 특정 민감한 영역을 보호하기 위해 수행할 수 있습니다: 

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **배경 이미지**

애플리케이션을 백그라운드에 두면, Android는 **애플리케이션의 스냅샷**을 저장하므로, 포그라운드로 복구될 때 앱보다 이미지를 로드하기 시작하여 앱이 더 빨리 로드된 것처럼 보입니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람은 **그 정보를 훔칠 수 있습니다** (접근하려면 루트 권한이 필요합니다).

스냅샷은 일반적으로 다음 위치에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 **FLAG\_SECURE** 레이아웃 매개변수를 설정하여 스크린샷 캡처를 **방지하는 방법**을 제공합니다. 이 플래그를 사용하면 창의 내용이 안전한 것으로 처리되어 스크린샷에 나타나거나 비안전한 디스플레이에서 볼 수 없게 됩니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **안드로이드 애플리케이션 분석기**

이 도구는 동적 분석 중 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### 인텐트 주입

개발자들은 종종 이러한 인텐트를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)`와 같은 메서드로 전달하는 프록시 구성 요소인 액티비티, 서비스 및 브로드캐스트 수신기를 생성합니다. 이는 위험할 수 있습니다.

위험은 공격자가 이러한 인텐트를 잘못 유도하여 비공식 앱 구성 요소를 트리거하거나 민감한 콘텐츠 제공자에 접근할 수 있도록 허용하는 데 있습니다. 주목할 만한 예는 `WebView` 구성 요소가 URL을 `Intent` 객체로 변환하는 `Intent.parseUri(...)`를 통해 이를 실행하여 악의적인 인텐트 주입으로 이어질 수 있습니다.

### 필수 요점

* **인텐트 주입**은 웹의 오픈 리디렉션 문제와 유사합니다.
* 익스플로잇은 `Intent` 객체를 추가로 전달하여 안전하지 않은 작업을 실행하도록 리디렉션할 수 있습니다.
* 비공식 구성 요소와 콘텐츠 제공자를 공격자에게 노출할 수 있습니다.
* `WebView`의 URL을 `Intent`로 변환하는 것은 의도하지 않은 작업을 촉진할 수 있습니다.

### 안드로이드 클라이언트 측 주입 및 기타

아마도 웹에서 이러한 종류의 취약점에 대해 알고 계실 것입니다. 안드로이드 애플리케이션에서 이러한 취약점에 특히 주의해야 합니다:

* **SQL 주입:** 동적 쿼리 또는 콘텐츠 제공자를 다룰 때 매개변수화된 쿼리를 사용하고 있는지 확인하십시오.
* **자바스크립트 주입 (XSS):** 모든 WebView에 대해 자바스크립트 및 플러그인 지원이 비활성화되어 있는지 확인하십시오 (기본적으로 비활성화됨). [자세한 정보는 여기](webview-attacks.md#javascript-enabled)를 참조하십시오.
* **로컬 파일 포함:** WebView는 파일 시스템에 대한 접근이 비활성화되어야 합니다 (기본적으로 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [자세한 정보는 여기](webview-attacks.md#javascript-enabled)를 참조하십시오.
* **영구 쿠키**: 여러 경우에 안드로이드 애플리케이션이 세션을 종료할 때 쿠키가 취소되지 않거나 디스크에 저장될 수 있습니다.
* [**쿠키의 보안 플래그**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

경험이 풍부한 해커 및 버그 바운티 헌터와 소통하기 위해 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 참여하세요!

**해킹 통찰력**\
해킹의 스릴과 도전에 대해 깊이 있는 콘텐츠에 참여하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계의 최신 정보를 유지하세요.

**최신 발표**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 유지하세요.

오늘 [**Discord**](https://discord.com/invite/N3FrSbmwdy)에 참여하여 최고의 해커들과 협업을 시작하세요!

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../.gitbook/assets/image (866).png>)

멋진 웹 기반 프론트엔드를 사용하여 애플리케이션의 **취약점 평가**를 수행합니다. 동적 분석도 수행할 수 있지만 (환경을 준비해야 함) 필요합니다.
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
또한, **Android** 또는 **IOS** 앱의 소스 코드로 **ZIP** 파일을 생성하면 (애플리케이션의 루트 폴더로 이동하여 모든 것을 선택하고 ZIP 파일을 생성), 그것도 분석할 수 있습니다.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF 동적 분석기**는 다음을 수행할 수 있습니다:

* **애플리케이션 데이터 덤프** (URL, 로그, 클립보드, 사용자가 만든 스크린샷, "**Exported Activity Tester**"가 만든 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 기타 생성된 파일). 이 모든 것은 자동으로 수행되며, 스크린샷은 원할 때 눌러야 하거나 "**Exported Activity Tester**"를 눌러야 모든 내보낸 활동의 스크린샷을 얻을 수 있습니다.
* **HTTPS 트래픽 캡처**
* **Frida**를 사용하여 **런타임** **정보**를 얻기

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../.gitbook/assets/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

* **로드된 클래스 나열**: 모든 로드된 클래스를 출력합니다.
* **문자열 캡처**: 애플리케이션을 사용하는 동안 캡처된 모든 문자열을 출력합니다 (매우 시끄러움).
* **문자열 비교 캡처**: 매우 유용할 수 있습니다. **비교되는 2개의 문자열**과 결과가 True인지 False인지 보여줍니다.
* **클래스 메서드 나열**: 클래스 이름(예: "java.io.File")을 입력하면 클래스의 모든 메서드를 출력합니다.
* **클래스 패턴 검색**: 패턴으로 클래스를 검색합니다.
* **클래스 메서드 추적**: **전체 클래스**를 **추적**합니다 (클래스의 모든 메서드의 입력 및 출력을 봅니다). 기본적으로 MobSF는 여러 흥미로운 Android API 메서드를 추적합니다.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

http 트래픽이 캡처되면 "**HTTP(S) Traffic**" 하단에서 캡처된 트래픽의 보기 불량한 형태를 볼 수 있으며, "**Start HTTPTools**" 녹색 버튼에서 더 나은 보기를 볼 수 있습니다. 두 번째 옵션에서 **캡처된 요청**을 Burp 또는 Owasp ZAP과 같은 **프록시**로 **전송**할 수 있습니다.\
이를 위해, _Burp 켜기 -->_ _Intercept 끄기 --> MobSB HTTPTools에서 요청 선택_ --> "**Send to Fuzzer**" 버튼을 누르기 --> _프록시 주소 선택_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 마친 후 "**Start Web API Fuzzer**"를 눌러 **http 요청을 퍼징**하고 취약점을 찾아볼 수 있습니다.

{% hint style="info" %}
MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못 구성될 수 있으며 GUI에서 이를 수정할 수 없습니다. 프록시 설정을 수정하려면:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckage를 이용한 보조 동적 분석

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 받을 수 있습니다.\
이 도구는 **Hooks**를 사용하여 **동적 분석**을 수행하는 동안 **애플리케이션에서 무슨 일이 일어나고 있는지** 알 수 있게 해줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

이것은 **GUI를 이용한 정적 분석을 수행하기 위한 훌륭한 도구**입니다.

![](<../../.gitbook/assets/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **소스 코드** 또는 **패키지된 APK**에서 여러 **보안 관련 Android 애플리케이션 취약점**을 찾기 위해 설계되었습니다. 이 도구는 또한 발견된 취약점(노출된 활동, 인텐트, 탭재킹 등)을 악용하기 위한 **"Proof-of-Concept" 배포 가능한 APK** 및 **ADB 명령**을 생성할 수 있습니다. Drozer와 마찬가지로 테스트 장치를 루팅할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 쉽게 참조할 수 있도록 모든 추출된 파일을 표시합니다.
* APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다.
* 일반적인 취약점 및 동작을 위해 AndroidManifest.xml을 분석합니다.
* 일반적인 취약점 및 동작에 대한 정적 소스 코드 분석
* 장치 정보
* 및 기타
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 애플리케이션으로, _.apk_ 파일을 분석하여 취약점을 찾습니다. 이는 APK를 압축 해제하고 일련의 규칙을 적용하여 이러한 취약점을 감지하는 방식으로 수행됩니다.

모든 규칙은 `rules.json` 파일에 중심을 두고 있으며, 각 회사나 테스터는 자신이 필요한 것을 분석하기 위해 고유한 규칙을 만들 수 있습니다.

최신 바이너리는 [다운로드 페이지](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (297).png>)

StaCoAn은 개발자, 버그 바운티 헌터 및 윤리적 해커가 모바일 애플리케이션에 대한 [정적 코드 분석](https://en.wikipedia.org/wiki/Static_program_analysis)을 수행하는 데 도움을 주는 **크로스 플랫폼** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 보고서를 생성하는 것입니다. 설정과 단어 목록을 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드 [최신 릴리스](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 개발자 또는 해커가 Android 애플리케이션에서 잠재적인 보안 취약점을 찾는 데 도움을 주는 Android 취약점 분석 시스템입니다.\
[Windows 릴리스](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 Android 애플리케이션에서 발생할 수 있는 악의적인 행동을 감지하고 사용자에게 경고하는 것을 주요 목표로 하는 도구입니다.

감지는 애플리케이션의 Dalvik 바이트코드를 **정적 분석**하여 수행되며, 이는 **Smali**로 표현됩니다. [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용합니다.

이 도구는 다음과 같은 **"나쁜" 애플리케이션의 일반적인 행동**을 찾습니다: 전화 식별자 유출, 오디오/비디오 흐름 가로채기, PIM 데이터 수정, 임의 코드 실행...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (595).png>)

**MARA**는 **모바일 애플리케이션 역공학 및 분석 프레임워크**입니다. 이는 OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 데 도움을 주기 위해 일반적으로 사용되는 모바일 애플리케이션 역공학 및 분석 도구를 통합한 도구입니다. 이 작업을 모바일 애플리케이션 개발자와 보안 전문가에게 더 쉽고 친숙하게 만드는 것이 목표입니다.

다음과 같은 기능을 제공합니다:

* 다양한 도구를 사용하여 Java 및 Smali 코드를 추출합니다.
* 다음을 사용하여 APK를 분석합니다: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* 정규 표현식을 사용하여 APK에서 개인 정보를 추출합니다.
* 매니페스트를 분석합니다.
* 다음을 사용하여 발견된 도메인을 분석합니다: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
* [apk-deguard.com](http://www.apk-deguard.com)을 통해 APK를 디오브스큐레이션합니다.

### Koodous

악성코드를 탐지하는 데 유용합니다: [https://koodous.com/](https://koodous.com)

## 코드 난독화/디오브스큐레이션

사용하는 서비스와 구성에 따라 코드가 난독화될 수 있습니다. 비밀은 난독화될 수도 있고 아닐 수도 있습니다.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard_\(software\))

[위키백과](https://en.wikipedia.org/wiki/ProGuard_\(software\))에서: **ProGuard**는 Java 코드를 축소, 최적화 및 난독화하는 오픈 소스 명령줄 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령어를 감지 및 제거할 수 있습니다. ProGuard는 무료 소프트웨어이며 GNU 일반 공중 라이선스 버전 2에 따라 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 애플리케이션을 릴리스 모드로 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

[https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 APK를 디오브스큐레이션하는 단계별 가이드를 찾으세요.

(그 가이드에서) 마지막으로 확인했을 때, Dexguard의 작동 모드는 다음과 같았습니다:

* 리소스를 InputStream으로 로드합니다;
* 결과를 FilterInputStream에서 상속받은 클래스에 제공하여 복호화합니다;
* 리버서의 시간을 낭비하기 위해 쓸모없는 난독화를 수행합니다;
* ZipInputStream에 복호화된 결과를 제공하여 DEX 파일을 얻습니다;
* 마지막으로 `loadDex` 메서드를 사용하여 결과 DEX를 리소스로 로드합니다.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구가 수행한 난독화 프로세스를 역전시킵니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 수많은 보안 분석이 가능합니다.**

난독화된 APK를 그들의 플랫폼에 업로드할 수 있습니다.

### [Simplify](https://github.com/CalebFenton/simplify)

**일반적인 Android 디오브스큐레이터입니다.** Simplify는 **앱을 가상 실행**하여 그 동작을 이해하고, **코드를 최적화**하여 동일하게 동작하지만 사람이 이해하기 쉽게 만듭니다. 각 최적화 유형은 간단하고 일반적이므로 사용된 특정 난독화 유형은 중요하지 않습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 **APK가 어떻게 만들어졌는지**에 대한 정보를 제공합니다. 많은 **컴파일러**, **패커**, **난독화 도구** 및 기타 이상한 것들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)입니다.

### Manual

[사용자 정의 난독화를 역전시키는 방법에 대한 몇 가지 요령을 배우려면 이 튜토리얼을 읽으세요](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 우분투-메이트 기반의 Android 보안 가상 머신으로, 역공학 및 악성코드 분석을 위한 다양한 보안 전문가와 연구자들의 최신 프레임워크, 튜토리얼 및 실험실을 포함합니다.

## References

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 리소스 목록입니다.
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 과정
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec)

## Yet to try

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 참여하여 경험이 풍부한 해커 및 버그 바운티 헌터와 소통하세요!

**Hacking Insights**\
해킹의 스릴과 도전에 대한 내용을 다루는 콘텐츠에 참여하세요.

**Real-Time Hack News**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 최신 상태로 유지하세요.

**Latest Announcements**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 유지하세요.

[**Discord**](https://discord.com/invite/N3FrSbmwdy)에 참여하여 오늘날 최고의 해커들과 협력하세요!

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop)을 확인하세요!
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**를 팔로우하세요.**
* **HackTricks** 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 리포지토리에 PR을 제출하여 해킹 요령을 공유하세요.

</details>
{% endhint %}
