# LLM Training

## Tokenizing

Tokenizing полягає в розділенні даних на конкретні частини та присвоєнні їм специфічних ID (номерів).\
Дуже простий токенізатор для текстів може просто отримати кожне слово тексту окремо, а також знаки пунктуації та видалити пробіли.\
Отже, `"Hello, world!"` буде: `["Hello", ",", "world", "!"]`

Тоді, щоб присвоїти кожному з слів і символів токен ID (номер), потрібно створити **словник** токенізатора. Якщо ви токенізуєте, наприклад, книгу, це може бути **всі різні слова книги** в алфавітному порядку з деякими додатковими токенами, такими як:

* `[BOS] (Початок послідовності)`: Розміщується на початку тексту, вказує на початок тексту (використовується для розділення нерелевантних текстів).
* `[EOS] (Кінець послідовності)`: Розміщується в кінці тексту, вказує на кінець тексту (використовується для розділення нерелевантних текстів).
* `[PAD] (доповнення)`: Коли розмір партії більший за один (зазвичай), цей токен використовується для збільшення довжини цієї партії, щоб вона була такою ж великою, як інші.
* `[UNK] (невідомий)`: Для представлення невідомих слів.

Слідуючи прикладу, маючи токенізований текст, присвоївши кожному слову та символу тексту позицію в словнику, токенізоване речення `"Hello, world!"` -> `["Hello", ",", "world", "!"]` буде чимось на зразок: `[64, 455, 78, 467]`, припускаючи, що `Hello` на позиції 64, "`,"` на позиції `455`... в масиві результативного словника.

Однак, якщо в тексті, використаному для генерації словника, слово `"Bye"` не існувало, це призведе до: `"Bye, world!"` -> `["[UNK]", ",", "world", "!"]` -> `[987, 455, 78, 467]`, припускаючи, що токен для `[UNK]` на позиції 987.

### BPE - Byte Pair Encoding

Щоб уникнути проблем, таких як необхідність токенізувати всі можливі слова для текстів, LLMs, такі як GPT, використовують BPE, який в основному **кодує часті пари байтів** для зменшення розміру тексту в більш оптимізованому форматі, поки його не можна буде зменшити більше (перевірте [**вікіпедію**](https://en.wikipedia.org/wiki/Byte\_pair\_encoding)). Зверніть увагу, що таким чином немає "невідомих" слів для словника, і фінальний словник буде всіма виявленими наборами частих байтів, згрупованими якомога більше, тоді як байти, які не часто пов'язані з тим самим байтом, будуть токеном самі по собі.

## Data Sampling

LLMs, такі як GPT, працюють, передбачаючи наступне слово на основі попередніх, тому для підготовки деяких даних для навчання необхідно підготувати дані таким чином.

Наприклад, використовуючи текст "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"

Щоб підготувати модель до навчання передбачення наступного слова (припускаючи, що кожне слово є токеном, використовуючи дуже простий токенізатор), і використовуючи максимальний розмір 4 та ковзаюче вікно 1, ось як текст має бути підготовлений:
```javascript
Input: [
["Lorem", "ipsum", "dolor", "sit"],
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
],
Target: [
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
["amet,", "consectetur", "adipiscing", "elit,"],
["consectetur", "adipiscing", "elit,", "sed"],
]
```
Зверніть увагу, що якщо б ковзаюче вікно становило 2, це означало б, що наступний запис у вхідному масиві почнеться на 2 токени пізніше, а не лише на один, але цільовий масив все ще передбачатиме лише 1 токен. У pytorch це ковзаюче вікно виражається в параметрі `stride`.
